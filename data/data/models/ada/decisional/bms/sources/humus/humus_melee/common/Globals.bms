includedFiles = includedFiles or {}
includedFiles["sources/humus/humus_melee/common/Globals.bms"] = true

local emptyTable = emptyTable

include "bit.lua"


--[[// *****************************************************************************
]]--[[//
]]--[[// $Created: JCR 03-07-30 $
]]--[[// $Archive: /MVW_v10/Build/Data/Data/Modeles/Sources/Melee/Inf/Automates/Common/Globals.hal $
]]--[[// $Author: Ggr $
]]--[[// $Modtime: 19/09/05 9:45 $
]]--[[// $Revision: 30 $
]]--[[// $Workfile: Globals.hal $
]]--[[//
]]--[[// *****************************************************************************
]]include "Humus/Humus_Melee/Inf/Globals.bms"

include "Humus/Humus_Melee/Inf/Parameters.bms"


include "Humus/Humus_Melee/Abc/Automates/Common/Globals.bms"

--[[// ============================================================================
]]--[[// Coordination ligne avant et ligne arriere
]]--[[//
]]--[[// ============================================================================
]]--[[//----------------------------------------------------------------
]]--[[// Macro de gestions des appuis dans la MRT
]]--[[//----------------------------------------------------------------
]]--[[// ----------------------------------------------------------------------------
]]--[[// $Created : JCR : 02/02/2004 14:49
]]--[[// Boucle parcourant l'ensemble des elements d'une liste T_ListePoints 
]]--[[// ----------------------------------------------------------------------------
]]--[[// $$$$ JCR: A mettre dans common ?
]]--[[// -------------------------------------------------------------------------
]]--[[// S_ChercherPosition_Mine :
]]--[[//		Cherche une position sur laquelle on peut miner et non genante pour
]]--[[//		le pion
]]--[[// -------------------------------------------------------------------------
]]--[[//=============================================================================
]]--[[// Fonctions
]]--[[//=============================================================================
]]function S_Eni_Automate_EstDetruitTactique( cible )
    local _returnValue = false
    _returnValue = DEC_ConnaissanceAgent_EtatOps( cible ) == nil
    do return _returnValue end
end

function S_Geometrie_Automate_INF_ChercherPosition_Interdire( ptMine, rDistance )
    local _returnValue = nil
    _returnValue = DEC_Geometrie_CalculerPositionObstacle( ptMine, S_TypeObject_ToString( eTypeObjectBouchonMines ), rDistance )
    do return _returnValue end
end

function S_Medo_Automate_InitialiseSE( selPions, eEtatEchelon )
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            F_Pion_SeteEtatEchelon( pion, eEtatEchelon )
        end

    end

end


--[[// Retourne un ennemi traite par la compagnie
]]--[[// ------------------------------------------------------------------------	
]]--[[// ------------------------------------------------------------------------
]]--[[// rNombrePions_Actifs
]]--[[// ------------------------------------------------------------------------
]]--[[// ------------------------------------------------------------------------
]]--[[// Renvois la liste des pions en Appuis, succeptubles de relever ..
]]--[[// ------------------------------------------------------------------------
]]--[[//-----------------------------------------------------------------------------
]]--[[// Recherche parmi une selection de pions, recherche le PE de l'autre fuseau 
]]--[[//-----------------------------------------------------------------------------
]]--[[//	l'unite de tete dans l'autre fuseau garde sa mission
]]--[[//-----------------------------------------------------------------------------
]]--[[// Recherche un pion qui serait le plus susceptible de recevoir un appui
]]--[[//-----------------------------------------------------------------------------
]]--[[// S'il n'y a pas suffisamment de pion en premier echelon
]]--[[//	On cherche l'unite qui a le moins d'appuis
]]--[[// ----------------------------------------------------------------------------	
]]--[[// Renvoie l'appui d'un pion appuye
]]--[[// ----------------------------------------------------------------------------
]]--[[// Mission Soutenir pour l'ABC						
]]--[[// Mission Soutenir pour l'ABC						
]]--[[// Mission Soutenir pour l'INF						
]]--[[//-----------------------------------------------------------------------------
]]--[[// On regarde dans les pions en appuis s'il yen a un qui appuis pPion
]]--[[//-----------------------------------------------------------------------------
]]--[[// ------------------------------------------------------------------------
]]--[[// Renvoie le nombre de pions dans la compagnie en reduction sur ksEni
]]--[[// ------------------------------------------------------------------------
]]--[[// Dans le cas de l'infanterie, on regarde l'unite en cours,
]]--[[// Sinon, l'unite de la mission
]]--[[// ------------------------------------------------------------------------
]]--[[// Cherche le 'meilleur' Ennemi a reduire dans la zone 
]]--[[// ------------------------------------------------------------------------
]]--[[// DEC_Connaissances_UnitesEnnemiesDangereusesPourPion( pionAppui );
]]--[[// selection selEnis_DansZone = S_PionsDansZone	
]]--[[// On traite uniquement les pions dans la zone
]]--[[// Au Max 2 intervenants sur un meme ennemi -> 0.5 + ( 1 - S_ )
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie tous les pions disponibles pour la coordination
]]--[[//-----------------------------------------------------------------------------
]]--[[// ----------------------------------------------------------------------------    
]]--[[// Cherche le meilleur pion a appuyer en fonction des ennemis sur une liste
]]--[[// de pions a appuyer
]]--[[// ----------------------------------------------------------------------------
]]--[[// Recherche la zone d'intervention du pion appuye
]]--[[// Si j'appui deja la pion
]]--[[// Sinon, on est plutot attire par les pions ne possedant pas d'appui
]]--[[// On pondere le tout par la distance au pion
]]--[[// Si un ennemi se decouvre
]]--[[// On a tendance a intervenir dans sa zone
]]--[[// Plus le pion est en difficulte, plus on veut l'aider
]]--[[// S_Force_Etat( pion.eEtat_ );
]]--[[// Force final d'intervention
]]--[[// ----------------------------------------------------------------------------	
]]--[[// Cherche un ennemi valide autours dans la zone d'action d'un pion
]]--[[// ----------------------------------------------------------------------------
]]--[[// ----------------------------------------------------------------------------	
]]--[[// Calcule le nombre de pion possedant la mission @typeMission, et @bEnTete
]]--[[// ----------------------------------------------------------------------------
]]--[[// ------------------------------------------------------------------------
]]--[[// Cherche le premier pion avec une mission particuliere et en 1er echelon
]]--[[// ------------------------------------------------------------------------
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie vrai si au moins un des pions est en attente en bord du fuseau
]]--[[//-----------------------------------------------------------------------------	
]]--[[// case eEtatLima_LC:
]]--[[// case eEtatLima_LD:
]]--[[// ----------------------------------------------------------------------------    
]]--[[// Cherche le premier PIA dans le fuseau du point de recueil dans une 
]]--[[// liste de PIA.
]]--[[// ----------------------------------------------------------------------------
]]--[[// 0
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie vrai si au moins un pion amis est en difficulte
]]--[[//-----------------------------------------------------------------------------
]]--[[// ----------------------------------------------------------------------------
]]--[[// Renvoie point le plus proche de la zone parmis les pooints passés en paramètre 	
]]--[[// ----------------------------------------------------------------------------
]]--[[// Init
]]--[[/*    
    
    //-----------------------------------------------------------------------------
    // Renvoie la liste des pions de premier echelon en mode "RAS" sur ennemi
    //-----------------------------------------------------------------------------
    selection S_Dispositif_Automate_ABC_ObtenirPionsPE_EnRAS()
    {
        selection listePionsPEEnRAS;
        selection listePions = S_ObtenirPionsDe( eEtatEchelon_Premier, eEtatDestruction_None );

        with( x in listePions )
        {
            T_PionModeleDEC pion = x;
            if( F_Pion_GeteEtatDec( pion ) == eEtatDec_RAS )
                DIA_PushFront( listePionsPEEnRAS, pion );
        }
        S_Dispositif_Automate_ABC_ObtenirPionsPE_EnRAS = listePionsPEEnRAS;
    }

    //-----------------------------------------------------------------------------
    // Renvoie la liste des pions de premier echelon en mode "Fixe" ou"esquive" 
	// sur ennemi
    //-----------------------------------------------------------------------------
    selection S_Dispositif_Automate_ABC_ObtenirPionsPE_EnDifficultes()
    {
        selection listePionsPEEnDifficulte;
        selection listePions = S_ObtenirPionsDe( eEtatEchelon_Premier, eEtatDestruction_None );

        with( x in listePions )
        {
            T_PionModeleDEC pion = x;
            if( F_Pion_GeteEtatDec( pion ) == eEtatDec_Sauvegarde || F_Pion_GeteEtatDecPrudence( pion ) == eEtatDecPrudence_Actif  )
                DIA_PushFront( listePionsPEEnDifficulte, pion );
        }
        S_Dispositif_Automate_ABC_ObtenirPionsPE_EnDifficultes = listePionsPEEnDifficulte;
    }

    //-----------------------------------------------------------------------------
    // Renvoie la liste des pions succeptibles de soutenir une unite de premier 
    // echelon 
	// LES 2 CONDITIONS pour etre en mesure de soutenir:
    // 1) Ne pas être détruit
    // 2) Etre un pion de deuxieme echelon
    //-----------------------------------------------------------------------------
    selection S_Dispositif_Automate_ABC_ObtenirPionsSoutien()
    {
        selection listePion = DEC_Automate_PionsSansPC();
        selection listePionDeSoutien;

	    with ( x in listePion )
	    {
		    T_PionModeleDEC pion = x;

            if( F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon_Second && F_Pion_GeteEtatDestruction( pion ) == eEtatDestruction_None )
            {
                switch( pion.__type_ )
                {
                    case Peloton_AMX: // seul pion suceptible de soutenir ou reprendre mission à leur compte
                    case Peloton_XL:
                    {
                         DIA_PushFront( listePionDeSoutien, pion );
                         break;
                    }
                }
            }
	    }
        S_Dispositif_Automate_ABC_ObtenirPionsSoutien = listePionDeSoutien;
    }


   

    //-----------------------------------------------------------------------------
    // Renvoie le pion qui soutien l'unite passé en paramètre.
    // Si ce pion n'a pas de soutien renvoie 0.
    // // $$$$ MIA 03-10-13: faire plus générique et renvoyer une liste?
    //-----------------------------------------------------------------------------
    T_PionModeleDEC S_Dispositif_Automate_ABC_ObtenirPionEnSoutienDe( T_Pion pionSoutenu )
    {
	    T_PionModeleDEC pionEnSoutien = nil;

	    selection listePions = DEC_Automate_PionsSansPC();
	    with( x in listePions )
	    {
		    T_PionModeleDEC pion = x;
		    if( DEC_GetMission(pion) != nil && DEC_GetMission( pion ).__type_ == T_Mission_Pion_ABC_Soutenir )
            {
                T_Mission_Pion_ABC_Soutenir mis = DEC_GetMission(pion);
                if( mis.uniteASoutenir_ == pionSoutenu )
                    pionEnSoutien = pion;
            }   
	    }
	    S_Dispositif_Automate_ABC_ObtenirPionEnSoutienDe = pionEnSoutien;
    }


    //-----------------------------------------------------------------------------
    // Renvoie vrai qd tous les pions passer en paramètre sont en position( mission statique )
    //-----------------------------------------------------------------------------
    bool S_Misc_Automate_ABC_PionsEnPosition( selection listePions )
    {
    	S_Misc_Automate_ABC_PionsEnPosition = false; // TEMP
    	
        float rNbrePionsPrets = 0;
		with( x in listePions )
        {
            T_PionModeleDEC pion = x;
            if( F_Pion_GeteEtatPhaseMission( pion ) == eEtatPhaseMission_EnPosition )
                ++rNbrePionsPrets;
        }
        S_Misc_Automate_ABC_PionsEnPosition = ( rNbrePionsPrets == DIA_Size( listePions ) );
    }

    //-----------------------------------------------------------------------------
    // Renvoie la liste des pions Ecl
    // --> en PAUSE ou ESQUIVE
    //-----------------------------------------------------------------------------
    bool S_Dispositif_Automate_ABC_EstPEclEnDanger()
    {
        S_Dispositif_Automate_ABC_EstPEclEnDanger = false;

        selection listePionEcl = S_ObtenirPionsDe( eEtatEchelon_Eclairage, eEtatDestruction_None );
        with( x in listePionEcl )
        {
            T_PionModeleDEC pionEcl = x;
            if( F_Pion_GeteEtatDec( pionEcl ) == eEtatDec_Sauvegarde )
			{
                S_Dispositif_Automate_ABC_EstPEclEnDanger = true;
				return;
			}
        }
    }

	//-----------------------------------------------------------------------------
	// Renvoie vrai si le pion passé en paramètre est un pion INF
	//-----------------------------------------------------------------------------
	bool S_Dispositif_Automate_ABC_EstPionInfanterie( T_PionModeleDEC pion )
	{
		S_Dispositif_Automate_ABC_EstPionInfanterie = false;

		if( pion.__type_ == SectionInfanterie_HOT  || 
		    pion.__type_ == SectionInfanterie_MILAN ||
			pion.__type_ == SectionInfanterie )
			S_Dispositif_Automate_ABC_EstPionInfanterie = true;
	}
	
	//-----------------------------------------------------------------------------
	// Renvoie vrai si au moins un pion de premier echelon  ou Ecl est detruit
	//-----------------------------------------------------------------------------
	bool S_Dispositif_Automate_ABC_EvtPionDetruit()
	{
		S_Dispositif_Automate_ABC_EvtPionDetruit = false;
		
		selection listePionsPE   = S_ObtenirTousPionsDe( eEtatEchelon_Premier );
		selection listePionsPEcl = S_ObtenirTousPionsDe( eEtatEchelon_Eclairage );
		
		with( x in listePionsPE )
		{
            T_PionModeleDEC pion = x;
            if( F_Pion_GeteEtatDestruction( pion ) != eEtatDestruction_None )
            {
                S_Dispositif_Automate_ABC_EvtPionDetruit = true;
                return;
            }
		}
		
		with( x in listePionsPEcl )
		{
			 T_PionModeleDEC pion = x;
			 if( F_Pion_GeteEtatDestruction( pion ) != eEtatDestruction_None )
			 	S_Dispositif_Automate_ABC_EvtPionDetruit = true;
		}
	}
	//-----------------------------------------------------------------------------
	// Renvoie la liste des pions sans mission 
	// Pour missions rétrogrades
	//-----------------------------------------------------------------------------
	selection S_Dispositif_Automate_ABC_PionsSansMission()
	{
		selection selTemp;
		with( x in DEC_Automate_PionsAvecPC() )
		{
			 T_PionModeleDEC pion = x;
			 if( DEC_GetMission(pion) == nil )
			 	DIA_PushFront( selTemp, pion );
		}
		S_Dispositif_Automate_ABC_PionsSansMission = selTemp;
	}
	
	//-----------------------------------------------------------------------------
    // Renvoie la liste des pions qui freinent
    //-----------------------------------------------------------------------------
    selection S_Dispositif_Automate_ABC_ObtenirListePionsFreinantDe( E_EtatPion_Echelon eEtatEchelon )
    {
    	selection listeFiltre;
        selection listePionFreinant 
        = S_Cherche_Automate_Filtre_TypeMission( DEC_Automate_PionsAvecPC(), T_Mission_Pion_ABC_Freiner );

	    with ( x in listePionFreinant )
	    {
		    T_PionModeleDEC pion = x;
            if( F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon )
                 DIA_PushFront( listeFiltre, pion );
	    }
        S_Dispositif_Automate_ABC_ObtenirListePionsFreinantDe = listeFiltre;
    }
    
    //-----------------------------------------------------------------------------
    // Renvoie le pion ami (meme escadron) le plus proche
    //-----------------------------------------------------------------------------
    T_PionModeleDEC S_Dispositif_ObtenirPionSoutienProcheDe( T_PionModeleDEC pion )
  	{
  	    S_Dispositif_ObtenirPionSoutienProcheDe = 0;
  	    
		float rDistanceMax = 1105199104; // M_FLOATMAX()
		selection listePionsSecondEchelonNonDetruits = S_ObtenirPionsDe( eEtatEchelon_Second, eEtatDestruction_None );
		with( x in listePionsSecondEchelonNonDetruits )
		{
		    T_PionModeleDEC pionProche = x;
		    if( pionProche.__type_ == Peloton_XL || pionProche.__type_ == Peloton_AMX )
		    {
    		    float rDistanceCourante = DEC_Geometrie_Distance( DEC_Automate_PionPosition( pion ), DEC_Automate_PionPosition( pionProche ) );
    			if( rDistanceCourante < rDistanceMax )
    			{
     				rDistanceCourante = rDistanceMax;
     				S_Dispositif_ObtenirPionSoutienProcheDe = pionProche;
     			}
     		}
		}
  	}
  	
  	//-----------------------------------------------------------------------------
    // Renvoie le pion ami (meme escadron) le plus proche
    //-----------------------------------------------------------------------------
  	selection S_Dispositif_Automate_ABC_PionsPourArmerPointControle()
  	{
  	    selection listePionPatrouille      = S_ObtenirPionsOperationnelsFiltre ( Patrouille_EI );
		selection listePionPatrouilleMilan = S_ObtenirPionsOperationnelsFiltre ( Patrouille_EI_Milan );
		selection listePionPAD             = S_ObtenirPionsOperationnelsFiltre ( Peloton_AD );
		
		selection selTemp;
		
		with( pion in listePionPatrouille )
		    DIA_PushFront( selTemp, pion );
		    
		with( pion in listePionPatrouilleMilan )
		    DIA_PushFront( selTemp, pion );
		    
		with( pion in listePionPAD )
		    DIA_PushFront( selTemp, pion );
		    
		S_Dispositif_Automate_ABC_PionsPourArmerPointControle = selTemp;
	}
	
	
	//-----------------------------------------------------------------------------
    // Renvoie la liste des pions détruits (tactiquement OU totalement) de l'échelon
    // passé en paramètre
    //-----------------------------------------------------------------------------
	selection S_Dispositif_Automate_ABC_ObtenirPionDetruitsDe( E_EtatPion_Echelon eEtatEchelon )
	{
	    selection selTemp;
	    selection listePions = S_ObtenirTousPionsDe( eEtatEchelon );
	    with( x in listePions )
	    {
	        T_PionModeleDEC pion = x;
	        if( F_Pion_GeteEtatDestruction( pion ) != eEtatDestruction_None )
	            DIA_PushFront( selTemp, pion );
	    }
	    S_Dispositif_Automate_ABC_ObtenirPionDetruitsDe = selTemp;
	}
	
	//-----------------------------------------------------------------------------
    // Renvoie la liste des pions détruits (tactiquement OU totalement) de l'échelon
    // passé en paramètre
    //-----------------------------------------------------------------------------
	bool S_Dispositif_Automate_ABC_Freiner_PionsDevant( T_CalculLignesAvantArriere resultatCalcul, 
	                                                    E_EtatPion_Echelon         eEtatEchelon )
	{
	    S_Dispositif_Automate_ABC_Freiner_PionsDevant = false;
	    selection listePions = S_ObtenirTousPionsDe( eEtatEchelon );
	    with( x in listePions )
	    {
	        T_PionModeleDEC pion = x;
	        // ATTENTION le dispositif est inversé, Devant = derriere...
	        if( DEC_Geometrie_CalculerDistanceLigneArriere( resultatCalcul, pion ) > 200 ) // Le pion est devant
	            S_Dispositif_Automate_ABC_Freiner_PionsDevant = true;
	    }
	}
	
    //-----------------------------------------------------------------------------
    // Renvoie vrai si au moins un pion amis est en difficulte
    //-----------------------------------------------------------------------------
    bool S_Dispositif_Automate_ABC_PionsAmisEnDifficultes( T_Automate compagnie )
    {
        S_Dispositif_Automate_ABC_PionsAmisEnDifficultes = false;
        
        with( x in DEC_Automate_PionsDeAutomateAvecPC( compagnie ) )
        {
            T_PionModeleDEC pion = x;
            if( F_Pion_GeteEtatDec( pion ) == eEtatDec_Sauvegarde )
                S_Dispositif_Automate_ABC_PionsAmisEnDifficultes = true;
        }
    }
    
    //-----------------------------------------------------------------------------
    // Renvoie vrai si tous les pions de l'automate sont hors fuseau
    //-----------------------------------------------------------------------------
    bool S_Dispositif_ABC_Automate_TousPionsHorsFuseau( T_Automate compagnie )
    {
        S_Dispositif_ABC_Automate_TousPionsHorsFuseau = false;
        
        float rIterateur = 0;
        selection listePions = DEC_Automate_PionsDeAutomateAvecPC( compagnie );
        with( x in listePions )
        {
            T_PionModeleDEC pion = x;
            if( ! DEC_Geometrie_EstPointDansFuseau( DEC_Automate_PionPosition( pion ) ) )
                ++rIterateur;
        }
        
        if( rIterateur  == DIA_Size( listePions ) )
            S_Dispositif_ABC_Automate_TousPionsHorsFuseau = true;
    }
    */]]function S_Cherche_Automate_INF_EnnemiCompagnie( )
    local _returnValue = nil
    _returnValue = 0
    local selPions = DEC_Automate_PionsSansPC()
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            local ksEni_EnCours = S_Pion_EniEnCours( pion )
            if( DEC_ConnaissanceAgent_EstValide( ksEni_EnCours ) ) then
                do
                    _returnValue = ksEni_EnCours
                                        do return _returnValue end

                end
            end

        end

    end

    do return _returnValue end
end

function S_Nombre_PionsActifs( )
    local _returnValue = 0
    _returnValue = 0
    local selPions = DEC_Automate_PionsSansPC()
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
             do
                local _continue = true
                local switch_1 = pion:GetType()
                local cases_switch_1 = {}
                    if switch_1 == "SectionInfanterie"
                    or switch_1 == "SectionInfanterie_HOT"
                    or switch_1 == "SectionInfanterie_MILAN"
                    or switch_1 == "Peloton_AMX"
                    or switch_1 == "Peloton_XL"
                    or switch_1 == "Terroriste"
                    or switch_1 == "Patrouille_RBRR_Blindee"
                    or switch_1 == "GroupeInfanterie_Mortier" then
                                                _returnValue = _returnValue + 1
                        _continue = false
                                        cases_switch_1[1] = true
                    end
                end

        end

    end

    do return _returnValue end
end

function S_Cherche_Automate_PionsPourReleve( )
    local _returnValue = {}
    local lstPionsEnSoutien = {}
    local selPion = S_Cherche_Automate_Filtre_TypePion( DEC_Automate_PionsSansPC(), "SectionInfanterie" )
    for _,x in pairs( selPion or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( not S_Pion_EstDetruitTactique( pion ) and F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon_Second ) then
                DIA_PushBack( lstPionsEnSoutien, pion )
            end

        end

    end

    _returnValue = lstPionsEnSoutien
    do return _returnValue end
end

function S_TousPionsEnPE_Ou_Freinant( )
    local _returnValue = {}
    local selTemp = {}
    local selPions = DEC_Automate_PionsSansPC()
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon_Premier or S_Misc_EstMissionAffectee_Pion( pion, "T_Mission_Pion_INF_Freiner" ) ) then
                DIA_PushBack( selTemp, pion )
            end

        end

    end

    _returnValue = selTemp
    do return _returnValue end
end

function S_Cherche_Automate_INF_PE( selPions, pPion )
    local _returnValue = nil
    local pionFoo = nil
    _returnValue = pionFoo
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon_Premier and pion ~= pPion ) then
                do
                    _returnValue = pion
                                        do return _returnValue end

                end
            end

        end

    end

    do return _returnValue end
end

function S_Cherche_Automate_INF_PionAAppuyer( sPion_PE, pPion )
    local _returnValue = nil
    local rMin_Appui = #( sPion_PE )
    local pionFoo = nil
    _returnValue = pionFoo
    if( #( sPion_PE ) < 2 ) then
        do return _returnValue end
    end

    for _,x in pairs( sPion_PE or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( #( F_Pion_GetselUnitesEnAppui( pion ) ) < rMin_Appui ) then
                do
                    rMin_Appui = #( F_Pion_GetselUnitesEnAppui( pion ) )
                    _returnValue = pion
                                        do return _returnValue end

                end
            end

        end

    end

    do return _returnValue end
end

function S_Automate_INF_UniteMission_Appuyer( pPionAppui )
    local _returnValue = nil
    local pionFoo = nil
    _returnValue = pionFoo
    if( DEC_GetMission( pPionAppui ) == nil ) then
        do return _returnValue end
    end

    local mission = DEC_GetMission( pPionAppui )
     do
        local _continue = true
        local switch_1 = mission:GetType()
        local cases_switch_1 = {}
            if switch_1 == "T_Mission_Pion_ABC_Soutenir" then
                local missionABC = DEC_GetMission( pPionAppui )
                _returnValue = missionABC.uniteASoutenir_
                _continue = false
                        cases_switch_1[1] = true
elseif switch_1 == "T_Mission_Pion_ABC_Appuyer" then
                local missionABC = DEC_GetMission( pPionAppui )
                _returnValue = missionABC.uniteAAppuyer_
                _continue = false
                        cases_switch_1[2] = true
elseif switch_1 == "T_Mission_Pion_INF_Appuyer" then
                local missionINF = DEC_GetMission( pPionAppui )
                _returnValue = missionINF.uniteAAppuyer_
                _continue = false
                        cases_switch_1[3] = true
            end
        end

    do return _returnValue end
end

function S_Automate_INF_EstAppuye_Par( pPion, pPionAppui )
    local _returnValue = false
    _returnValue = S_Automate_INF_UniteMission_Appuyer( pPionAppui ) == pPion
    do return _returnValue end
end

function S_Automate_INF_EstAppuye( pPion, sPionsAppui )
    local _returnValue = false
    _returnValue = false
    for _,x in pairs( sPionsAppui or emptyTable ) do
    local _continue = true
do
            local pAppui = x
            if( DEC_GetMission( pAppui ) ~= nil ) then
                do
                    _returnValue = S_Automate_INF_EstAppuye_Par( pPion, pAppui )
                    if( _returnValue ) then
                        do return _returnValue end
                    end

                end
            end

        end

    end

    do return _returnValue end
end

function S_CompagnieAbimee( )
    local _returnValue = false
    _returnValue = false
    local selPions = DEC_Automate_PionsSansPC()
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( S_Pion_EstDetruitTactique( pion ) ) then
                do
                    _returnValue = true
                                        do return _returnValue end

                end
            end

        end

    end

    do return _returnValue end
end

function S_Misc_Automate_INF_Pions_EnReductionsSur( ksEni )
    local _returnValue = 0
    _returnValue = -1
    local selPions = DEC_Automate_PionsSansPC()
    if( not DEC_ConnaissanceAgent_EstValide( ksEni ) ) then
        do return _returnValue end
    end

    _returnValue = 0
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( S_Misc_EstMissionAffectee_Pion( pion, "T_Mission_Pion_INF_Reduire" ) ) then
                do
                    if( ksEni == S_Pion_EniEnCours( pion ) ) then
                                                _returnValue = _returnValue + 1
                    end

                end
            end

            if( S_Misc_EstMissionAffectee_Pion( pion, "T_Mission_Pion_ABC_Reduire" ) ) then
                do
                    local misABC = DEC_GetMission( pion )
                    if( ksEni == misABC.uniteAReduire_ ) then
                                                _returnValue = _returnValue + 1
                    end

                end
            end

        end

    end

    do return _returnValue end
end

function S_Cherche_Automate_INF_EniDangereux_DansZone( pionAppui, locZone )
    local _returnValue = nil
    local rMaxForce = 0
    local lstEnisPourAppui = DEC_Connaissances_UnitesEnnemiesVivantesPercuesParPion( pionAppui )
    local pionFoo = nil
    _returnValue = pionFoo
    for _,ksEni in pairs( lstEnisPourAppui or emptyTable ) do
    local _continue = true
do
            if( not S_Eni_EstDansZone( ksEni, locZone ) ) then
                _continue = false
            end

                if _continue then
                local rForceEni_Reduction = 1.5 - S_Misc_Automate_INF_Pions_EnReductionsSur( ksEni )
                local rForceEni = rForceEni_Reduction * 0.5 * S_Pion_ForceActionContre( pionAppui, ksEni )
                if( rForceEni > rMaxForce ) then
                    do
                        rMaxForce = rForceEni
                        _returnValue = ksEni
                    end
                end

            end
        end

    end

    do return _returnValue end
end

function S_ObtenirPionsOperationnels_SansPC_Coordination( )
    local _returnValue = {}
    local selTemp = {}
    local selPions = S_ObtenirPionsOperationnels_SansPC()
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
             do
                local _continue = true
                local switch_1 = pion:GetType()
                local cases_switch_1 = {}
                    if switch_1 == "GroupeInfanterie_Mortier" then
                        _continue = false
                                        cases_switch_1[1] = true

                    else
                        DIA_PushBack( selTemp, pion )
                    end
                end

        end

    end

    _returnValue = selTemp
    do return _returnValue end
end

function S_Cherche_Automate_INF_PionReception_Appui( pionAppui, lst_Pions_AAppuyer )
    local _returnValue = nil
    local pionAppui_Max = nil
    local rForceAppui_Max = 0
    for _,x in pairs( lst_Pions_AAppuyer or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( pionAppui == x ) then
                _continue = false
            end

                if _continue then
                if( S_Misc_EstMissionAffectee_Pion( pion, "T_Mission_Pion_INF_Couvrir" ) ) then
                    _continue = false
                end

                    if _continue then
                    local locZone_Intervention = nil
                    if( S_Misc_EstMissionAffectee_Pion( pion, "T_Mission_Pion_INF_ControlerSecteur" ) ) then
                        do
                            local misControler = DEC_GetMission( pion )
                            locZone_Intervention = misControler.zone_
                        end
                    end

                    local rForceAppui = 1
                    local rSelectedBoost = 1
                    if( S_Automate_INF_EstAppuye_Par( pion, pionAppui ) ) then
                        rSelectedBoost = 2
                    end

                    if( #( F_Pion_GetselUnitesEnAppui( pion ) ) > 1 ) then
                        rForceAppui = 1 / #( F_Pion_GetselUnitesEnAppui( pion ) )
                    end

                    if( ( rSelectedBoost > 1 ) and ( #( F_Pion_GetselUnitesEnAppui( pion ) ) == 1 ) ) then
                        rForceAppui = 2.5
                    end

                    if( #( F_Pion_GetselUnitesEnAppui( pion ) ) == 0 ) then
                        rForceAppui = 3.5
                    end

                    rForceAppui = rForceAppui * S_Pion_ForceDistancePt( pionAppui, DEC_Automate_PionPosition( pion ) )
                    local ksEni_EnCours = S_Pion_EniEnCours( pion )
                    if( DEC_ConnaissanceAgent_EstValide( ksEni_EnCours ) ) then
                        do
                            local rForceZone = 1
                            if( S_Eni_EstDansZone( ksEni_EnCours, locZone_Intervention ) ) then
                                rForceZone = 2.5
                            end

                            local rForceEtat = 1
                            local rForce = rForceEtat * S_Pion_ForceActionContre( pionAppui, ksEni_EnCours )
                            rForceAppui = rForce + rForceZone * rForceAppui
                            DEC_Debug( "		- IntervenirSur: " .. DEC_GetSzName( pion ) .. FloatToString( rForce ) )
                        end
                    end

                    if( ( rSelectedBoost * rForceAppui ) > rForceAppui_Max ) then
                        do
                            rForceAppui_Max = rSelectedBoost * rForceAppui
                            pionAppui_Max = pion
                        end
                    end

                end
            end
        end

    end

    _returnValue = pionAppui_Max
    if( S_Automate_INF_EstAppuye_Par( pionAppui_Max, pionAppui ) ) then
        _returnValue = 0
    end

    do return _returnValue end
end

function S_Cherche_Automate_INF_EniValide_Pour( pion )
    local _returnValue = nil
    local lstEnisPourPion = DEC_Connaissances_UnitesEnnemiesVivantesPercuesParPion( pion )
    local ksEni = nil
    local rEni_MaxDist = 2500
    for _,x_eni in pairs( lstEnisPourPion or emptyTable ) do
    local _continue = true
do
            local rEni_Dist = DEC_Geometrie_Distance( S_Eni_Position( x_eni ), DEC_Automate_PionPosition( pion ) )
            if( rEni_Dist < rEni_MaxDist ) then
                do
                    rEni_MaxDist = rEni_Dist
                    ksEni = x_eni
                end
            end

        end

    end

    _returnValue = ksEni
    do return _returnValue end
end

function S_Misc_Automate_INF_Compte_MissionEchelon( typeMission, eEtatEchelon )
    local _returnValue = 0
    _returnValue = 0
    local selPions = DEC_Automate_PionsSansPC()
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( S_Misc_EstMissionAffectee_Pion( pion, typeMission ) and F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon ) then
                                _returnValue = _returnValue + 1
            end

        end

    end

    do return _returnValue end
end

function S_Cherche_Automate_INF_PionMission( sPions, typeMission )
    local _returnValue = nil
    local pionFoo = nil
    _returnValue = pionFoo
    for _,x in pairs( sPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( S_Misc_EstMissionAffectee_Pion( pion, typeMission ) and F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon_Premier ) then
                do
                    _returnValue = pion
                                        do return _returnValue end

                end
            end

        end

    end

    do return _returnValue end
end

function S_Conduite_PionHorsFuseau( sPionsOrdre )
    local _returnValue = false
    _returnValue = false
    for _,x in pairs( sPionsOrdre or emptyTable ) do
    local _continue = true
do
            _returnValue = not DEC_Geometrie_EstPointDansFuseau( DEC_Automate_PionPosition( x ) )
            if( _returnValue ) then
                do return _returnValue end
            end

        end

    end

    do return _returnValue end
end

function S_Conduite_PionEnAttente_OrdreCoordination( sPionsOrdre )
    local _returnValue = false
    _returnValue = false
    for _,x in pairs( sPionsOrdre or emptyTable ) do
    local _continue = true
do
            local pionOrdre = x
             do
                local _continue = true
                local switch_1 = F_Pion_GeteEtatPhaseMission( pionOrdre )
                local cases_switch_1 = {}
                    if switch_1 == eEtatPhaseMission_RejointFuseau then
                        _returnValue = true
                                                do return _returnValue end

                                        end
                end

             do
                local _continue = true
                local switch_1 = F_Pion_GeteEtatLima( pionOrdre )
                local cases_switch_1 = {}
                    if switch_1 == eEtatLima_Fuseau then
                        _returnValue = true
                                                do return _returnValue end

                                        end
                end

        end

    end

    do return _returnValue end
end

function S_Geometrie_Automate_INF_PIA_DansFuseau( pRecueil, lstPIA, rItPIA )
    local _returnValue = nil
    local ptTest_Fuseau = DEC_ListePoints_GetAt( lstPIA, rItPIA )
    if( pRecueil:DEC_Geometrie_EstPointDansFuseau( ptTest_Fuseau ) ) then
        do
            _returnValue = ptTest_Fuseau
                        do return _returnValue end

        end
    end

    local rIt_Max = DEC_ListePoints_Size( lstPIA )
    local rIt = 0
    rIt = 0
    while rIt < rIt_Max do
        local _continue = true
do
            ptTest_Fuseau = DEC_ListePoints_GetAt( lstPIA, rIt )
            if( pRecueil:DEC_Geometrie_EstPointDansFuseau( ptTest_Fuseau ) ) then
                do
                    _returnValue = ptTest_Fuseau
                                        do return _returnValue end

                end
            end

        end
    rIt = rIt + 1
    end

    _returnValue = ptTest_Fuseau
    do return _returnValue end
end

function S_Dispositif_Automate_INF_PionsAmisEnDifficultes( compagnie )
    local _returnValue = false
    _returnValue = false
    for _,x in pairs( DEC_Automate_PionsDeAutomateAvecPC( compagnie ) or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( F_Pion_GeteEtatDec( pion ) == eEtatDec_Sauvegarde ) then
                _returnValue = true
            end

        end

    end

    do return _returnValue end
end

function S_Geometrie_PointPlusProchePosition_DansFuseau( ptZone, listePoints )
    local _returnValue = 0
    local rDistanceMin = 524280
    _returnValue = DEC_ListePoints_Size( listePoints )
    local it = 0
    while it < DEC_ListePoints_Size( listePoints ) do
        local _continue = true
do
            local ptBuffer = DEC_ListePoints_GetAt( listePoints, it )
            if( not DEC_Geometrie_EstPointDansFuseau( ptBuffer ) ) then
                _continue = false
            end

                if _continue then
                local rDistanceTmp = DEC_Geometrie_Distance( ptBuffer, ptZone )
                if( rDistanceTmp < rDistanceMin ) then
                    do
                        rDistanceMin = rDistanceTmp
                        _returnValue = it
                    end
                end

            end
        end
    it = it + 1
    end

    do return _returnValue end
end

