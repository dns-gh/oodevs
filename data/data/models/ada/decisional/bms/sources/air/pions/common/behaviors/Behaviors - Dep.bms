includedFiles = includedFiles or {}
includedFiles["sources/air/pions/common/behaviors/Behaviors - Dep.bms"] = true

include "bit.lua"


--[[// *****************************************************************************
]]--[[// Se Poser
]]--[[// --------
]]--[[//
]]--[[// commentaires : on est à l'altitude nulle (par rapport au sol. Les moteurs ne
]]--[[// sont pas coupés => on ne veut pas arreter les moteurs automatiquement
]]--[[// *****************************************************************************
]]node "BEH_Dep_Pion_AIR_SePoserEnAttenteDe"
{
    instances =
    {
        max = 1,
    },

    activations =
    {
        { "ACT_Dep_Pions_AIR_Voler", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        Activate( self.activations.ACT_Dep_Pions_AIR_Voler, 1, { 0.001, } )
                self.params.__returnValue = eActionEffectuee
        do return end

    end,

}

node "BEH_Dep_Pion_AIR_SePoser"
{
    instances =
    {
        max = 1,
    },

    activations =
    {
        { "ACT_Dep_Pions_AIR_Voler", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        Activate( self.activations.ACT_Dep_Pions_AIR_Voler, 1, { 0, } )
                self.params.__returnValue = eActionEffectuee
        do return end

    end,

--[[// *****************************************************************************
]]--[[// Voler
]]--[[// -----
]]--[[//
]]--[[// Commentaires : on ne peut voler que si l'on a allumer les moteurs
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_AIR_Voler"
{
    instances =
    {
        max = 1,
    },

    activations =
    {
        { "ACT_Dep_PasserEnModeFurtif", {} },
        { "BEH_Dep_Pion_AIR_SecondeAllure", {} },
        { "BEH_Dep_Pion_AIR_SecondeAllureAvecAppuis", {} },
        { "BEH_Dep_Pion_AIR_TroisiemeAllure", {} },
        { "BEH_Dep_Pion_AIR_TroisiemeAllureAvecAppuis", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        --[[// variables persistantes
]]self.delaiDemarageOK = self.delaiDemarageOK or false
        self.eEtatDemarageMoteurs = self.eEtatDemarageMoteurs or eActionEnCours
         do
            local _continue = true
            local switch_1 = F_Pion_GeteEtatAmbiance( myself )
            local cases_switch_1 = {}
                if switch_1 == eEtatAmbiance_Surete then
                    Activate( self.activations.ACT_Dep_PasserEnModeFurtif, 1, {} )
                    if( DIA_IsListEmpty( F_Pion_GetselUnitesEnAppui( myself ) ) ) then
                        Activate( self.activations.BEH_Dep_Pion_AIR_SecondeAllure, 1, {} )
                    else
                        Activate( self.activations.BEH_Dep_Pion_AIR_SecondeAllureAvecAppuis, 1, {} )
                    end

                    _continue = false
                                cases_switch_1[1] = true
elseif switch_1 == eEtatAmbiance_Vitesse then
                    if( DIA_IsListEmpty( F_Pion_GetselUnitesEnAppui( myself ) ) ) then
                        Activate( self.activations.BEH_Dep_Pion_AIR_TroisiemeAllure, 1, {} )
                    else
                        Activate( self.activations.BEH_Dep_Pion_AIR_TroisiemeAllureAvecAppuis, 1, {} )
                    end

                    _continue = false
                                cases_switch_1[2] = true
                end
            end

    end,

--[[// hauteur et vitesse en première allure
]]}

node "BEH_Dep_Pion_AIR_PremiereAllure"
{
    activations =
    {
        { "ACT_Dep_Pions_AIR_Voler", {} },
        { "ACT_Dep_ModulationVitesse", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        Activate( self.activations.ACT_Dep_Pions_AIR_Voler, 1, { M_POLY_PION_AIR_HAUTEUR_VOL_TACTIQUE(), } )
        Activate( self.activations.ACT_Dep_ModulationVitesse, 1, { M_DEP_PION_AIR_VITESSE_PREMIERE_ALLURE(), } )
    end,

}

node "BEH_Dep_Pion_AIR_PremiereAllureAvecAppuis"
{
    activations =
    {
        { "ACT_Dep_Pions_AIR_Voler", {} },
        { "ACT_Dep_ModulationVitesse", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        Activate( self.activations.ACT_Dep_Pions_AIR_Voler, 1, { M_POLY_PION_AIR_HAUTEUR_VOL_TACTIQUE(), } )
        Activate( self.activations.ACT_Dep_ModulationVitesse, 1, { M_DEP_PION_AIR_VITESSE_PREMIERE_ALLURE_AVEC_APPUIS(), } )
    end,

--[[// hauteur et vitesse en seconde allure
]]}

node "BEH_Dep_Pion_AIR_SecondeAllure"
{
    activations =
    {
        { "ACT_Dep_Pions_AIR_Voler", {} },
        { "ACT_Dep_ModulationVitesse", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        Activate( self.activations.ACT_Dep_Pions_AIR_Voler, 1, { M_POLY_PION_AIR_HAUTEUR_VOL_TACTIQUE(), } )
        Activate( self.activations.ACT_Dep_ModulationVitesse, 1, { M_DEP_PION_AIR_VITESSE_SECONDE_ALLURE(), } )
    end,

}

node "BEH_Dep_Pion_AIR_SecondeAllureAvecAppuis"
{
    activations =
    {
        { "ACT_Dep_Pions_AIR_Voler", {} },
        { "ACT_Dep_ModulationVitesse", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        Activate( self.activations.ACT_Dep_Pions_AIR_Voler, 1, { M_POLY_PION_AIR_HAUTEUR_VOL_NORMAL(), } )
        Activate( self.activations.ACT_Dep_ModulationVitesse, 1, { M_DEP_PION_AIR_VITESSE_SECONDE_ALLURE_AVEC_APPUIS(), } )
    end,

--[[// hauteur et vitesse en troisième allure
]]}

node "BEH_Dep_Pion_AIR_TroisiemeAllure"
{
    activations =
    {
        { "ACT_Dep_Pions_AIR_Voler", {} },
        { "ACT_Dep_ModulationVitesse", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        Activate( self.activations.ACT_Dep_Pions_AIR_Voler, 1, { M_POLY_PION_AIR_HAUTEUR_VOL_NORMAL(), } )
        Activate( self.activations.ACT_Dep_ModulationVitesse, 1, { M_DEP_PION_AIR_VITESSE_TROISIEME_ALLURE(), } )
    end,

}

node "BEH_Dep_Pion_AIR_TroisiemeAllureAvecAppuis"
{
    activations =
    {
        { "ACT_Dep_Pions_AIR_Voler", {} },
        { "ACT_Dep_ModulationVitesse", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        Activate( self.activations.ACT_Dep_Pions_AIR_Voler, 1, { M_POLY_PION_AIR_HAUTEUR_VOL_NORMAL(), } )
        Activate( self.activations.ACT_Dep_ModulationVitesse, 1, { M_DEP_PION_AIR_VITESSE_TROISIEME_ALLURE_AVEC_APPUIS(), } )
    end,

--[[// *****************************************************************************
]]--[[// RejoindrePoint :
]]--[[// ----------------
]]--[[// Cas particulier de BEH_RejoindreParItineraire.
]]--[[// la liste des points est une liste composée uniquement du point d'arrivé
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_AIR_RejoindrePoint"
{
    activations =
    {
        { "BEH_Dep_Pion_AIR_RejoindreParItineraire", {} },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.point = self.params[1]
        self._namedParams.typeProgression = self.params[2]
        self._namedParams.ePathType = self.params[3]
        self._namedParams.distanceMin = self.params[4]
        self._namedParams.distanceMax = self.params[5]
        self._namedParams.forceDelaiSucces = self.params[6]
        self._namedParams.forceDelaiPenalite = self.params[7]
    end,

    activate = function( self )
        assert( self._namedParams.point ~= nil, "AIR : Rejoindre Point" )
        --[[// variables persistantes
]]self.listePoints = self.listePoints or DEC_Geometrie_CreerListePoints()
        self.eEtat = self.eEtat or eActionEnCours
        if( ( DEC_Geometrie_Distance( myself:DEC_Agent_Position(), self._namedParams.point ) == 0 or DEC_Geometrie_Distance( myself:DEC_Agent_Position(), self._namedParams.point ) == nil ) ) then
            self.params.__returnValue = eActionEffectuee
            Halt( self )
            do return end
        end

        if( ModuleBegins() ) then
            DEC_ListePoints_PushBack( self.listePoints, self._namedParams.point )
        end

        if( self.eEtat ~= eActionEnCours ) then
            self.params.__returnValue = self.eEtat
            Halt( self )
            do return end
        else
            Activate( self.activations.BEH_Dep_Pion_AIR_RejoindreParItineraire, 1, setmetatable( { self.listePoints, self._namedParams.typeProgression, self._namedParams.ePathType, self._namedParams.distanceMin, self._namedParams.distanceMax, self._namedParams.forceDelaiSucces, self._namedParams.forceDelaiPenalite, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
        end

    end,

--[[// *****************************************************************************
]]--[[// RejoindrePoint :
]]--[[// ----------------
]]--[[// Cas particulier de BEH_RejoindrePoint.
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_AIR_RejoindrePion"
{
    activations =
    {
        { "BEH_Dep_Pion_AIR_RejoindrePoint", {} },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.pion = self.params[1]
        self._namedParams.typeProgression = self.params[2]
        self._namedParams.ePathType = self.params[3]
        self._namedParams.distanceMin = self.params[4]
        self._namedParams.distanceMax = self.params[5]
        self._namedParams.forceDelaiSucces = self.params[6]
        self._namedParams.forceDelaiPenalite = self.params[7]
        self._namedParams.distanceAvantRelance = self.params[8]
    end,

    activate = function( self )
        assert( self._namedParams.pion ~= nil, "AIR : Rejoindre Pion" )
        --[[// variables persistantes
]]self.listePoints = self.listePoints or DEC_Geometrie_CreerListePoints()
        self.eEtat = self.eEtat or eActionEnCours
        self.positionPion = self.positionPion or DEC_Geometrie_CreerPoint()
        if( ModuleBegins() ) then
            DEC_Copie_Point( self._namedParams.pion:DEC_Agent_Position(), self.positionPion )
        end

        if( ( DEC_Geometrie_Distance( myself:DEC_Agent_Position(), self.positionPion ) == 0 or DEC_Geometrie_Distance( myself:DEC_Agent_Position(), self.positionPion ) == nil ) ) then
            self.params.__returnValue = eActionEffectuee
            Halt( self )
            do return end
        end

        if( DEC_Geometrie_Distance( self._namedParams.pion:DEC_Agent_Position(), self.positionPion ) >= self._namedParams.distanceAvantRelance ) then
            Halt( self )
            do return end
        end

        if( self.eEtat ~= eActionEnCours ) then
            self.params.__returnValue = self.eEtat
            do return end
        else
            Activate( self.activations.BEH_Dep_Pion_AIR_RejoindrePoint, 1, setmetatable( { self.positionPion, self._namedParams.typeProgression, self._namedParams.ePathType, self._namedParams.distanceMin, self._namedParams.distanceMax, self._namedParams.forceDelaiSucces, self._namedParams.forceDelaiPenalite, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
        end

    end,

--[[// *****************************************************************************
]]--[[// RejoindreParItineraire
]]--[[// ======================
]]--[[// Ce comportement permet de rejoindre une position en acceptant certains 
]]--[[// compromis. Il arrive qu'il ne soit pas possible de rejoindre un point 
]]--[[// (exemple : si dans de l'eau...)
]]--[[// Pour eviter les comportements bloquants, on va autoriser la validation du 
]]--[[// comportement selon plusieurs criteres :
]]--[[//
]]--[[//                  - distance significative   : distance que l'on est censé 
]]--[[//                                              avoir parcouru avant evaluation
]]--[[//                  - force enlevée à la volonter de rejoindre a chaque tic où 
]]--[[//                    l'on n'arrive pas a progresser
]]--[[//                  - force ajoutee à chaque fois que l'on arrive a progresser
]]--[[//                    ( on ne depasse pas l'envie max)
]]--[[//                  - distanceMin à l'obj. : ne veut pas rejoindre à moins de...
]]--[[//                  - distanceMax à l'obj. : accepte de s'arreter à partir de...
]]--[[//
]]--[[// Forces :
]]--[[// -------
]]--[[//
]]--[[// La force sur l'action de deplacement est la force propagée dans les 
]]--[[// comportements de plus hauts niveaux. Le test sur la satisfaction se fait
]]--[[// simplement en verifiant que la volonté de parcourir l'itineraire est superieure
]]--[[// a 1
]]--[[//
]]--[[// Itineraires Partiels
]]--[[// --------------------
]]--[[//
]]--[[//      Le pathfind peut renvoyer un itineraire partiel, c'est a dire qui
]]--[[//      essaie de rejoindre au mieux la position demandée tout en respectant
]]--[[//      les containtes passés en argument. Typiquement, si on essaie de rejoindre
]]--[[//      un point en dehors du fuseau et que l'on specifie comme argument de
]]--[[//      pathfind eInfoFuseau, alors, l'itineraire sera calculé dans le fuseau
]]--[[//      => aucune chance de rejoindre le point. Il faut donc considerer ce cas 
]]--[[//      dans la mission
]]--[[//
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_AIR_RejoindreParItineraire"
{
    activations =
    {
        { "BEH_Dep_Pion_AIR_Voler", {} },
        { "ACT_Obs_EtablirVisionCur", {} },
        { "BEH_Dep_Progresser", {} },
        { "ACT_Info_Trace", {} },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.listePoints = self.params[1]
        self._namedParams.typeProgression = self.params[2]
        self._namedParams.ePathType = self.params[3]
        self._namedParams.distanceMin = self.params[4]
        self._namedParams.distanceMax = self.params[5]
        self._namedParams.forceDelaiSucces = self.params[6]
        self._namedParams.forceDelaiPenalite = self.params[7]
    end,

    activate = function( self )
        --[[//variables persistantes
]]        self.eEtat = self.eEtat or eActionEnCours
        self.itineraire = self.itineraire or nil
        self.initialisationOK = self.initialisationOK or false
        self.forceDelai = self.forceDelai or 0
        self.pointEffectifARejoindre = self.pointEffectifARejoindre or nil
        self.distanceMaxEffective = self.distanceMaxEffective or 0
        --[[//variables locales
]]local forceEnvieRejoindre = 0
        local envieArret = 0
        --[[//condition d'arret
]]if( DEC_Geometrie_PositionsEgales( myself:DEC_Agent_Position(), DEC_ListePoints_GetAt( self._namedParams.listePoints, DEC_ListePoints_Size( self._namedParams.listePoints ) - 1 ) ) ) then
            do
                self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_AIR_RejoindreParItineraire" )
                                self.params.__returnValue = eActionEffectuee
                Halt( self )
                do return end

            end
        end

        if( ModuleBegins() ) then
            do
                assert( self._namedParams.listePoints ~= nil, "liste de points non valide" )
                assert( ( DEC_ListePoints_Size( self._namedParams.listePoints ) ~= 0 and DEC_ListePoints_Size( self._namedParams.listePoints ) ~= nil ), "liste de points vide" )
                if( self._namedParams.distanceMax < self._namedParams.distanceMin ) then
                    self.distanceMaxEffective = self._namedParams.distanceMin
                else
                    self.distanceMaxEffective = self._namedParams.distanceMax
                end

                self.itineraire = DEC_CreerItineraireListe( self._namedParams.listePoints, self._namedParams.ePathType )
            end
--[[// gestion de la progression
]]        end

        if( self.eEtat == eActionEffectuee ) then
            do
                self.eEtat = eActionEnCours
                                do
                    self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_AIR_RejoindreParItineraire" )
                                        self.params.__returnValue = eActionEffectuee
                    Halt( self )
                    do return end

                end

            end
        end

        Activate( self.activations.BEH_Dep_Pion_AIR_Voler, 1, {} )
        Activate( self.activations.ACT_Obs_EtablirVisionCur, 1, {} )
        Activate( self.activations.BEH_Dep_Progresser, 1, setmetatable( { self.itineraire, self._namedParams.typeProgression, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
         do
            local _continue = true
            local switch_1 = DEC_Itineraire_Etat( self.itineraire )
            local cases_switch_1 = {}
                if switch_1 == eItineraire_Valide
                or switch_1 == eItineraire_Partiel then
                    --[[// prise en compte des penalités
]]if( DEC_Itineraire_Etat( self.itineraire ) == eItineraire_Partiel ) then
                        Activate( self.activations.ACT_Info_Trace, 1, { "ATTENTION : Itineraire Partiel", } )
                    end

                    if( not self.initialisationOK ) then
                        do
                            self.pointEffectifARejoindre = DEC_Itineraire_DernierPoint( self.itineraire )
                            self.initialisationOK = true
                        end
                    end

                    if( self.pointEffectifARejoindre ~= nil and DEC_Agent_EstEnVol() ) then
                        do
                            local distance = DEC_Geometrie_Distance( myself:DEC_Agent_Position(), self.pointEffectifARejoindre )
                            local coordinationAutomate = DEC_Agent_AutomateEstEmbraye() and ( DIA_IsListEmpty( myself.listePionsCoordination_ ) )
                            if( ( distance >= self._namedParams.distanceMin ) and ( distance <= self._namedParams.distanceMax ) and not coordinationAutomate ) then
                                do
                                    --[[//penalite
]]if( not DEC_Itineraire_EstEnMouvementSur( self.itineraire ) ) then
                                        self.forceDelai = Min( 1, self.forceDelai + self._namedParams.forceDelaiPenalite )
                                    else
                                        --[[//succes
]]self.forceDelai = Max( 0, self.forceDelai - self._namedParams.forceDelaiSucces )
                                    end

                                    if( self.forceDelai >= 1 ) then
                                        do
                                            self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_AIR_RejoindreParItineraire" )
                                                                                        self.params.__returnValue = eActionEffectuee
                                            Halt( self )
                                            do return end

                                        end
                                    end

                                end
                            end

                        end
                    end

                    _continue = false
                                cases_switch_1[1] = true
elseif switch_1 == eItineraire_Invalide then
                    do
                    end

                    self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_AIR_RejoindreParItineraire" )
                                        self.params.__returnValue = eActionImpossible
                    Halt( self )
                    do return end

                                end
                if cases_switch_1[2] or switch_1 == eItineraire_CalculEnCours then
                    do
                    end

                    _continue = false
                                cases_switch_1[3] = true
elseif switch_1 == eItineraire_Impossible then
                    do
                    end

                    self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_AIR_RejoindreParItineraire" )
                                        self.params.__returnValue = eActionImpossible
                    Halt( self )
                    do return end

                                end
                if cases_switch_1[4] or switch_1 == eItineraire_Annule then
                    self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_AIR_RejoindreParItineraire" )
                                        self.params.__returnValue = eActionImpossible
                    Halt( self )
                    do return end

                                end
            end

    end,

    destroy = function( self )
                self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_AIR_RejoindreParItineraire" )
    end,

--[[// *****************************************************************************
]]--[[// S'eloigner Position Vers : Ce comportement permet de s'eloigner d'un point
]]--[[// par rapport à une direction à une distance donnée.
]]--[[//
]]--[[// Elle est employée dans la manoeuvre jalonner de l'AIR
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_AIR_SEloignerPositionVers"
{
    activations =
    {
        { "BEH_Dep_Pion_AIR_RejoindrePoint", {} },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.position = self.params[1]
        self._namedParams.distance = self.params[2]
        self._namedParams.directionDangereuse = self.params[3]
        self._namedParams.ePathType = self.params[4]
    end,

    activate = function( self )
        self.pointARejoindre = self.pointARejoindre or nil--[[// variables persistantes
]]
        self.eEtat = self.eEtat or eActionEnCours
        if( ModuleBegins() ) then
            self.pointARejoindre = S_Geometrie_PtInvDirDangereuse( self._namedParams.position, self._namedParams.directionDangereuse, self._namedParams.distance )
        end

        if( self.eEtat == eActionEffectuee ) then
            do
                self.eEtat = eActionEnCours
                                do
                                        self.params.__returnValue = eActionEffectuee
                    Halt( self )
                    do return end

                end

            end
        end

        Activate( self.activations.BEH_Dep_Pion_AIR_RejoindrePoint, 1, setmetatable( { self.pointARejoindre, eProgressionDefaut, self._namedParams.ePathType, 0, 0, 0, 0, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
    end,

--[[// *****************************************************************************
]]--[[// Suivre un T_Pion entre distanceMin et DistanceMax
]]--[[//
]]--[[// On evite les cas bloquant en utilisant le systeme de penalites dans le dep.
]]--[[// en effet, si entre distanceMin et distanceMax au pion, on n'est bloqué, on
]]--[[// se donne un delai avant de killer l'intance de ce comportement. De cette facon
]]--[[// si on veut continuer a suivre, on prendra la nouvelle position de "agent".
]]--[[//
]]--[[// exemple => on est bloqué, le pion a suivre decroche, et on reste sur place
]]--[[//
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_AIR_Suivre"
{
    activations =
    {
        { "BEH_Dep_Pion_AIR_RejoindrePoint", {} },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.agent = self.params[1]
        self._namedParams.distanceMin = self.params[2]
        self._namedParams.typeProgression = self.params[3]
        self._namedParams.ePathType = self.params[4]
    end,

    activate = function( self )
        --[[// variables persistantes
]]self.eEtat = self.eEtat or eActionEnCours
        self.pointARejoindre = self.pointARejoindre or nil
        if( ModuleBegins() ) then
            do
                local mission = DEC_GetMission( self._namedParams.agent )
                if( mission ~= nil ) then
                    do
                        --[[//le point à rejondre est à distanceMin du pion que l'on suit
]]self.pointARejoindre = DEC_Geometrie_PositionTranslateDir( self._namedParams.agent:DEC_Agent_Position(), DEC_GetDirectionDanger( mission ), -self._namedParams.distanceMin )
                    end
                else
do
                        self.pointARejoindre = DEC_Geometrie_CreerPoint()
                        DEC_Copie_Point( self._namedParams.agent:DEC_Agent_Position(), self.pointARejoindre )
                    end
                end

            end
        end

        if( self.eEtat == eActionEffectuee ) then
            do
                self.eEtat = eActionEnCours
                                do
                                        self.params.__returnValue = eActionEffectuee
                    Halt( self )
                    do return end

                end

            end
        end

        if( self.eEtat == eActionImpossible ) then
            do
                                do
                                        self.params.__returnValue = eActionImpossible
                    Halt( self )
                    do return end

                end

                                self.params.__returnValue = eActionImpossible
                Halt( self )
                do return end

            end
        end

        Activate( self.activations.BEH_Dep_Pion_AIR_RejoindrePoint, 1, setmetatable( { self.pointARejoindre, self._namedParams.typeProgression, self._namedParams.ePathType, 0, 1105199104, 0.05, 0.1, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
    end,

--[[// *****************************************************************************
]]--[[// SuivreSurFlanc : Ce comportement permet de suivre un groupe d'agent face à 
]]--[[//une direction donnée
]]--[[//
]]--[[// En outre, on favorise l'observation face à cette direction
]]--[[//
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_AIR_SuivreSurFlanc"
{
    activations =
    {
        { "ACT_Maj_Pions_ObjectifEsquive", {} },
        { "ACT_Obs_EtablirVisionFaceADir", {} },
        { "BEH_Dep_Pion_AIR_RejoindrePoint", {} },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.listePions = self.params[1]
        self._namedParams.dirObservation = self.params[2]
        self._namedParams.distance = self.params[3]
        self._namedParams.distanceMin = self.params[4]
        self._namedParams.typeProgression = self.params[5]
        self._namedParams.ePathType = self.params[6]
    end,

    activate = function( self )
        --[[// variables persistantes   
]]self.eEtat = self.eEtat or eActionEnCours
        self.pointARejoindre = self.pointARejoindre or nil
        if( ModuleBegins() ) then
            self.pointARejoindre = DEC_Geometrie_CalculerPositionCouverture( self._namedParams.listePions, self._namedParams.dirObservation, self._namedParams.distance )
        end

        Activate( self.activations.ACT_Maj_Pions_ObjectifEsquive, 1, { self.pointARejoindre, } )
        Activate( self.activations.ACT_Obs_EtablirVisionFaceADir, 1, { self._namedParams.dirObservation, } )
        if( self.eEtat == eActionEffectuee ) then
            do
                self.eEtat = eActionEnCours
                                do
                                        self.params.__returnValue = eActionEffectuee
                    Halt( self )
                    do return end

                end

            end
        end

        if( self.eEtat == eActionImpossible ) then
            do
                                do
                                        self.params.__returnValue = eActionImpossible
                    Halt( self )
                    do return end

                end

                                self.params.__returnValue = eActionImpossible
                Halt( self )
                do return end

            end
        end

        Activate( self.activations.BEH_Dep_Pion_AIR_RejoindrePoint, 1, setmetatable( { self.pointARejoindre, self._namedParams.typeProgression, self._namedParams.ePathType, 0, 1105199104, 0.05, 0.1, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
    end,

}

connections = connections or {}
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_PremiereAllure, "ACT_Dep_Pions_AIR_Voler", nodes.ACT_Dep_Pions_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_PremiereAllure, "ACT_Dep_ModulationVitesse", nodes.ACT_Dep_ModulationVitesse }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_PremiereAllureAvecAppuis, "ACT_Dep_Pions_AIR_Voler", nodes.ACT_Dep_Pions_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_PremiereAllureAvecAppuis, "ACT_Dep_ModulationVitesse", nodes.ACT_Dep_ModulationVitesse }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_RejoindreParItineraire, "BEH_Dep_Pion_AIR_Voler", nodes.BEH_Dep_Pion_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_RejoindreParItineraire, "ACT_Obs_EtablirVisionCur", nodes.ACT_Obs_EtablirVisionCur }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_RejoindreParItineraire, "BEH_Dep_Progresser", nodes.BEH_Dep_Progresser }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_RejoindreParItineraire, "ACT_Info_Trace", nodes.ACT_Info_Trace }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_RejoindrePion, "BEH_Dep_Pion_AIR_RejoindrePoint", nodes.BEH_Dep_Pion_AIR_RejoindrePoint }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_RejoindrePoint, "BEH_Dep_Pion_AIR_RejoindreParItineraire", nodes.BEH_Dep_Pion_AIR_RejoindreParItineraire }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SEloignerPositionVers, "BEH_Dep_Pion_AIR_RejoindrePoint", nodes.BEH_Dep_Pion_AIR_RejoindrePoint }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SePoser, "ACT_Dep_Pions_AIR_Voler", nodes.ACT_Dep_Pions_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SePoserEnAttenteDe, "ACT_Dep_Pions_AIR_Voler", nodes.ACT_Dep_Pions_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SecondeAllure, "ACT_Dep_Pions_AIR_Voler", nodes.ACT_Dep_Pions_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SecondeAllure, "ACT_Dep_ModulationVitesse", nodes.ACT_Dep_ModulationVitesse }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SecondeAllureAvecAppuis, "ACT_Dep_Pions_AIR_Voler", nodes.ACT_Dep_Pions_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SecondeAllureAvecAppuis, "ACT_Dep_ModulationVitesse", nodes.ACT_Dep_ModulationVitesse }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_Suivre, "BEH_Dep_Pion_AIR_RejoindrePoint", nodes.BEH_Dep_Pion_AIR_RejoindrePoint }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SuivreSurFlanc, "ACT_Maj_Pions_ObjectifEsquive", nodes.ACT_Maj_Pions_ObjectifEsquive }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SuivreSurFlanc, "ACT_Obs_EtablirVisionFaceADir", nodes.ACT_Obs_EtablirVisionFaceADir }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_SuivreSurFlanc, "BEH_Dep_Pion_AIR_RejoindrePoint", nodes.BEH_Dep_Pion_AIR_RejoindrePoint }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_TroisiemeAllure, "ACT_Dep_Pions_AIR_Voler", nodes.ACT_Dep_Pions_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_TroisiemeAllure, "ACT_Dep_ModulationVitesse", nodes.ACT_Dep_ModulationVitesse }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_TroisiemeAllureAvecAppuis, "ACT_Dep_Pions_AIR_Voler", nodes.ACT_Dep_Pions_AIR_Voler }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_TroisiemeAllureAvecAppuis, "ACT_Dep_ModulationVitesse", nodes.ACT_Dep_ModulationVitesse }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_Voler, "ACT_Dep_PasserEnModeFurtif", nodes.ACT_Dep_PasserEnModeFurtif }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_Voler, "BEH_Dep_Pion_AIR_SecondeAllure", nodes.BEH_Dep_Pion_AIR_SecondeAllure }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_Voler, "BEH_Dep_Pion_AIR_SecondeAllureAvecAppuis", nodes.BEH_Dep_Pion_AIR_SecondeAllureAvecAppuis }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_Voler, "BEH_Dep_Pion_AIR_TroisiemeAllure", nodes.BEH_Dep_Pion_AIR_TroisiemeAllure }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_AIR_Voler, "BEH_Dep_Pion_AIR_TroisiemeAllureAvecAppuis", nodes.BEH_Dep_Pion_AIR_TroisiemeAllureAvecAppuis }
