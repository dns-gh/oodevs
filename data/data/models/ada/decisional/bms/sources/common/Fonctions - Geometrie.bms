includedFiles = includedFiles or {}
includedFiles["sources/common/Fonctions - Geometrie.bms"] = true


--[[// ------------------------------------------------------------------------
]]--[[// 							Geometrie									 //
]]--[[// ------------------------------------------------------------------------
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie le point barycentre d'une liste d'agents
]]--[[// Renvoie 0 si l'objet est invalide
]]--[[//-----------------------------------------------------------------------------
]]--[[// Si la localisation transmise est invalide
]]--[[// ------------------------------------------------------------------------
]]--[[// Calcule une direction inverse a la direction dangereuse.
]]--[[//
]]--[[// Renvoie 0 si la source n'est pas valide.
]]--[[// Le point renvoye doit etre detruit
]]--[[// ------------------------------------------------------------------------
]]--[[//calcul du point translaté de direction dirOpposée et de distance rDist au point source 
]]--[[// ----------------------------------------------------------------------------
]]--[[// Retourne true si la distance entre ptDest et ptTest est < a rEcart
]]--[[// ----------------------------------------------------------------------------
]]--[[//-----------------------------------------------------------------------------
]]--[[// Barycentre d'une localisation
]]--[[//
]]--[[// Commentaires : 
]]--[[// Cette fonction calcule si possible la localisation clippee dans le fuseau du pion.
]]--[[// Si la localisation n'est pas dans le fuseau, alors on calcul le simple
]]--[[// barycentre
]]--[[//-----------------------------------------------------------------------------
]]--[[// Calcul de la position de l'objet dans la fuseau
]]--[[//si l'objet n'a aucune surface dans le fuseau, alors, on calcul sa
]]--[[//position sans considérer le fuseau.
]]--[[// ----------------------------------------------------------------------------
]]--[[// Renvoie point le plus proche de la zone parmis les pooints passés en paramètre 
]]--[[// OPT MIA: Spé ALAT
]]--[[// ----------------------------------------------------------------------------
]]--[[// Init
]]--[[// ----------------------------------------------------------------------------
]]--[[// Renvoie point le plus proche de la zone parmis les pooints passés en paramètre 
]]--[[// OPT MIA: Spé ALAT
]]--[[// ----------------------------------------------------------------------------
]]function S_Geometrie_BarycentreAgents( listePions )
    local _returnValue = nil
    if( ( #( listePions ) == 0 or #( listePions ) == nil ) ) then
        do
            _returnValue = nil
                        return _returnValue

        end
    end

    _returnValue = DEC_Geometrie_CalculerBarycentreAgents( listePions )
    return _returnValue
end

function S_Geometrie_PtInvDirDangereuse( ptSrc, dirEnnemi, rDist )
    local _returnValue = nil
    _returnValue = DEC_Geometrie_PositionTranslateDir( ptSrc, dirEnnemi, -rDist )
    return _returnValue
end

function S_Geometrie_EstProchePosition( ptDest, ptTest, rEcart )
    local _returnValue = false
    _returnValue = DEC_Geometrie_Distance( ptDest, ptTest ) <= rEcart
    return _returnValue
end

function S_Geometrie_BarycentreZone( localisation )
    local _returnValue = nil
    assert( ( localisation ~= 0 and localisation ~= nil ), "Pointeur Invalide" )
    local ptRetour = nil
    local returnCode = nil
    ptRetour = DEC_Geometrie_CalculerBarycentreLocalisationDansFuseau( localisation )
    if( ptRetour ~= nil ) then
        _returnValue = ptRetour
    else
        _returnValue = DEC_Geometrie_CalculerBarycentreLocalisation( localisation )
    end

    return _returnValue
end

function S_Geometrie_PointPlusProcheLocalisation( zone, listePoints )
    local _returnValue = nil
    local pointEntreeDansZone = nil
    local distanceMin = 1105199104
    local pointRetour = nil
    local pointBuffer = nil
    _returnValue = nil
    pointEntreeDansZone = DEC_Geometrie_CalculerPointProcheLocalisationDansFuseau( zone )
    if( pointEntreeDansZone == nil ) then
        return _returnValue
    end

    local distanceTmp = 0
    local it = 0
    while it < DEC_ListePoints_Size( listePoints ) do
        local _continue = true
do
            pointBuffer = DEC_ListePoints_GetAt( listePoints, it )
            distanceTmp = DEC_Geometrie_Distance( pointBuffer, pointEntreeDansZone )
            if( distanceTmp < distanceMin ) then
                do
                    distanceMin = distanceTmp
                    pointRetour = pointBuffer
                end
            end

        end
    it = it + 1
    end

    _returnValue = pointRetour
    return _returnValue
end

function S_Geometrie_DecoupeLocalisation( localisationSrc, rNombreSections )
    local _returnValue = {}
    local eError = nil
    local listeLocalisationBuffer = {}
    listeLocalisationBuffer = DEC_Geometrie_DecoupeLocalisation( localisationSrc, rNombreSections, eError )
    eError = listeLocalisationBuffer.second
    listeLocalisationBuffer = listeLocalisationBuffer.first
     do
        local switch_1 = eError
        local cases_switch_1 = {}
            if switch_1 == eNoError then
                _returnValue = listeLocalisationBuffer
                
                        cases_switch_1[1] = true
elseif switch_1 == eError_PionsPasDansMemeFuseau then
                do
                end

                
                        cases_switch_1[2] = true
elseif switch_1 == eError_LocalisationPasDansFuseau then
                do
                end

                
                        cases_switch_1[3] = true
elseif switch_1 == eWarning_DecoupageIncomplet then
                do
                end

                
                        cases_switch_1[4] = true
            end
        end

    return _returnValue
end

