includedFiles = includedFiles or {}
includedFiles["sources/marine/pions/common/behaviors/Behaviors - Dep.bms"] = true

local emptyTable = emptyTable

include "bit.lua"


--[[// *****************************************************************************
]]--[[// RejoindrePoint :
]]--[[// ----------------
]]--[[// Cas particulier de BEH_RejoindreParItineraire.
]]--[[// la liste des points est une liste composée uniquement du point d'arrivé
]]--[[// *****************************************************************************
]]node "BEH_Dep_Pion_MARINE_RejoindrePoint"
{
    feedbacks = { { { "done_BEH_Dep_Pion_MARINE_RejoindrePoint" }, "BEH_Dep_Pion_MARINE_RejoindrePoint" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_BEH_Dep_Pion_MARINE_RejoindrePoint, {value} ) end,
    activations =
    {
        { "BEH_Dep_Pion_MARINE_RejoindreParItineraire", { "done_BEH_Dep_Pion_MARINE_RejoindreParItineraire" } },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.point = self.params[1]
        self._namedParams.typeProgression = self.params[2]
        self._namedParams.ePathType = self.params[3]
        self._namedParams.distanceMin = self.params[4]
        self._namedParams.distanceMax = self.params[5]
        self._namedParams.forceDelaiSucces = self.params[6]
        self._namedParams.forceDelaiPenalite = self.params[7]
    end,

    activate = function( self )
        local Activate = Activate
        assert( self._namedParams.point ~= nil, "MARINE : Rejoindre Point" )
        --[[// variables persistantes
]]self.listePoints = self.listePoints or DEC_Geometrie_CreerListePoints()
        self.eEtat = self.eEtat or eActionEnCours
        if( DEC_Geometrie_Distance( myself:DEC_Agent_Position(), self._namedParams.point ) == 0 ) then
            self:SendFeedback( eActionEffectuee )
            Halt( self )
            do return end
        end

        if( ModuleBegins() ) then
            DEC_ListePoints_PushBack( self.listePoints, self._namedParams.point )
        end

        if( self.eEtat ~= eActionEnCours ) then
            self:SendFeedback( self.eEtat )
            Halt( self )
            do return end
        else
            Activate( self.activations.BEH_Dep_Pion_MARINE_RejoindreParItineraire, 1, { self.listePoints, self._namedParams.typeProgression, self._namedParams.ePathType, self._namedParams.distanceMin, self._namedParams.distanceMax, self._namedParams.forceDelaiSucces, self._namedParams.forceDelaiPenalite, } )
self.done_BEH_Dep_Pion_MARINE_RejoindreParItineraire = function( self, _, v ) self.eEtat = v[1] end
        end

    end,

--[[// *****************************************************************************
]]--[[// RejoindrePoint :
]]--[[// ----------------
]]--[[// Cas particulier de BEH_RejoindrePoint.
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_MARINE_RejoindrePion"
{
    feedbacks = { { { "done_BEH_Dep_Pion_MARINE_RejoindrePion" }, "BEH_Dep_Pion_MARINE_RejoindrePion" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_BEH_Dep_Pion_MARINE_RejoindrePion, {value} ) end,
    activations =
    {
        { "BEH_Dep_Pion_MARINE_RejoindrePoint", { "done_BEH_Dep_Pion_MARINE_RejoindrePoint" } },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.pion = self.params[1]
        self._namedParams.typeProgression = self.params[2]
        self._namedParams.ePathType = self.params[3]
        self._namedParams.distanceMin = self.params[4]
        self._namedParams.distanceMax = self.params[5]
        self._namedParams.forceDelaiSucces = self.params[6]
        self._namedParams.forceDelaiPenalite = self.params[7]
        self._namedParams.distanceAvantRelance = self.params[8]
    end,

    activate = function( self )
        local Activate = Activate
                assert( self._namedParams.pion ~= nil, "MARINE : Rejoindre Pion" )
        --[[// variables persistantes
]]self.listePoints = self.listePoints or DEC_Geometrie_CreerListePoints()
        self.eEtat = self.eEtat or eActionEnCours
        self.positionPion = self.positionPion or DEC_Geometrie_CreerPoint()
        if( ModuleBegins() ) then
            DEC_Copie_Point( self._namedParams.pion:DEC_Agent_Position(), self.positionPion )
        end

        if( DEC_Geometrie_Distance( myself:DEC_Agent_Position(), self.positionPion ) == 0 ) then
            self:SendFeedback( eActionEffectuee )
            Halt( self )
            do return end
        end

        if( DEC_Geometrie_Distance( self._namedParams.pion:DEC_Agent_Position(), self.positionPion ) >= self._namedParams.distanceAvantRelance ) then
            Halt( self )
            do return end
        end

        if( self.eEtat ~= eActionEnCours ) then
            do
                                self:SendFeedback( self.eEtat )
                do return end

            end
        else
do
                Activate( self.activations.BEH_Dep_Pion_MARINE_RejoindrePoint, 1, { self.positionPion, self._namedParams.typeProgression, self._namedParams.ePathType, self._namedParams.distanceMin, self._namedParams.distanceMax, self._namedParams.forceDelaiSucces, self._namedParams.forceDelaiPenalite, } )
self.done_BEH_Dep_Pion_MARINE_RejoindrePoint = function( self, _, v ) self.eEtat = v[1] end
            end
        end

    end,

--[[// *****************************************************************************
]]--[[// RejoindreParItineraire
]]--[[// ======================
]]--[[// Ce comportement permet de rejoindre une position en acceptant certains 
]]--[[// compromis. Il arrive qu'il ne soit pas possible de rejoindre un point 
]]--[[// (exemple : si dans de l'eau...)
]]--[[// Pour eviter les comportements bloquants, on va autoriser la validation du 
]]--[[// comportement selon plusieurs criteres :
]]--[[//
]]--[[//                  - distance significative   : distance que l'on est censé 
]]--[[//                                              avoir parcouru avant evaluation
]]--[[//                  - force enlevée à la volonter de rejoindre a chaque tic où 
]]--[[//                    l'on n'arrive pas a progresser
]]--[[//                  - force ajoutee à chaque fois que l'on arrive a progresser
]]--[[//                    ( on ne depasse pas l'envie max)
]]--[[//                  - distanceMin à l'obj. : ne veut pas rejoindre à moins de...
]]--[[//                  - distanceMax à l'obj. : accepte de s'arreter à partir de...
]]--[[//
]]--[[// Forces :
]]--[[// -------
]]--[[//
]]--[[// La force sur l'action de deplacement est la force propagée dans les 
]]--[[// comportements de plus hauts niveaux. Le test sur la satisfaction se fait
]]--[[// simplement en verifiant que la volonté de parcourir l'itineraire est superieure
]]--[[// a 1
]]--[[//
]]--[[// Itineraires Partiels
]]--[[// --------------------
]]--[[//
]]--[[//      Le pathfind peut renvoyer un itineraire partiel, c'est a dire qui
]]--[[//      essaie de rejoindre au mieux la position demandée tout en respectant
]]--[[//      les containtes passés en argument. Typiquement, si on essaie de rejoindre
]]--[[//      un point en dehors du fuseau et que l'on specifie comme argument de
]]--[[//      pathfind eInfoFuseau, alors, l'itineraire sera calculé dans le fuseau
]]--[[//      => aucune chance de rejoindre le point. Il faut donc considerer ce cas 
]]--[[//      dans la mission
]]--[[//
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_MARINE_RejoindreParItineraire"
{
    feedbacks = { { { "done_BEH_Dep_Pion_MARINE_RejoindreParItineraire" }, "BEH_Dep_Pion_MARINE_RejoindreParItineraire" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_BEH_Dep_Pion_MARINE_RejoindreParItineraire, {value} ) end,
    activations =
    {
        { "ACT_Obs_EtablirVisionCur", { "done_ACT_Obs_EtablirVisionCur" } },
        { "BEH_Dep_Progresser", { "done_BEH_Dep_Progresser" } },
        { "ACT_Info_Trace", { "done_ACT_Info_Trace" } },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.listePoints = self.params[1]
        self._namedParams.typeProgression = self.params[2]
        self._namedParams.ePathType = self.params[3]
        self._namedParams.distanceMin = self.params[4]
        self._namedParams.distanceMax = self.params[5]
        self._namedParams.forceDelaiSucces = self.params[6]
        self._namedParams.forceDelaiPenalite = self.params[7]
    end,

    activate = function( self )
        local Activate = Activate
        --[[//variables persistantes
]]        self.eEtat = self.eEtat or eActionEnCours
        self.itineraire = self.itineraire or nil
        self.initialisationOK = self.initialisationOK or false
        self.forceDelai = self.forceDelai or 0
        self.pointEffectifARejoindre = self.pointEffectifARejoindre or nil
        self.distanceMaxEffective = self.distanceMaxEffective or 0
        --[[//variables locales
]]local forceEnvieRejoindre = 0
        local envieArret = 0
        --[[//condition d'arret
]]if( DEC_Geometrie_PositionsEgales( myself:DEC_Agent_Position(), DEC_ListePoints_GetAt( self._namedParams.listePoints, DEC_ListePoints_Size( self._namedParams.listePoints ) - 1 ) ) ) then
            do
                self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_MARINE_RejoindreParItineraire" )
                                self:SendFeedback( eActionEffectuee )
                Halt( self )
                do return end

            end
        end

        if( ModuleBegins() ) then
            do
                assert( self._namedParams.listePoints ~= nil, "liste de points non valide" )
                assert( DEC_ListePoints_Size( self._namedParams.listePoints ) ~= nil, "liste de points vide" )
                if( self._namedParams.distanceMax < self._namedParams.distanceMin ) then
                    self.distanceMaxEffective = self._namedParams.distanceMin
                else
                    self.distanceMaxEffective = self._namedParams.distanceMax
                end

                self.itineraire = DEC_CreerItineraireListe( self._namedParams.listePoints, self._namedParams.ePathType )
            end
        end

        if( self.eEtat == eActionEffectuee ) then
            do
                self.eEtat = eActionEnCours
                                do
                    self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_MARINE_RejoindreParItineraire: " )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                end

            end
        end

        Activate( self.activations.ACT_Obs_EtablirVisionCur, 1, emptyTable )
        Activate( self.activations.BEH_Dep_Progresser, 1, { self.itineraire, self._namedParams.typeProgression, } )
self.done_BEH_Dep_Progresser = function( self, _, v ) self.eEtat = v[1] end
         do
            local _continue = true
            local switch_1 = DEC_Itineraire_Etat( self.itineraire )
            local cases_switch_1 = {}
                if switch_1 == eItineraire_Valide
                or switch_1 == eItineraire_Partiel then
                    if( DEC_Itineraire_Etat( self.itineraire ) == eItineraire_Partiel ) then
                        Activate( self.activations.ACT_Info_Trace, 1, { "ATTENTION : Itineraire Partiel", } )
                    end

                    if( not self.initialisationOK ) then
                        do
                            self.pointEffectifARejoindre = DEC_Itineraire_DernierPoint( self.itineraire )
                            self.initialisationOK = true
                        end
                    end

                    if( self.pointEffectifARejoindre ~= nil ) then
                        do
                            --[[//si je suis entre distanceMin et distanceMax
]]local distance = DEC_Geometrie_Distance( myself:DEC_Agent_Position(), self.pointEffectifARejoindre )
                            if( ( distance >= self._namedParams.distanceMin ) and ( distance <= self._namedParams.distanceMax ) ) then
                                do
                                    --[[//penalite
]]if( not DEC_Itineraire_EstEnMouvementSur( self.itineraire ) ) then
                                        self.forceDelai = Min( 1, self.forceDelai + self._namedParams.forceDelaiPenalite )
                                    else
                                        --[[//succes
]]self.forceDelai = Max( 0, self.forceDelai - self._namedParams.forceDelaiSucces )
                                    end

                                    if( self.forceDelai >= 1 ) then
                                        do
                                            self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_MARINE_RejoindreParItineraire: " )
                                                                                        self:SendFeedback( eActionEffectuee )
                                            Halt( self )
                                            do return end

                                        end
                                    end

                                end
                            end

                        end
                    end

                    _continue = false
                                cases_switch_1[1] = true
elseif switch_1 == eItineraire_Invalide then
                    do
                    end

                    self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_MARINE_RejoindreParItineraire: " )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
                if cases_switch_1[2] or switch_1 == eItineraire_CalculEnCours then
                    do
                    end

                    _continue = false
                                cases_switch_1[3] = true
elseif switch_1 == eItineraire_Impossible then
                    do
                    end

                    self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_MARINE_RejoindreParItineraire: " )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
                if cases_switch_1[4] or switch_1 == eItineraire_Annule then
                    self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_MARINE_RejoindreParItineraire: " )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
            end

    end,

    destroy = function( self )
                self.itineraire = S_Misc_DetruireItineraire( self.itineraire, "BEH_Dep_Pion_MARINE_RejoindreParItineraire: " )
    end,

--[[// *****************************************************************************
]]--[[// Suivre un T_Pion entre distanceMin et DistanceMax
]]--[[//
]]--[[// On evite les cas bloquant en utilisant le systeme de penalites dans le dep.
]]--[[// en effet, si entre distanceMin et distanceMax au pion, on n'est bloqué, on
]]--[[// se donne un delai avant de killer l'intance de ce comportement. De cette facon
]]--[[// si on veut continuer a suivre, on prendra la nouvelle position de "agent".
]]--[[//
]]--[[// exemple => on est bloqué, le pion a suivre decroche, et on reste sur place
]]--[[//
]]--[[// *****************************************************************************
]]}

node "BEH_Dep_Pion_MARINE_Suivre"
{
    feedbacks = { { { "done_BEH_Dep_Pion_MARINE_Suivre" }, "BEH_Dep_Pion_MARINE_Suivre" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_BEH_Dep_Pion_MARINE_Suivre, {value} ) end,
    activations =
    {
        { "BEH_Dep_Pion_MARINE_RejoindrePoint", { "done_BEH_Dep_Pion_MARINE_RejoindrePoint" } },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.agent = self.params[1]
        self._namedParams.distanceMin = self.params[2]
        self._namedParams.typeProgression = self.params[3]
        self._namedParams.ePathType = self.params[4]
    end,

    activate = function( self )
        local Activate = Activate
        --[[// variables persistantes
]]self.eEtat = self.eEtat or eActionEnCours
        self.pointARejoindre = self.pointARejoindre or nil
        if( ModuleBegins() ) then
            do
                local mission = DEC_GetMission( self._namedParams.agent )
                if( mission ~= nil ) then
                    do
                        self.pointARejoindre = DEC_Geometrie_PositionTranslateDir( self._namedParams.agent:DEC_Agent_Position(), DEC_GetDirectionDanger( mission ), self._namedParams.distanceMin )
                    end
                else
do
                        self.pointARejoindre = DEC_Geometrie_CreerPoint()
                        DEC_Copie_Point( self._namedParams.agent:DEC_Agent_Position(), self.pointARejoindre )
                    end
                end

            end
        end

        if( self.eEtat == eActionEffectuee ) then
            do
                self.eEtat = eActionEnCours
                                do
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                end

            end
        end

        if( self.eEtat == eActionImpossible ) then
            do
                                do
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                end

                                self:SendFeedback( eActionImpossible )
                Halt( self )
                do return end

            end
        end

        Activate( self.activations.BEH_Dep_Pion_MARINE_RejoindrePoint, 1, { self.pointARejoindre, self._namedParams.typeProgression, self._namedParams.ePathType, 0, 1105199104, 0.05, 0.1, } )
self.done_BEH_Dep_Pion_MARINE_RejoindrePoint = function( self, _, v ) self.eEtat = v[1] end
    end,

}

connections = connections or {}
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_MARINE_RejoindreParItineraire, "ACT_Obs_EtablirVisionCur", nodes.ACT_Obs_EtablirVisionCur }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_MARINE_RejoindreParItineraire, "BEH_Dep_Progresser", nodes.BEH_Dep_Progresser }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_MARINE_RejoindreParItineraire, "ACT_Info_Trace", nodes.ACT_Info_Trace }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_MARINE_RejoindrePion, "BEH_Dep_Pion_MARINE_RejoindrePoint", nodes.BEH_Dep_Pion_MARINE_RejoindrePoint }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_MARINE_RejoindrePoint, "BEH_Dep_Pion_MARINE_RejoindreParItineraire", nodes.BEH_Dep_Pion_MARINE_RejoindreParItineraire }
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_MARINE_Suivre, "BEH_Dep_Pion_MARINE_RejoindrePoint", nodes.BEH_Dep_Pion_MARINE_RejoindrePoint }
