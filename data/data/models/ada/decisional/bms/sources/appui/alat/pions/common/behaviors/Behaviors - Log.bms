includedFiles = includedFiles or {}
includedFiles["sources/appui/alat/pions/common/behaviors/Behaviors - Log.bms"] = true

include "bit.lua"


--[[// -----------------------------------------------------------------------------
]]--[[// Recompletement :
]]--[[//
]]--[[// Rejoindre un plot de ravitaillement assigné
]]--[[// se poser sans eteindre les moteurs (important car pas detectable)
]]--[[// se recompleter (selon specs carburant et munitions)
]]--[[//
]]--[[//
]]--[[// Si pas de plot attribué, se ravitailler au TC2
]]--[[// Pas de déplacement si on est à moins de 1000m de la position de ravitaillement
]]--[[//
]]--[[// itinéraire direct pour ravitaillement avec evitement des ennemis connus
]]--[[// -----------------------------------------------------------------------------
]]node "BEH_Log_Pion_ALAT_Recompletement"
{
    activations =
    {
        { "BEH_Dep_Pion_ALAT_RejoindrePoint", {} },
        { "BEH_Dep_Pion_ALAT_RejoindrePion", {} },
        { "BEH_Log_Pion_ALAT_SeRecompleterSurPlot", {} },
        { "BEH_Log_Pion_ALAT_SeRecompleterSurTC2", {} },
        { "BEH_Dep_Pion_ALAT_SePoser", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        self.eEtat = self.eEtat or eActionEnCours
        self.positionPlotRavitaillement = self.positionPlotRavitaillement or DEC_Geometrie_CreerPoint()
        self.ePhase = self.ePhase or eRejoindre
        local TC2 = DEC_Pion_TC2()
        local pionTC2 = nil
        if( TC2 ~= nil ) then
            pionTC2 = DEC_Pion_PionPCDeAutomate( TC2 )
        end

        --[[// Si on n'a pas de TC2 ni de plot de ravitaillement attribué
]]if( not ( DEC_ConnaissanceObjet_EstValide( myself.plotRavitaillementAssigne_ ) and TC2 == 0 or DEC_ConnaissanceObjet_EstValide( myself.plotRavitaillementAssigne_ ) and TC2 == nil ) ) then
            do return end
        end

         do
            local _continue = true
            local switch_1 = self.ePhase
            local cases_switch_1 = {}
                if switch_1 == eRejoindre then
                    if( self.eEtat == eActionEffectuee ) then
                        do
                            self.eEtat = eActionEnCours
                                                        do
                                self.ePhase = eRecompleter
                                                                do return end

                            end

                        end
                    end

                    if( self.eEtat == eActionImpossible ) then
                        do
                                                        do
                                DEC_Warning( eRC_MissionImpossible )
                            end

                                                        self.params.__returnValue = eActionImpossible
                            Halt( self )
                            do return end

                        end
--[[// si on a un changement de mission et qu'on est en cours de ravitaillement
]]--[[// relancer le calcul du chemin pour prendre en compte les nouvelles
]]--[[// limites tactiques
]]                    end

                    self.missionPrec = self.missionPrec or DEC_GetMission( myself )
                    if( DEC_GetMission( myself ) ~= self.missionPrec ) then
                        do
                            self.missionPrec = DEC_GetMission( myself )
                                                        do return end

                        end
                    end

                    if( DEC_ConnaissanceObjet_EstValide( myself.plotRavitaillementAssigne_ ) ) then
                        do
                            DEC_Copie_Point( S_Geometrie_BarycentreZone( DEC_ConnaissanceObjet_Localisation( myself.plotRavitaillementAssigne_ ) ), self.positionPlotRavitaillement )
                            --[[// si l'agent est à moins de 1000m du plot de ravitaillement, ne
]]--[[// pas se déplacer
]]if( DEC_Geometrie_Distance( self.positionPlotRavitaillement, myself:DEC_Agent_Position() ) <= 1000 ) then
                                do
                                    self.eEtat = eActionEffectuee
                                                                        do return end

                                end
--[[//rejoindre le plot de ravitaillement selectionné
]]                            end

                            Activate( self.activations.BEH_Dep_Pion_ALAT_RejoindrePoint, 1, setmetatable( { self.positionPlotRavitaillement, eProgressionDefaut, eTypeItiInfiltration, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
                        end
--[[//rejoindre le TC2 si on en a un
]]                    else
do
                            if( ( pionTC2 == 0 or pionTC2 == nil ) ) then
                                do return end
                            end

                            --[[// si l'agent est à moins de 1000m du TC2, ne pas se déplacer
]]if( DEC_Geometrie_Distance( pionTC2:DEC_Agent_Position(), myself:DEC_Agent_Position() ) <= 1000 ) then
                                do
                                    self.eEtat = eActionEffectuee
                                                                        do return end

                                end
                            end

                            Activate( self.activations.BEH_Dep_Pion_ALAT_RejoindrePion, 1, setmetatable( { pionTC2, eProgressionDefaut, eTypeItiInfiltration, 6000, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
                        end
                    end

                    _continue = false
                                cases_switch_1[1] = true
elseif switch_1 == eRecompleter then
                    if( self.eEtat == eActionEffectuee ) then
                        do
                            self.eEtat = eActionEnCours
                                                        do
                                myself.bEnPhaseRavitaillement_ = false
                                                                self.params.__returnValue = eActionEffectuee
                                Halt( self )
                                do return end

                            end

                        end
                    end

                    if( self.eEtat == eActionImpossible ) then
                        do
                                                        do
                                DEC_Warning( eRC_MissionImpossible )
                            end

                                                        self.params.__returnValue = eActionImpossible
                            Halt( self )
                            do return end

                        end
                    end

                    if( DEC_ConnaissanceObjet_EstValide( myself.plotRavitaillementAssigne_ ) ) then
                        Activate( self.activations.BEH_Log_Pion_ALAT_SeRecompleterSurPlot, 1, setmetatable( { myself.plotRavitaillementAssigne_, }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
                    else
                        Activate( self.activations.BEH_Log_Pion_ALAT_SeRecompleterSurTC2, 1, setmetatable( {}, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
                    end

                    Activate( self.activations.BEH_Dep_Pion_ALAT_SePoser, 1, {} )--[[//empeche le pion de se déplacer pendant son ravitaillement
]]
                    _continue = false
                                cases_switch_1[2] = true
                end
            end

    end,

--[[// -----------------------------------------------------------------------------
]]--[[// Gerer le plots de ravitaillement
]]--[[//
]]--[[// Commentaires : Ce comportement ne fonctionne que quand l'automate est debrayé 
]]--[[//
]]--[[// Il permet de choisir le plot de ravitaillement le plus proche de la position
]]--[[// actuelle du pion => maj dynamique du plot le plus proche.
]]--[[//
]]--[[// L'unité à le droit d'utiliser n'importe quel plot disponible dans sa liste.
]]--[[//
]]--[[// Si on n'a pas de plot de ravitaillement, ou si le TC2 est plus pres que le plus
]]--[[// proche des plots, alors, le plot assigné est nul, ce qui signifie que le pion
]]--[[// ira en cas de besoin se recompleter sur le TC2
]]--[[//
]]--[[// Jouer les pion en debrayer peut alors poser un problème (normal). En effet, 
]]--[[// les pions ne gereront pas l'occupation des plots par les autres pions, car 
]]--[[// c'est le travail de l'automate de commandement.
]]--[[// -----------------------------------------------------------------------------
]]}

node "BEH_Log_Pion_ALAT_GererPlotsRavitaillement"
{
    activations =
    {
        { "BEH_Log_Pion_ALAT_Recompletement", {} },
        { "BEH_Mot_Pion_ALAT_AffecterVariablesDEtat", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        local TC2 = DEC_Pion_TC2()
        local pionTC2 = nil
        local distance = 1105199104
        local distanceBuffer = 0
        myself.plotRavitaillementAssigne_ = nil
        --[[//dependances des comportements
]]Activate( self.activations.BEH_Log_Pion_ALAT_Recompletement, 0, {} )
        Activate( self.activations.BEH_Mot_Pion_ALAT_AffecterVariablesDEtat, 0, {} )
        if( TC2 ~= nil ) then
            pionTC2 = DEC_Pion_PionPCDeAutomate( TC2 )
        end

        for _,x in pairs( S_Obj_ListeObjetsValides( myself.plotsRavitaillement_ ) ) do
        local _continue = true
do
                local positionLocalisation = S_Geometrie_BarycentreZone( DEC_ConnaissanceObjet_Localisation( x ) )
                distanceBuffer = DEC_Geometrie_Distance( myself:DEC_Agent_Position(), positionLocalisation )
                if( distanceBuffer < distance ) then
                    do
                        distance = distanceBuffer
                        myself.plotRavitaillementAssigne_ = x
                    end
                end

            end
--[[//si le TC2 est plus interressant que le plot le moins loin, alors
]]--[[//plotRavitaillementAssigne_ = nil => aller sur le tc2
]]
        end

        if( pionTC2 ~= nil ) then
            do
                if( DEC_Geometrie_Distance( myself:DEC_Agent_Position(), pionTC2:DEC_Agent_Position() ) <= distance ) then
                    myself.plotRavitaillementAssigne_ = nil
                end

            end
        end

    end,

--[[// -----------------------------------------------------------------------------
]]--[[// Se Recompleter sur plot de ravitaillement
]]--[[// -----------------------------------------------------------------------------
]]}

node "BEH_Log_Pion_ALAT_SeRecompleterSurPlot"
{
    activations =
    {
        { "ACT_RC", {} },
        { "ACT_Misc_Delai", {} },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.plotRavitaillement = self.params[1]
    end,

    activate = function( self )
        self.eEtat = self.eEtat or eActionEnCours
        if( not DEC_ConnaissanceObjet_EstValide( self._namedParams.plotRavitaillement ) ) then
            self.params.__returnValue = eActionImpossible
            Halt( self )
            do return end
        end

        Activate( self.activations.ACT_RC, 1, { eRC_EnCoursRavitaillement, } )
        if( self.eEtat == eActionEffectuee ) then
            do
                self.eEtat = eActionEnCours
                                do
                    F_POLY_PION_ALAT_RECOMPLETEMENT( myself.porteeAction_, myself.ambianceMission_ )
                    Activate( self.activations.ACT_RC, 1, { eRC_RavitaillementTermine, } )
                                        self.params.__returnValue = eActionEffectuee
                    Halt( self )
                    do return end

                end

            end
        end

        if( self.eEtat == eActionImpossible ) then
            do
                                do
                    DEC_Warning( eRC_MissionImpossible )
                end

                                self.params.__returnValue = eActionImpossible
                Halt( self )
                do return end

            end
        end

        Activate( self.activations.ACT_Misc_Delai, 1, setmetatable( { 1, M_DOCTRINE_ALAT_TEMPS_RECOMPLETEMENT(), }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
    end,

--[[// -----------------------------------------------------------------------------
]]--[[// Se recompleter sur TC2
]]--[[//
]]--[[// Commentaires : On pourra eventuellement jouer un delai pour le ravitaillement
]]--[[// sur le TC2
]]--[[//
]]--[[// -----------------------------------------------------------------------------
]]}

node "BEH_Log_Pion_ALAT_SeRecompleterSurTC2"
{
    activations =
    {
        { "ACT_RC", {} },
        { "ACT_Misc_Delai", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        self.eEtat = self.eEtat or eActionEnCours
        Activate( self.activations.ACT_RC, 1, { eRC_EnCoursRavitaillement, } )
        if( self.eEtat == eActionEffectuee ) then
            do
                self.eEtat = eActionEnCours
                                do
                    F_POLY_PION_ALAT_RECOMPLETEMENT( myself.porteeAction_, myself.ambianceMission_ )
                    Activate( self.activations.ACT_RC, 1, { eRC_RavitaillementTermine, } )
                                        self.params.__returnValue = eActionEffectuee
                    Halt( self )
                    do return end

                end

            end
        end

        if( self.eEtat == eActionImpossible ) then
            do
                                do
                    DEC_Warning( eRC_MissionImpossible )
                end

                                self.params.__returnValue = eActionImpossible
                Halt( self )
                do return end

            end
        end

        Activate( self.activations.ACT_Misc_Delai, 1, setmetatable( { 1, M_DOCTRINE_ALAT_TEMPS_RECOMPLETEMENT(), }, { __newindex = function( t, k, v ) if k == "__returnValue" then self.eEtat = v else rawset( t, k, v ) end end } ) )
    end,

--[[// -----------------------------------------------------------------------------
]]--[[// Si on sait qu'il y a de nouveaux plots dans le fuseau attribué à myself, on
]]--[[// les push dans la listeDesPlots
]]--[[// -----------------------------------------------------------------------------
]]}

node "BEH_Log_Pion_ALAT_AjoutNouveauPlotsDansFuseau"
{
    activations =
    {
        { "BEH_Log_Pion_ALAT_GererPlotsRavitaillement", {} },
    },

    create = function( self )
    end,

    activate = function( self )
        --[[// OPT MIA: les objets sont forcément valides
]]--[[// OPT MIA: Faire avec DEC_Connaissances_ObjetsDansFuseau
]]local sConnaissancesObjets = DEC_Connaissances_ObjetsDansFuseau( S_TypeObject_ToString( eTypeObjectPlotRavitaillement ) )
        --[[// dependance de comportements
]]Activate( self.activations.BEH_Log_Pion_ALAT_GererPlotsRavitaillement, 0, {} )
        for _,x in pairs( sConnaissancesObjets ) do
        local _continue = true
do
                if( ( not DEC_UserTypeList_Contient( myself.plotsRavitaillement_, x ) ) ) then
                    DEC_UserTypeList_PushBack( myself.plotsRavitaillement_, x )
                end

            end

        end

    end,

}

connections = connections or {}
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_AjoutNouveauPlotsDansFuseau, "BEH_Log_Pion_ALAT_GererPlotsRavitaillement", nodes.BEH_Log_Pion_ALAT_GererPlotsRavitaillement }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_GererPlotsRavitaillement, "BEH_Log_Pion_ALAT_Recompletement", nodes.BEH_Log_Pion_ALAT_Recompletement }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_GererPlotsRavitaillement, "BEH_Mot_Pion_ALAT_AffecterVariablesDEtat", nodes.BEH_Mot_Pion_ALAT_AffecterVariablesDEtat }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_Recompletement, "BEH_Dep_Pion_ALAT_RejoindrePoint", nodes.BEH_Dep_Pion_ALAT_RejoindrePoint }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_Recompletement, "BEH_Dep_Pion_ALAT_RejoindrePion", nodes.BEH_Dep_Pion_ALAT_RejoindrePion }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_Recompletement, "BEH_Log_Pion_ALAT_SeRecompleterSurPlot", nodes.BEH_Log_Pion_ALAT_SeRecompleterSurPlot }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_Recompletement, "BEH_Log_Pion_ALAT_SeRecompleterSurTC2", nodes.BEH_Log_Pion_ALAT_SeRecompleterSurTC2 }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_Recompletement, "BEH_Dep_Pion_ALAT_SePoser", nodes.BEH_Dep_Pion_ALAT_SePoser }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_SeRecompleterSurPlot, "ACT_RC", nodes.ACT_RC }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_SeRecompleterSurPlot, "ACT_Misc_Delai", nodes.ACT_Misc_Delai }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_SeRecompleterSurTC2, "ACT_RC", nodes.ACT_RC }
connections[ #connections + 1 ] = { nodes.BEH_Log_Pion_ALAT_SeRecompleterSurTC2, "ACT_Misc_Delai", nodes.ACT_Misc_Delai }
