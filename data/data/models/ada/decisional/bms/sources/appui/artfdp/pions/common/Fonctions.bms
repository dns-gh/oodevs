includedFiles = includedFiles or {}
includedFiles["sources/appui/artfdp/pions/common/Fonctions.bms"] = true

local emptyTable = emptyTable


--[[// M_FLOATMAX()
]]--[[// On ne suit pas les unites detruites
]]--[[// On favorise les unites de premier echelon
]]--[[// ============================================================================
]]--[[// $Created : JCR : 17/03/2005 18:23
]]--[[// Calcul les positions d'installation pour lanceurs Canon
]]--[[// OPT MIA:
]]--[[// ============================================================================
]]--[[/*IN*//*IN*//* IN */]]--[[/*OUT*/]]--[[/*OUT*/]]--[[/* OUT */]]--[[// Point d'installation 1
]]--[[// ---------------------------------------------------------------------
]]--[[// Point d'installation 2
]]--[[// ---------------------------------------------------------------------
]]--[[// Point de sauvegarde
]]--[[// ---------------------------------------------------------------------
]]--[[// ============================================================================
]]--[[// $Created : JCR : 17/03/2005 18:23
]]--[[// Calcul les positions d'installation pour lanceurs LRM
]]--[[// ============================================================================
]]--[[/*IN*//*IN*/]]--[[// Emplacements 1 et 2
]]--[[// Point d'installation 1
]]--[[// ---------------------------------------------------------------------
]]--[[// Chercher un position valide ?
]]--[[// Point d'installation 2
]]--[[// ---------------------------------------------------------------------
]]--[[// Chercher un position valide ?
]]--[[// Point d'installation 3
]]--[[// ---------------------------------------------------------------------
]]--[[// Chercher un position valide ?
]]--[[// Point d'installation 4
]]--[[// ---------------------------------------------------------------------
]]--[[// Chercher un position valide ?
]]--[[// ----------------------------------------------------------------------------
]]--[[// $Created : JCR : 16/06/2004 10:47
]]--[[// Cree un itineraire a partir d'un seul point
]]--[[// ----------------------------------------------------------------------------
]]function S_SuppressionZoneTir( typeObjectZoneImplantation )
    local eNiveauInstallation = DEC_Agent_NiveauInstallation()
    if( eNiveauInstallation_PosteAmenage <= eNiveauInstallation ) then
        DEC_DetruireObjetSansDelais( DEC_Connaissances_ObjetLePlusProche( typeObjectZoneImplantation ) )
    end

end

function S_Cherche_Pion_ASS_ASuivreProcheZone( pAutomate, zone )
    local _returnValue = nil
    _returnValue = DEC_Pion_PionPCDeAutomate( pAutomate )
    local ptZone = DEC_Geometrie_CreerPoint()
    local rMin = 1105199104
    local ptZone = DEC_Geometrie_CalculerPointProcheLocalisationDansFuseau( zone )
    if( ptZone == nil ) then
        do return _returnValue end
    end

    local selPions = DEC_Pion_PionsDeAutomateSansPC( pAutomate )
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            local rFact = 1
            if( F_Pion_GeteEtatDestruction( pion ) ~= eEtatDestruction_None ) then
                _continue = false
            end

                if _continue then
                if( F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon_Premier ) then
                    rFact = 0.75
                end

                local rDist_Zone = rFact * DEC_Geometrie_Distance( ptZone, pion:DEC_Agent_Position() )
                if( rDist_Zone < rMin ) then
                    do
                        rMin = rDist_Zone
                        _returnValue = pion
                    end
                end

            end
        end

    end

    do return _returnValue end
end

function S_Geometrie_CreerPositionTir_Canon( zoneInstallation, rFloat, direction )
    local lstObstacles = {}
    local repObj = nil
    local locInstallation_1 = nil
    local locInstallation_2 = nil
    local ptSauvegarde = nil
    local subLocs = S_Geometrie_DecoupeLocalisation( zoneInstallation, 3, direction )
    if( #( subLocs ) < 3 ) then
        do return end
    end

    local tempLoc = nil
    local tempPoint = nil
    tempLoc = DEC_UserTypeList_GetAt( subLocs, 0 )
    lstObstacles = S_Obj_ListeObstacleDansLocalisation( tempLoc )
    tempPoint = S_Geometrie_BarycentreZone( tempLoc )
    repObj = S_Obj_ObtenirObjetProcheDePosition( tempLoc, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        locInstallation_1 = DEC_Geometrie_ConvertirPointEnLocalisation( tempPoint )
    end

    tempLoc = DEC_UserTypeList_GetAt( subLocs, 2 )
    lstObstacles = S_Obj_ListeObstacleDansLocalisation( tempLoc )
    tempPoint = S_Geometrie_BarycentreZone( tempLoc )
    repObj = S_Obj_ObtenirObjetProcheDePosition( tempLoc, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        locInstallation_2 = DEC_Geometrie_ConvertirPointEnLocalisation( tempPoint )
    end

    tempLoc = DEC_UserTypeList_GetAt( subLocs, 1 )
    lstObstacles = S_Obj_ListeObstacleDansLocalisation( tempLoc )
    tempPoint = S_Geometrie_BarycentreZone( tempLoc )
    repObj = S_Obj_ObtenirObjetProcheDePosition( tempLoc, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        ptSauvegarde = tempPoint
    end

    return locInstallation_1, locInstallation_2, ptSauvegarde

end

function S_Geometrie_CreerPositionTir_LRM( zoneInstallation, rFloat )
    local _returnValue = {}
    local lstPositionsLRM = DEC_Geometrie_CreerListePoints()
    local lstObstacles = S_Obj_ListeObstacleDansLocalisation( zoneInstallation )
    local repObj = nil
    local dirPos = nil
    local ptTemp = nil
    local ptPos = nil
    local ptPos1 = nil
    local ptPos2 = nil
    local ptInstallation = S_Geometrie_BarycentreZone( zoneInstallation )
    local mission = DEC_GetMission( myself )
    local directionDanger = DEC_GetDirectionDanger( mission )
    ptTemp = DEC_Geometrie_PositionTranslateDir( ptInstallation, directionDanger, rFloat )
    dirPos = DEC_Geometrie_CreerDirectionPerpendiculaire( directionDanger, true )
    ptPos1 = DEC_Geometrie_PositionTranslateDir( ptTemp, dirPos, rFloat )
    assert( ptPos1 ~= nil, "ptPos 1" )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos1, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        DEC_ListePoints_PushBack( lstPositionsLRM, ptPos1 )
    end

    dirPos = DEC_Geometrie_CreerDirectionPerpendiculaire( directionDanger, false )
    ptPos2 = DEC_Geometrie_PositionTranslateDir( ptTemp, dirPos, rFloat )
    assert( ptPos2 ~= nil, "ptPos 2" )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos2, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        DEC_ListePoints_PushBack( lstPositionsLRM, ptPos2 )
    end

    local dirInvPos = DEC_Geometrie_CreerDirection( ptInstallation, ptTemp )
    DEC_Geometrie_InverseDirection( dirInvPos )
    ptPos = DEC_Geometrie_PositionTranslateDir( ptPos1, dirInvPos, 2 * rFloat )
    assert( ptPos ~= nil, "pPos 3" )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        DEC_ListePoints_PushBack( lstPositionsLRM, ptPos )
    end

    ptPos = DEC_Geometrie_PositionTranslateDir( ptPos2, dirInvPos, 2 * rFloat )
    assert( ptPos ~= nil, "pPos 4" )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        DEC_ListePoints_PushBack( lstPositionsLRM, ptPos )
    end

    _returnValue = lstPositionsLRM
    do return _returnValue end
end

function S_Misc_CreerItineraire_Points( ptDest, ptDebarquement )
    local _returnValue = {}
    _returnValue = DEC_Geometrie_CreerListePoints()
    assert( ptDebarquement ~= nil, "ptDebarquement != nil" )
    assert( ptDest ~= nil, "ptDest != nil" )
    DEC_Copie_PointDansListePoints( ptDebarquement, _returnValue )
    DEC_ListePoints_PushBack( _returnValue, ptDest )
    do return _returnValue end
end

