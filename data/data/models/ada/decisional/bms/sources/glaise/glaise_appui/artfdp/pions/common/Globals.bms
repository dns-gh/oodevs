includedFiles = includedFiles or {}
includedFiles["sources/glaise/glaise_appui/artfdp/pions/common/Globals.bms"] = true

local emptyTable = emptyTable

--[[// *****************************************************************************
]]--[[//
]]--[[// $Created: JDY 02-11-06 $
]]--[[// $Archive: /MVW_v10/Build/Data/Data/Modeles/Sources/Appui/ArtFdp/Pions/Common/Globals.hal $
]]--[[// $Author: Ggr $
]]--[[// $Modtime: 23/08/05 15:21 $
]]--[[// $Revision: 19 $
]]--[[// $Workfile: Globals.hal $
]]--[[//
]]--[[// *****************************************************************************
]]
include "Glaise/glaise_Common/Pions/Globals.bms"

include "Glaise/glaise_Appui/ArtFdp/Pions/Common/Parameters.bms"

include "Glaise/glaise_Appui/ArtFdp/Pions/Common/Globals Poly.bms"



--[[// Delai apres lequel le pion fait un mouvement de sauvegarde soit apres un tir
]]--[[// en presence de contre-batterie M_DELAI_SAUVEGARDE_TIR(), soit comme mvt
]]--[[// de sauvegarde M_DELAI_SAUVEGARDE().
]]--[[// ----------------------------------------------------------------------------
]]function M_DELAI_SAUVEGARDE()
    return 60
end



function M_DELAI_SAUVEGARDE_TIR()
    return 10
end

--[[// M_FLOATMAX()
]]--[[// On ne suit pas les unites detruites
]]--[[// On favorise les unites de premier echelon
]]--[[// ============================================================================
]]--[[// $Created : JCR : 17/03/2005 18:23
]]--[[// Calcul les positions d'installation pour lanceurs Canon
]]--[[// OPT MIA: 
]]--[[// ============================================================================
]]--[[/*IN*//*IN*/]]--[[/*OUT*/]]--[[/*OUT*/]]--[[// Point d'installation 1		
]]--[[// ---------------------------------------------------------------------
]]--[[// Chercher un position valide ?
]]--[[// Point d'installation 2
]]--[[// ---------------------------------------------------------------------
]]--[[// Chercher un position valide ?
]]--[[// ============================================================================
]]--[[// $Created : JCR : 17/03/2005 18:23
]]--[[// Calcul les positions d'installation pour lanceurs LRM
]]--[[// ============================================================================
]]--[[/*IN*//*IN*/]]--[[// Emplacements 1 et 2
]]--[[// Point d'installation 1		
]]--[[// ---------------------------------------------------------------------
]]--[[// Chercher un position valide ?
]]--[[// Point d'installation 2
]]--[[// ---------------------------------------------------------------------
]]--[[// Chercher un position valide ?
]]--[[// Point d'installation 3
]]--[[// ---------------------------------------------------------------------					
]]--[[// Chercher un position valide ?
]]--[[// Point d'installation 4
]]--[[// ---------------------------------------------------------------------		
]]--[[// Chercher un position valide ?
]]--[[// ----------------------------------------------------------------------------
]]--[[// $Created : JCR : 16/06/2004 10:47
]]--[[// Cree un itineraire a partir d'un seul point
]]--[[// ----------------------------------------------------------------------------
]]function S_Cherche_Pion_ASS_ASuivreProcheZone( pAutomate, zone )
    local _returnValue = nil
    _returnValue = DEC_Pion_PionPCDeAutomate( pAutomate )
    local rMin = 1105199104
    local ptZone = DEC_Geometrie_CalculerPointProcheLocalisationDansFuseau( zone )
    if( ptZone == nil ) then
        do return _returnValue end
    end

    local selPions = DEC_Pion_PionsDeAutomateSansPC( pAutomate )
    for _,x in pairs( selPions or emptyTable ) do
    local _continue = true
do
            local pion = x
            local rFact = 1
            if( F_Pion_GeteEtatDestruction( pion ) ~= eEtatDestruction_None ) then
                _continue = false
            end

                if _continue then
                if( F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon_Premier ) then
                    rFact = 0.75
                end

                local rDist_Zone = rFact * DEC_Geometrie_Distance( ptZone, pion:DEC_Agent_Position() )
                if( rDist_Zone < rMin ) then
                    do
                        rMin = rDist_Zone
                        _returnValue = pion
                    end
                end

            end
        end

    end

    do return _returnValue end
end

function S_Geometrie_CreerPositionTir_Canon( ptInstallation, rFloat, locInstallation_1, locInstallation_2 )
    local lstObstacles = S_Obj_ListeObstacle( ptInstallation, rFloat + 100 )
    local repObj = nil
    local dirPos = nil
    local ptPos = nil
    local mission = DEC_GetMission( myself )
    locInstallation_1 = nil
    local directionDanger = DEC_GetDirectionDanger( mission )
    dirPos = DEC_Geometrie_CreerDirectionPerpendiculaire( directionDanger, true )
    ptPos = DEC_Geometrie_PositionTranslateDir( ptInstallation, dirPos, rFloat )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        locInstallation_1 = DEC_Geometrie_ConvertirPointEnLocalisation( ptPos )
    end

    locInstallation_2 = nil
    dirPos = DEC_Geometrie_CreerDirectionPerpendiculaire( directionDanger, false )
    ptPos = DEC_Geometrie_PositionTranslateDir( ptInstallation, dirPos, rFloat )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        locInstallation_2 = DEC_Geometrie_ConvertirPointEnLocalisation( ptPos )
    end

end

function S_Geometrie_CreerPositionTir_LRM( ptInstallation, rFloat )
    local _returnValue = {}
    local lstPositionsLRM = DEC_Geometrie_CreerListePoints()
    local lstObstacles = S_Obj_ListeObstacle( ptInstallation, rFloat + 100 )
    local repObj = nil
    local dirPos = nil
    local ptTemp = nil
    local ptPos = nil
    local ptPos1 = nil
    local ptPos2 = nil
    local mission = DEC_GetMission( myself )
    local directionDanger = DEC_GetDirectionDanger( mission )
    ptTemp = DEC_Geometrie_PositionTranslateDir( ptInstallation, directionDanger, rFloat )
    dirPos = DEC_Geometrie_CreerDirectionPerpendiculaire( directionDanger, true )
    ptPos1 = DEC_Geometrie_PositionTranslateDir( ptTemp, dirPos, rFloat )
    assert( ptPos1 ~= nil, "ptPos 1" )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos1, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        DEC_ListePoints_PushBack( lstPositionsLRM, ptPos1 )
    end

    dirPos = DEC_Geometrie_CreerDirectionPerpendiculaire( directionDanger, false )
    ptPos2 = DEC_Geometrie_PositionTranslateDir( ptTemp, dirPos, rFloat )
    assert( ptPos2 ~= nil, "ptPos 2" )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos2, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        DEC_ListePoints_PushBack( lstPositionsLRM, ptPos2 )
    end

    local dirInvPos = DEC_Geometrie_CreerDirection( ptInstallation, ptTemp )
    DEC_Geometrie_InverseDirection( dirInvPos )
    ptPos = DEC_Geometrie_PositionTranslateDir( ptPos1, dirInvPos, 2 * rFloat )
    assert( ptPos ~= nil, "pPos 3" )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        DEC_ListePoints_PushBack( lstPositionsLRM, ptPos )
    end

    ptPos = DEC_Geometrie_PositionTranslateDir( ptPos2, dirInvPos, 2 * rFloat )
    assert( ptPos ~= nil, "pPos 4" )
    repObj = S_Obj_ObtenirObjetProcheDePosition( ptPos, lstObstacles, rFloat + 100 )
    if( not DEC_ConnaissanceObjet_EstValide( repObj ) ) then
        DEC_ListePoints_PushBack( lstPositionsLRM, ptPos )
    end

    _returnValue = lstPositionsLRM
    do return _returnValue end
end

function S_Misc_CreerItineraire_Points( ptDest, ptDebarquement )
    local _returnValue = {}
    _returnValue = DEC_Geometrie_CreerListePoints()
    assert( ptDebarquement ~= nil, "ptDebarquement != nil" )
    assert( ptDest ~= nil, "ptDest != nil" )
    DEC_Copie_PointDansListePoints( ptDebarquement, _returnValue )
    DEC_ListePoints_PushBack( _returnValue, ptDest )
    do return _returnValue end
end

