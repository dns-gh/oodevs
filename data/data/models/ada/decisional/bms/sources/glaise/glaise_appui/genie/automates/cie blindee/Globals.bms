includedFiles = includedFiles or {}
includedFiles["sources/glaise/glaise_appui/genie/automates/cie blindee/Globals.bms"] = true

local emptyTable = emptyTable

include "bit.lua"


--[[//-----------------------------------------------------------------------------
]]--[[// fichiers à inclure (Cf autres include en bas du fichier)
]]--[[//-----------------------------------------------------------------------------
]]include "glaise/glaise_appui/Genie/Automates/Globals.bms"


--[[//=============================================================================
]]--[[// Valeurs paramètrables
]]--[[//=============================================================================
]]function M_DOCTRINE_Pion_GEN_TAILLE_SITEFRANCHISSEMENT_PAA()
    return 25
end



function M_DOCTRINE_Pion_GEN_TAILLE_SITEFRANCHISSEMENT_MLF()
    return 300
end



function M_DOCTRINE_Pion_GEN_TAILLE_SITEFRANCHISSEMENT_EFA()
    return 300
end



function M_DOCTRINE_Pion_GEN_TAILLE_SITEFRANCHISSEMENT_PFM()
    return 300
end

--[[//=============================================================================
]]--[[// Definition des fonctions script
]]--[[//=============================================================================
]]--[[//-------------------------------------------------------------------------
]]--[[// Renvoi true si l'unité peut réaliser l'obstacle, false sinon.
]]--[[//-------------------------------------------------------------------------
]]--[[//-------------------------------------------------------------------------
]]--[[// Renvoi true si l'unité peut dégager l'obstacle, false sinon.
]]--[[//-------------------------------------------------------------------------
]]--[[//-------------------------------------------------------------------------
]]--[[// Renvoi true si l'unité peut contourner l'obstacle, false sinon.
]]--[[//-------------------------------------------------------------------------
]]--[[//-------------------------------------------------------------------------
]]--[[// Renvoie le T_ConnaissanceObjet le plus proche parmis ceux passer
]]--[[// en paramètre
]]--[[//-------------------------------------------------------------------------
]]--[[//1105199104;
]]--[[// Attention la liste peut être une copie et contenir des con. invalides
]]--[[// cf. BEH_Misc_Automate_GEN_GererReductionDesObstacles()
]]--[[//-------------------------------------------------------------------------
]]--[[// Renvoie la liste des pions section disponibles
]]--[[//-------------------------------------------------------------------------
]]--[[//-------------------------------------------------------------------------
]]--[[// Creer un T_Gen_Objet_ARealiser, associe init les attributs et 
]]--[[// l'ajoute dans la liste globale
]]--[[//-------------------------------------------------------------------------
]]--[[// ObjetARealiser.pionRenforcement_ = nil; // On ne connait pas encore le renforcement
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie les renforts dispo
]]--[[//-----------------------------------------------------------------------------
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie la liste des groupe du génie
]]--[[//-----------------------------------------------------------------------------
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie la liste des objets non contourner
]]--[[//-----------------------------------------------------------------------------
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie la liste triée des objets contructible par l'automate
]]--[[// Temp --> à faire dans le moteur!!
]]--[[//-----------------------------------------------------------------------------
]]--[[// Tri dans deux listes différentes
]]--[[// Concatenation
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie la liste triée des objets contructible par l'automate
]]--[[// Temp --> à faire dans le moteur!!
]]--[[//-----------------------------------------------------------------------------
]]--[[// Tri dans deux listes différentes
]]--[[// Concatenation
]]--[[//-----------------------------------------------------------------------------
]]--[[// Renvoie la liste triée des objets planifies contructible par l'automate
]]--[[// Temp --> à faire dans le moteur!!
]]--[[//-----------------------------------------------------------------------------
]]--[[// Tri dans deux listes différentes
]]--[[// Concatenation
]]function S_Obj_Automate_GEN_PeutRealiserObstacle( obstacle, pion )
    local _returnValue = false
    _returnValue = DEC_Automate_PionPeutConstruireObjet( pion, DEC_GenObject_Type( obstacle ) )
    _returnValue = false
    do return _returnValue end
end

function S_Obj_Automate_GEN_PeutDegagerObstacle( obstacle, pion )
    local _returnValue = false
    local eValidite = nil
    _returnValue = DEC_Automate_PionPeutDetruireObjet( pion, obstacle )
    do return _returnValue end
end

function S_Obj_Automate_GEN_PeutContournerObstacle( obstacle, pion )
    local _returnValue = false
    local eValidite = nil
    _returnValue = DEC_Automate_PionPeutConstruireContournementObjet( pion, obstacle )
    do return _returnValue end
end

function S_Obj_Automate_GEN_ObjetPlusProche( listeObjets, point )
    local _returnValue = nil
    _returnValue = 0
    local distanceMax = 1105199104
    local objetProche = nil
    for _,x in pairs( listeObjets or emptyTable ) do
    local _continue = true
do
            local objet = x
            if( not DEC_ConnaissanceObjet_EstValide( objet ) ) then
                _continue = false
            end

                if _continue then
                local rDistance = DEC_Geometrie_Distance( point, S_Obj_Position( objet ) )
                if( rDistance < distanceMax ) then
                    do
                        distanceMax = rDistance
                        objetProche = objet
                    end
                end

            end
        end

    end

    _returnValue = objetProche
    do return _returnValue end
end

function S_Gen_ObtenirSectionsGenieDisponibles( )
    local _returnValue = {}
    local listeTemp = {}
    for _,x in pairs( DEC_Automate_PionsAvecPC() or emptyTable ) do
    local _continue = true
do
            local pion = x
            local mission = DEC_GetMission( pion )
            if( pion:GetType() == "SectionGenie" and F_Pion_GeteEtatDestruction( pion ) == eEtatDestruction_None and ( mission == nil or mission:GetType() == "T_Mission_Pion_FaireMouvement" or F_Pion_GeteEtatPhaseMission( pion ) == eEtatPhaseMission_FinMission ) ) then
                DIA_PushFront( listeTemp, pion )
            end

        end

    end

    _returnValue = listeTemp
    do return _returnValue end
end

function S_Gen_AssocierGenObjetAPion( pion, objet )
    local ObjetARealiser = DEC_CreerDIAThing( "T_Gen_Objet_ARealiser" )
    ObjetARealiser:Setobstacle_( objet )
    ObjetARealiser:Setpion_( pion )
    DIA_PushBack( g_selObs_ARealiser, ObjetARealiser )
end

function S_Misc_Automate_GEN_ObtenirRenfortsDisponibles( eTypePion )
    local _returnValue = {}
    local selTemp = {}
    for _,x in pairs( DEC_Automate_PionsSansPC() or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( F_Pion_GeteEtatEchelon( pion ) == eEtatEchelon_Second and pion:GetType() == eTypePion ) then
                DIA_PushFront( selTemp, pion )
            end

        end

    end

    _returnValue = selTemp
    do return _returnValue end
end

function S_Gen_ObtenirGroupeGenie( )
    local _returnValue = {}
    local selTemp = {}
    for _,x in pairs( DEC_Automate_PionsSansPC() or emptyTable ) do
    local _continue = true
do
            local pion = x
            if( pion:GetType() == "GroupeEBG" or pion:GetType() == "GroupeMPG" or pion:GetType() == "GroupePAA" or pion:GetType() == "GroupeEFA" or pion:GetType() == "SectionPFM" or pion:GetType() == "SectionTravaux" or pion:GetType() == "GroupeDISP" or pion:GetType() == "SectionSOUVIM" or pion:GetType() == "GroupeMFRD" or pion:GetType() == "GroupeOT" or pion:GetType() == "SectionDeminageLourd" or pion:GetType() == "GroupeMADEZ" or pion:GetType() == "GroupeMATS" or pion:GetType() == "GroupePAT" or pion:GetType() == "GroupeEnfouisseur" or pion:GetType() == "GroupeEnergie" or pion:GetType() == "GroupeEquipementPoser" or pion:GetType() == "SectionEquipementPlage" or pion:GetType() == "SectionEau" or pion:GetType() == "DLRG" ) then
                DIA_PushFront( selTemp, pion )
            end

        end

    end

    _returnValue = selTemp
    do return _returnValue end
end

function S_Obj_ListeObjetsNonContournes( objets )
    local _returnValue = {}
    local listeObjets = {}
    for _,objet in pairs( objets or emptyTable ) do
    local _continue = true
do
            if( not S_Obj_EstContourne( objet ) and DEC_ConnaissanceObjet_EstValide( objet ) ) then
                DEC_UserTypeList_PushBack( listeObjets, objet )
            end

        end

    end

    _returnValue = listeObjets
    do return _returnValue end
end

function S_Obj_TrierListePourDetruireObjets( objets )
    local _returnValue = {}
    local eValidite = nil
    local listeObjetsOK = {}
    local listeObjetsKO = {}
    local listeObjetsTries = {}
    for _,objet in pairs( objets or emptyTable ) do
    local _continue = true
do
            if( DEC_ConnaissanceObjet_EstValide( objet ) ) then
                do
                    for _,pion in pairs( DEC_Automate_PionsSansPC() or emptyTable ) do
                    local _continue = true
                        do
                            if( DEC_Automate_PionPeutDetruireObjet( pion, objet ) ) then
                                do
                                    DEC_UserTypeList_PushBack( listeObjetsOK, objet )
                                    break
                                end
                            end

                        end

                    end

                    if( not DEC_UserTypeList_Contient( listeObjetsOK, objet ) ) then
                        DEC_UserTypeList_PushBack( listeObjetsKO, objet )
                    end

                end
            end

        end

    end

    for _,objet in pairs( listeObjetsOK or emptyTable ) do
    local _continue = true
        DEC_UserTypeList_PushBack( listeObjetsTries, objet )

    end

    for _,objet in pairs( listeObjetsKO or emptyTable ) do
    local _continue = true
        DEC_UserTypeList_PushBack( listeObjetsTries, objet )

    end

    _returnValue = listeObjetsTries
    do return _returnValue end
end

function S_Obj_TrierListePourContournerObjets( objets )
    local _returnValue = {}
    local eValidite = nil
    local listeObjetsOK = {}
    local listeObjetsKO = {}
    local listeObjetsTries = {}
    for _,objet in pairs( objets or emptyTable ) do
    local _continue = true
do
            if( DEC_ConnaissanceObjet_EstValide( objet ) ) then
                do
                    for _,pion in pairs( DEC_Automate_PionsSansPC() or emptyTable ) do
                    local _continue = true
                        do
                            if( DEC_Automate_PionPeutConstruireContournementObjet( pion, objet ) ) then
                                do
                                    DEC_UserTypeList_PushBack( listeObjetsOK, objet )
                                    break
                                end
                            end

                        end

                    end

                    if( not DEC_UserTypeList_Contient( listeObjetsOK, objet ) ) then
                        DEC_UserTypeList_PushBack( listeObjetsKO, objet )
                    end

                end
            end

        end

    end

    for _,objet in pairs( listeObjetsOK or emptyTable ) do
    local _continue = true
        DEC_UserTypeList_PushBack( listeObjetsTries, objet )

    end

    for _,objet in pairs( listeObjetsKO or emptyTable ) do
    local _continue = true
        DEC_UserTypeList_PushBack( listeObjetsTries, objet )

    end

    _returnValue = listeObjetsTries
    do return _returnValue end
end

function S_Obj_TrierListePourContruireObjetsPlanifies( objets )
    local _returnValue = {}
    local listeObjetsOK = {}
    local listeObjetsKO = {}
    local listeObjetsTries = {}
    for _,x in pairs( objets or emptyTable ) do
    local _continue = true
do
            local objet = x
            local type = DEC_GenObject_Type( objet )
            for _,pion in pairs( DEC_Automate_PionsSansPC() or emptyTable ) do
            local _continue = true
do
                    if( DEC_Automate_PionPeutConstruireObjet( pion, type ) ) then
                        do
                            DEC_UserTypeList_PushBack( listeObjetsOK, objet )
                            break
                        end
                    end

                end

            end

            if( not DEC_UserTypeList_Contient( listeObjetsOK, objet ) ) then
                DEC_UserTypeList_PushBack( listeObjetsKO, objet )
            end

        end

    end

    for _,objet in pairs( listeObjetsOK or emptyTable ) do
    local _continue = true
        DEC_UserTypeList_PushBack( listeObjetsTries, objet )

    end

    for _,objet in pairs( listeObjetsKO or emptyTable ) do
    local _continue = true
        DEC_UserTypeList_PushBack( listeObjetsTries, objet )

    end

    _returnValue = listeObjetsTries
    do return _returnValue end
end

