includedFiles = includedFiles or {}
includedFiles["sources/glaise/glaise_melee/inf/pions/common/missions/Embuscade.bms"] = true

local emptyTable = emptyTable

include "bit.lua"


--[[// *****************************************************************************
]]--[[//
]]--[[// $Created: JCR 03-02-20 $
]]--[[// $Archive: /MVW_v10/Build/Data/Data/Modeles/Sources/Melee/Inf/Pions/Common/Missions/Embuscade.hal $
]]--[[// $Author: Ggr $
]]--[[// $Modtime: 25/08/05 17:44 $
]]--[[// $Revision: 12 $
]]--[[// $Workfile: Embuscade.hal $
]]--[[//
]]--[[// *****************************************************************************
]]




--[[// ----------------------------------------------------------------------------
]]--[[// BEH_Pion_Milice_GererInstallationObstacle
]]--[[// Gestion des obstacles : Construction, activation en fonction de l'ennemi
]]--[[// ----------------------------------------------------------------------------
]]node "BEH_Obj_Pion_INF_GererInstallationObstacle"
{
    feedbacks = { { { "done_BEH_Obj_Pion_INF_GererInstallationObstacle" }, "BEH_Obj_Pion_INF_GererInstallationObstacle" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_BEH_Obj_Pion_INF_GererInstallationObstacle, {value} ) end,
    activations =
    {
        { "ACT_Info_Trace", { "done_ACT_Info_Trace" } },
        { "ACT_Obj_Pion_INF_RealiserBouchonMines", { "done_ACT_Obj_Pion_INF_RealiserBouchonMines" } },
        { "ACT_Obj_Pion_INF_PreparerAbattis", { "done_ACT_Obj_Pion_INF_PreparerAbattis" } },
        { "ACT_Misc_Pion_DelaiInstallation", { "done_ACT_Misc_Pion_DelaiInstallation" } },
        { "ACT_Obj_Pion_INF_Activer", { "done_ACT_Obj_Pion_INF_Activer" } },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.ptEmbuscade = self.params[1]
        self._namedParams.eTypeObjet = self.params[2]
    end,

    activate = function( self )
        local Activate = Activate
        self.locEmbuscade = self.locEmbuscade or nil
        self.eAction = self.eAction or eActionEnCours
        self.eActionAbattis = self.eActionAbattis or eActionEnCours
        self.repObj = self.repObj or nil
        self.ePhase = self.ePhase or eRealiserObstacle
        do
        end

        if( ModuleBegins() ) then
            do
                self.locEmbuscade = S_Geometrie_INF_ChercherPositionObstacle( self._namedParams.ptEmbuscade, self._namedParams.eTypeObjet, 500 )
                if( self.locEmbuscade == nil ) then
                    self.locEmbuscade = DEC_Geometrie_ConvertirPointEnLocalisation( self._namedParams.ptEmbuscade )
                end

            end
--[[// Demande exterieur d'activation de l'obstacle
]]        end

        if( GetActivity() >= 2 and self.eActionAbattis == eActionEffectuee and self.ePhase == eAttendre ) then
            self.ePhase = eActiverObstacle
        end

        do
        end

         do
            local _continue = true
            local switch_1 = self.ePhase
            local cases_switch_1 = {}
                if switch_1 == eRealiserObstacle then
                    do
                    end

                    if( self.eActionAbattis == eActionImpossible ) then
                        do
                            self.ePhase = eAttendre
                            Activate( self.activations.ACT_Info_Trace, 1, { "preparation echouee, on attend", } )
                                                        do return end

                                                        self:SendFeedback( eActionImpossible )
                            Halt( self )
                            do return end

                        end
                    end

                    if( self.eAction == eActionEffectuee and self.eActionAbattis == eActionEffectuee ) then
                        do
                            self.ePhase = eAttendre
                            self.repObj = S_Obj_ObtenirObjetProcheDe( self.locEmbuscade, self._namedParams.eTypeObjet, 800 )
                            Activate( self.activations.ACT_Info_Trace, 1, { "preparation terminee, on attend", } )
                                                        do return end

                        end
                    end

                    if( self.eActionAbattis == eActionEnCours ) then
                        do
                             do
                                local _continue = true
                                local switch_2 = --[[// Realiser abatti		
]]self._namedParams.eTypeObjet
                                local cases_switch_2 = {}
                                    if switch_2 == eTypeObjectBouchonMines then
                                                                            Activate( self.activations.ACT_Obj_Pion_INF_RealiserBouchonMines, 1, { self.locEmbuscade, M_NOMBRE_MINES(), } )
self.done_ACT_Obj_Pion_INF_RealiserBouchonMines = function( self, _, v ) self.eActionAbattis = v[1] end
                                        _continue = false
                                                                        cases_switch_2[1] = true
elseif switch_2 == eTypeObjectAbatti then
                                                                            Activate( self.activations.ACT_Obj_Pion_INF_PreparerAbattis, 1, { self.locEmbuscade, M_LONGUEUR_ABATTIS(), } )
self.done_ACT_Obj_Pion_INF_PreparerAbattis = function( self, _, v ) self.eActionAbattis = v[1] end
                                        _continue = false
                                                                        cases_switch_2[2] = true

                                    else
                                                                            DEC_Trace( "eTypeObstacle : Object non reconnu " .. EnumToString( self._namedParams.eTypeObjet, E_TypeObject ) )
                                        self.eActionAbattis = eActionEffectuee
                                                                        end
                                end

                        end
                    end

                    if( self.eAction == eActionEnCours ) then
                        --[[// Temps de mise en place du dispositif
]]Activate( self.activations.ACT_Misc_Pion_DelaiInstallation, 1, { eNiveauInstallation_Poste, } )
self.done_ACT_Misc_Pion_DelaiInstallation = function( self, _, v ) self.eAction = v[1] end
                    end

                    _continue = false
                                cases_switch_1[1] = true
elseif switch_1 == eActiverObstacle then
                    if( not DEC_ConnaissanceObjet_EstValide( self.repObj ) ) then
                        do
                            DEC_Trace( "objet cree non recupere" )
                            self.ePhase = ePrendreContact
                                                        self:SendFeedback( eActionEffectuee )
                            do return end

                        end
                    end

                    if( F_Pion_GeteniEnCours( myself ) ~= nil ) then
                        do
                            Activate( self.activations.ACT_Info_Trace, 1, { "unite eni se presente bien", } )
                            --[[// Si il est a porte de tir, on lance l'assaut    				    				
]]if( S_Geometrie_EstProcheLocalisation( S_Eni_Position( F_Pion_GeteniEnCours( myself ) ), S_Obj_Localisation( self.repObj ), 200 ) ) then
                                do
                                    StartActivateOverride( self, self.activations.ACT_Obj_Pion_INF_Activer, 1, { self.repObj, } )
                                    self.ePhase = ePrendreContact
                                                                        self:SendFeedback( eActionEffectuee )
                                    do return end

                                end
                            end

                        end
                    end

                    _continue = false
                                cases_switch_1[2] = true
elseif switch_1 == ePrendreContact
                or switch_1 == eAttendre then
                    _continue = false
                                cases_switch_1[3] = true
                end
            end

    end,

--[[// ============================================================================
]]--[[// BEH_Pion_Milice_RejoindrePositionTir_Embusc( T_Point ptPos )
]]--[[//
]]--[[//		ptPos : Point sur lequel la section eni est censee arriver
]]--[[//
]]--[[// Description: rejoins une position sur laquel on va pouvoir ouvrir le feu
]]--[[// ============================================================================
]]}

node "BEH_Dep_Pion_INF_RejoindrePositionTir_Embusc"
{
    feedbacks = { { { "done_BEH_Dep_Pion_INF_RejoindrePositionTir_Embusc" }, "BEH_Dep_Pion_INF_RejoindrePositionTir_Embusc" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_BEH_Dep_Pion_INF_RejoindrePositionTir_Embusc, {value} ) end,
    activations =
    {
        { "BEH_Dep_ProgressionVers", { "done_BEH_Dep_ProgressionVers" } },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.ptPos = self.params[1]
        self._namedParams.ptRepli = self.params[2]
    end,

    activate = function( self )
        local Activate = Activate
        self.eAction = self.eAction or eActionEnCours
        --[[// Cree la position d'observation		
]]self.ptEmbuscade = self.ptEmbuscade or nil
        if( ModuleBegins() ) then
            do
                self.ptEmbuscade = DEC_Geometrie_CalculerPositionEmbuscade( self._namedParams.ptPos, self._namedParams.ptRepli, 300 )
                DEC_Trace( "deplacement sur position d'embuscade" )
            end
        end

        if( self.eAction == eActionImpossible ) then
            do
                                do
                end

                                self:SendFeedback( eActionImpossible )
                Halt( self )
                do return end

            end
--[[// Puis on la rejoint								
]]        end

        if( self.eAction == eActionEffectuee ) then
            do
                self.eAction = eActionEnCours
                                do
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                end

            end
        end

        Activate( self.activations.BEH_Dep_ProgressionVers, 1, { self.ptEmbuscade, eProgressionDefaut, eTypeItiAttaque, } )
self.done_BEH_Dep_ProgressionVers = function( self, _, v ) self.eAction = v[1] end
    end,

--[[// ============================================================================
]]--[[// $Created : JCR : 25/03/2005 10:24
]]--[[// Partie commune de la destruction par embuscade
]]--[[// ============================================================================
]]}

node "BEH_Eni_Pion_INF_DetruireEmbuscade"
{
    feedbacks = { { { "done_BEH_Eni_Pion_INF_DetruireEmbuscade" }, "BEH_Eni_Pion_INF_DetruireEmbuscade" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_BEH_Eni_Pion_INF_DetruireEmbuscade, {value} ) end,
    activations =
    {
        { "ACT_Maj_Pion_PasserEnTirLibre", { "done_ACT_Maj_Pion_PasserEnTirLibre" } },
        { "BEH_MOT_DesactiveSauvegarde", { "done_BEH_MOT_DesactiveSauvegarde" } },
        { "BEH_Obj_Pion_INF_GererInstallationObstacle", { "done_BEH_Obj_Pion_INF_GererInstallationObstacle" } },
        { "ACT_Misc_Delai", { "done_ACT_Misc_Delai" } },
        { "ACT_MAJ_EnnemiEnCours", { "done_ACT_MAJ_EnnemiEnCours" } },
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.ptEmbuscade = self.params[1]
        self._namedParams.eTypeObj = self.params[2]
    end,

    activate = function( self )
        local Activate = Activate
        self.eActionDelai = self.eActionDelai or eActionEnCours
        self.eActionObst = self.eActionObst or eActionEnCours
        if( self.eActionDelai == eActionEffectuee ) then
            do
                self.eActionDelai = eActionEnCours
                                self:SendFeedback( eActionHalt )
                do return end

            end
--[[// Si pas d'objet, on active ici la gestion des ROE		
]]        end

        if( self.eActionObst == eActionEffectuee ) then
            Activate( self.activations.ACT_Maj_Pion_PasserEnTirLibre, 1, emptyTable )
        else
            Activate( self.activations.BEH_MOT_DesactiveSauvegarde, 1, emptyTable )
        end

        --[[//
]]--[[// Gestion des unites percues
]]local lstEnisPercus = DEC_Connaissances_UnitesEnnemiesVivantesPercuesDansFuseau()
        for _,x in pairs( lstEnisPercus or emptyTable ) do
        local _continue = true
do
                --[[// On fait l'assaut
]]if( S_Tir_EstAPorteePosturesReelles( x, GetStateVariable( "VE_Agressivite_Tir" ) ) ) then
                    do
                        StartActivateOverride( self, self.activations.BEH_Obj_Pion_INF_GererInstallationObstacle, 0.5, { self._namedParams.ptEmbuscade, self._namedParams.eTypeObj, } )
self.done_BEH_Obj_Pion_INF_GererInstallationObstacle = function( self, _, v ) self.eActionObst = v[1] end
                        --[[// Au bout de 3 min, on retourne au point de regroupement
]]if( F_Pion_GeteEtatFeu( myself ) == eEtatFeu_Executer ) then
                            StartActivateOverride( self, self.activations.ACT_Misc_Delai, 1, { 1, 1, } )
self.done_ACT_Misc_Delai = function( self, _, v ) self.eActionDelai = v[1] end
                        end

                        Activate( self.activations.ACT_MAJ_EnnemiEnCours, 1, { x, } )
                    end
                end

            end

        end

    end,

}

connections = connections or {}
connections[ #connections + 1 ] = { nodes.BEH_Dep_Pion_INF_RejoindrePositionTir_Embusc, "BEH_Dep_ProgressionVers", nodes.BEH_Dep_ProgressionVers }
connections[ #connections + 1 ] = { nodes.BEH_Eni_Pion_INF_DetruireEmbuscade, "ACT_Maj_Pion_PasserEnTirLibre", nodes.ACT_Maj_Pion_PasserEnTirLibre }
connections[ #connections + 1 ] = { nodes.BEH_Eni_Pion_INF_DetruireEmbuscade, "BEH_MOT_DesactiveSauvegarde", nodes.BEH_MOT_DesactiveSauvegarde }
connections[ #connections + 1 ] = { nodes.BEH_Eni_Pion_INF_DetruireEmbuscade, "BEH_Obj_Pion_INF_GererInstallationObstacle", nodes.BEH_Obj_Pion_INF_GererInstallationObstacle }
connections[ #connections + 1 ] = { nodes.BEH_Eni_Pion_INF_DetruireEmbuscade, "ACT_Misc_Delai", nodes.ACT_Misc_Delai }
connections[ #connections + 1 ] = { nodes.BEH_Eni_Pion_INF_DetruireEmbuscade, "ACT_MAJ_EnnemiEnCours", nodes.ACT_MAJ_EnnemiEnCours }
connections[ #connections + 1 ] = { nodes.BEH_Obj_Pion_INF_GererInstallationObstacle, "ACT_Info_Trace", nodes.ACT_Info_Trace }
connections[ #connections + 1 ] = { nodes.BEH_Obj_Pion_INF_GererInstallationObstacle, "ACT_Obj_Pion_INF_RealiserBouchonMines", nodes.ACT_Obj_Pion_INF_RealiserBouchonMines }
connections[ #connections + 1 ] = { nodes.BEH_Obj_Pion_INF_GererInstallationObstacle, "ACT_Obj_Pion_INF_PreparerAbattis", nodes.ACT_Obj_Pion_INF_PreparerAbattis }
connections[ #connections + 1 ] = { nodes.BEH_Obj_Pion_INF_GererInstallationObstacle, "ACT_Misc_Pion_DelaiInstallation", nodes.ACT_Misc_Pion_DelaiInstallation }
connections[ #connections + 1 ] = { nodes.BEH_Obj_Pion_INF_GererInstallationObstacle, "ACT_Obj_Pion_INF_Activer", nodes.ACT_Obj_Pion_INF_Activer }
