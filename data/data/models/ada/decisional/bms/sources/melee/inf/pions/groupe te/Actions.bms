includedFiles = includedFiles or {}
includedFiles["sources/melee/inf/pions/groupe te/Actions.bms"] = true

--[[// *****************************************************************************
]]--[[// $Archive: /MVW_v10/Build/Data/Data/Modeles/Sources/Melee/Inf/Pions/Groupe TE/Parameters.hal $
]]--[[// $Author: Jcr $
]]--[[// $Modtime: 22/09/05 18:27 $
]]--[[// $Revision: 24 $
]]--[[// Created: JCR 03-02-13
]]--[[// *****************************************************************************
]]
--[[//-----------------------------------------------------------------------------
]]--[[// Action de Debarquement de la Section d'Infanterie
]]--[[// @perc pourcentage total de debarquement
]]--[[//-----------------------------------------------------------------------------
]]node "ACT_Transport_Pion_INF_Debarquer"
{
    feedbacks = { { { "done_ACT_Transport_Pion_INF_Debarquer" }, "ACT_Transport_Pion_INF_Debarquer" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_ACT_Transport_Pion_INF_Debarquer, {value} ) end,
    actuators =
    {
        deplacement = 1,
        debarquement = 1,
    },

    create = function( self )
    end,

    select = function( self )
                self.bReprise = self.bReprise or false
        self.eEtat_EmbDeb = self.eEtat_EmbDeb or eActionEmbDeb_EnCours
        self.actionID = self.actionID or 0
        if( ModuleBegins() ) then
            do
                DEC_Message( eRC_DisembarkmentStarted )
                self.actionID = DEC_StartDebarquement(  )
                actionCallbacks[ self.actionID ] = function( arg ) self.eEtat_EmbDeb = arg end

            end
        end

         do
            local _continue = true
            local switch_1 = self.eEtat_EmbDeb
                if switch_1 == eActionEmbDeb_EnCours then
                    _continue = false
                elseif switch_1 == eActionEmbDeb_ErreurEmbDebEnMemeTemps
                or switch_1 == eActionEmbDeb_PasDeTransporteurs then
                    DEC_Trace( "Debarquement : ignore transporteur" )
                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionEmbDeb_Termine then
                    DEC_Message( eRC_DisembarkmentFinished )
                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                                end
            end

        if( self.bReprise ) then
            do
                DEC_Message( eRC_DisembarkmentResumed )
                DEC_ReprendAction( self.actionID )
                self.bReprise = false
            end
        end

--[[// arret du debarquement
]]--[[// arret du debarquement
]]    end,

    deselect = function( self )
                DEC_Message( eRC_DisembarkmentInterrupted )
        DEC_PauseAction( self.actionID )
        self.bReprise = true
    end,

    destroy = function( self )
                DEC_Trace( "Debarquement : spontaneous end" )
        DEC_StopAction( self.actionID )
    end,

}

--[[//=============================================================================
]]--[[//=============================================================================
]]--[[// Gestion des types de tir, debarques/embarques
]]--[[//=============================================================================
]]--[[//-----------------------------------------------------------------------------
]]--[[// Action de destruction d'un ennemi uniquement avec la composante debarque
]]--[[//-----------------------------------------------------------------------------
]]node "ACT_Tir_Pion_INF_TirDebarque"
{
    feedbacks = { { { "done_ACT_Tir_Pion_INF_TirDebarque" }, "ACT_Tir_Pion_INF_TirDebarque" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_ACT_Tir_Pion_INF_TirDebarque, {value} ) end,
    actuators =
    {
        tir_debarque = 1,
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.repEni = self.params[1]
    end,

    select = function( self )
                self.eTir = self.eTir or eActionTirDirect_Running
        self.bReprendre = self.bReprendre or false
        self.actionID = self.actionID or 0
        if( self.bReprendre ) then
            do
                self.bReprendre = false
                DEC_ReprendAction( self.actionID )
            end
        end

        if( ModuleBegins() ) then
            do
                                do
                end

                DEC_Trace( "debut tir fantassins" )
                self.actionID = DEC_StartTirDirectDebarques( self._namedParams.repEni, 1, eTirDirectNormal )
                actionCallbacks[ self.actionID ] = function( arg ) self.eTir = arg end

                self.bReprendre = true
            end
        end

         do
            local _continue = true
--[[// DEC_RC( eRC_SituationLogDefavorable, eRCType_DotationMunition );
]]            local switch_1 = self.eTir
                if switch_1 == eActionTirDirect_EnemyDestroyed then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_Impossible then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_Finished then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_NoAmmo then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_NoCapacity then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_Running then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_Executer )
                    do
                    end

                    _continue = false
                                end
            end

                self:SendFeedback( eActionEnCours )
        do return end

    end,

    deselect = function( self )
                F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
        do
        end

        DEC_Trace( "fin tir fantassins: perte de focus" )
        self.bReprendre = true
        DEC_PauseAction( self.actionID )
    end,

    destroy = function( self )
                F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
        do
        end

        DEC_Trace( "fin tir fantassins" )
        DEC_StopAction( self.actionID )
    end,

}

--[[//-----------------------------------------------------------------------------
]]--[[// Demande de tir de couverture
]]--[[// Tir uniquement avec la composante VAB ( qd les fantassins sont debarques )
]]--[[//-----------------------------------------------------------------------------
]]node "ACT_Tir_Pion_INF_TirCouverture"
{
    feedbacks = { { { "done_ACT_Tir_Pion_INF_TirCouverture" }, "ACT_Tir_Pion_INF_TirCouverture" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_ACT_Tir_Pion_INF_TirCouverture, {value} ) end,
    actuators =
    {
        tir_couverture = 1,
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.repEni = self.params[1]
    end,

    select = function( self )
                self.eTir = self.eTir or eActionTirDirect_Running
        self.bReprendre = self.bReprendre or false
        self.actionID = self.actionID or 0
        if( self.bReprendre ) then
            do
                self.bReprendre = false
                DEC_ReprendAction( self.actionID )
            end
        end

        if( ModuleBegins() ) then
            do
                                do
                end

                DEC_Trace( "debut tir fantassins" )
                self.actionID = DEC_StartTirDirectTransporteurs( self._namedParams.repEni, 1, eTirDirectNormal )
                actionCallbacks[ self.actionID ] = function( arg ) self.eTir = arg end

                self.bReprendre = true
            end
        end

         do
            local _continue = true
--[[// DEC_RC( eRC_SituationLogDefavorable, eRCType_DotationMunition );
]]            local switch_1 = self.eTir
                if switch_1 == eActionTirDirect_EnemyDestroyed then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_Impossible then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_Finished then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_NoAmmo then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_NoCapacity then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
                    do
                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                                end
                if switch_1 == eActionTirDirect_Running then
                    F_Pion_SeteEtatFeu( myself, eEtatFeu_Executer )
                    do
                    end

                    _continue = false
                                end
            end

                self:SendFeedback( eActionEnCours )
        do return end

    end,

    deselect = function( self )
                F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
        do
        end

        DEC_Trace( "fin tir couverture: perte de focus" )
        self.bReprendre = true
        DEC_PauseAction( self.actionID )
    end,

    destroy = function( self )
                F_Pion_SeteEtatFeu( myself, eEtatFeu_aucun )
        do
        end

        DEC_Trace( "fin tir couverture" )
        DEC_StopAction( self.actionID )
    end,

}

node "ACT_Pion_VAB_ControleZone"
{
    feedbacks = { { { "done_ACT_Pion_VAB_ControleZone" }, "ACT_Pion_VAB_ControleZone" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_ACT_Pion_VAB_ControleZone, {value} ) end,
    actuators =
    {
        controle_zone = 1,
        deplacement = 1,
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.locZone = self.params[1]
        self._namedParams.rDist = self.params[2]
        self._namedParams.bFaireFeu = self.params[3]
    end,

    select = function( self )
                self.bInit = self.bInit or true
        self.bTirDeclenche = self.bTirDeclenche or false
        self.actionID = self.actionID or 0
        if( self.bInit ) then
            do
                DEC_Trace( "Controle Zone : debut" )
                self.actionID = DEC_StartControlerZone( self._namedParams.rDist, self._namedParams.bFaireFeu )
                actionCallbacks[ self.actionID ] = function( arg ) self._namedParams.locZone = arg end

            end
--[[// Le rc eRC_DebutControleZone est fait au debut de la phase de la 
]]--[[// mission
]]--[[// {	if( ! DEC_Agent_AutomateEstEmbraye() )	    DEC_RC(  eRC_DebutControleZone  );    else        DEC_Message(  eRC_DebutControleZone  );}
]]        end

        if( self.bTirDeclenche ) then
            do
                if( not DEC_Agent_AutomateEstEmbraye() ) then
                    DEC_RC( eRC_TirExecute )
                else
                    DEC_Message( eRC_TirExecute )
                end

            end
        end

        self.bInit = false
    end,

    deselect = function( self )
                self.bInit = true
        DEC_Trace( "Controle Zone : fin" )
        DEC_StopAction( self.actionID )
        do
            if( not DEC_Agent_AutomateEstEmbraye() ) then
                DEC_RC( eRC_FinControleZone )
            else
                DEC_Message( eRC_FinControleZone )
            end

        end

    end,

    destroy = function( self )
                if( not self.bInit ) then
            DEC_StopAction( self.actionID )
        end

    end,

}

node "ACT_Obj_Pion_INF_RealiserBouchonMines"
{
    feedbacks = { { { "done_ACT_Obj_Pion_INF_RealiserBouchonMines" }, "ACT_Obj_Pion_INF_RealiserBouchonMines" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_ACT_Obj_Pion_INF_RealiserBouchonMines, {value} ) end,
    actuators =
    {
        deplacement = 2,
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.locObjet = self.params[1]
        self._namedParams.rQte = self.params[2]
    end,

    select = function( self )
        --[[//booleens suspension reprise et terminaison
]]        self.actionID = self.actionID or 0
        self.eEtatObjet = self.eEtatObjet or eActionObjetEnCours
        self.bSuspendu = self.bSuspendu or false
        self.bReprise = self.bReprise or false
        self.repObj = self.repObj or nil--[[//objet reel pour la creation de la representation de l'abatti
]]
        if( ModuleBegins() ) then
            do
                if( not DEC_Agent_PeutConstruireObjet( S_TypeObject_ToString( eTypeObjectBouchonMines ) ) ) then
                    self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end
                end

                DEC_Trace( "realisation bouchon mines : nbre = " .. FloatToString( self._namedParams.rQte ) )
                self.actionID = DEC_StartCreerObjet( self.repObj, S_TypeObject_ToString( eTypeObjectBouchonMines ), self._namedParams.locObjet, self._namedParams.rQte )
                actionCallbacks[ self.actionID ] = function( arg ) self.eEtatObjet = arg end
                actionKnowledgeCallbacks[ self.actionID ] = function( arg ) self.repObj = arg end

                do
                    if( not DEC_Agent_AutomateEstEmbraye() ) then
                        DEC_RC( eRC_DebutTravaux )
                    else
                        DEC_Message( eRC_DebutTravaux )
                    end

                end

            end
        end

         do
            local _continue = true
--[[// DEC_RC( eRC_SituationLogDefavorable, eRCType_DotationMine );
]]            local switch_1 = self.eEtatObjet
            local cases_switch_1 = {}
                if switch_1 == eActionObjetEnCours then
                    _continue = false
                                cases_switch_1[1] = true
elseif switch_1 == eActionObjetTerminee then
                    DEC_Trace( "fin realisation" )
                    do
                        if( not DEC_Agent_AutomateEstEmbraye() ) then
                            DEC_RC( eRC_FinTravaux )
                        else
                            DEC_Message( eRC_FinTravaux )
                        end

                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                    _continue = false
                elseif switch_1 == eActionObjetManqueDotation then
                                cases_switch_1[3] = true
                end
                if cases_switch_1[3] or switch_1 == eActionObjetImpossible then
                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                    _continue = false
                                end
            end

        if( self.bSuspendu ) then
            do
                --[[// Pas de delais de reorganisation du chantier
]]self.bReprise = true
                self.bSuspendu = false
            end
        end

        if( self.bReprise ) then
            do
                DEC_Trace( "reprise realisation" )
                DEC_ReprendAction( self.actionID )
                self.bReprise = false
            end
        end

    end,

    deselect = function( self )
                DEC_Trace( "realisation suspendue" )
        DEC_PauseAction( self.actionID )
        self.bSuspendu = true
    end,

    destroy = function( self )
                DEC_Trace( "realisation arretee" )
        DEC_StopAction( self.actionID )
    end,

}

node "ACT_Obj_Pion_INF_RealiserObjet"
{
    feedbacks = { { { "done_ACT_Obj_Pion_INF_RealiserObjet" }, "ACT_Obj_Pion_INF_RealiserObjet" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_ACT_Obj_Pion_INF_RealiserObjet, {value} ) end,
    actuators =
    {
        deplacement = 2,
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.eTypeObjet = self.params[1]
        self._namedParams.locObjet = self.params[2]
        self._namedParams.rParam = self.params[3]
    end,

    select = function( self )
        --[[//booleens suspension reprise et terminaison
]]        self.actionID = self.actionID or 0
        self.eEtatObjet = self.eEtatObjet or eActionObjetEnCours
        self.bSuspendu = self.bSuspendu or false
        self.bReprise = self.bReprise or false
        self.repObj = self.repObj or nil--[[//objet reel pour la creation de la representation de l'abatti
]]
        if( ModuleBegins() ) then
            do
                if( DEC_Agent_PeutConstruireObjet( S_TypeObject_ToString( eTypeObjectBouchonMines ) ) ) then
                    do
                        DEC_Trace( "realisation objet : impossible" )
                                                self:SendFeedback( eActionImpossible )
                        Halt( self )
                        do return end

                    end
                end

                DEC_Trace( "realisation objet : debut" )
                self.actionID = DEC_StartCreerObjet( self.repObj, S_TypeObject_ToString( self._namedParams.eTypeObjet ), self._namedParams.locObjet, self._namedParams.rParam )
                actionCallbacks[ self.actionID ] = function( arg ) self.eEtatObjet = arg end
                actionKnowledgeCallbacks[ self.actionID ] = function( arg ) self.repObj = arg end

                do
                    if( not DEC_Agent_AutomateEstEmbraye() ) then
                        DEC_RC( eRC_DebutTravaux )
                    else
                        DEC_Message( eRC_DebutTravaux )
                    end

                end

            end
        end

         do
            local _continue = true
            local switch_1 = self.eEtatObjet
            local cases_switch_1 = {}
                if switch_1 == eActionObjetEnCours then
                    _continue = false
                                cases_switch_1[1] = true
elseif switch_1 == eActionObjetTerminee then
                    DEC_Trace( "realisation objet : fin realisation" )
                    do
                        if( not DEC_Agent_AutomateEstEmbraye() ) then
                            DEC_RC( eRC_FinTravaux )
                        else
                            DEC_Message( eRC_FinTravaux )
                        end

                    end

                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                    _continue = false
                elseif switch_1 == eActionObjetPasDeCapacite then
                    DEC_Trace( "realisation objet : pas de capacites" )
                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                    _continue = false
                elseif switch_1 == eActionObjetManqueDotation then
                    DEC_Trace( "realisation objet : manque dotation" )
                    DEC_RC( eRC_PasDotationConstructionObjet )
                                cases_switch_1[4] = true
                end
                if cases_switch_1[4] or switch_1 == eActionObjetImpossible then
                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                    _continue = false
                                end
            end

        if( self.bSuspendu ) then
            do
                --[[// Pas de delais de reorganisation du chantier
]]self.bReprise = true
                self.bSuspendu = false
            end
        end

        if( self.bReprise ) then
            do
                DEC_Trace( "reprise realisation" )
                DEC_ReprendAction( self.actionID )
                self.bReprise = false
            end
        end

    end,

    deselect = function( self )
                DEC_Trace( "realisation suspendue" )
        DEC_PauseAction( self.actionID )
        self.bSuspendu = true
    end,

    destroy = function( self )
                DEC_Trace( "realisation arretee" )
        DEC_StopAction( self.actionID )
    end,

}

--[[//-----------------------------------------------------------------------------
]]--[[// Destruction de l'objet
]]--[[//-----------------------------------------------------------------------------
]]node "ACT_Obj_Pion_INF_Detruire"
{
    feedbacks = { { { "done_ACT_Obj_Pion_INF_Detruire" }, "ACT_Obj_Pion_INF_Detruire" } },
    SendFeedback = function( self, value ) Feedback( self.feedbacks.done_ACT_Obj_Pion_INF_Detruire, {value} ) end,
    actuators =
    {
        deplacement = 2,
    },

    create = function( self )
        self._namedParams = {}
        self._namedParams.repObj = self.params[1]
    end,

    select = function( self )
                self.actionID = self.actionID or 0
        --[[//booleens suspension reprise et terminaison
]]self.eEtatObjet = self.eEtatObjet or eActionObjetEnCours
        self.bSuspendu = self.bSuspendu or false
        self.bReprise = self.bReprise or false
        if( ModuleBegins() ) then
            do
                --[[// if ( !DEC_Agent_PeutDetruireObjet( ? ) )
]]--[[// 		halt( eActionImpossible );
]]DEC_Trace( "destruction : debut" )
                self.actionID = DEC_StartDetruireObjet( self._namedParams.repObj )
                actionCallbacks[ self.actionID ] = function( arg ) self.eEtatObjet = arg end

            end
        end

         do
            local _continue = true
            local switch_1 = self.eEtatObjet
                if switch_1 == eActionObjetEnCours then
                    _continue = false
                elseif switch_1 == eActionObjetTerminee then
                    DEC_Trace( "destruction : fin" )
                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionEffectuee )
                    Halt( self )
                    do return end

                    _continue = false
                elseif switch_1 == eActionObjetImpossible
                or switch_1 == eActionObjetManqueDotation then
                    DEC_StopAction( self.actionID )
                                        self:SendFeedback( eActionImpossible )
                    Halt( self )
                    do return end

                    _continue = false
                                end
            end

        if( self.bSuspendu ) then
            do
                --[[// Pas de delais de reorganisation du chantier
]]self.bReprise = true
                self.bSuspendu = false
            end
        end

        if( self.bReprise ) then
            do
                DEC_Trace( "destruction : reprise" )
                DEC_ReprendAction( self.actionID )
                self.bReprise = false
            end
        end

    end,

    deselect = function( self )
                DEC_Trace( "destruction : suspendue" )
        DEC_PauseAction( self.actionID )
        self.bSuspendu = true
    end,

    destroy = function( self )
                DEC_Trace( "destruction : arretee" )
        DEC_StopAction( self.actionID )
    end,

}

