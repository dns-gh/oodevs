-- set echelon for elements in bestUnits
-- @params bestUnits : list of element
-- @params echelon
-- @author LMT
-- @release 2011-01-13
local function setEchelon ( bestUnits, echelon )
    local nBestUnits = #bestUnits
    for i = 1, nBestUnits do
        local elem = bestUnits[i]
        F_Pion_SeteEtatEchelon( elem.entity.source, echelon )
    end
end

-- Find which unit will do the task
-- @params self
-- @params tasks : a list of platoon taks*
-- @params nbrFront : how many platoon can take this task
-- @params echelon : echelon number
-- @author LMT
-- @release 2011-01-13
local function issueMission ( self, tasks, nbrFront, echelon, entities )
    local tasks = explode( ";", tasks )
    entities = entities or self.entitiesWithoutMission
    local bestUnits = findBests( entities, tasks, self.companyTask, self.parameters, nbrFront ) --Save the nbrFront best couple unit/task
    self.entitiesWithoutMission = removeFromListForLead( bestUnits, self.entitiesWithoutMission )
    setEchelon( bestUnits, echelon )
    local nBestUnits = #bestUnits
    for i = 1, nBestUnits do
        local elem = bestUnits[i]
        if not integration.isLogisticConvoy( elem.entity.source ) then
            meKnowledge:sendTaskToPion( elem.entity, elem.taskName, elem.params, echelon ) -- Send the task to the unit
        end
    end
    return bestUnits
end

-- Listen front element  in order to manage automat feedback
-- @params frontElement : realize the main effect
-- @author LMT
-- @release 2011-01-14
local function manageFeedback ( frontElement )
    local nbUnitInOtherAutomat = 0
    local DEC_GetAutomate = DEC_GetAutomate
    for _, elem in pairs (frontElement) do
      integration.ListenFrontElement( elem.entity )
      if DEC_GetAutomate( elem.entity.source ) == meKnowledge then
      -- On vérifie que le pion est toujours sous l'automate
          nbUnitInOtherAutomat = nbUnitInOtherAutomat + 1
      end
    end
    -- si tous les pions ont changé d'automate (par exemple pour la mission preparer bascule), on remonte une fin de mission
    if nbUnitInOtherAutomat == #frontElement then
        myself.feedback = true
    end
end

local function manageAddedAndDeletedUnits( self )
    local redone = false
    self.listenFrontElementInitialized = false
    local DEC_HasMission = DEC_HasMission
    local oldEntities = self.parameters.commandingEntities
    local newEntities = integration.getEntitiesFromAutomat( meKnowledge, "none", self.params.withPC )
    local newOperationnalEntities = integration.getOperationnalEntitiesDespiteJammedFromAutomat( meKnowledge, "none", self.params.withPC )

    -- Si un pion a été supprimé de l'automate, on redistribue les missions
    for i, entity in pairs( oldEntities ) do
        if ( not exists( newEntities, entity ) ) and ( not integration.isLogisticConvoy( entity.source ) ) then
             -- faut tester si le ou les pion au moins est operationnel et brouille
             self:create()
             redone = true
             self.listenFrontElementInitialized = true
             integration.initializeListenFrontElement()
             break
        end
    end

    -- Si un pion est de nouveau operationnel et/ou un pion a été ajouté à l'automate
   if #newOperationnalEntities > #self.operationnalEntities and not redone then
        for i, entity in pairs( newOperationnalEntities ) do
            if not exists( self.operationnalEntities, entity ) then
                -- Si le pion n'a pas de mission ou si c'est de la LOG on donne Se deployer; si c'est un pion Convoi, il ne faut pas le prendre en compte
                if not DEC_Automate_isLogistic() and not integration.isLogisticConvoy( entity.source ) then 
                    local tasksForNewEntity = ""
                    if myself.taskParams.echelonNumber == 1 then
                          tasksForNewEntity = self.params.mainTasks..";"..self.params.supportTasks..";"..self.params.defaultTask
                          issueMission ( self, tasksForNewEntity, 1, eEtatEchelon_First, { entity } )
                    else
                          tasksForNewEntity = self.params.supportTasks..";"..self.params.defaultTask
                          issueMission ( self, tasksForNewEntity, 1, eEtatEchelon_Second, { entity } )
                    end
                end
            end
        end
    end

    self.operationnalEntities = newOperationnalEntities -- on enregistre la liste pour le tic suivant
    self.parameters.commandingEntities = newEntities
end

rootnode {

connections = { skill.links.supportManager, skill.links.coordinationManager, skill.links.relieveManager, 
                skill.links.AssignSETask, skill.links.synchronizeRC, skill.nodes.RC },

done = function( self ) end,

create = function( self )
        myself.stopFrago = false
           
        integration.initializeListenFrontElement()
        myself.newTask = false
        self.parameters = myself.taskParams
        self.parameters.commandingEntities = integration.getEntitiesFromAutomatCommunication( meKnowledge, "none", self.params.withPC )
        self.operationnalEntities = integration.getOperationnalEntitiesFromAutomat( meKnowledge, "none", self.params.withPC )
        for _, pion in pairs( self.parameters.commandingEntities ) do
            integration.setNeedReinforcement( pion, nil, nil, false )
        end
        -- Init
        local Activate = Activate
        myself.leadData = {}
        myself.leadData.taskError = false
        self.entitiesWithoutMission = copyTable( self.parameters.commandingEntities )
        myself.feedback = false
        self.companyTask = integration.RetrieveAutomateTask( meKnowledge, self.params.companyTask )
        self.companyTask:init( self.params, self.parameters )
        
        if myself.leadData.taskError then -- Impossible for automat to give tasks because one mandatory parameter for units cannot be given 
           Feedback( self.feedbacks.done )
           return
        end
        meKnowledge.nbPionsMain = integration.nbPlatoonsHaveTask( self.parameters.commandingEntities, self.params.mainTasks )

        if self.params.allInFront and self.params.allInFront ~= NIL then
            self.nbrFront = #self.parameters.commandingEntities -- All platoons in front
        else
            self.nbrFront = self.companyTask:getNbrFront() -- Ask how many platoon will be in the front group. Number giving by the user or by default.
        end
        self.progressionInAOR = {}

        -- Initialisation des missions pion
        -- Le pion PC rejoint le meetingPoint
        if self.params.pcTasks and self.params.pcTasks ~= NIL then
            self.parameters.pcObjective = self.params.pcObjective
            issueMission ( self, self.params.pcTasks, 1, eEtatEchelon_Reserve, { integration.query.getPCUnit() } )
        end

        -- S'il y a des obstacles à construire, les pions GEN (ou PIA) vont le construire
        if self.params.engineerTask and self.params.engineerTask ~= NIL then
            issueMission ( self, self.params.engineerTask,  #self.companyTask:getObstaclesPlan( myself.taskParams ), eEtatEchelon_None )
        end

        -- Le premier echelon recoit les missions principales ("mainTasks")
        local bestUnits = issueMission ( self, self.params.mainTasks, self.nbrFront, eEtatEchelon_First )
        
        if #bestUnits == 0 then
            Activate( skill.nodes.RC, 1, { RC = eRC_NoPEInAutomat } )
            return
        end
        manageFeedback( bestUnits )
        self.bestUnits = copyTable( bestUnits )
        
        -- Le second echelon recoit les missions de "supportTask"
        issueMission ( self, self.params.supportTasks, #self.entitiesWithoutMission, eEtatEchelon_Second )

        -- Les pions PEI
        if self.params.peiTasks and self.params.peiTasks ~= NIL then
            issueMission ( self, self.params.peiTasks, self.nbrFront, eEtatEchelon_Scout )
        end

        -- Ceux qui n'ont toujours pas de mission recoivent la mission par défaut
        issueMission ( self, self.params.defaultTask, #self.entitiesWithoutMission, eEtatEchelon_Reserve )
end,

activate = function( self )
    if myself.newTask then
      self:create()
    end
    
    if self.listenFrontElementInitialized then -- if a subordinate destroyed before and tasks issued a new time
        DEC_Trace("self.listenFrontElementInitialized true")
        for _, elem in pairs (self.bestUnits) do
            integration.ListenFrontElement( elem.entity )
        end
        self.listenFrontElementInitialized = false
    end

    if self.params.manageAddedAndDeletedUnits then
        manageAddedAndDeletedUnits( self )
    end

    local Activate = Activate
    local echelons = integration.getPionsInEchelons( self.parameters.commandingEntities )
    local pionsPE =  echelons[1]
    local pionsSE =  echelons[2]
    local pionsEE =  echelons[3]

    -- Gestion du CR quand les pions PE arrivent sur les limas de type LC ou LD
    Activate( skill.links.synchronizeRC, 1, { entities = pionsPE } )

    -- Gestion du soutien
    Activate( skill.links.supportManager, 1, { companyTask = self.companyTask, parameters = self.parameters, PE = pionsPE, SE = pionsSE, taskForSupporting = self.params.taskForSupporting })

    if not self.params.noCoordination then

        local fuseau = meKnowledge:getFuseau()
        

        -- Gestion de l'élongation   
        -- tous les pions sont projeté sur un des deux fuseaux de l'automate
        -- self.progressionInAOR: contient les valeurs de progression sur l'axe de progression
        -- plus la valeur est grande, plus le pion est en avant dans le fuseau
        -- Effet de bord indesirable : en cas d'aller retour dans le fuseau la coordination est completement inutilisable 
        local proj
        for _, entity in pairs( self.parameters.commandingEntities ) do
            proj = DEC_Geometrie_AdvanceAlongFuseau( entity.source ) 
            self.progressionInAOR[ entity ] = proj
        end
    
        local pionHasSupport, supportDistance
        local maxsupportDistance = 1200
        for _, pion in pairs( pionsSE ) do
              supportDistance = integration.getSupportDistanceToCoordination( pion.source, 0.5 )
              if supportDistance > maxsupportDistance then
                  maxsupportDistance = supportDistance
              end
        end
      
        local automatePosition = meKnowledge:getPosition()
        local inCity = integration.pointIsInCity(automatePosition)
    
        local largeurFuseau = fuseau:getWidth()
        
        if inCity then
          maxsupportDistance = maxsupportDistance/4
        else
          maxsupportDistance = maxsupportDistance/2
        end
       
        -- Gestion de l'élongation intra echelon   
        Activate( skill.links.coordinationManager , 1, { enititesFromEchelon = pionsPE, progressionInAOR = self.progressionInAOR, distance = largeurFuseau/2 } )
        Activate( skill.links.coordinationManager , 1, { enititesFromEchelon = pionsEE, progressionInAOR = self.progressionInAOR, distance = largeurFuseau/2 } )
        
        -- Gestion de l'élongation inter echelon
        Activate( skill.links.coordinationManager , 1, { enititesFromEchelon = fusionList( pionsPE, pionsSE ), progressionInAOR = self.progressionInAOR, distance = maxsupportDistance } )
    end

    -- Gestion de la rélève
    Activate( skill.links.relieveManager, 1, { pions = pionsPE, releve = pionsSE })

    -- Gestion du SE (car les objectifs ne sont plus les mêmes)
    local tasksForSE = self.params.supportTasks..";"..self.params.defaultTask
    Activate( skill.links.AssignSETask, 1, { SE = pionsSE, tasks = tasksForSE, parameters = self.parameters, companyTask = self.companyTask })
    
    if myself.feedback then
        if self.params.disableWhenDone then
           Feedback( self.feedbacks.done )
        else
           meKnowledge:RC( eRC_FinMission )
        end
        for i = 1, #self.parameters.commandingEntities do
           F_Pion_SeteEtatEchelon( self.parameters.commandingEntities[i].source, eEtatEchelon_None )
        end
        myself.feedback = false
        return
    end
    
    if not myself.stopFrago and not next(integration.getPionsInEchelons( self.parameters.commandingEntities )[1]) then
        Activate( skill.nodes.RC, 1, { RC = eRC_NoPEInAutomat } )
    end
end,

destroy = function (self )
    for i = 1, #self.parameters.commandingEntities do
       F_Pion_SeteEtatEchelon( self.parameters.commandingEntities[i].source, eEtatEchelon_None )
    end
end,
}

node "RC"
{
    create = function( self )
        meKnowledge:RC( self.params.RC )
    end,
}
