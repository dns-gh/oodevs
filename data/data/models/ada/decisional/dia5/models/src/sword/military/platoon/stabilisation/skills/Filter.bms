-- **************************************************************************** 
-- Filter.
-- self.params.position: the position wherer unit need to filter.
-- ****************************************************************************
rootnode 
{
    connections = { skill.nodes.AdoptFiltrationPosture, skill.links.moveToward, skill.links.dismount, skill.links.controlCrowds },

    -- -------------------------------------------------------------------------------- 
    -- Feedbacks
    -- --------------------------------------------------------------------------------
    done = function( self ) -- done from moveToward
        self.arrived = true
    end,
    failed = function( self, params, additionalParams ) -- failed from controlCrowds
        self.positionSurete = additionalParams.positionSurete
    end,

    -- -------------------------------------------------------------------------------- 
    -- Init
    -- --------------------------------------------------------------------------------
    create = function( self )
        self.arrived = false
        if self.params.blockingStrength == NIL then
             self.blockingStrength = 0
        else
             self.blockingStrength = self.params.blockingStrength 
                                or ( 0.9 * self.params.bodySearchStrength )
        end
    end,

    -- -------------------------------------------------------------------------------- 
    -- MoveToward position and adopt a filter posture
    -- --------------------------------------------------------------------------------
    activate = function( self )
        local Activate = Activate
        
        if self.positionSurete then -- If the control failed
            Activate( skill.links.moveToward, 1, { entities = { self.positionSurete } } )
        else
            if self.arrived then
                if self.params.position:isReached() then
                    Activate( skill.links.dismount, 1 )
                    Activate( skill.nodes.AdoptFiltrationPosture, 1, 
                                { position           = self.params.position,
                                  blockingStrength   = self.blockingStrength, 
                                  bodySearchStrength = self.params.bodySearchStrength } )
                    local crowds = integration.getCrowds()
                    local crowdsNearUnit = {}
                    for i = 1, #crowds do
                        local crowd = CreateKnowledge( integration.ontology.types.population, crowds[i])
                        if integration.distance( meKnowledge , crowd ) < 200 then
                            crowdsNearUnit[#crowdsNearUnit + 1 ] = crowd
                        end
                    end
                    Activate( skill.links.controlCrowds, 1, {crowds = crowdsNearUnit, dontMove = true} )
    
                else -- Objective not reached, don't build checkpoint
                    meKnowledge:RC( eRC_ImpossibleAtteindreObjectif )
                    Feedback( self.feedbacks.failed )
                end
            end
            Activate( skill.links.moveToward, 1, { entities = { self.params.position } } )
            self.arrived = false
         end
    end
}

-- **************************************************************************** 
-- AdoptFiltrationPosture.
-- self.params.crowd: the crowd
-- -- $$$ MIA: if this node is defined as a skill it should use movementCapacity 
-- ****************************************************************************
node "AdoptFiltrationPosture"
{
    feedbacks = { "filtered" },
    
    select = function( self )
        meKnowledge:adoptFiltrationPosture( self.params.blockingStrength, 
                                             self.params.bodySearchStrength, 
                                             self.params.position )
        Feedback( self.feedbacks.filtered )
    end
}