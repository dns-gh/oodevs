rootnode
{
    connections = { skill.nodes.ImproveElement };

    feedbacks = { "elementImproved", "elementNotActivated", "elementFailed", "elementImproved", "elementCancelled", "elementNotImprovable" },

    done = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementImproved, { element = additionalParams.element } )
        self.targets[ params.entity ] = nil
        if not next( self.targets ) then
            Feedback( self.feedbacks.done, { element = additionalParams.element } )
        end
    end,

    failed = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementFailed, { element = additionalParams.element, reason = additionalParams.reason, action = "mine" } )
    end,

    cancelled = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementCancelled, { element = additionalParams.element } )
        self.targets[ params.entity ] = nil
        if not next( self.targets ) then
            Feedback( self.feedbacks.done, { element = additionalParams.element } )
        end
    end,
    
    notActivated = function( self, params, additionalParams)
        Feedback( self.feedbacks.elementNotActivated, { element = additionalParams.element } )
        self.targets[ additionalParams.element ] = nil
    end,
    
    create = function( self )
        self.targets = {}
        for _, entity in pairs( self.params.entities ) do
            local object = entity:plannedworkToWork()
            if object:canBeImproved() then
                self.targets[ object ] = true
            else
                Feedback( self.feedbacks.elementNotImprovable, { element = object } )
            end
        end
    end,

    activate = function( self )
        local Activate = Activate
        for entity in pairs( self.targets ) do
            Activate( skill.nodes.ImproveElement, entity:improvePriority(), { entity = entity } )
        end
    end
}

node "ImproveElement"
{
    connections = { skill.links.moveAndTakePosition, skill.links.observe, skill.links.dismount, skill.nodes.Improve },

    feedbacks = { "cancelled", "notActivated" },

    done = function( self, params, additionalParams )  -- feedbackfrom moveAndTakePosition
        self.arrived = true
    end,
    
    create = function( self )
        self.arrived = false
        self.positions = sword.military.queries.tactical.getPositionsToBuild[ "execute" ](
                                             { elementsToBuild = { self.params.entity } } )
    end,

    activate = function( self )
        local Activate = Activate
        local cancelOrder = integration.query.getFirstFragOrderFromType( "Rep_OrderConduite_Pion_AbandonnerTravaux" )
        if cancelOrder then
            Feedback( self.feedbacks.cancelled, {element = self.params.entity } )
            return
        end

        if self.params.entity:isImproved() then
             if self.params.entity:isManeuverObstacle() and not self.params.entity:isActivated() then  --if maneuver obstacle, it need to be activated to consider the mining action is over
               meKnowledge:sendObstacleToActivate( integration.GetSuperiorKnowledge( meKnowledge), self.params.entity )
               Feedback( self.feedbacks.notActivated, { element = self.params.entity } )
               return   
             end
            Feedback( self.feedbacks.done, { element = self.params.entity} )
            return
        end 

        Activate( skill.links.observe, 1, { entity = self.params.entity } )

        if self.arrived then
            if not self.params.entity:improvingDotation() then
                Feedback( self.feedbacks.failed, { element = self.params.entity, reason = eRC_ConstructionObjetImpossible } )
            elseif not self.params.entity:canImproveIt() then
                Feedback( self.feedbacks.failed, { element = self.params.entity, reason = eRC_PasDotationConstructionObjet } )
            else
                Activate( skill.links.dismount, 1 )
                Activate( skill.nodes.Improve, 1, { entity = self.params.entity } )
            end
        end

        -- Moving toward improvement positions, same as build
        for _, position in pairs ( self.positions ) do
            Activate( skill.links.moveAndTakePosition, position:buildEfficiency( self.params.entity ), { entity = position, pathType = eTypeItiDeminage } )
        end
        self.arrived = false
    end,
    
}

node "Improve"
{
    feedbacks = { "done" };

    acquire = { [ skill.resources.buildCapacity ] = 1 };

    select = function( self )
        self.params.entity:improveIt()
    end
}