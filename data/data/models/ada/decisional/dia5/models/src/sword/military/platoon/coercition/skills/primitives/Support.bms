-- ****************************************************************************
-- Support elements.
-- self.params.entities: the supportable elements
-- self.params.positions: the supportable elements
-- ****************************************************************************
rootnode
{
    connections =
    {
        skill.nodes.SupportElement
    },
    
    -- --------------------------------------------------------------------------------
    -- A support position is reached
    -- --------------------------------------------------------------------------------
    done = function( self ) -- feedbackfrom moveAndTakePosition
        self.onPosition = true
    end,

    failed = function( self, additionnalParams )
        removeFromList(additionnalParams.entity, self.entities)
        if not next(self.entities) then
            DEC_RC( eRC_NoUnitsInParameter )
            Feedback( self.feedbacks.done )
        end
    end,

    -- --------------------------------------------------------------------------------
    -- Init
    -- --------------------------------------------------------------------------------
    create = function( self ) 
        self.onPosition = false 
        self.entities = copyTable( self.params.entities )
    end,

    -- --------------------------------------------------------------------------------
    -- Try to support elements
    -- Suppport element if possible, else try to coordinate
    -- --------------------------------------------------------------------------------
    activate = function( self )
        for _, entity in pairs( self.entities ) do
            Activate( skill.nodes.SupportElement, entity:supportPriority(),
                { entity = entity, retrogradeContext = self.params.retrogradeContext } )
        end
        self.onPosition = false
    end
}

-- ****************************************************************************
-- SupportElement.
-- self.params.entities: the supportable elements
-- self.params.positions: the supporting elements
-- ****************************************************************************
node "SupportElement"
{
    connections = { skill.links.observe, skill.links.moveAndTakePosition },
    feedbacks = { "failed" },

    -- --------------------------------------------------------------------------------
    -- A support position is reached
    -- --------------------------------------------------------------------------------
    done = function( self, params, additionalParams ) -- feedbackfrom moveAndTakePosition
        Feedback( self.feedbacks.done, additionalParams )
    end,

    create = function( self )
        self.positions = queries.getPositionsToSupport[ "execute" ]( { retrogradeContext = self.params.retrogradeContext, elementsToSupport = { self.params.entity }, dynamic = true})
    end,
    -- --------------------------------------------------------------------------------
    -- Move toward a destroying element and edstroy the entity
    -- --------------------------------------------------------------------------------
    activate = function( self )
        local Activate = Activate

        if not self.params.entity:isOperational() then
               DEC_RC( eRC_CombatSupportUnitIsDead, DEC_GetSzName(self.params.entity.source) )
               Feedback( self.feedbacks.failed, {entity = self.params.entity } )
        end

        -- Main observation effort on the entity
        Activate( skill.links.observe, 1, { entity = self.params.entity } )

        -- Moving toward supporting positions
        
        --If the old bestPosition is still good
        if self.bestPosition then
         --   if self.bestPosition:supportEfficiency( self.params.entity ) > 0.8 then
                for i=1, #self.positions do
                     Activate( skill.links.moveAndTakePosition,
                               self.efficiencies[self.positions[i]], { entity = self.positions[i] } )
                end
                if not self.bestPosition:isReached() then
                    return
                end
   --         end
        end
        -- If the bestPosition is not enought good for supporting the entity
        self.efficiencies = {}
        self.maxEfficiency = 0
        self.positions = queries.getPositionsToSupport[ "execute" ]( { retrogradeContext = self.params.retrogradeContext,elementsToSupport = { self.params.entity }, dynamic = true})
        for i = 1, #self.positions do
            local position = self.positions[i]
            local efficiency = position:supportEfficiency( self.params.entity )
            self.efficiencies[position] = efficiency
            --DEC_Trace( "Efficiencies pour le point " .. tostring(i) .. " = " .. tostring( self.efficiencies[position] ))
            if( efficiency > self.maxEfficiency ) then
                self.maxEfficiency = efficiency
                self.bestPosition = position
            end
        end
    end
}