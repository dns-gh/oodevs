-- **************************************************************************** 
-- Build elements.
-- self.params.entities: the buildable elements
-- self.params.positions: the building elements
-- ****************************************************************************
rootnode
{
    connections = { skill.nodes.BuildElement },

    feedbacks = { "elementBuilt", "elementNotActivated", "elementFailed", "elementImproved", "elementCancelled", "elementNotImprovable" },
    -- -------------------------------------------------------------------------------- 
    -- Feedback when position reached and when occupied 
    -- --------------------------------------------------------------------------------
    done = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementBuilt, { element = additionalParams.element } )
        self.objectsToBuild[ params.entity ] = nil
        if next( self.objectsToBuild ) == nil then
            Feedback( self.feedbacks.done )
        end
    end,

    failed = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementFailed, { element = additionalParams.element, reason = additionalParams.reason, action ="build" } )
    end,

    cancelled = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementCancelled, { element = additionalParams.element } )
        self.objectsToBuild[ params.entity ] = nil
        if next( self.objectsToBuild ) == nil then
            Feedback( self.feedbacks.done )
        end
    end,
    
    notActivated = function( self, params, additionalParams)
        Feedback( self.feedbacks.elementNotActivated, { element = additionalParams.element } )
        self.objectsToBuild[ additionalParams.element ] = nil
    end,

    create = function( self )
        self.objectsToBuild = {}
        for _, object in pairs( self.params.entities ) do
            self.objectsToBuild[ object ] = true
        end
        meKnowledge:SendClearBuildingObstacleList( meKnowledge )
    end,

    activate = function( self ) 
        local Activate = Activate
        for object, _ in pairs( self.objectsToBuild ) do
            Activate( skill.nodes.BuildElement, 
                object:buildPriority(), { entity = object, positions = self.params.positions } )
        end
    end
}

node "BuildElement"
{
    connections = 
    {
        skill.links.moveAndTakePosition, 
        skill.links.observe,
        skill.links.dismount,
        skill.nodes.Build
    },

    feedbacks = { "cancelled", "notActivated", "failed" },

    done = function( self, params, additionalParams )
       self.arrived = true
    end,
    elementFailed = function( self, params, additionalParams )
        local scaledObject = DEC_Geometrie_AgrandirLocalisation(  self.params.entity:getLocalisation() , 100 )
        if additionalParams.reason == "blocked" then
          if DEC_Geometrie_EstPointDansLocalisation(meKnowledge:getPosition(), scaledObject) then 
               self.arrived = true
          end
        else
          Feedback( self.feedbacks.failed, { element = additionalParams.element, reason = additionalParams.reason } )
        end
    end,
    failed = function( self, params, additionalParams )
       Feedback( self.feedbacks.failed, { element = additionalParams.element, reason = additionalParams.reason } )
    end,

    create = function( self )
        self.arrived = false
        self.obstacleBeginConstructByOther = false
        self.alreadyBeginByMe = false
        if self.params.positions or self.params.positions == NIL then
            self.positions = sword.military.queries.tactical.getPositionsToBuild[ "execute" ](
                                             { elementsToBuild = { self.params.entity } } )
        else
            self.positions = self.params.positions
        end
        self.pionsFriends = {}
        if not meKnowledge:isSelfCommanding() then
            self.pionsFriends = sword.military.queries.miscellaneous.getFriends[ "execute" ]()
        end
    end,

    -- -------------------------------------------------------------------------------- 
    -- Move to appropriate position to build element and build.
    -- --------------------------------------------------------------------------------
    activate = function( self )
        local Activate = Activate
        local toBuild = self.params.entity:plannedworkToWork()
        local cancelOrder = integration.query.getFirstFragOrderFromType( "Rep_OrderConduite_Pion_AbandonnerTravaux" )
        if cancelOrder then
            Feedback( self.feedbacks.cancelled )
            return
        end
        -- when the entity is built send a feedback
        if toBuild:isBuilt() then
            if toBuild:isManeuverObstacle() and not toBuild:isActifManeuverObstacle() and toBuild:delayedActivationTime() == 0 then  --if maneuver obstacle, it need to be activated to consider building action is over
               meKnowledge:sendObstacleToActivate( integration.GetSuperiorKnowledge( meKnowledge), toBuild )
               Feedback( self.feedbacks.notActivated, { element = toBuild } )
               return   
           end
           Feedback( self.feedbacks.done, { element = toBuild } )
           return
       end

        -- current observation toward the element to build
        Activate( skill.links.observe, 1, { entity = toBuild } )

        if self.arrived then
            if self.params.entity:canBuildIt() then
                if not meKnowledge:isDismounted() and not self.params.entity:canBuildItNow() then
                    Activate( skill.links.dismount, 1 )
                else
                    if meKnowledge:isDismounted() then
                        Activate( skill.links.dismount, 1 )
                    end
                    if not integration.unitBuildSameObstacleAtSameTime( toBuild, true ) then
                        if not self.obstacleBeginConstructByOther and not self.alreadyBeginByMe then
                            for i = 1, #self.pionsFriends do
                                if self.pionsFriends[i] ~= meKnowledge then
                                    meKnowledge:sendStartBuildingObstacle( self.pionsFriends[i], meKnowledge, toBuild:getType(), toBuild:getLocalisation() )
                                end
                            end
                        end
                        Activate( skill.nodes.Build, 1, { entity = toBuild } )
                        self.alreadyBeginByMe = true
                    else
                        self.obstacleBeginConstructByOther = true
                    end
                end
            else
                if not self.params.entity:buildingCapacity() then
                    Feedback( self.feedbacks.failed, { element = toBuild, reason = eRC_ConstructionObjetImpossible } )
                elseif not self.params.entity:buildingDotation() then
                    Feedback( self.feedbacks.failed, { element = toBuild, reason = eRC_PasDotationConstructionObjet } )
                end
            end
        end

        for _, position in pairs( self.positions ) do
            Activate( skill.links.moveAndTakePosition, position:buildEfficiency( toBuild ), { entity = position } )
        end

        self.arrived = false
    end,
}

-- **************************************************************************** 
-- Build.
-- Simple action to build element
-- ****************************************************************************
node "Build"
{
    feedbacks = { "failed" },
    acquire = { [ skill.resources.buildCapacity ] = 1 },

    select = function( self )
        local result = self.params.entity:buildIt()
        if result ~= eRC_RAS then
           Feedback( self.feedbacks.failed, { element = self.params.entity, reason = result } )
        end
    end
}
