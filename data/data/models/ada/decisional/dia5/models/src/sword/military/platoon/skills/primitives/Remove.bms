-- **************************************************************************** 
-- Remove obstacles.
-- self.params.entities: the removable elements
-- self.params.positions: the removing elements
-- ****************************************************************************
rootnode
{
    connections = { skill.nodes.removeElement },

    -- -------------------------------------------------------------------------------- 
    -- Feedback when position reached and when occupied
    -- --------------------------------------------------------------------------------
    done = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementRemoved, { element = additionalParams.element } )
        self.targets[ params.entity ] = nil
        if not next( self.targets ) then
            Feedback( self.feedbacks.done )
        end
    end,

    failed = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementFailed, { element = additionalParams.element, needReinforcement = "destroy" } )
    end,

    cancelled = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementCancelled, { element = additionalParams.element } )
        self.targets[ params.entity ] = nil
        if not next( self.targets ) then
          Feedback( self.feedbacks.done )
        end
    end,

    create = function( self )
        self.targets = {}
        for _, entity in pairs( self.params.entities ) do
            self.targets[ entity ] = true
        end
    end,
    
    -- -------------------------------------------------------------------------------- 
    -- For each objective of the skill, try to remove it. 
    -- --------------------------------------------------------------------------------
    activate = function( self )
        for entity in pairs( self.targets ) do
            Activate( skill.nodes.removeElement, entity:removalPriority(), 
                { entity = entity, positions = self.params.positions, avoidObstacles = self.params.avoidObstacles } )
        end
    end
}
-- **************************************************************************** 
-- remove removable element using MoveAndTakePosition skills
-- self.params.entity: the removable element
-- self.params.positions: the removing elements
-- ****************************************************************************
node "removeElement"
{
    connections = { skill.links.moveAndTakePosition, skill.nodes.Remove, skill.nodes.Demine,
                    skill.links.observe },

    feedbacks = { "cancelled" },

    done = function( self, params, additionalParams )  -- feedback from moveAndTakePosition
        self.arrived = true
    end, 
    
    failed = function( self, params, additionalParams )
       Feedback( self.feedbacks.failed, { element = additionalParams.element } )
    end,

    create = function( self )
        self.eTypeIti = eTypeItiDeminage
        if self.params.avoidObstacles then
            self.eTypeIti = eTypeItiMouvement
        end
        self.arrived = false
    end,

    -- -------------------------------------------------------------------------------- 
    -- Move toward a removing element and remove the entity
    -- --------------------------------------------------------------------------------
    activate = function( self )
        local cancelOrder = integration.query.getFirstFragOrderFromType( "Rep_OrderConduite_Pion_AbandonnerTravaux" )
        if cancelOrder then
            Feedback( self.feedbacks.cancelled, {element = self.params.entity} )
            return
        end

        if self.params.entity:isRemoved() then
            Feedback( self.feedbacks.done, { element = self.params.entity} )
            return
        end

        Activate( skill.links.observe, 1, { entity = self.params.entity } )

        if self.arrived then
            if self.params.entity:isMined() then
                if self.params.entity:canDemineIt() then
                  Activate( skill.nodes.Demine, 1, { entity = self.params.entity } )
                else
                  Feedback( self.feedbacks.failed, {element = self.params.entity} )
                end
            elseif self.params.entity:canRemoveIt() then
                Activate( skill.nodes.Remove, 1, { entity = self.params.entity } )
            else
                Feedback( self.feedbacks.failed, {element = self.params.entity} )
            end
        end

        -- Moving toward a removing position
        for _, position in pairs( self.params.positions )  do
            Activate( skill.links.moveAndTakePosition, 
                position:removalEfficiency( self.params.entity ),
                                { entity = position, pathType = self.eTypeIti } )
        end
        self.arrived = false
    end,
}
-- **************************************************************************** 
-- Demine action on the removable element 
-- ****************************************************************************
node "Demine"
{
    feedbacks = { "done" };
    
    acquire = { [ skill.resources.buildCapacity ] = 1 };

    select = function( self )
        if not self.params.entity:demineIt() then
            Feedback( self.feedbacks.failed,{ element = self.params.entity } )
        end
    end
}

-- **************************************************************************** 
-- Remove action on the removable element 
-- ****************************************************************************
node "Remove"
{
    feedbacks = { "done" };
    
    acquire = { [ skill.resources.buildCapacity ] = 1 };

    select = function( self )
        if not self.params.entity:removeIt() then
            Feedback( self.feedbacks.failed,{ element = self.params.entity } )
        end
    end
}