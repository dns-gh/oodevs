local echelonString = {}
echelonString[ eEtatEchelon_First ] = "eEtatEchelon_Premier"
echelonString[ eEtatEchelon_Second ] = "eEtatEchelon_Second"
echelonString[ eEtatEchelon_Scout ] = "eEtatEchelon_Eclairage"

-- **************************************************************************** 
-- Default CR skill
-- ****************************************************************************
rootnode
{
    connections = 
    { 
        skill.nodes.DecisionalState, 
        skill.nodes.ChangeEtatRapportDeForce,
        skill.nodes.ChangeEtatOperationnel,
        skill.links.dismount,
        skill.links.moveTo,
        skill.nodes.RC,
        skill.nodes.UnloadCrowd,
        skill.nodes.UnloadQueue
    },

    done = function( self, params, additionalParams ) -- skill moveTo
        self.isMoving = false
    end,

    activate = function( self )
        local Activate = Activate

        -- Debarquement sur magic move
        if integration.shouldDismount() then
            Activate( skill.links.dismount, 1 )
        end

        -- Alert NBC
        if meKnowledge:isContaminated() or meKnowledge:isPoisoned() then
            meKnowledge:alertNBC()
        end

        if meKnowledge:isUnderIndirectFire() and not self.isMoving then
            if not self.isMoving then
                self.direction = sword.military.queries.miscellaneous.getMissionDirection[ "execute" ]()
                if meKnowledge:isParked() then
                    self.positionSurete = meKnowledge:getPosition()
                elseif( self.direction[1] ~= nil ) then
                    self.positionSurete = DEC_Geometrie_PositionTranslateDir( meKnowledge:getPosition(), self.direction[1].source, -1100 )
                else
                    self.positionSurete = DEC_Geometrie_PositionTranslateDir( meKnowledge:getPosition(), DEC_Agent_Direction(), -1100 )
                end
             self.isMoving = true
             end
        end
        if self.positionSurete and integration.isAgentNeutralized() then
            Activate( skill.links.moveTo, 10, { entities = {CreateKnowledge( integration.ontology.types.point, self.positionSurete )} } )
        end
        
        -- Brouillage
        if meKnowledge:isJammed() then
            Activate( skill.nodes.RC, 1, { RC = eRC_Jammed } )
        end
        -- Brouillage du PC
        if meKnowledge:isPCJammed() then
            Activate( skill.nodes.RC, 1, { RC = eRC_PCJammed } )
        end

        -- Transport
        if DEC_Agent_EstTransporte() then -- $$$ MIA TODO Virer fonction DEC, mettre isNeutraized sur le body
            Activate( skill.nodes.RC, 1, { RC = eRC_TransportEnCours } )
        end

        -- Etat décisionnel sur les echelons
        local etat = meKnowledge:getEchelon()
        Activate( skill.nodes.DecisionalState, 1, { category = "Echelon", value = echelonString[ etat ] or "eEtatEchelon_None" } )

        -- CR sur le rapport de force 
        if meKnowledge:hasBadForceRatio() then
            Activate( skill.nodes.DecisionalState, 1, { category = "Contact", value = "eEtatDec_Sauvegarde" } )
            Activate( skill.nodes.ChangeEtatRapportDeForce, 1, { value = eForceRatioStateUnfavorable } )
            F_Pion_SeteEtatDec ( meKnowledge.source, eEtatDec_Sauvegarde )
        else -- favorable ou neutre
            Activate( skill.nodes.DecisionalState, 1, { category = "Contact", value = "eEtatDec_Continu" } )
            Activate( skill.nodes.ChangeEtatRapportDeForce, 1, { value = eForceRatioStateFavorable } )
            F_Pion_SeteEtatDec ( meKnowledge.source, eEtatDec_Continu ) -- pour l'automate
        end

        -- Etat décisionnel sur la destruction
        if meKnowledge:isDestroyed() then
            Activate( skill.nodes.ChangeEtatOperationnel, 1, { value = 0 } ) -- $$$ MIA TODO trouver l'enum!
        elseif not meKnowledge:isOperational() then
            Activate( skill.nodes.ChangeEtatOperationnel, 1, { value = 1 } ) -- $$$ MIA TODO trouver l'enum!
        else -- operational
            Activate( skill.nodes.ChangeEtatOperationnel, 1, { value = 2 } ) -- $$$ MIA TODO trouver l'enum!
        end
        
        -- Comportement par défaut pour le transport de pion et de foule
        if meKnowledge.isStoppingTransport then
            meKnowledge.isStoppingTransport = false
            local pos = CreateKnowledge( sword.military.world.Point, meKnowledge:getPosition() )
            Activate( skill.links.moveTo, 1, {entities = { pos } } )
            if DEC_Transport_EnCoursDeTransport() then
                Activate( skill.nodes.UnloadQueue, 1, emptyTable )
            elseif meKnowledge.transportedCrowd and DEC_Agent_TransporteFoule( meKnowledge.source ) then
                local pos = CreateKnowledge( sword.military.world.Point, meKnowledge:getPosition() )
                Activate( skill.nodes.UnloadCrowd, 1, { crowd = meKnowledge.transportedCrowd, position = pos } )
            end
        end
    end
}

-- **************************************************************************** 
-- Affiche l'état décisionnel 
-- **************************************************************************** 
node "DecisionalState"
{
    create = function( self )
        DEC_DecisionalState( self.params.category, self.params.value )
    end
}
node "ChangeEtatRapportDeForce"
{
    create = function( self )
       DEC_Agent_ChangeEtatRapportDeForce( self.params.value )
    end
} 
node "ChangeEtatOperationnel"
{
    create = function( self )
        DEC_Agent_ChangeEtatOperationnel( self.params.value )
    end
}
node "RC"
{
    create = function( self )
        meKnowledge:RC( self.params.RC )
    end
}
node "UnloadCrowd"
{
    select = function( self )
        meKnowledge.isStoppingTransport = true
        self.params.crowd:unloadIt( self.params.position )
    end,
}
node "UnloadQueue"
{
    select = function( self )
        meKnowledge.isStoppingTransport = true
        meKnowledge:dropTroups()
    end,
}