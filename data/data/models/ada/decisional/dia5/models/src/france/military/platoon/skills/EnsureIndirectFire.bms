-------------------------------------------------------------------------------
-- Skill EnsureIndirectFire
-- @author MGD
-- @created 2010-06-02
--
-- This file is part of a MASA library or program.
-- Refer to the included end-user license agreement for restrictions.
--
-- Copyright (c) 2010 Mathématiques Appliquées SA (MASA)
-------------------------------------------------------------------------------

rootnode
{
    connections = { skill.links.deploy, skill.links.indirectFire, skill.nodes.CR_ReceiveFireOrder,
                    skill.nodes.CR_NotDeployedIndirectFireImpossible, skill.nodes.CR_ReadyToFire };
   
    feedbacks = { "done" };
   
    done = function( self, params, additionnalParams )
        if additionnalParams.state == "hasFire" then
            self.hasFire = true
            self.order = nil
            self.nextTargetIndex = self.nextTargetIndex + 1
            if self.nextTargetIndex > #self.params.firePositions and self.params.retreatPosition == NIL then
                self.nextTargetIndex = 1
            elseif self.nextTargetIndex > #self.params.firePositions + 1 and self.params.retreatPosition ~= NIL then
                self.nextTargetIndex = #self.params.firePositions + 1
            end
            if self.nextTargetIndex <= #self.params.firePositions and #self.params.firePositions >= 2 then
                meKnowledge:RC( eRC_ChangementDePosition )
            end
        elseif additionnalParams.state == "no ammo" or
               additionnalParams.state == "forbidden ammo" or
               additionnalParams.state == "out of range" or
               additionnalParams.state == "impossible to fire" or
               additionnalParams.state == "no Launcher" or
               additionnalParams.state == "target not illuminated" then
            self.order = nil
        else
            if self.params.retreatPosition ~= NIL then
                if additionnalParams.element == self.params.retreatPosition then
                    Feedback( self.feedbacks.done)
                end
            end
        end
    end,
    
    create = function( self )
        self.hasFire = false
        self.order = nil
        self.positions = {}
        self.nextTargetIndex = 1
        self.waitOrder = false
    end,
    
    activate = function( self )
        local Activate = Activate
        
        if self.params.firePositions == NIL then
            self.waitOrder = true
        end
        if self.hasFire and self.nextTargetIndex > #self.params.firePositions and self.params.retreatPosition ~= NIL then
            Activate( skill.links.deploy, 1, { objective = self.params.retreatPosition } )
        else
            self.waitOrder = true
            Activate( skill.links.deploy, 1, { objective = self.params.firePositions[ self.nextTargetIndex ] } )
        end        
        
        if self.waitOrder then
            if not self.order then
                self.order = integration.query.getFirstFireOrder()
            end
            if meKnowledge:isDeployed() then --or self.params.canReceiveUnexpectedOrder then
                integration.sendfireAvailable(true)
                Activate( skill.nodes.CR_ReadyToFire, 1 )
                if self.order then
                    Activate( skill.nodes.CR_ReceiveFireOrder, 1 )
                    Activate( skill.links.indirectFire, 1, self.order )
                end
            else
                integration.sendfireAvailable(false)
                if self.order then
                  Activate( skill.nodes.CR_NotDeployedIndirectFireImpossible, 1 )
                end
            end
        end
    end,
  
    destroy = function( self )
      integration.sendfireAvailable(false)
    end
}

node "CR_ReceiveFireOrder"
{ 
    create = function( self )
        meKnowledge:RC( eRC_ReceptionOrdreDeFeu )
    end
}

node "CR_ReadyToFire"
{ 
    create = function( self )
        meKnowledge:RC( eRC_PretPourConduiteTir )
    end
}


node "CR_NotDeployedIndirectFireImpossible"
{
    create = function( self )
        meKnowledge:RC( eRC_NotDeployedIndirectFireImpossible )
    end
}
