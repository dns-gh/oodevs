-------------------------------------------------------------------------------
-- Skill EnsureIndirectFire
-- @author MGD
-- @created 2010-06-02
--
-- This file is part of a MASA library or program.
-- Refer to the included end-user license agreement for restrictions.
--
-- Copyright (c) 2010 Mathématiques Appliquées SA (MASA)
-------------------------------------------------------------------------------

rootnode
{
    connections = { skill.links.deploy, skill.links.indirectFire, skill.nodes.CR };
   
    feedbacks = { "done" };
   
    done = function( self, params, additionnalParams )
        if additionnalParams.state == "hasFire" or
           additionnalParams.state == "no ammo" or
           additionnalParams.state == "forbidden ammo" or
           additionnalParams.state == "out of range" or
           additionnalParams.state == "impossible to fire" or
           additionnalParams.state == "no Launcher" or
           additionnalParams.state == "target not illuminated" then
              self.order = nil
              if self.params.changeAutomatically then
                  self.nextTargetIndex = self.nextTargetIndex + 1
                  if self.nextTargetIndex > #self.params.firePositions then
                     self.nextTargetIndex = 1
                  end
              end
        end
    end,
    
    create = function( self )
        self.order = nil
        self.positions = {}
        self.nextTargetIndex = 1
        self.waitOrder = false
        self.neutralized = false
    end,
    
    activate = function( self )
        local Activate = Activate
        
        if integration.isAgentNeutralized() then
            integration.sendfireAvailable(false)
            self.neutralized = true
            Activate( skill.nodes.CR, 1, {RC = eRC_AgentNeutralizedIndirectFireImpossible } )
        else
            self.neutralized = false
        end
         
        if self.params.firePositions == NIL then
            self.waitOrder = true
        end

        self.waitOrder = true
        Activate( skill.links.deploy, 1, { objective = self.params.firePositions[ self.nextTargetIndex ] } )
        if self.waitOrder then
            if not self.order then
                self.order = integration.query.getFirstFireOrder()
            end
            if meKnowledge:isDeployed() and not self.neutralized then
                integration.sendfireAvailable(true)
                Activate( skill.nodes.CR, 1, {RC = eRC_PretPourConduiteTir} )
                if self.params.callByFragOrder then
                      Feedback( self.feedbacks.done )
                end
                if self.order then
                    Activate( skill.nodes.CR, 1, {RC = eRC_ReceptionOrdreDeFeu} )
                    Activate( skill.links.indirectFire, 1, self.order )
                end
            else
                integration.sendfireAvailable(false)
                if self.order then
                  Activate( skill.nodes.CR, 1, {RC = eRC_NotDeployedIndirectFireImpossible} )
                end
            end
        end
    end,
  
    destroy = function( self )
        integration.sendfireAvailable(false)
        meKnowledge:sendConstructedObjectInitialized( integration.GetSuperiorKnowledge( meKnowledge) )
    end
}

-- **************************************************************************** 
-- CR
-- ****************************************************************************
node "CR"
{
    create = function( self )
        meKnowledge:RC( self.params.RC )
    end
}