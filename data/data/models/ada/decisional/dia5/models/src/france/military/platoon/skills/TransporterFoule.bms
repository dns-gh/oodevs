-- **************************************************************************** 
-- TransportCrowd.
-- self.params.crowd: crowd to transport
-- self.params.loadingPoint: loading area
-- self.params.destination: destination where 
-- ****************************************************************************
rootnode
{
    connections = {
        skill.links.moveToward,
        skill.nodes.LoadCrowd,
        skill.nodes.UnloadCrowd
        },

    -- unite arrivee a destination
    done = function( self, params, additionalParams )
        if additionalParams.element == self.params.destination then
            self.arrivedDestination = true
        else
            self.arrivedLoadPoint = true
        end
    end,

    loaded = function( self )
        -- après le chargement, se diriger vers la destination
        self.loadFinished = true
        self.position = self.params.destination
        if not meKnowledge:isTransportingCrowd() then
            Feedback( self.feedbacks.done )
        end
        self.roundTrip = self.roundTrip + 1
        -- take care of agents hidden in crowd
        local hiddenUnits = self.params.crowd:getHiddenUnits()
        for _, agent in pairs( hiddenUnits ) do
            if not exists( self.alreadyTransportedAgents, agent ) then
                self.loadedAgents[ #self.loadedAgents + 1 ] = agent
            end
        end
        meKnowledge:loadElements( self.loadedAgents )
    end,

    unloaded = function( self )
        -- après le déchargement, se diriger vers la position d'embarquement
        self.unloadFinished = true
        self.position = self.positionInit
        meKnowledge:unloadElements( self.loadedAgents )
        self.alreadyTransportedAgents = fusionList( self.alreadyTransportedAgents, self.loadedAgents )
        self.loadedAgents = {}
    end,

    -- init
    create = function( self )
        self.numberOfRoundTrip = 0
        self.roundTrip = 1
        meKnowledge.isStoppingTransport = false
        -- init crowd's concentration information
        integration.lockCrowdKnowledge( self.params.crowd )
        meKnowledge.transportedCrowd = self.params.crowd
        self.concentration = integration.getNearbyConcentration( meKnowledge.transportedCrowd, self.params.loadingPoint )
        self.position = integration.getPositionConcentration( meKnowledge.transportedCrowd, self.concentration )
        self.positionInit = self.position
        
        self.arrivedLoadPoint = false
        self.arrivedDestination = false
        self.loadFinished = false
        self.unloadFinished = false
        --compute and display the number of round trip
        self.numberOfRoundTrip = math.ceil( meKnowledge:transportCrowdRoundTrip( meKnowledge.transportedCrowd ) )
        self.alreadyTransportedAgents = {} -- for hidden units transportation
        self.loadedAgents = {} -- for hidden units transportation
    end,

    activate = function( self )
        local Activate = Activate

        if self.concentration == 0 then
            Feedback( self.feedbacks.done )
            return
        end

        if not meKnowledge:canTransportCrowd() then
            meKnowledge:RC( eRC_TransportImpossiblePasDeMoyens )
            Feedback( self.feedbacks.done )
        end

        -- Detect agents no more hidden in crowd
        local hiddenUnits = self.params.crowd:getHiddenUnits()
        for i, agent in pairs( self.alreadyTransportedAgents ) do
            if not exists( hiddenUnits, agent ) then
                self.alreadyTransportedAgents[ i ] = nil
            end
        end

        -- deplacement
        Activate( skill.links.moveToward, 1, { entities = { self.position } } )

        if self.arrivedDestination and not self.unloadFinished then
            -- Unload Crowd
            Activate( skill.nodes.UnloadCrowd, 1, { crowd = meKnowledge.transportedCrowd, position = self.position } )
        end
 
        if self.arrivedLoadPoint and not self.loadFinished then
            -- Load Crowd
            Activate( skill.nodes.LoadCrowd, 1, { crowd = meKnowledge.transportedCrowd, concentration = self.concentration, roundTrip = self.numberOfRoundTrip, currentRoundTrip = self.roundTrip } )
        end

        if self.unloadFinished then
            local concentration = integration.getNearbyConcentration( meKnowledge.transportedCrowd, self.params.loadingPoint )
            if concentration == 0 or concentration ~= self.concentration then
                Feedback( self.feedbacks.done )
            end
           
        end
        
        self.loadFinished = false
        self.unloadFinished = false
        self.arrivedLoadPoint = false
        self.arrivedDestination = false
    end,
    
    destroy = function( self )
        integration.unlockCrowdKnowledge( self.params.crowd )
        meKnowledge.isStoppingTransport = true
    end,

}

node "LoadCrowd"
{

    connections = { skill.nodes.ReportsWithParameters },
        
    feedbacks = { "loaded" },

    acquire = { [ skill.resources.loadcapacity ] = 1 },
    
    create = function( self )
        Activate( skill.nodes.ReportsWithParameters, 1, { RC = eRC_TransportRoundTrip, roundTrip = self.params.roundTrip, current = self.params.currentRoundTrip } )
    end,

    select = function( self )
        if self.params.crowd:loadIt( self.params.concentration ) then
            Feedback( self.feedbacks.loaded )
        end
    end,
}

node "UnloadCrowd"
{
    feedbacks = { "unloaded" },
    
    acquire = { [ skill.resources.loadcapacity ] = 1 },
    
    select = function( self )
        if self.params.crowd:unloadIt( self.params.position ) then
            Feedback( self.feedbacks.unloaded )
        end
    end,
}

node "ReportsWithParameters"
{
    create = function( self )
        meKnowledge:RC( self.params.RC, self.params.current , self.params.roundTrip )
    end,
}

