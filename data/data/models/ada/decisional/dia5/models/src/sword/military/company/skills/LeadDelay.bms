-------------------------------------------------------------------------------
-- SequentialLead
-- @author DDA
-- @created 2011-11-06
--
-- This file is part of a MASA library or program.
-- Refer to the included end-user license agreement for restrictions.
--
-- Copyright (c) 2010 MASA Group
-------------------------------------------------------------------------------

-- set echelon for elements in bestUnits
-- @params bestUnits : list of element
-- @params echelon
-- @author LMT
-- @release 2011-01-13
local function setEchelon ( bestUnits, echelon )
    for _, elem in pairs (bestUnits) do
        F_Pion_SeteEtatEchelon( elem.entity.source, echelon )
    end
end

-- Find which unit will do the task
-- @params self
-- @params tasks : a list of platoon taks*
-- @params nbrFront : how many platoon can take this task
-- @params echelon : echelon number
-- @author LMT
-- @release 2011-01-13
local function giveMission ( self, tasks, nbrFront, echelon, entities )
    local tasks = explode( ";", tasks )
    entities = entities or self.entitiesWithoutMission
    local bestUnits = findBests( entities, tasks, self.companyTask, self.parameters, nbrFront )
    self.entitiesWithoutMission = removeFromListForLead( bestUnits, self.entitiesWithoutMission )
    setEchelon( bestUnits, echelon )

    for _, elem in pairs( bestUnits ) do
        meKnowledge:sendTaskToPion( elem.entity, elem.taskName, elem.params, echelon )
    end
    
    return bestUnits
end

local function giveSupport( self, tasks, nbrFront, echelon, entities )
    local tasks = explode( ";", tasks )
    entities = entities or self.entitiesWithoutMission
    local bestUnits = findBests( entities, tasks, self.companyTask, self.parameters, nbrFront, true )
    self.entitiesWithoutMission = removeFromListForLead( bestUnits, self.entitiesWithoutMission )
    setEchelon( bestUnits, echelon )
    return bestUnits
end
-- Listen front element  in order to manage automat feedback
-- @params frontElement : realize the main effect
-- @author LMT
-- @release 2011-01-14
local function manageFeedback ( frontElement )
    for _, elem in pairs (frontElement) do
      integration.ListenFrontElement( elem.entity )
    end
end

local function manageAddedAndDeletedUnits( self )
    local redone = false
    local DEC_HasMission = DEC_HasMission
    local oldEntities = self.parameters.commandingEntities
    local newEntities = integration.getEntitiesFromAutomatCommunication( meKnowledge, "none", true )
    local newOperationnalEntities = integration.getOperationnalEntitiesFromAutomat( meKnowledge, "none", true )

    -- Si un pion a été supprimé de l'automate, on redistribue les missions
    for i, entity in pairs( oldEntities ) do
        if not exists( newEntities, entity ) then
             self:create()
             redone = true
             break
        end
    end

    -- Si un pion est de nouveau operationnel et/ou un pion a été ajouté à l'automate
   if #newOperationnalEntities > #self.operationnalEntities and not redone then
        for i, entity in pairs( newOperationnalEntities ) do
            if not exists( self.operationnalEntities, entity ) then
                local tasksForNewEntity = ""
                if myself.taskParams.echelonNumber == 1 then
                      tasksForNewEntity = self.params.mainTasks..";"..self.params.supportTasks..";"..self.params.defaultTask
                      giveMission ( self, tasksForNewEntity, 1, eEtatEchelon_First, { entity } )
                else
                      tasksForNewEntity = self.params.supportTasks..";"..self.params.defaultTask
                      giveMission ( self, tasksForNewEntity, 1, eEtatEchelon_Second, { entity } )
                end
            end
        end
    end

    self.operationnalEntities = newOperationnalEntities -- on enregistre la liste pour le tic suivant
    self.parameters.commandingEntities = newEntities
end

local function managePositionsToScreen( self )
    -- Pour la mission jalonner on force le décrochage juste devant la LCAR ou sur la position de l'unité ayant la mission jalonner la plus loin du début du fuseau
    if self.params.companyTask == "france.military.company.tasks.Jalonner" then
            self.screenPosition  = true
    end	
end

rootnode {

connections = { skill.links.manageFragOrder, skill.links.coordinationManager, skill.nodes.RC, skill.links.AssignSETask },

    done = function( self ) end,

create = function( self )
        myself.stopFrago = false
        integration.initializeListenFrontElement()
        local Activate = Activate
        self.parameters = myself.taskParams
        self.parameters.commandingEntities = integration.getEntitiesFromAutomatCommunication( meKnowledge, "none", true )
        self.operationnalEntities = integration.getOperationnalEntitiesFromAutomat( meKnowledge, "none", true )

        -- Initialisation
        myself.leadData = {}
        self.progressionInAOR = {}

        self.entitiesWithoutMission = copyTable( self.parameters.commandingEntities )
        self.companyTask = integration.RetrieveAutomateTask( meKnowledge, self.params.companyTask )
   
         -- Initialisation
        self.nbrFront = self.companyTask:getNbrFront()
        meKnowledge.nbPionsScout = integration.reconPlatoons( self.parameters.commandingEntities )
        meKnowledge.nbPionsMain = integration.nbPlatoonsHaveTask( self.parameters.commandingEntities, self.params.mainTasks )
        
        self.companyTask:init( self.params )
        self.pionsLimaTmp = {}
        self.decrocher = false
        
        meKnowledge.pionsToAwait = {}
        self.sendSupport = true
        self.screenPosition  = false

        self.progressionInAOR = {}
        if self.nbrFront == 0 then
            self.nbrFront = #self.parameters.commandingEntities
        end
        
        for _, unit in pairs( self.parameters.commandingEntities ) do
          unit:setHasMission(false)
        end

        -- Initialisation des missions pion

        -- S'il y a des obstacles à construire, les pions GEN (ou PIA) vont le construire
        giveMission ( self, self.params.engineerTask,  #self.companyTask:getObstaclesPlan( self.parameters ), eEtatEchelon_None )

        -- Le pion PC rejoint le meetingPoint
        if self.params.pcTasks and self.params.pcTasks ~= NIL and self.params.pcObjective and self.params.pcObjective ~= NIL then
            self.parameters.pcObjective = self.params.pcObjective
            giveMission ( self, self.params.pcTasks, 1, eEtatEchelon_None, { integration.query.getPCUnit() })
        end
        
        -- Les pions PEI
        if self.params.peiTasks and self.params.peiTasks ~= NIL and self.params.peiTasks ~= "none" then
            giveMission ( self, self.params.peiTasks, meKnowledge.nbPionsScout, eEtatEchelon_Scout )
        end

        -- Le premier echelon recoit les missions principales ("mainTasks")
        local bestUnits = giveMission ( self, self.params.mainTasks, self.nbrFront, eEtatEchelon_First)
        if #bestUnits == 0 then
            Activate( skill.nodes.RC, 1, { RC = eRC_NoPEInAutomat } )
            return
        end
        manageFeedback( bestUnits )
        -- Le second echelon recoit les missions de soutien
        giveSupport ( self, self.params.supportTasks, #self.entitiesWithoutMission, eEtatEchelon_Reserve )

        -- Ceux qui n'ont toujours pas de mission recoivent la mission par défaut
        giveMission ( self, self.params.defaultTask, #self.entitiesWithoutMission, eEtatEchelon_None )

        -- Pour la mission jalonner on force le décrochage juste devant la LCAR si elle est présente
        managePositionsToScreen( self )		
    end,

 activate = function( self )  
      manageAddedAndDeletedUnits( self )
    
        -- Mis à jour des echelons
      integration.setPionsEchelons( myself.leadData.pionsLima1, eEtatEchelon_First )
      integration.setPionsEchelons( myself.leadData.pionsLima2, eEtatEchelon_Second )
      
      -- Changement d'échelons lorsque l'ordre de conduite Decrocher a été donné et que tous le deuxième échelon est en place, prêt à appuyer
      if self.decrocher and not next( meKnowledge.pionsToAwait ) then
        if next(myself.leadData.pionsLima2) ~= nil then
          self.pionsLimaTmp = copyTable( myself.leadData.pionsLima1 )
          myself.leadData.pionsLima1 = copyTable( myself.leadData.pionsLima2 )
          myself.leadData.pionsLima2 = copyTable( self.pionsLimaTmp )
        end
        self.sendSupport = true
        self.decrocher = false
        return 
      end

      -- L'automate donne l'ordre de conduite Decrocher à tout le premier echelon si au moins 1 pion du premier échelon est en danger
      -- Decrocher comporte l'embarquement du premier echelon et le débarquement à l'arrivée 
      if ( not self.decrocher and meKnowledge:hasPionsInDanger( myself.leadData.pionsLima1 ) ) or self.screenPosition then
        local fragOrder = CreateFragOrder("Rep_OrderConduite_Decrocher")
        local fragOrderKn = CreateKnowledge( sword.military.world.FragOrder, fragOrder )

        meKnowledge.pionsToAwait = copyTable( myself.leadData.pionsLima1 )

        Activate( skill.links.manageFragOrder, 1, { fragOrders = { fragOrderKn } , entities = myself.leadData.pionsLima1 } )

        self.decrocher = true
        self.screenPosition = false
      end
      local echelons = integration.getPionsInEchelons( self.parameters.commandingEntities )

       -- Gestion de l'appui: les pions d'appui, appuient toujours le premier échelon  
      local tableObjectives = {}
      if not next( tableObjectives ) then
          tableObjectives = echelons[1]
      else
          for _, entity in pairs( myself.leadData.pionsLima1 ) do
              tableObjectives[ #tableObjectives + 1 ] = entity
          end
      end
      
      if self.sendSupport then
        local tasksForSupporting = explode( ";", self.params.taskForSupporting ) 
        for _, supportingEntity in pairs( echelons[4] ) do
            for _, taskForSupporting in pairs( tasksForSupporting ) do
                if integration.RetrievePionTask( supportingEntity, taskForSupporting ) then
                    meKnowledge:sendTaskToPion( supportingEntity , taskForSupporting , { objectives = tableObjectives, marcheRetrograde = true } , eEtatEchelon_Reserve )  
                end
            end
        end
        self.sendSupport = false
      end
     
         
      -- Coordination intra echelon
      -- tous les pions sont projeté sur un des deux fuseaux de l'automate
      -- self.progressionInAOR: contient les valeurs de progression sur l'axe de progression
      -- plus la valeur est grande, plus le pion est en avant dans le fuseau
      local proj
      for _, entity in pairs( self.parameters.commandingEntities ) do
          proj = DEC_Geometrie_AdvanceAlongFuseau( entity.source ) 
          self.progressionInAOR[ entity ] = proj
      end

      local fuseau = meKnowledge:getFuseau()

      largeurFuseau = fuseau:getWidth()

      Activate( skill.links.coordinationManager , 1, { enititesFromEchelon = myself.leadData.pionsLima1, progressionInAOR = self.progressionInAOR, distance = largeurFuseau/2 } )

      -- Gestion du SE (car les objectifs ne sont plus les mêmes)
      local tasksForSE = self.params.supportTasks..";"..self.params.defaultTask
      Activate( skill.links.AssignSETask, 1, { SE = pionsSE, tasks = tasksForSE, parameters = self.parameters, companyTask = self.companyTask })
      if not myself.stopFrago and not next(integration.getPionsInEchelons( self.parameters.commandingEntities )[1]) then
        Activate( skill.nodes.RC, 1, { RC = eRC_NoPEInAutomat } )
      end
    end,

}

node "RC"
{
    create = function( self )
        meKnowledge:RC( self.params.RC )
    end,
}




