rootnode {

connections = { skill.links.issueTaskGeneral },

    done = function( self ) end,

create = function( self )
  self.supportList = copyTable( self.params.SE )
  self.supportedList = {}
  self.linkSupportSupported = {}
  self.inSupport = {}
  self.pionsToHelp = {}
  self.bestSupportDotationCumule = 0
end,

activate = function( self )
  local Activate = Activate
  local unitsCanSupport = {}
  local bestDistance = math.huge
  local bestSupport = nil
  local bestIndex = nil
  local bestTask = nil
  self.bestSupportDotation = 0
  -- Demander à tous les pions s’ils sont en difficulté
  self.pionsToHelp = fusionList(self.params.PE, self.inSupport )
  for _, pion in pairs ( self.pionsToHelp ) do
      if pion.source.stopNeedReinforcement then
            local support = self.linkSupportSupported [pion]
            if support then
                support.source.reinforceGivenByUser = false
                self.supportList[#self.supportList + 1 ] = support
                self.supportedList = removeFromList( pion, self.supportedList )
                self.linkSupportSupported[pion] = nil
                self.inSupport = removeFromList( support, self.inSupport )
            end
            pion.source.stopNeedReinforcement = false
       end
       local position = pion:getMyPosition()
       -- Trouver un bon pion pour appuyer le pion en difficulté
       if not exists( self.supportedList, pion ) then
            repeat
               stopBoucle = true
               if pion.source.needReinforcementForCapacity then
                  local unitsAbleToReinforce = integration.unitsAbleToReinforce( pion, self.supportList, pion.source.needReinforcementForCapacity, pion.source.needReinforcementForAction )
                  for i=1, #unitsAbleToReinforce do
                     unitsCanSupport[#unitsCanSupport + 1] = CreateKnowledge( sword.military.world.PlatoonAlly, unitsAbleToReinforce[i] )
                  end
                else
                    for i=1, #self.supportList do -- SE qui ne supporte pas déja
                      if( pion.source.needReinforcementForDotation and integration.nombreDotationAgent( self.supportList[i], pion.source.needReinforcementForDotation ) > 0 ) then
                         unitsCanSupport[#unitsCanSupport + 1] = self.supportList[i]
                      end
                    end
                 end
                 for i=1, #unitsCanSupport do
                    local support = unitsCanSupport[i]
                    local distance = integration.distance( position, support:getMyPosition() )
                    local task = integration.RetrievePionTask( support, self.params.taskForSupporting )
                    local dotationAgent = -1
                    if pion.source.needReinforcementForDotation then
                        dotationAgent = integration.nombreDotationAgent( support, pion.source.needReinforcementForDotation )
                    end
                     if task and distance < bestDistance and support.source:DEC_Agent_EtatOpsMajeur() > 0 and ( dotationAgent == -1 or dotationAgent > self.bestSupportDotation) then
                        bestSupport = support
                        bestDistance = distance
                        bestTask = task
                        self.bestSupportDotation = integration.nombreDotationAgent( bestSupport, pion.source.needReinforcementForDotation )
                    end
                end
                if bestSupport then
                    bestSupport.params = bestTask:fillParameters( self.params.companyTask, self.params.parameters, bestSupport, 0, pion )
                    self.supportList = removeFromList( bestSupport, self.supportList )
                    self.supportedList [#self.supportedList + 1] = pion
                    self.linkSupportSupported[pion] = bestSupport
                    self.inSupport[#self.inSupport + 1] = bestSupport
                    self.bestSupportDotationCumule = self.bestSupportDotationCumule + self.bestSupportDotation
                    Activate( skill.links.issueTaskGeneral, 1, { entities = { bestSupport }, taskName = self.params.taskForSupporting, objectives = bestSupport.params, echelon = F_Pion_GeteEtatEchelon( bestSupport.source ) } )
                    if  pion.source.needReinforcementForNumberMissing and #unitsCanSupport > 2 and self.bestSupportDotationCumule < (pion.source.needReinforcementForNumberMissing - integration.nombreDotationAgent( pion, pion.source.needReinforcementForDotation )) then
                        self.supportList = removeFromList( bestSupport, self.supportList )
                        bestDistance = math.huge
                        unitsCanSupport = {}
                        bestSupport = nil
                        bestIndex = nil
                        bestTask = nil
                        self.bestSupportDotation = 0
                        stopBoucle = false
                    end
                end
             until stopBoucle
        end
    end
end
}
