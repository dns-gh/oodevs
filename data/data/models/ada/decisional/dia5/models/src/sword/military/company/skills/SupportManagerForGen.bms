rootnode {

connections = { skill.links.issueTaskGeneral },

    done = function( self ) end,

create = function( self )
  self.supportList = copyTable( self.params.SE )
  self.linkSupportSupported = {}
  self.inSupport = {}
  self.pionsToHelp = {}
  self.bestSupportDotationCumule = 0
  self.supportedListForMineOrDemine = {}
  self.supportedListForBuildOrDestroy = {}
end,

activate = function( self )
  local Activate = Activate
  local unitsCanSupport = {}
  local bestDistance = math.huge
  local bestSupport = nil
  local bestTask = nil
  self.bestSupportDotation = 0
  -- Demander à tous les pions s’ils sont en difficulté
  self.pionsToHelp = fusionList(self.params.PE, self.inSupport )
  for _, pion in pairs ( self.pionsToHelp ) do
      if pion.source.stopNeedReinforcement then
          local support = self.linkSupportSupported [pion]
          if support then
              support.source.reinforceGivenByUser = false
              self.supportList[#self.supportList + 1 ] = support
              self.supportedListForMineOrDemine = removeFromList( pion, self.supportedListForMineOrDemine )
              self.supportedListForBuildOrDestroy = removeFromList( pion, self.supportedListForBuildOrDestroy )
              self.linkSupportSupported[pion] = nil
              self.inSupport = removeFromList( support, self.inSupport )
          end
          pion.source.stopNeedReinforcement = false
      end
      local position = pion:getMyPosition()
      -- Trouver un bon pion pour appuyer le pion en difficulté
      if ( not exists( self.supportedListForMineOrDemine, pion ) ) or ( not exists( self.supportedListForBuildOrDestroy, pion ) ) then
          repeat
              stopBoucle = true
              if pion.source.needReinforcementForCapacity ~= nil then
                  local unitsAbleToReinforce = integration.unitsAbleToReinforce( pion, self.supportList, pion.source.needReinforcementForCapacity, pion.source.needReinforcementForAction )
                  for i=1, #unitsAbleToReinforce do
                      unitsCanSupport[#unitsCanSupport + 1] = CreateKnowledge( sword.military.world.PlatoonAlly, unitsAbleToReinforce[i] )
                  end
              else
                  for i=1, #self.supportList do -- SE qui ne supporte pas déja
                      if( pion.source.needReinforcementForDotation ~= nil and integration.nombreDotationAgent( self.supportList[i], pion.source.needReinforcementForDotation ) > 0 ) then
                          unitsCanSupport[#unitsCanSupport + 1] = self.supportList[i]
                      end
                  end
              end
              for i=1, #unitsCanSupport do
                  local support = unitsCanSupport[i]
                  local distance = integration.distance( position, support:getMyPosition() )
                  local task = integration.RetrievePionTask( support, self.params.taskForSupporting )
                  local dotationAgent = -1
                  if pion.source.needReinforcementForDotation ~= nil then
                      dotationAgent = integration.nombreDotationAgent( support, pion.source.needReinforcementForDotation )
                  end
                  if task and distance < bestDistance and support.source:DEC_Agent_EtatOpsMajeur() > 0 and ( dotationAgent == -1 or dotationAgent > self.bestSupportDotation) then
                      bestSupport = support
                      bestDistance = distance
                      bestTask = task
                      self.bestSupportDotation = integration.nombreDotationAgent( bestSupport, pion.source.needReinforcementForDotation )
                  end
              end
              if bestSupport ~= nil then
                  bestSupport.params = bestTask:fillParameters( self.params.companyTask, self.params.parameters, bestSupport, 0, pion )
                  self.supportList = removeFromList( bestSupport, self.supportList )
                  if pion.source.needReinforcementForAction == "mine" or pion.source.needReinforcementForAction == "demine" then
                      self.supportedListForMineOrDemine [#self.supportedListForMineOrDemine + 1] = pion
                  else
                      self.supportedListForBuildOrDestroy [#self.supportedListForBuildOrDestroy + 1] = pion
                  end
                  self.linkSupportSupported[pion] = bestSupport
                  self.inSupport[#self.inSupport + 1] = bestSupport
                  self.bestSupportDotationCumule = self.bestSupportDotationCumule + self.bestSupportDotation
                  Activate( skill.links.issueTaskGeneral, 1, { entities = { bestSupport }, taskName = self.params.taskForSupporting, objectives = bestSupport.params, echelon = eEtatEchelon_Second } )
                  self.supportList = removeFromList( bestSupport, self.supportList )
                  bestDistance = math.huge
                  unitsCanSupport = {}
                  bestSupport = nil
                  bestTask = nil
                  if  pion.source.needReinforcementForNumberMissing and #unitsCanSupport < 2 and self.bestSupportDotationCumule < (pion.source.needReinforcementForNumberMissing - integration.nombreDotationAgent( pion, pion.source.needReinforcementForDotation )) then
                      self.bestSupportDotation = 0
                      stopBoucle = false
                  end
              end
          until stopBoucle
      end
  end
end
}
