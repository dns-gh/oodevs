rootnode {

connections = { skill.links.issueTaskGeneral },

    done = function( self ) end,

create = function( self )
  self.supportList = copyTable( self.params.SE )
  self.supportedList = {}
  self.linkSupportSupported = {}
end,

activate = function( self )
  local Activate = Activate
  local unitsCanSupport = {}
  local bestDistance = math.huge
  local bestSupport = nil
  local bestIndex = nil
  local bestTask = nil
  -- Demander à tous les pions s’ils sont en difficulté
  for _, pion in pairs ( self.params.PE ) do
       if pion.source.stopNeedReinforcement then
            local support = self.linkSupportSupported [pion]
            if support then
                self.supportList[#self.supportList + 1 ] = support
                self.supportedList = removeFromList( pion, self.supportedList )
                self.linkSupportSupported[pion] = nil
            end
            pion.source.stopNeedReinforcement = false
       end
       local position = pion:getMyPosition()
        -- Trouver un bon pion pour appuyer le pion en difficulté
        if not exists( self.supportedList, pion ) then
           if pion.source.needReinforcementForCapacity then
              local unitsAbleToReinforce = integration.unitsAbleToReinforce( pion, self.supportList, pion.source.needReinforcementForCapacity, pion.source.needReinforcementForAction )
              for i=1, #unitsAbleToReinforce do
                 unitsCanSupport[#unitsCanSupport + 1] = CreateKnowledge( sword.military.world.PlatoonAlly, unitsAbleToReinforce[i] )
              end
            else
                for i=1, #self.supportList do -- SE qui ne supporte pas déja
                  if( pion.source.needReinforcementForDotation and integration.nombreDotationAgent( self.supportList[i], pion.source.needReinforcementForDotation ) >= pion.source.needReinforcementForNumberMissing ) then
                      unitsCanSupport[#unitsCanSupport + 1] = self.supportList[i]
                  end
                end
             end
             for i=1, #unitsCanSupport do
                local support = unitsCanSupport[i]
                local distance = integration.distance( position, support:getMyPosition() )
                local task = integration.RetrievePionTask( support, self.params.taskForSupporting )
                if task and distance < bestDistance and support.source:DEC_Agent_EtatOpsMajeur() > 0 then
                    bestSupport = support
                    bestDistance = distance
                    bestTask = task
                end
            end
            if bestSupport then
                bestSupport.params = bestTask:fillParameters( self.params.companyTask, self.params.parameters, bestSupport, 0, pion )
                self.supportList = removeFromList( bestSupport, self.supportList )
                self.supportedList [#self.supportedList + 1] = pion
                self.linkSupportSupported[pion] = bestSupport
                Activate( skill.links.issueTaskGeneral, 1, { entities = { bestSupport }, taskName = self.params.taskForSupporting, objectives = bestSupport.params, echelon = F_Pion_GeteEtatEchelon( bestSupport.source ) } )
            end
        end
    end
end
}
