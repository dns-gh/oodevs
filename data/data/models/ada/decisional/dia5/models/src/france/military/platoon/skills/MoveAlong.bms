-------------------------------------------------------------------------------
-- Skill MoveAlong
-- Reach objectif in order given by the caller skill
-- @author MGD
-- @created 2010-08-02
-- @modified MGD 2010-03-24
--
-- This file is part of a MASA library or program.
-- Refer to the included end-user license agreement for restrictions.
--
-- Copyright (c) 2010 Mathématiques Appliquées SA (MASA)
-------------------------------------------------------------------------------

rootnode
{
    connections = { skill.links.moveToward, skill.links.stayClose };

    done = function( self, params, additionalParams )
        if self.nextTargetIndex + 1 > #self.params.entities then
          if not self.params.entities[ self.nextTargetIndex ]:isReached() then
            if myself.isEscorted then return end
              self.notArrived = true
           else
               Feedback( self.feedbacks.done, { sender = "moveAlong", element = self.params.entities[ self.nextTargetIndex ] } )
           end
        else
            if additionalParams.reason == "blocked" then -- Cas ou un endroit non atteignable me bloque 
                myself.blocked = nil -- Si ce n'est pas le dernier point de mon itinéraire, je passe au suivant sans rester bloqué
            end
            self.nextTargetIndex = self.nextTargetIndex + 1
        end
        myself.isEscorted = false
    end,
    failed = function( self, params, additionalParams )
        self:done(params, additionalParams)
    end,

    create = function( self )
        self.nextTargetIndex = 1
        myself.isEscorted = false
        self.notArrived = false
    end,

    activate = function( self )
      local Activate = Activate
      if self.notArrived then
          Activate( skill.links.moveToward, 1, { entities  = { self.params.entities[ self.nextTargetIndex ] } , 
                                                 positions = { self.params.entities[ self.nextTargetIndex ] } } )
      else
          local escort = F_Pion_GetpionEnEscorte( meKnowledge.source )
          if escort then -- Une unité m'escorte, la mission MoveToward devient StayClose
              local distanceMax = 100
              self.escortUnit = CreateKnowledge( sword.military.world.PlatoonAlly, escort )
              if myself.getRouteForEscorting then -- Si l'escorteur a récupéré mon itinéraire
                  if not myself.isEscorted then
                       F_Pion_SetNewEscorted( escort, true )
                       myself.isEscorted = true
                       meKnowledge:sendCanGiveRouteForEscorting( self.escortUnit, true )
                       Activate( skill.links.moveToward, 1, { entities  = { self.params.entities[ self.nextTargetIndex ] } , 
                                                   positions = { self.params.entities[ self.nextTargetIndex ] } } )
                  else
                  -- On suit
                      local position = CreateProxyKnowledge( sword.military.world.ReachingArea, self.escortUnit, 
                                                       { distanceMin = 0, distanceMax = distanceMax } )
                      Activate( skill.links.stayClose, 1, { entities  = { self.escortUnit }, positions = { position } } )
                      meKnowledge:sendCanGiveRouteForEscorting( self.escortUnit, false )
                  end
              else -- Si l'escorteur n'a pas récupéré mon itinéraire
                  if myself.askForRoute then
                      meKnowledge:sendCanGiveRouteForEscorting( self.escortUnit, true )
                      Activate( skill.links.moveToward, 1, { entities  = { self.params.entities[ self.nextTargetIndex ] } , 
                                                           positions = { self.params.entities[ self.nextTargetIndex ] } } )
                 end
              end
          else -- MoveAlong par défaut (si pas d'escorte)
              myself.isEscorted = false
              self.escortUnit = nil
              Activate( skill.links.moveToward, 1, { entities  = { self.params.entities[ self.nextTargetIndex ] } , 
                                                   positions = { self.params.entities[ self.nextTargetIndex ] },
                                                    pathType = self.params.pathType } )
          end
        end
    end,

    destroy = function( self )
        myself.isEscorted = false
        myself.getRouteForEscorting = nil
    end,
}