-- set echelon for elements in bestUnits
-- @params bestUnits : list of element
-- @params echelon
-- @author LMT
-- @release 2011-01-13
local function setEchelon ( bestUnits, echelon )
    local nBestUnits = #bestUnits
    for i = 1, nBestUnits do
        local elem = bestUnits[i]
        F_Pion_SeteEtatEchelon( elem.entity.source, echelon )
    end
end

-- Find which unit will do the task
-- @params self
-- @params tasks : a list of platoon taks*
-- @params nbrFront : how many platoon can take this task
-- @params echelon : echelon number
-- @author LMT
-- @release 2011-01-13
local function issueMission ( self, tasks, nbrFront, echelon, entities )
    local tasks = explode( ";", tasks )
    entities = entities or self.entitiesWithoutMission
    local bestUnits = findBests( entities, tasks, self.companyTask, self.parameters, nbrFront ) --Save the nbrFront best couple unit/task
    self.entitiesWithoutMission = removeFromListForLead( bestUnits, self.entitiesWithoutMission )
    setEchelon( bestUnits, echelon )
    local nBestUnits = #bestUnits
    for i = 1, nBestUnits do
        local elem = bestUnits[i]
        meKnowledge:sendTaskToPion( elem.entity, elem.taskName, elem.params, echelon ) -- Send the task to the unit
    end
    return bestUnits
end

-- Listen front element  in order to manage automat feedback
-- @params frontElement : realize the main effect
-- @author LMT
-- @release 2011-01-14
local function manageFeedback ( frontElement )
    local nbUnitInOtherAutomat = 0
    local DEC_GetAutomate = DEC_GetAutomate
    for _, elem in pairs (frontElement) do
      integration.ListenFrontElement( elem.entity )
      if DEC_GetAutomate( elem.entity.source ) == meKnowledge then
      -- On vérifie que le pion est toujours sous l'automate
          nbUnitInOtherAutomat = nbUnitInOtherAutomat + 1
      end
    end
    -- si tous les pions ont changé d'automate (par exemple pour la mission preparer bascule), on remonte une fin de mission
    if nbUnitInOtherAutomat == #frontElement then
        myself.feedback = true
    end
end

local function manageAddedAndDeletedUnits( self )
    local redone = false
    local DEC_HasMission = DEC_HasMission
    local oldEntities = self.parameters.commandingEntities
    local newEntities = integration.getEntitiesFromAutomat( meKnowledge, "none", self.params.withPC )
    local newOperationnalEntities = integration.getOperationnalEntitiesFromAutomat( meKnowledge, "none", self.params.withPC )

    -- Si un pion a été supprimé de l'automate, on redistribue les missions
    for i, entity in pairs( oldEntities ) do
        if not exists( newEntities, entity ) then
             self:create()
             redone = true
             break
        end
    end

    -- Si un pion est de nouveau operationnel et/ou un pion a été ajouté à l'automate
   if #newOperationnalEntities > #self.operationnalEntities and not redone then
        for i, entity in pairs( newOperationnalEntities ) do
            if not exists( self.operationnalEntities, entity ) then
                if not DEC_HasMission( entity.source ) then -- Si le pion n'a pas de mission
                    issueMission ( self, self.params.supportTasks, 1, eEtatEchelon_Second, { entity } )
                    if not DEC_HasMission( entity.source ) then -- Si le pion n'a toujours pas de mission
                        issueMission ( self, self.params.defaultTask, 1, eEtatEchelon_Second, { entity } )
                    end
                end
            end
        end
    end

    self.operationnalEntities = newOperationnalEntities -- on enregistre la liste pour le tic suivant
    self.parameters.commandingEntities = newEntities
end

rootnode {

connections = { skill.links.synchronizeRC, skill.nodes.RC },

done = function( self ) end,

create = function( self )
        myself.newTask = false
        self.parameters = myself.taskParams
        self.parameters.commandingEntities = integration.getEntitiesFromAutomat( meKnowledge, "none", self.params.withPC )
        self.operationnalEntities = integration.getOperationnalEntitiesFromAutomat( meKnowledge, "none", self.params.withPC )
        for _, pion in pairs( self.parameters.commandingEntities ) do
            integration.setNeedReinforcement( pion, nil, nil, false )
        end
        -- Init
        local Activate = Activate
        myself.leadData = {}
        self.entitiesWithoutMission = copyTable( self.parameters.commandingEntities )
        myself.feedback = false
        self.companyTask = integration.RetrieveAutomateTask( meKnowledge, self.params.companyTask )
        self.companyTask:init( self.params, self.parameters )
        myself.numberOfConstructedObject = 0

        if self.params.allInFront and self.params.allInFront ~= NIL then
            self.nbrFront = #self.parameters.commandingEntities -- All platoons in front
        else
            self.nbrFront = self.companyTask:getNbrFront() -- Ask how many platoon will be in the front group. Number giving by the user or by default.
        end
        self.progressionInAOR = {}

        -- Initialisation des missions pion
        -- Le pion PC rejoint le meetingPoint
        if self.params.pcTasks and self.params.pcTasks ~= NIL then
            self.parameters.pcObjective = self.params.pcObjective
            issueMission ( self, self.params.pcTasks, 1, eEtatEchelon_Reserve, { integration.query.getPCUnit() } )
        end

        -- S'il y a des obstacles à construire, les pions GEN (ou PIA) vont le construire
        if self.params.engineerTask and self.params.engineerTask ~= NIL then
            issueMission ( self, self.params.engineerTask,  #self.companyTask:getObstaclesPlan( myself.taskParams ), eEtatEchelon_None )
        end

        -- Le premier echelon recoit les missions principales ("mainTasks")
        local bestUnits = issueMission ( self, self.params.mainTasks, self.nbrFront, eEtatEchelon_First )
        
        if #bestUnits == 0 then
            return
        end
end,

activate = function( self )
    local Activate = Activate
    if myself.newTask then
      self:create()
    end
    
    -- Si on a recu l'ordre de conduite poursuivre alors on distribue les missions au second echelon
    if integration.query.getFirstFragOrderFromType( "Rep_OrderConduite_Poursuivre" ) ~= nil then
        -- Le second echelon recoit les missions de "supportTask"
        issueMission ( self, self.params.supportTasks, #self.entitiesWithoutMission, eEtatEchelon_Second )

        -- Ceux qui n'ont toujours pas de mission recoivent la mission par défaut
        issueMission ( self, self.params.defaultTask, #self.entitiesWithoutMission, eEtatEchelon_Second )
    end

    manageAddedAndDeletedUnits( self )

    if myself.leadData.NombreTotalSitesAConstruire ==  myself.numberOfConstructedObject then -- On affiche le CR une fois tous les sites construits
        Activate( skill.nodes.RC, 1, { RC = eRC_AttenteOrdrePoursuivre } )
    end    

    local echelons = integration.getPionsInEchelons( self.parameters.commandingEntities )
    local pionsPE =  echelons[1]

    -- Gestion du CR quand les pions PE arrivent sur les limas de type LC ou LD
    Activate( skill.links.synchronizeRC, 1, { entities = pionsPE } )
end,
}

node "RC"
{
    create = function( self )
        meKnowledge:RC( self.params.RC )
    end,
}
