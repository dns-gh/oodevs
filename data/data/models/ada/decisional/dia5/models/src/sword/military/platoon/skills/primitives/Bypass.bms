-- **************************************************************************** 
-- Bypass elements.
-- self.params.entities: the bypassable elements
-- self.params.positions: the bypassing elements
-- ****************************************************************************
rootnode
{
    connections = { skill.nodes.bypassElement },

    -- -------------------------------------------------------------------------------- 
    -- Feedback when position reached and when occupied
    -- --------------------------------------------------------------------------------
    done = function( self, params, additionnalParams )
        Feedback( self.feedbacks.elementBypassed, { element = params.entity } )
        self.targets[ params.entity ] = nil
        if not next( self.targets ) then
          Feedback( self.feedbacks.done )
        end
    end,

    failed = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementFailed, { element = additionalParams.element, needReinforcement = "destroy" } )
    end,

    notBypassable = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementNotBypassable, { element = additionalParams.element } )
    end,

    cancelled = function( self, params, additionalParams )
        Feedback( self.feedbacks.elementCancelled, { element = additionalParams.element } )
        self.targets[ params.entity ] = nil
        if not next( self.targets ) then
          Feedback( self.feedbacks.done )
        end
    end,

    create = function( self )
        self.targets = {}
        for _, entity in pairs( self.params.entities ) do
            self.targets[ entity ] = true
        end
    end,
    
    -- -------------------------------------------------------------------------------- 
    -- For each objective of the skill, try to remove it. 
    -- --------------------------------------------------------------------------------
    activate = function( self )
        local Activate = Activate
        for entity in pairs( self.targets ) do
            Activate( skill.nodes.bypassElement, entity:bypassPriority(), 
                { entity = entity, positions = self.params.positions, avoidObstacles = self.params.avoidObstacles } )
        end
    end
}
-- **************************************************************************** 
-- Bypass element.
-- self.params.entity: the bypassable elements
-- self.params.positions: the bypassing elements
-- ****************************************************************************
node "bypassElement"
{
    connections = { skill.links.moveAndTakePosition, skill.nodes.bypass, skill.links.observe, skill.links.dismount },

    feedbacks = { "cancelled", "notBypassable" },

    done = function( self, params, additionalParams )  -- feedback from moveAndTakePosition
        self.arrived = true
    end, 
    
    failed = function( self, params, additionalParams )
       Feedback( self.feedbacks.failed, { element = additionalParams.element } )
    end,

    create = function( self )
        self.eTypeIti = eTypeItiDeminage
        if self.params.avoidObstacles then
            self.eTypeIti = eTypeItiMouvement
        end
        self.arrived = false
    end,

    -- -------------------------------------------------------------------------------- 
    -- Move toward a removing element and remove the entity
    -- --------------------------------------------------------------------------------
    activate = function( self )
        local Activate = Activate
        -- current observation toward the element to reconnoiter
        local cancelOrder = integration.query.getFirstFragOrderFromType( "Rep_OrderConduite_Pion_AbandonnerTravaux" )
        if cancelOrder then
            Feedback( self.feedbacks.cancelled, { element = self.params.entity } )
            return
        end

        if not self.params.entity:canBeBypassed() then
            Feedback( self.feedbacks.notBypassable, { element = self.params.entity } )
        end

        if self.params.entity:isBypassed() then
            Feedback( self.feedbacks.done, { element = self.params.entity} )
            return
        end

        Activate( skill.links.observe, 1, { entity = self.params.entity } )

        if self.arrived then
            if not meKnowledge:isDismounted() and meKnowledge:canDismount() then
                Activate( skill.links.dismount, 1 )
            else
                if self.params.entity:canBypassIt() then
                    Activate( skill.nodes.bypass, 1, { entity = self.params.entity } )
                else
                    Feedback( self.feedbacks.failed,{ element = self.params.entity } )
                end
            end
        end

        -- Moving toward a removing position
        for _, position in pairs( self.params.positions )  do
            Activate( skill.links.moveAndTakePosition, 
                position:removalEfficiency( self.params.entity ),
                                { entity = position, pathType = self.eTypeIti } )
        end
        self.arrived = false
    end
}
-- **************************************************************************** 
-- bypass action on the bypassable element 
-- ****************************************************************************
node "bypass"
{
    feedbacks = { "done" };

    acquire = { [ skill.resources.buildCapacity ] = 1 };

    select = function( self )
        if not self.params.entity:bypassIt() then
            Feedback( self.feedbacks.failed, { element = self.params.entity } )
        end
    end
}
