rootnode 
{
    connections = { skill.links.lead, skill.links.manageFragOrder },

    done = function( self ) end,

    create = function( self )
        if masalife.brain.core.class.isOfType(  self.params.objective, sword.military.world.Company) then
            self.escortableUnits = integration.getEntitiesFromAutomatCommunication( self.params.objective, "none", true)
        elseif masalife.brain.core.class.isOfType( self.params.objective, sword.military.world.Platoon) then
            self.escortableUnits = { integration.getAgentFromAutomatKnowledge( self.params.objective ) }
        else
            self.escortableUnits = { self.params.objective }
            self.activate = function( self )
                 Activate( skill.links.lead , 1, { companyTask = self.params.companyTask,
                                     mainTasks = self.params.escortTask, supportTasks = self.params.supportTask,
                                     defaultTask = self.params.defaultTask, taskForSupporting = self.params.taskForSupporting, noCoordination = true } )
            end
        end

    end,

    activate = function( self )
         local Activate = Activate
         local distance = meKnowledge:getProximity( self.params.objective )
         -- Si l'automate escorteur est proche (95%) de l'automate escorté
         if distance > 95 then
            -- Si on passe une fois dans le if, on ne veut plus jamais passer dans le else
            self.activate = self.beginEscort
         else
            -- Il faut que l'automate escorteur se rapproche de l'automate a escorter
            if not self.fragOrderSent then
                local platoonInMeKnowledge = integration.getEntitiesFromAutomatCommunication( meKnowledge, "none", true)
                local sizePlatoonInMeKnowledge = #platoonInMeKnowledge
                local objectivePosition = CreateKnowledge( sword.military.world.Point, DEC_Geometrie_CopiePoint( self.params.objective:getPosition() ) )
                for i = 1, sizePlatoonInMeKnowledge do
                    local element = platoonInMeKnowledge[i]
                    element:sendTaskToPion( element, "france.military.platoon.tasks.FaireMouvement", { objectives = { objectivePosition },
                           dangerDirection_ = self.params.automateParameters.dangerDirection_}, eEtatEchelon_First )
                end
                self.fragOrderSent = true
             end
             if not integration.query.getFirstFragOrderFromType( "Rep_OrderConduite_Poursuivre" ) then
               local fragOrder = CreateFragOrder("Rep_OrderConduite_SArreter")
               local fragOrderKn = CreateKnowledge( sword.military.world.FragOrder, fragOrder )       
               Activate( skill.links.manageFragOrder, 1, { fragOrders = { fragOrderKn } , entities = self.escortableUnits } )
             end
         end
    end,

    beginEscort = function( self )
       local Activate = Activate
       -- self.waitFollowFragOrder nous permet d'attendre deux tics avant que le pion suive l'escorteur
       -- Le fragorder Poursuivre fait un "stopTask" du fragOrder "Se Poster" qui s'executera au tic suivant
       -- On veut être sur que le pion ait eu le temps de lancer un pathfind, quelque soit l'ordre d'evaluation des pions
       if not self.waitFollowFragOrder then
            self.waitFollowFragOrder = 1
            local fragOrder = CreateFragOrder("Rep_OrderConduite_Poursuivre")
            local fragOrderKn = CreateKnowledge( sword.military.world.FragOrder, fragOrder )
            Activate( skill.links.manageFragOrder, 1, { fragOrders = { fragOrderKn } , entities = self.escortableUnits } )
       elseif self.waitFollowFragOrder == 1 then
           self.waitFollowFragOrder = 2
       else
           Activate( skill.links.lead , 1, { companyTask = self.params.companyTask,
                                     mainTasks = self.params.escortTask, supportTasks = self.params.supportTask,
                                     defaultTask = self.params.defaultTask, taskForSupporting = self.params.taskForSupporting, noCoordination = true } )
        end
    end,
}
