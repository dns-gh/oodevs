-- set echelon for elements in bestUnits
-- @params bestUnits : list of element
-- @params echelon
-- @author LMT
-- @release 2011-01-13
local function setEchelon ( bestUnits, echelon )
    for _, elem in pairs (bestUnits) do
        F_Pion_SeteEtatEchelon( elem.entity.source, echelon )
    end
end

-- Compare two elements with their efficiency
-- @param w1 First element
-- @param w2 Second element
-- @return True if the efficiency of w1 is better than w2's
-- @author MGD
-- @release 2010-12-03
local function comp( w1,w2 )
    return ( w1.efficiency > w2.efficiency )
end

-- Fill the unit task parameter
-- @param bestList Units sorted by efficiency
-- @param companyTask The company's task
-- @param params Parameters from the company's task
-- @param nbrFront The number of element that we want in this echelon
-- @author MGD
-- @release 2010-12-03
local function fillParameters( bestList, companyTask, params, nbrFront, marcheRetrograde, isMain, objectif )
    local bestListNbrFront = {}
    local findFront = 1
    local current = 1
    params.maxNbrFront = math.min( #bestList, nbrFront )
    while findFront <= nbrFront and current <= params.maxNbrFront do
       local paramsPion = bestList[current].task:fillParameters( companyTask, params, bestList[current].entity, marcheRetrograde, objectif, bestList[current].taskName ) -- Save the parameter needed for the platoon task
       if paramsPion then
          if isMain then          
              F_Pion_SeteEtatEchelon( bestList[current].entity.source, eEtatEchelon_First )
          end   
          bestListNbrFront[findFront] = bestList[current]
          bestListNbrFront[findFront].params = paramsPion
          findFront = findFront+1
       end
       current = current+1
    end
    return bestListNbrFront
end


-- Fill worMap liste. If no one can construct an obstacle, someone who knows the task will do it
-- @author LMT
-- @release 2010-08-26
local function fillWorkMap()
    for taskName, taskWorkMap in pairs( myself.leadData.workMap ) do
        local platoonHasTask = myself.leadData.platoonHasTask[taskName]
        for obstacle, builders in pairs( taskWorkMap ) do
            if not next(builders) then
                builders = builders or {}
                for _, platoon in pairs( platoonHasTask[obstacle] ) do
                    builders[ #builders + 1 ] = platoon
                end
            end
        end
    end
end

-- Optimize workMap list (obstacle/platoons)
-- @author LMT
-- @release 2010-08-26
local function optimizeWorkMap( nbrFront, nbrTotalObstacle )
    local nombreAffectation = {}
    local nbrObstacleParBuilder = ( nbrTotalObstacle / nbrFront )
    for _, taskWorkMap in pairs( myself.leadData.workMap ) do
        for obstacle, builders in pairs( taskWorkMap ) do
            local chosenBuilder = builders[1]
            nombreAffectation[chosenBuilder] = nombreAffectation[chosenBuilder] or 0
            nombreAffectation[chosenBuilder] = nombreAffectation[chosenBuilder] + 1
            local nextObstacle = obstacle
            nextObstacle = next(taskWorkMap, nextObstacle ) -- car on ne veut pas toucher au builders[obstacle]
            while ( nextObstacle ) do
                 local nextBuilders = taskWorkMap[ nextObstacle ]
                 local nextSize = #nextBuilders
                 if nextSize > 1 then
                     for i,currentBuilder in pairs( nextBuilders ) do
                         if currentBuilder == chosenBuilder and nombreAffectation[chosenBuilder] >= nbrObstacleParBuilder then
                             local index = i
                             while index < nextSize do
                                 nextBuilders[index] = nextBuilders[index+1]
                                 index = index + 1
                             end
                             nextBuilders[index] = nil
                             break
                         end
                     end
                 end
                 nextObstacle = next( taskWorkMap, nextObstacle )
            end
        end
    end
end

-- @param entities A list of PlatoonAlly
-- @param tasks A list of Task that we want to give
-- @param companyTask The company's task
-- @param effect The effect of the company's task
-- @param params Parameters from the company's task
-- @param isMain True if tasks are for the first echelon
-- @return List of entities than can do tasks, sorted by efficiency
-- @author MGD
-- @modifier LMT
-- @release 2010-12-03
findBestsGEN = function( entities, tasks, companyTask , params, nbrFront, marcheRetrograde, isMain, objectif )
    local bestList = {}
    local size = 1
    local bestTask = nil
    local bestTaskName = nil
    local bestParams = nil
    myself.leadData.nbUnitsByObstacle ={}
    myself.leadData.platoonHasTask = {}
    for _, entity in pairs( entities ) do
        local efficiencyFind = false
        local bestEfficiency = -1
        local efficiency  = -1
        for _, taskName in pairs( tasks ) do
            local task = integration.RetrievePionTask( entity, taskName ) -- Save the task object if  the entity can do it
            if task then
                efficiency = entity:computePhysicalEfficiencyForEffect( task:getPionEfficiency() ) -- Efficiency for this entity to do this task
                if efficiency > bestEfficiency then
                    efficiencyFind = true
                    bestEfficiency = efficiency
                    bestTask = task
                    bestTaskName = taskName
                end
                if efficiencyFind then
                    if isMain then
                        myself.leadData.obstacles = task:getObstaclesParameter( companyTask, params )
                        myself.leadData.nbrTotalObstacle = #myself.leadData.obstacles
                        for _, obstacle in pairs ( myself.leadData.obstacles) do
                            myself.leadData.nbUnitsByObstacle[ obstacle ] = myself.leadData.nbUnitsByObstacle[ obstacle ] or 0
                            myself.leadData.workMap[taskName] =  myself.leadData.workMap[taskName] or {}
                            local workMap =  myself.leadData.workMap[taskName]
                            workMap[obstacle] = workMap[obstacle] or {}
                            local currentMap = workMap[obstacle]
                            local hasDotation = task:hasDotation( entity, obstacle )
                            local canDoIt = task:canDoIt( entity, obstacle )

                            myself.leadData.platoonHasTask[taskName] = myself.leadData.platoonHasTask[taskName] or {}
                            local platoonHasTask =  myself.leadData.platoonHasTask[taskName]
                            platoonHasTask[obstacle] = platoonHasTask[obstacle] or {}
                            local platoons = platoonHasTask[obstacle]
                            platoons[ #platoons + 1 ] = entity.source
                            
                            if hasDotation and canDoIt then
                                currentMap[#currentMap + 1] = entity.source
                                myself.leadData.nbUnitsByObstacle[ obstacle ] = myself.leadData.nbUnitsByObstacle[ obstacle ] + 1
                            end
                        end
                     end
                     bestList[size] = { entity = entity,
                                        task = bestTask,
                                        taskName = bestTaskName,
                                        efficiency = bestEfficiency }
                     size = size + 1
                end
            end
        end
    end
    local maxNbrFront = 0
    if  next(myself.leadData.nbUnitsByObstacle) then
      for _, obstacle in pairs ( myself.leadData.obstacles ) do
          maxNbrFront =  math.max( myself.leadData.nbUnitsByObstacle[ obstacle ], maxNbrFront )
      end
    else
      maxNbrFront = nbrFront
    end
    -- methode qui rempli la liste si les aucun pion n'a de dotation pour construire un obstacle donné
    fillWorkMap()
    if myself.leadData.workMap then
        params.maxNbrFront = math.min( maxNbrFront, nbrFront )
        if params.maxNbrFront~= 0 then
            optimizeWorkMap( params.maxNbrFront, myself.leadData.nbrTotalObstacle )
        end
    end
    return fillParameters( bestList, companyTask, params, nbrFront, marcheRetrograde, isMain, objectif )
end

-- Find which unit will do the task
-- @params self
-- @params tasks : a list of platoon taks*
-- @params nbrFront : how many platoon can take this task
-- @params echelon : echelon number
-- @author LMT
-- @release 2011-01-13
local function issueMission ( self, tasks, nbrFront, echelon, entities, isMain )
    local tasks = explode( ";", tasks )
    entities = entities or self.entitiesWithoutMission
    local bestUnits = findBestsGEN( entities, tasks, self.companyTask, self.parameters, nbrFront, nil, isMain ) --Save the nbrFront best couple unit/task
    self.entitiesWithoutMission = removeFromListForLead( bestUnits, self.entitiesWithoutMission )
    setEchelon( bestUnits, echelon )
    for _, elem in pairs( bestUnits ) do
        meKnowledge:sendTaskToPion( elem.entity, elem.taskName, elem.params, echelon ) -- Send the task to the unit
    end
    return bestUnits
end

-- Listen front element  in order to manage automat feedback
-- @params frontElement : realize the main effect
-- @author LMT
-- @release 2011-01-14
local function manageFeedback ( frontElement )
    local nbUnitInOtherAutomat = 0
    for _, elem in pairs (frontElement) do
      integration.ListenFrontElement( elem.entity )
      if DEC_GetAutomate( elem.entity.source ) == meKnowledge then
      -- On vérifie que le pion est toujours sous l'automate
          nbUnitInOtherAutomat = nbUnitInOtherAutomat + 1
      end
    end
    -- si tous les pions ont changer d'automate (par exemple pour la mission preparer bascule), on remonte un fin de mission
    if nbUnitInOtherAutomat == #frontElement then
        myself.feedback = true
    end
end

rootnode {

connections = { skill.links.supportManager, skill.links.coordinationManager, skill.links.relieveManager, skill.links.AssignSETask, skill.nodes.RC },

done = function( self ) end,

create = function( self )
        myself.newTask = false
        myself.hasSentFinMission = false
        myself.leadData = {}
        myself.leadData.workMap = {}
        self.parameters = myself.taskParams
        self.parameters.commandingEntities = integration.getEntitiesFromAutomatCommunication( meKnowledge, "none", self.params.withPC )
        for _, pion in pairs( self.parameters.commandingEntities ) do
            integration.setNeedReinforcement( pion, nil, nil, false )
        end
        -- Init
        local Activate = Activate
        self.entitiesWithoutMission = copyTable( self.parameters.commandingEntities )
        myself.feedback = false
        self.companyTask = integration.RetrieveAutomateTask( meKnowledge, self.params.companyTask )
        if self.params.allInFront and self.params.allInFront ~= NIL then
            self.nbrFront = #self.parameters.commandingEntities -- All platoons in front
        else
            self.nbrFront = self.companyTask:getNbrFront() -- Ask how many platoon will be in the front group. Number giving by the user or by default.
        end
        self.progressionInAOR = {}

        self.companyTask:init( self.params )

        -- Initialisation des missions pion
        -- Le pion PC rejoint le meetingPoint
        if self.params.pcTasks and self.params.pcTasks ~= NIL then
            self.parameters.pcObjective = self.params.pcObjective
            issueMission ( self, self.params.pcTasks, 1, eEtatEchelon_Reserve, { integration.query.getPCUnit() } )
        end

        -- S'il y a des obstacles à construire, les pions GEN (ou PIA) vont le construire
        if self.params.engineerTask and self.params.engineerTask ~= NIL then
            issueMission ( self, self.params.engineerTask,  #self.companyTask:getObstaclesPlan( myself.taskParams ), eEtatEchelon_None )
        end

        -- Le premier echelon recoit les missions principales ("mainTasks")
        local bestUnits = issueMission ( self, self.params.mainTasks, self.nbrFront, eEtatEchelon_First, nil, true )
        manageFeedback( bestUnits )

        -- Le second echelon recoit les missions de "supportTask"
        issueMission ( self, self.params.supportTasks, #self.entitiesWithoutMission, eEtatEchelon_Second )

        -- Les pions PEI
        if self.params.peiTasks and self.params.peiTasks ~= NIL then
            issueMission ( self, self.params.peiTasks, self.nbrFront, eEtatEchelon_Scout )
        end

        -- Ceux qui n'ont toujours pas de mission recoivent la mission par défaut
        issueMission ( self, self.params.defaultTask, #self.entitiesWithoutMission, eEtatEchelon_Second )
end,

activate = function( self )
    if myself.newTask then
      self:create()
    end
    local oldEntities = self.parameters.commandingEntities
    local newEntities = integration.getEntitiesFromAutomatCommunication( meKnowledge, "none", self.params.withPC )
    local redone = false
    -- Si un pion a été supprimé de l'automate, on redistribue les missions
    for i, entity in pairs( oldEntities ) do
        if not exists( newEntities, entity ) then
             self:create()
             redone = true
             break
        end
    end
    -- Si un pion a été ajouté à l'automate
    if not redone then
        for i, entity in pairs( newEntities ) do
            if not exists( oldEntities, entity ) then
              F_Pion_SeteEtatEchelon( entity.source, eEtatEchelon_Second ) -- on met les nouveaux pions au second echelon
              if not DEC_HasMission( entity.source ) then -- Si le pion n'a pas de mission
                  local tasksForNewEntity = self.params.supportTasks..";"..self.params.defaultTask
                  issueMission ( self, tasksForNewEntity, 1, eEtatEchelon_Second, { entity } )
              end
            end
        end
    end
    self.parameters.commandingEntities = newEntities
    local Activate = Activate
    local echelons = integration.getPionsInEchelons( self.parameters.commandingEntities )
    local pionsPE =  echelons[1]
    local pionsSE =  echelons[2]
    local pionsEE =  echelons[3]
    if myself.feedback then
        if self.params.disableWhenDone then
           Feedback( self.feedbacks.done )
        else
           meKnowledge:RC( eRC_FinMission )
           myself.hasSentFinMission = true
        end
        myself.feedback = false
    end

    -- Gestion du soutien
    Activate( skill.links.supportManager, 1, { companyTask = self.companyTask, parameters = self.parameters, PE = pionsPE, SE = pionsSE, taskForSupporting = self.params.taskForSupporting })

    if self.params.noCoordination then
        return
    end
    local fuseau = meKnowledge:getFuseau()
    
    -- Gestion de l'élongation   
    -- tous les pions sont projeté sur un des deux fuseaux de l'automate
    -- self.progressionInAOR: contient les valeurs de progression sur l'axe de progression
    -- plus la valeur est grande, plus le pion est en avant dans le fuseau
    local proj
    for _, entity in pairs( self.parameters.commandingEntities ) do
        proj = DEC_Geometrie_AdvanceAlongFuseau( entity.source ) 
        self.progressionInAOR[ entity ] = proj
    end

    local pionHasSupport, supportDistance
    local maxsupportDistance = 1200
    if next(pionsSE) ~= nil then
        for _, pion in pairs( pionsSE ) do
              supportDistance = DEC_Tir_PorteeMaxPourTirer( pion.source, 0.5 )
              if supportDistance > maxsupportDistance then
                  maxsupportDistance = supportDistance
              end
        end
    end
  
    local automatePosition = meKnowledge:getPosition()
    local inCity = integration.pointIsInCity(automatePosition)

    local largeurFuseau = fuseau:getWidth()
    
    
    if inCity then
      maxsupportDistance = maxsupportDistance/4
    else
      maxsupportDistance = maxsupportDistance/2
    end
   
    -- Gestion de l'élongation intra echelon   
    Activate( skill.links.coordinationManager , 1, { enititesFromEchelon = pionsPE, progressionInAOR = self.progressionInAOR, distance = largeurFuseau/2 } )
    Activate( skill.links.coordinationManager , 1, { enititesFromEchelon = pionsSE, progressionInAOR = self.progressionInAOR, distance = largeurFuseau/2 } )
    Activate( skill.links.coordinationManager , 1, { enititesFromEchelon = pionsEE, progressionInAOR = self.progressionInAOR, distance = largeurFuseau/2 } )
    
    -- Gestion de l'élongation inter echelon
    Activate( skill.links.coordinationManager , 1, { enititesFromEchelon = fusionList( pionsPE, pionsSE ), progressionInAOR = self.progressionInAOR, distance = maxsupportDistance } )
    
    -- Gestion de la rélève
    Activate( skill.links.relieveManager, 1, { pions = pionsPE, releve = pionsSE, followTask = self.params.defaultTask })

    -- Gestion du SE (car les objectifs ne sont plus les mêmes)
    Activate( skill.links.AssignSETask, 1, { SE = pionsSE, tasks = self.params.supportTasks, parameters = self.parameters, companyTask = self.companyTask })
    if not next(integration.getPionsInEchelons( self.parameters.commandingEntities )[1]) then
        Activate( skill.nodes.RC, 1, { RC = eRC_NoPEInAutomat } )
    end
end,
}

node "RC"
{
    create = function( self )
        meKnowledge:RC( self.params.RC )
    end,
}