rootnode {

connections = { skill.links.issueTaskGeneral },

    done = function( self ) end,

create = function( self )
  self.supportList = copyTable( self.params.SE )
  self.supportedList = {}
end,

activate = function( self )
  local Activate = Activate
  -- Demander à tous les pions s’ils sont en difficulté
  for _, pion in pairs ( self.params.PE ) do
     if( F_Pion_GeteEtatDec( pion.source ) == eEtatDec_Sauvegarde and not exists( self.supportedList, pion ) ) then --  si le pion est en difficulté et qu'il n'est pas déja soutenu
        local bestDistance = math.huge
        local bestSupport = nil
        local bestIndex = nil
        local bestTask = nil
        local position = pion:getMyPosition()
        -- Trouver un bon pion pour appuyer le pion en difficulté
        for index, support in pairs ( self.supportList ) do -- SE qui n'supporte pas déja
          local task = integration.RetrievePionTask( support, self.params.taskForSupporting )
          local distance = integration.distance( position, support:getMyPosition() )
          if task and integration.getAgentMajorOpsState( support.source ) > 0  and distance < bestDistance then
              bestSupport = support 
              bestIndex = index
              bestDistance = distance
              bestTask = task
          end
        end
        if bestSupport then
          bestSupport.params = bestTask:fillParameters( self.params.companyTask, self.params.parameters, bestSupport, 0, pion )
          table.remove(self.supportList, bestIndex )
          self.supportedList [#self.supportedList + 1] = pion
          Activate( skill.links.issueTaskGeneral, 1, { entities = { bestSupport }, taskName = self.params.taskForSupporting, objectives = bestSupport.params, echelon = F_Pion_GeteEtatEchelon( bestSupport.source ) } )
        end
    end
  end

end
}
