rootnode {

    done = function( self ) end,

activate = function( self )
  local Activate = Activate

  -- Demander à tous les pions s’ils sont en difficulté
  for _, pion in pairs ( self.params.pions ) do
       if integration.getAgentMajorOpsState( pion.source ) == 0 then --  si le pion a un mauvais état opérationnel
           local possibleReleve = {}
           for _, pionReleve in pairs ( self.params.releve ) do
             if integration.getAgentMajorOpsState( pionReleve.source ) > 0 and integration.isAgentInAutomatCanRelieveAgent( pionReleve.source, pion.source ) then
               possibleReleve [#possibleReleve + 1] = pionReleve
             end
           end
           local bestReleve = nil
           local bestDistance = math.huge
           for _, pionReleve in pairs ( possibleReleve ) do
               local distance = integration.distance( pionReleve, pion )
               if distance < bestDistance then
                   bestReleve = pionReleve
                   bestDistance = distance
               end

           end
           if bestReleve then
               integration.agentInAutomatRelieveAgent( bestReleve.source, pion.source )
               F_Pion_SeteEtatEchelon( bestReleve.source, F_Pion_GeteEtatEchelon( pion.source ) )
               meKnowledge:sendTaskToPion(pion, self.params.followTask, { objectives = { bestReleve } }, eEtatEchelon_None )
           else
               for _, unit in pairs ( self.params.pions ) do
                   if unit ~= pion then           
                      meKnowledge:sendTaskToPion(pion, self.params.followTask, { objectives = { unit } }, eEtatEchelon_None )
                      return
                   end
               end
               F_Pion_SeteEtatEchelon( pion.source, eEtatEchelon_None )
           end
      end
  end

end
}
