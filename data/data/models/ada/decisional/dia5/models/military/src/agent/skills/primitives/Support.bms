-- ****************************************************************************
-- Support elements.
-- self.params.entities: the supportable elements
-- self.params.positions: the supportable elements
-- ****************************************************************************
rootnode
{
    connections =
    {
        skill.nodes.SupportElement
    },

    -- --------------------------------------------------------------------------------
    -- A support position is reached
    -- --------------------------------------------------------------------------------
    done = function( self ) -- feedbackfrom moveAndTakePosition
        self.onPosition = true
    end,

    -- --------------------------------------------------------------------------------
    -- Init
    -- --------------------------------------------------------------------------------
    create = function( self ) 
        self.onPosition = false 
    end,

    -- --------------------------------------------------------------------------------
    -- Try to support elements
    -- Suppport element if possible, else try to coordinate
    -- --------------------------------------------------------------------------------
    activate = function( self )
        for _, entity in pairs( self.params.entities ) do
            Activate( skill.nodes.SupportElement, entity:supportPriority(),
                { entity = entity } )
        end
        self.onPosition = false
    end
}

-- ****************************************************************************
-- SupportElement.
-- self.params.entities: the supportable elements
-- self.params.positions: the supporting elements
-- ****************************************************************************
node "SupportElement"
{
    connections = { skill.links.observe, skill.links.moveAndTakePosition },

    -- --------------------------------------------------------------------------------
    -- A support position is reached
    -- --------------------------------------------------------------------------------
    done = function( self, params, additionalParams ) -- feedbackfrom moveAndTakePosition
        Feedback( self.feedbacks.done, additionalParams )
    end,

    create = function( self )
        self.positions = queries_positions.getPositionsToSupport[ "execute" ]({elementsToSupport = {self.params.entity}, dynamic = true})
    end,
    -- --------------------------------------------------------------------------------
    -- Move toward a destroying element and edstroy the entity
    -- --------------------------------------------------------------------------------
    activate = function( self )
        local Activate = Activate

        -- Main observation effort on the entity
        Activate( skill.links.observe, 1, { entity = self.params.entity } )

        -- Moving toward supporting positions
        
        --If the old bestPosition is still good
        if self.bestPosition then
           if self.bestPosition:supportEfficiency( self.params.entity ) > 0.8 then
                for i=1, #self.positions do
                     Activate( skill.links.moveAndTakePosition,
                               self.efficiencies[self.positions[i]], { entity = self.positions[i] } )
                end
                if not self.bestPosition:isReached() then
                    return
                end
            end
        end
        -- If the bestPosition is not enought good for supporting the entity
        self.efficiencies = {}
        self.maxEfficiency = 0
        self.positions = queries_positions.getPositionsToSupport[ "execute" ]({elementsToSupport = {self.params.entity}, dynamic = true})
        for i = 1, #self.positions do
            local position = self.positions[i]
            local efficiency = position:supportEfficiency( self.params.entity )
            self.efficiencies[position] = efficiency
            if( efficiency > self.maxEfficiency ) then
                self.maxEfficiency = efficiency
                self.bestPosition = position
            end
        end
    end
}