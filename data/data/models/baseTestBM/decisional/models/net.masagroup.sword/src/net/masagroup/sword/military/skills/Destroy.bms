rootnode
{
    connections =
    {
        skill.nodes.DestroyElement
    };

  done = function( self, params, additionnalParams )
    self.targets[ additionnalParams.destroyedEntity ] = nil
    if not next( self.targets ) then
        Feedback( self.feedbacks.done ) -- the job is done, all targets are destroyed
    end
  end,
  
  create = function( self )
    self.targets = {}
    for _, entity in ipairs( self.params.entity ) do 
        self.targets[ entity ] = true
    end
  end,

  activate = function( self )
    for _, entity in ipairs( self.params.entity ) do
         Activate( skill.nodes.DestroyElement, entity:destructionPriority(), { entity = entity, area = self.params.area[ entity ] or self.params.area } )
       end
  end
}

node "DestroyElement"
{
    connections =
    {
       skill.links.MoveTo,
       skill.nodes.Destroy,
       skill.links.observe
    };

    feedbacks = 
  {
    { { "done" }, "DestroyElement" }
  }; 

    activate = function( self )
      if self.params.entity:isDestroyed() then
      Feedback( self.feedbacks.done, { destroyedEntity = self.params.entity } )
    end

  -- ajout du skill moveTo pour chaque entity au lieu de faire parcours de positions clés
     Activate( skill.nodes.MoveTo, 1, { position = self.params.entity } )
     
      Activate( skill.links.observe, 1, { entity = self.params.entity } )
      
        if self.params.entity:canDestroyIt() then
            Activate( skill.nodes.Destroy, 1, { entity = self.params.entity } )
        end

      --[[ for _,position in ipairs( self.params.area )  do
        Activate( skill.links.moveAndTakePosition, position:destructionEfficiency( self.params.entity ), { entity = position } )
      end --]]
    end
}

node "Destroy"
{
  --select = acquire{ [ skill.resources.engage ] = 1 } + function( self )
    self.params.entity:destroyIt()
  --end
}