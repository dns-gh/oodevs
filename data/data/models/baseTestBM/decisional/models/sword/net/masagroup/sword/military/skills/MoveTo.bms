rootnode
{
    connections =
    {
        skill.nodes.MoveToPosition
    };

    activate = function( self )
      BreakForDebug( "call root" )
      for _, entity in pairs( self.params.entities ) do
        Activate( skill.nodes.MoveToPosition, entity:reachPriority(), { position = entity, area = self.params.area[entity] } )
      end
    end
}

node "MoveToPosition"
{
  connections =
  {
      skill.nodes.MoveToNode
  };

  activate = function( self )
    BreakForDebug( "call move to position" )
    BreakForDebug( "efficiency"..tostring( self.params.area[1]:reachEfficiency( self.params.position ) ) )
    for _, keypoint in pairs( self.params.area ) do
      Activate( skill.nodes.MoveToNode, keypoint:reachEfficiency( self.params.position ), { entity = keypoint } )
    end
  end
}

node "MoveToNode"
{
    connections = { skill.nodes.MoveTo, skill.nodes.TakePosition };
    
    activate = function( self )
        BreakForDebug("movetonode:enter")
        if self.params.entity:canTakePosition() then
            BreakForDebug( "movetonode:takePos" )
            Activate( skill.nodes.TakePosition, 1, { position = self.params.entity } )
        else
            BreakForDebug("movetonode:moveTo")
            Activate( skill.nodes.MoveTo, 1, { position = self.params.entity } )
        end
    end
}

node "MoveTo"
{
    feedbacks = { "done" };

    acquire = { [ skill.resources.move ] = 1 };

    select = function( self )
        if self.params.position:moveToIt() then
            Feedback( self.feedbacks.done, { position = self.params.position, state = "arrived" } )
        end
    end
}

node "TakePosition"
{
    feedbacks = { "done" }; 

    acquire = { [ skill.resources.move ] = 1 };

    select = function( self )
        if self.params.position:takeUpPosition() then
            Feedback( self.feedbacks.done, { position = self.params.position, state = "posted" } )
        end
    end
}