// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2010 MASA Group
//
// *****************************************************************************

import "common.proto";

package sword;

/** @file
 *  @brief Messages from clients to the simulation
 *  @addtogroup Simulation
 *  @{
 */

/** @struct ControlDateTimeChange
    @brief A date and/or time change request
    @see ControlDateTimeChangeAck
*/
message ControlDateTimeChange {
    //! The new date and/or time
    required DateTime date_time = 1;
}

//! Creates a new checkpoint. If "name" is not supplied, generates one
//! based on the current date and time. Returns a
//! ControlCheckPointSaveNowAck message, containing the generated
//! checkpoint name on success. Between both messages, a
//! ControlCheckPointSaveBegin matched by a ControlCheckPointSaveEnd may
//! be sent if the checkpoint creation is successful or at least
//! initiated.
message ControlCheckPointSaveNow {
    //! Checkpoint name, contains only alphanumeric characters, spaces
    //! or underscores.
    optional string name = 1;
    //! If true, the simulation state will be sent like it is upon new
    //! connections, right after the ControlCheckPointSaveBegin message.
    //! Note: this option is currently only used for testing purpose,
    //! its behaviour may change in future versions.
    optional bool   send_state = 2;
}

/** @struct UnitCreationRequest
    @brief An agent creation request
    @see UnitCreationRequestAck
    @todo rename into AgentCreationRequest
    @todo no clue what the fields are exactly...
*/
message UnitCreationRequest {
    //! The agent type
    required Id           type     = 1;
    //! The superior identifier
    required Id           superior = 2;
    //! The position
    required CoordLatLong position = 3;
}

/** @struct ControlCheckPointSetFrequency
    @brief Requests a checkpoint frequency change
    @see ControlCheckPointSetFrequencyAck
    @todo rename to ControlCheckpointSetFrequency
*/
message ControlCheckPointSetFrequency {
    //! The frequency of checkpoints in minutes
    required int32 frequency = 1;
}

/** @struct ControlCheckPointDeleteRequest
    @brief Request the deletion of a checkpoint
    @see ControlCheckPointDeleteAck
*/
message ControlCheckPointDeleteRequest {
    //! The checkpoint identifier
    required string checkpoint = 1;
}

/** @struct ControlCheckPointListRequest
    @brief Request the list of previously saved checkpoints
    @see ControlCheckPointListAck
    @see ControlCheckPointList
*/
message ControlCheckPointListRequest {
}

/** @struct ControlEnableVisionCones
    @brief A vision cones toggle request.

    This message is sent by a client to toggle the sending of vision
    cones. Enabling vision cones will produce UnitVisionCones messages.

    @see UnitVisionCones
    @todo see how it is related to ControlInformation::send_vision_cones
*/
message ControlEnableVisionCones {
    //! Whether to activate vision cones or not
    required bool vision_cones = 1;
    //! Units for which to activate/deactivate vision cones updates,
    //! applies to all units if empty
    repeated Id   units = 2;
}

/** @struct ChangePopulationMagicAction
    @brief A change population magic action.
    @see UnitMagicActionAck
*/
message ChangePopulationMagicAction {
    //! The population identifier @todo rename to population
    required Id             tasker     = 1;
    //! The party adhesions
    repeated PartyAdhesion  adhesions  = 2;
    //! The number of healthy persons
    optional int32          healthy    = 3;
    //! The number of wounded persons
    optional int32          wounded    = 4;
    //! The number of dead persons
    optional int32          dead       = 5;
    //! The motivation @todo What is that ?
    optional string         motivation = 6;
    //! Whether the population have received an alert
    optional bool           alerted    = 7;
}

/** @struct BurningCellRequest
    @brief Request details of a burning cell.

    This message is sent by a client to request burning cell details.

    @see BurningCellRequestAck
*/
message BurningCellRequest {
    //! Identifier of the burning object
    required Id    object = 1;
    //! X coordinates of the burning cell
    required float x      = 2;
    //! Y coordinates of the burning cell
    required float y      = 3;
}

/** @struct OrderStream
*/
message OrderStream {
    //! The serialized order
    required string serialized_order = 1;
}

/** @struct ListEnabledVisionCones
    @brief requests the list of units for which vision updates are currently
           listened to.
    @see ListEnableVisionConesAck
    @see ControlEnableVisionCones
*/
message ListEnabledVisionCones {
    //! Identifier to start from (included), if omitted start from the
    //! beginning
    optional Id     start = 1;
    //! Maximum number of identifiers to send
    optional uint32 count = 2;
}

/** List of supported terrain types
*/
enum TerrainType {
    forest         = 0;
    orchard        = 1;
    swamp          = 2;
    urban          = 3;
    water          = 4;
    dune           = 5;
    ice            = 6;
    mountain       = 7;
    forest_edge    = 8;
    orchard_edge   = 9;
    swamp_edge     = 10;
    urban_edge     = 11;
    dune_edge      = 12;
    ice_edge       = 13;
    mountain_edge  = 14;
    cliff          = 15;
    highway        = 16;
    large_road     = 17;
    medium_road    = 18;
    small_road     = 19;
    bridge         = 20;
    railroad       = 21;
    large_river    = 22;
    medium_river   = 23;
    small_river    = 24;
    crossroad      = 25;
    street         = 26;
    avenue         = 27;
    underpass      = 28;
    metro          = 29;
}

/** Performs a search among terrain graph segments to locate the closest from
    a given position up to a certain count with terrain types intersecting a
    given list of types.
*/
message SegmentRequest {
    //! The position near which to search
    required CoordLatLong position = 1;
    //! The terrain types to consider, if empty it defaults to all combined
    //! terrain types
    repeated TerrainType  terrains  = 2;
    //! The maximum number of segments to return
    optional uint32       count     = 3;
    //! The maximum radius into which to consider terrain graph nodes in
    //! meters, defaults to 10 km
    optional float        radius    = 4;
}

/** @struct ClientToSim
    @brief Wraps messages from clients to the simulation
*/
message ClientToSim {
    /** @struct Content
        @brief The possible messages contained in a client to simulation
               message.
        @warning Each Content message must contain exactly one of the
                 possible messages.
    */
    message Content {
        //! @copybrief ControlStop
        optional ControlStop              control_stop                    = 1;
        //! @copybrief ControlPause
        optional ControlPause             control_pause                   = 2;
        //! @copybrief ControlResume
        optional ControlResume            control_resume                  = 3;
        //! @copybrief ControlChangeTimeFactor
        optional ControlChangeTimeFactor  control_change_time_factor      = 4;
        //! @copybrief ControlDateTimeChange
        optional ControlDateTimeChange    control_date_time_change        = 5;
        //! @copybrief ControlCheckPointSaveNow
        optional ControlCheckPointSaveNow control_checkpoint_save_now     = 6;
        //! @copybrief ControlCheckPointSetFrequency
        optional ControlCheckPointSetFrequency
            control_checkpoint_set_frequency                              = 7;
        //! @copybrief ControlEnableVisionCones
        optional ControlEnableVisionCones control_toggle_vision_cones     = 8;
        //! @copybrief UnitOrder
        optional UnitOrder                unit_order                      = 9;
        //! @copybrief AutomatOrder
        optional AutomatOrder             automat_order                   = 10;
        //! @copybrief CrowdOrder
        optional CrowdOrder               crowd_order                     = 11;
        //! @copybrief FragOrder
        optional FragOrder                frag_order                      = 12;
        //! @copybrief SetAutomatMode
        optional SetAutomatMode           set_automat_mode                = 13;
        //! @copybrief UnitCreationRequest
        optional UnitCreationRequest      unit_creation_request           = 14;
        //! @copybrief UnitCreationRequest
        optional UnitMagicAction          unit_magic_action               = 15;
        //! @copybrief ObjectMagicAction
        optional ObjectMagicAction        object_magic_action             = 16;
        //! @copybrief KnowledgeMagicAction
        optional KnowledgeMagicAction     knowledge_magic_action          = 17;
        //! @copybrief MagicAction
        optional MagicAction              magic_action                    = 18;
        //! @copybrief ControlCheckPointListRequest
        optional ControlCheckPointListRequest
            control_checkpoint_list_request                               = 19;
        //! @copybrief ControlCheckPointDeleteRequest
        optional ControlCheckPointDeleteRequest
            control_checkpoint_delete_request                             = 20;
        //! @copybrief ChangePopulationMagicAction
        optional ChangePopulationMagicAction
            change_population_magic_action                                = 21;
        //! @copybrief BurningCellRequest
        optional BurningCellRequest       burning_cell_request            = 23;
        //! @copybrief OrderStream
        optional OrderStream              order_stream                    = 24;
        //! @copybrief ListEnabledVisionCones
        optional ListEnabledVisionCones   list_enabled_vision_cones       = 25;
        optional LogisticHistoryRequest   logistic_history_request        = 26;
        optional ListLogisticRequests     list_logistic_requests          = 27;
        optional ComputePathfind          compute_pathfind                = 28;
        optional SegmentRequest           segment_request                 = 29;
    }
    /** @property context
        @brief Identifies the request matching the response

        This field is used to fill the "context" fields in the response
        message (from SimToClient). This context allows the client
        application to put an unique identifier (based for instance on
        MAC address), thus allowing to track response message matching a
        specific request emitted by the client.
    */
    optional int32   context = 1;
    //! The content of the message
    required Content message = 2;
    //! specific messages, mostly requests acknowledgements.
    optional int32   client_id = 3;
}

/** @}*/
