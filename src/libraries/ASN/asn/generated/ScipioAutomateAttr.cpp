/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 04-Oct-2006.
 */
#include "ScipioAutomateAttr.h"

/**************************************************************/
/*                                                            */
/*  EnumAutomateState                                         */
/*                                                            */
/**************************************************************/

ASN1C_EnumAutomateState::ASN1C_EnumAutomateState (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumAutomateState& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumAutomateState (ASN1CTXT* ctxt_p, ASN1T_EnumAutomateState value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumAutomateState: start\n");

   switch (value) {
      case EnumAutomateState::embraye: ui = 0; break;
      case EnumAutomateState::debraye: ui = 1; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumAutomateState: end\n");
   return (stat);
}

int ASN1C_EnumAutomateState::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumAutomateState (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumAutomateState (ASN1CTXT* ctxt_p, ASN1T_EnumAutomateState* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumAutomateState: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumAutomateState::embraye; break;
      case 1: *pvalue = EnumAutomateState::debraye; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumAutomateState: end\n");

   return (stat);
}

int ASN1C_EnumAutomateState::Decode ()
{
   return asn1PD_EnumAutomateState (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomateAttributes                                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomateAttributes::ASN1C_MsgAutomateAttributes (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomateAttributes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomateAttributes (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateAttributes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgAutomateAttributes: start\n");

   PU_NEWFIELD (ctxt_p, "etat_automatePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.etat_automatePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "rapport_de_forcePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.rapport_de_forcePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "combat_de_rencontrePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.combat_de_rencontrePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "etat_operationnelPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.etat_operationnelPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "disponibilite_au_tir_indirectPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.disponibilite_au_tir_indirectPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "roePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.roePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PE_Automate (ctxt_p, pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode etat_automate */

   if (pvalue->m.etat_automatePresent) {
      PU_PUSHNAME (ctxt_p, "etat_automate");

      stat = asn1PE_EnumAutomateState (ctxt_p, pvalue->etat_automate);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode rapport_de_force */

   if (pvalue->m.rapport_de_forcePresent) {
      PU_PUSHNAME (ctxt_p, "rapport_de_force");

      stat = asn1PE_EnumEtatRapFor (ctxt_p, pvalue->rapport_de_force);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode combat_de_rencontre */

   if (pvalue->m.combat_de_rencontrePresent) {
      PU_PUSHNAME (ctxt_p, "combat_de_rencontre");

      stat = asn1PE_EnumEtatCombatRencontre (ctxt_p, pvalue->combat_de_rencontre);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode etat_operationnel */

   if (pvalue->m.etat_operationnelPresent) {
      PU_PUSHNAME (ctxt_p, "etat_operationnel");

      stat = asn1PE_EnumEtatOperationnel (ctxt_p, pvalue->etat_operationnel);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode disponibilite_au_tir_indirect */

   if (pvalue->m.disponibilite_au_tir_indirectPresent) {
      PU_PUSHNAME (ctxt_p, "disponibilite_au_tir_indirect");

      stat = asn1PE_EnumDisponibiliteAuTir (ctxt_p, pvalue->disponibilite_au_tir_indirect);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode roe */

   if (pvalue->m.roePresent) {
      PU_PUSHNAME (ctxt_p, "roe");

      stat = asn1PE_EnumRoe (ctxt_p, pvalue->roe);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgAutomateAttributes: end\n");
   return (stat);
}

int ASN1C_MsgAutomateAttributes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomateAttributes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomateAttributes (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateAttributes* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgAutomateAttributes: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "etat_automatePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.etat_automatePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "rapport_de_forcePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.rapport_de_forcePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "combat_de_rencontrePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.combat_de_rencontrePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "etat_operationnelPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.etat_operationnelPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "disponibilite_au_tir_indirectPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.disponibilite_au_tir_indirectPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "roePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.roePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PD_Automate (ctxt_p, &pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode etat_automate */

   if (pvalue->m.etat_automatePresent) {
      PU_PUSHNAME (ctxt_p, "etat_automate");

      stat = asn1PD_EnumAutomateState (ctxt_p, &pvalue->etat_automate);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode rapport_de_force */

   if (pvalue->m.rapport_de_forcePresent) {
      PU_PUSHNAME (ctxt_p, "rapport_de_force");

      stat = asn1PD_EnumEtatRapFor (ctxt_p, &pvalue->rapport_de_force);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode combat_de_rencontre */

   if (pvalue->m.combat_de_rencontrePresent) {
      PU_PUSHNAME (ctxt_p, "combat_de_rencontre");

      stat = asn1PD_EnumEtatCombatRencontre (ctxt_p, &pvalue->combat_de_rencontre);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode etat_operationnel */

   if (pvalue->m.etat_operationnelPresent) {
      PU_PUSHNAME (ctxt_p, "etat_operationnel");

      stat = asn1PD_EnumEtatOperationnel (ctxt_p, &pvalue->etat_operationnel);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode disponibilite_au_tir_indirect */

   if (pvalue->m.disponibilite_au_tir_indirectPresent) {
      PU_PUSHNAME (ctxt_p, "disponibilite_au_tir_indirect");

      stat = asn1PD_EnumDisponibiliteAuTir (ctxt_p, &pvalue->disponibilite_au_tir_indirect);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode roe */

   if (pvalue->m.roePresent) {
      PU_PUSHNAME (ctxt_p, "roe");

      stat = asn1PD_EnumRoe (ctxt_p, &pvalue->roe);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgAutomateAttributes: end\n");

   return (stat);
}

int ASN1C_MsgAutomateAttributes::Decode ()
{
   return asn1PD_MsgAutomateAttributes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgSetAutomateMode                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgSetAutomateMode::ASN1C_MsgSetAutomateMode (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgSetAutomateMode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgSetAutomateMode (ASN1CTXT* ctxt_p, ASN1T_MsgSetAutomateMode* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgSetAutomateMode: start\n");

   /* encode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PE_Agent (ctxt_p, pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode mode */

   PU_PUSHNAME (ctxt_p, "mode");

   stat = asn1PE_EnumAutomateState (ctxt_p, pvalue->mode);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgSetAutomateMode: end\n");
   return (stat);
}

int ASN1C_MsgSetAutomateMode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgSetAutomateMode (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgSetAutomateMode (ASN1CTXT* ctxt_p, ASN1T_MsgSetAutomateMode* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgSetAutomateMode: start\n");

   /* decode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PD_Agent (ctxt_p, &pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode mode */

   PU_PUSHNAME (ctxt_p, "mode");

   stat = asn1PD_EnumAutomateState (ctxt_p, &pvalue->mode);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgSetAutomateMode: end\n");

   return (stat);
}

int ASN1C_MsgSetAutomateMode::Decode ()
{
   return asn1PD_MsgSetAutomateMode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumSetAutomateModeErrorCode                              */
/*                                                            */
/**************************************************************/

ASN1C_EnumSetAutomateModeErrorCode::ASN1C_EnumSetAutomateModeErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumSetAutomateModeErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumSetAutomateModeErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumSetAutomateModeErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumSetAutomateModeErrorCode: start\n");

   switch (value) {
      case EnumSetAutomateModeErrorCode::no_error: ui = 0; break;
      case EnumSetAutomateModeErrorCode::error_invalid_unit: ui = 1; break;
      case EnumSetAutomateModeErrorCode::error_unit_not_automate: ui = 2; break;
      case EnumSetAutomateModeErrorCode::error_already_embraye: ui = 3; break;
      case EnumSetAutomateModeErrorCode::error_already_debraye: ui = 4; break;
      case EnumSetAutomateModeErrorCode::error_unit_surrendered: ui = 5; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 5);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumSetAutomateModeErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumSetAutomateModeErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumSetAutomateModeErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumSetAutomateModeErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumSetAutomateModeErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumSetAutomateModeErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 5);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumSetAutomateModeErrorCode::no_error; break;
      case 1: *pvalue = EnumSetAutomateModeErrorCode::error_invalid_unit; break;
      case 2: *pvalue = EnumSetAutomateModeErrorCode::error_unit_not_automate; break;
      case 3: *pvalue = EnumSetAutomateModeErrorCode::error_already_embraye; break;
      case 4: *pvalue = EnumSetAutomateModeErrorCode::error_already_debraye; break;
      case 5: *pvalue = EnumSetAutomateModeErrorCode::error_unit_surrendered; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumSetAutomateModeErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumSetAutomateModeErrorCode::Decode ()
{
   return asn1PD_EnumSetAutomateModeErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgSetAutomateModeAck                                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgSetAutomateModeAck::ASN1C_MsgSetAutomateModeAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgSetAutomateModeAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgSetAutomateModeAck (ASN1CTXT* ctxt_p, ASN1T_MsgSetAutomateModeAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgSetAutomateModeAck: start\n");

   /* encode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PE_Agent (ctxt_p, pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumSetAutomateModeErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgSetAutomateModeAck: end\n");
   return (stat);
}

int ASN1C_MsgSetAutomateModeAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgSetAutomateModeAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgSetAutomateModeAck (ASN1CTXT* ctxt_p, ASN1T_MsgSetAutomateModeAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgSetAutomateModeAck: start\n");

   /* decode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PD_Agent (ctxt_p, &pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumSetAutomateModeErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgSetAutomateModeAck: end\n");

   return (stat);
}

int ASN1C_MsgSetAutomateModeAck::Decode ()
{
   return asn1PD_MsgSetAutomateModeAck (mpContext->GetPtr(), &msgData);
}

