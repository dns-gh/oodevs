/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 25-Nov-2006.
 */
#include "ScipioObject.h"

/**************************************************************/
/*                                                            */
/*  EnumMissionGenSousTypeObstacle                            */
/*                                                            */
/**************************************************************/

ASN1C_EnumMissionGenSousTypeObstacle::ASN1C_EnumMissionGenSousTypeObstacle (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumMissionGenSousTypeObstacle& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumMissionGenSousTypeObstacle (ASN1CTXT* ctxt_p, ASN1T_EnumMissionGenSousTypeObstacle value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumMissionGenSousTypeObstacle: start\n");

   switch (value) {
      case EnumMissionGenSousTypeObstacle::preliminaire: ui = 0; break;
      case EnumMissionGenSousTypeObstacle::de_manoeuvre: ui = 1; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumMissionGenSousTypeObstacle: end\n");
   return (stat);
}

int ASN1C_EnumMissionGenSousTypeObstacle::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumMissionGenSousTypeObstacle (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumMissionGenSousTypeObstacle (ASN1CTXT* ctxt_p, ASN1T_EnumMissionGenSousTypeObstacle* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumMissionGenSousTypeObstacle: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumMissionGenSousTypeObstacle::preliminaire; break;
      case 1: *pvalue = EnumMissionGenSousTypeObstacle::de_manoeuvre; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumMissionGenSousTypeObstacle: end\n");

   return (stat);
}

int ASN1C_EnumMissionGenSousTypeObstacle::Decode ()
{
   return asn1PD_EnumMissionGenSousTypeObstacle (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumObjectErrorCode                                       */
/*                                                            */
/**************************************************************/

ASN1C_EnumObjectErrorCode::ASN1C_EnumObjectErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumObjectErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumObjectErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumObjectErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumObjectErrorCode: start\n");

   switch (value) {
      case EnumObjectErrorCode::no_error: ui = 0; break;
      case EnumObjectErrorCode::error_invalid_object: ui = 1; break;
      case EnumObjectErrorCode::error_invalid_id: ui = 2; break;
      case EnumObjectErrorCode::error_invalid_camp: ui = 3; break;
      case EnumObjectErrorCode::error_invalid_localisation: ui = 4; break;
      case EnumObjectErrorCode::error_missing_specific_attributes: ui = 5; break;
      case EnumObjectErrorCode::error_invalid_specific_attributes: ui = 6; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumObjectErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumObjectErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumObjectErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumObjectErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumObjectErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumObjectErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumObjectErrorCode::no_error; break;
      case 1: *pvalue = EnumObjectErrorCode::error_invalid_object; break;
      case 2: *pvalue = EnumObjectErrorCode::error_invalid_id; break;
      case 3: *pvalue = EnumObjectErrorCode::error_invalid_camp; break;
      case 4: *pvalue = EnumObjectErrorCode::error_invalid_localisation; break;
      case 5: *pvalue = EnumObjectErrorCode::error_missing_specific_attributes; break;
      case 6: *pvalue = EnumObjectErrorCode::error_invalid_specific_attributes; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumObjectErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumObjectErrorCode::Decode ()
{
   return asn1PD_EnumObjectErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicActionAck                                   */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicActionAck::ASN1C_MsgObjectMagicActionAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicActionAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicActionAck (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicActionAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectMagicActionAck: start\n");

   /* encode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumObjectErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgObjectMagicActionAck: end\n");
   return (stat);
}

int ASN1C_MsgObjectMagicActionAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicActionAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicActionAck (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicActionAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgObjectMagicActionAck: start\n");

   /* decode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumObjectErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgObjectMagicActionAck: end\n");

   return (stat);
}

int ASN1C_MsgObjectMagicActionAck::Decode ()
{
   return asn1PD_MsgObjectMagicActionAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumObjectType                                            */
/*                                                            */
/**************************************************************/

ASN1C_EnumObjectType::ASN1C_EnumObjectType (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumObjectType& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumObjectType (ASN1CTXT* ctxt_p, ASN1T_EnumObjectType value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumObjectType: start\n");

   switch (value) {
      case EnumObjectType::bouchon_mines: ui = 0; break;
      case EnumObjectType::zone_minee_lineaire: ui = 1; break;
      case EnumObjectType::zone_minee_par_dispersion: ui = 2; break;
      case EnumObjectType::fosse_anti_char: ui = 3; break;
      case EnumObjectType::abattis: ui = 4; break;
      case EnumObjectType::barricade: ui = 5; break;
      case EnumObjectType::eboulement: ui = 6; break;
      case EnumObjectType::destruction_route: ui = 7; break;
      case EnumObjectType::destruction_pont: ui = 8; break;
      case EnumObjectType::pont_flottant_continu: ui = 9; break;
      case EnumObjectType::poste_tir: ui = 10; break;
      case EnumObjectType::zone_protegee: ui = 11; break;
      case EnumObjectType::zone_implantation_canon: ui = 12; break;
      case EnumObjectType::zone_implantation_cobra: ui = 13; break;
      case EnumObjectType::zone_implantation_lrm: ui = 14; break;
      case EnumObjectType::site_franchissement: ui = 15; break;
      case EnumObjectType::nuage_nbc: ui = 16; break;
      case EnumObjectType::plot_ravitaillement: ui = 17; break;
      case EnumObjectType::site_decontamination: ui = 18; break;
      case EnumObjectType::zone_brouillage_brod: ui = 19; break;
      case EnumObjectType::rota: ui = 20; break;
      case EnumObjectType::zone_nbc: ui = 21; break;
      case EnumObjectType::zone_brouillage_bromure: ui = 22; break;
      case EnumObjectType::aire_poser: ui = 23; break;
      case EnumObjectType::piste: ui = 24; break;
      case EnumObjectType::plateforme: ui = 25; break;
      case EnumObjectType::zone_mobilite_amelioree: ui = 26; break;
      case EnumObjectType::zone_poser_helicoptere: ui = 27; break;
      case EnumObjectType::aire_logistique: ui = 28; break;
      case EnumObjectType::itineraire_logistique: ui = 29; break;
      case EnumObjectType::camp_prisonniers: ui = 30; break;
      case EnumObjectType::camp_refugies: ui = 31; break;
      case EnumObjectType::poste_controle: ui = 32; break;
      case EnumObjectType::terrain_largage: ui = 33; break;
      case EnumObjectType::zone_interdite_mouvement: ui = 34; break;
      case EnumObjectType::zone_interdite_tir: ui = 35; break;
      case EnumObjectType::zone_implantation_mortier: ui = 36; break;
      case EnumObjectType::pont_flottant_discontinu: ui = 37; break;
      case EnumObjectType::installation: ui = 38; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 38);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumObjectType: end\n");
   return (stat);
}

int ASN1C_EnumObjectType::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumObjectType (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumObjectType (ASN1CTXT* ctxt_p, ASN1T_EnumObjectType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumObjectType: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 38);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumObjectType::bouchon_mines; break;
      case 1: *pvalue = EnumObjectType::zone_minee_lineaire; break;
      case 2: *pvalue = EnumObjectType::zone_minee_par_dispersion; break;
      case 3: *pvalue = EnumObjectType::fosse_anti_char; break;
      case 4: *pvalue = EnumObjectType::abattis; break;
      case 5: *pvalue = EnumObjectType::barricade; break;
      case 6: *pvalue = EnumObjectType::eboulement; break;
      case 7: *pvalue = EnumObjectType::destruction_route; break;
      case 8: *pvalue = EnumObjectType::destruction_pont; break;
      case 9: *pvalue = EnumObjectType::pont_flottant_continu; break;
      case 10: *pvalue = EnumObjectType::poste_tir; break;
      case 11: *pvalue = EnumObjectType::zone_protegee; break;
      case 12: *pvalue = EnumObjectType::zone_implantation_canon; break;
      case 13: *pvalue = EnumObjectType::zone_implantation_cobra; break;
      case 14: *pvalue = EnumObjectType::zone_implantation_lrm; break;
      case 15: *pvalue = EnumObjectType::site_franchissement; break;
      case 16: *pvalue = EnumObjectType::nuage_nbc; break;
      case 17: *pvalue = EnumObjectType::plot_ravitaillement; break;
      case 18: *pvalue = EnumObjectType::site_decontamination; break;
      case 19: *pvalue = EnumObjectType::zone_brouillage_brod; break;
      case 20: *pvalue = EnumObjectType::rota; break;
      case 21: *pvalue = EnumObjectType::zone_nbc; break;
      case 22: *pvalue = EnumObjectType::zone_brouillage_bromure; break;
      case 23: *pvalue = EnumObjectType::aire_poser; break;
      case 24: *pvalue = EnumObjectType::piste; break;
      case 25: *pvalue = EnumObjectType::plateforme; break;
      case 26: *pvalue = EnumObjectType::zone_mobilite_amelioree; break;
      case 27: *pvalue = EnumObjectType::zone_poser_helicoptere; break;
      case 28: *pvalue = EnumObjectType::aire_logistique; break;
      case 29: *pvalue = EnumObjectType::itineraire_logistique; break;
      case 30: *pvalue = EnumObjectType::camp_prisonniers; break;
      case 31: *pvalue = EnumObjectType::camp_refugies; break;
      case 32: *pvalue = EnumObjectType::poste_controle; break;
      case 33: *pvalue = EnumObjectType::terrain_largage; break;
      case 34: *pvalue = EnumObjectType::zone_interdite_mouvement; break;
      case 35: *pvalue = EnumObjectType::zone_interdite_tir; break;
      case 36: *pvalue = EnumObjectType::zone_implantation_mortier; break;
      case 37: *pvalue = EnumObjectType::pont_flottant_discontinu; break;
      case 38: *pvalue = EnumObjectType::installation; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumObjectType: end\n");

   return (stat);
}

int ASN1C_EnumObjectType::Decode ()
{
   return asn1PD_EnumObjectType (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AttrObjectSiteFranchissement                              */
/*                                                            */
/**************************************************************/

ASN1C_AttrObjectSiteFranchissement::ASN1C_AttrObjectSiteFranchissement (
   ASN1MessageBuffer& msgBuf, ASN1T_AttrObjectSiteFranchissement& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AttrObjectSiteFranchissement (ASN1CTXT* ctxt_p, ASN1T_AttrObjectSiteFranchissement* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AttrObjectSiteFranchissement: start\n");

   /* encode largeur */

   PU_PUSHNAME (ctxt_p, "largeur");

   stat = pe_UnconsInteger (ctxt_p, pvalue->largeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode profondeur */

   PU_PUSHNAME (ctxt_p, "profondeur");

   stat = pe_UnconsInteger (ctxt_p, pvalue->profondeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode vitesse_courant */

   PU_PUSHNAME (ctxt_p, "vitesse_courant");

   stat = pe_UnconsInteger (ctxt_p, pvalue->vitesse_courant);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode berges_a_amenager */

   PU_PUSHNAME (ctxt_p, "berges_a_amenager");

   PU_NEWFIELD (ctxt_p, "boolean");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->berges_a_amenager);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_AttrObjectSiteFranchissement: end\n");
   return (stat);
}

int ASN1C_AttrObjectSiteFranchissement::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AttrObjectSiteFranchissement (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AttrObjectSiteFranchissement (ASN1CTXT* ctxt_p, ASN1T_AttrObjectSiteFranchissement* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AttrObjectSiteFranchissement: start\n");

   /* decode largeur */

   PU_PUSHNAME (ctxt_p, "largeur");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->largeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode profondeur */

   PU_PUSHNAME (ctxt_p, "profondeur");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->profondeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode vitesse_courant */

   PU_PUSHNAME (ctxt_p, "vitesse_courant");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->vitesse_courant);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode berges_a_amenager */

   PU_PUSHNAME (ctxt_p, "berges_a_amenager");

   PU_NEWFIELD (ctxt_p, "boolean");

   stat = pd_bit (ctxt_p, &pvalue->berges_a_amenager);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_AttrObjectSiteFranchissement: end\n");

   return (stat);
}

int ASN1C_AttrObjectSiteFranchissement::Decode ()
{
   return asn1PD_AttrObjectSiteFranchissement (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AttrObjectNuageNBC                                        */
/*                                                            */
/**************************************************************/

ASN1C_AttrObjectNuageNBC::ASN1C_AttrObjectNuageNBC (
   ASN1MessageBuffer& msgBuf, ASN1T_AttrObjectNuageNBC& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AttrObjectNuageNBC (ASN1CTXT* ctxt_p, ASN1T_AttrObjectNuageNBC* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AttrObjectNuageNBC: start\n");

   /* encode agent_nbc */

   PU_PUSHNAME (ctxt_p, "agent_nbc");

   stat = asn1PE_OID (ctxt_p, pvalue->agent_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_AttrObjectNuageNBC: end\n");
   return (stat);
}

int ASN1C_AttrObjectNuageNBC::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AttrObjectNuageNBC (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AttrObjectNuageNBC (ASN1CTXT* ctxt_p, ASN1T_AttrObjectNuageNBC* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AttrObjectNuageNBC: start\n");

   /* decode agent_nbc */

   PU_PUSHNAME (ctxt_p, "agent_nbc");

   stat = asn1PD_OID (ctxt_p, &pvalue->agent_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_AttrObjectNuageNBC: end\n");

   return (stat);
}

int ASN1C_AttrObjectNuageNBC::Decode ()
{
   return asn1PD_AttrObjectNuageNBC (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfOID                                                 */
/*                                                            */
/**************************************************************/

ASN1C__SeqOfOID::ASN1C__SeqOfOID (
   ASN1MessageBuffer& msgBuf, ASN1T__SeqOfOID& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE__SeqOfOID (ASN1CTXT* ctxt_p, ASN1T__SeqOfOID* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE__SeqOfOID: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_OID (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE__SeqOfOID: end\n");
   return (stat);
}

int ASN1C__SeqOfOID::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE__SeqOfOID (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD__SeqOfOID (ASN1CTXT* ctxt_p, ASN1T__SeqOfOID* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD__SeqOfOID: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_OID);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_OID (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD__SeqOfOID: end\n");

   return (stat);
}

int ASN1C__SeqOfOID::Decode ()
{
   return asn1PD__SeqOfOID (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AttrObjectROTA                                            */
/*                                                            */
/**************************************************************/

ASN1C_AttrObjectROTA::ASN1C_AttrObjectROTA (
   ASN1MessageBuffer& msgBuf, ASN1T_AttrObjectROTA& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AttrObjectROTA (ASN1CTXT* ctxt_p, ASN1T_AttrObjectROTA* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AttrObjectROTA: start\n");

   /* encode niveau_danger */

   PU_PUSHNAME (ctxt_p, "niveau_danger");

   if ( (pvalue->niveau_danger >= 0 && pvalue->niveau_danger <= 10) ) {
      stat = pe_ConsInteger (ctxt_p, pvalue->niveau_danger, 0, 10);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   }
   else
      return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

   PU_POPNAME (ctxt_p);

   /* encode agents_nbc */

   PU_PUSHNAME (ctxt_p, "agents_nbc");

   stat = asn1PE__SeqOfOID (ctxt_p, &pvalue->agents_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_AttrObjectROTA: end\n");
   return (stat);
}

int ASN1C_AttrObjectROTA::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AttrObjectROTA (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AttrObjectROTA (ASN1CTXT* ctxt_p, ASN1T_AttrObjectROTA* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AttrObjectROTA: start\n");

   /* decode niveau_danger */

   PU_PUSHNAME (ctxt_p, "niveau_danger");

   stat = pd_ConsInteger (ctxt_p, &pvalue->niveau_danger, 0, 10);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode agents_nbc */

   PU_PUSHNAME (ctxt_p, "agents_nbc");

   stat = asn1PD__SeqOfOID (ctxt_p, &pvalue->agents_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_AttrObjectROTA: end\n");

   return (stat);
}

int ASN1C_AttrObjectROTA::Decode ()
{
   return asn1PD_AttrObjectROTA (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AttrObjectZoneNBC                                         */
/*                                                            */
/**************************************************************/

ASN1C_AttrObjectZoneNBC::ASN1C_AttrObjectZoneNBC (
   ASN1MessageBuffer& msgBuf, ASN1T_AttrObjectZoneNBC& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AttrObjectZoneNBC (ASN1CTXT* ctxt_p, ASN1T_AttrObjectZoneNBC* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AttrObjectZoneNBC: start\n");

   /* encode agent_nbc */

   PU_PUSHNAME (ctxt_p, "agent_nbc");

   stat = asn1PE_OID (ctxt_p, pvalue->agent_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_AttrObjectZoneNBC: end\n");
   return (stat);
}

int ASN1C_AttrObjectZoneNBC::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AttrObjectZoneNBC (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AttrObjectZoneNBC (ASN1CTXT* ctxt_p, ASN1T_AttrObjectZoneNBC* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AttrObjectZoneNBC: start\n");

   /* decode agent_nbc */

   PU_PUSHNAME (ctxt_p, "agent_nbc");

   stat = asn1PD_OID (ctxt_p, &pvalue->agent_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_AttrObjectZoneNBC: end\n");

   return (stat);
}

int ASN1C_AttrObjectZoneNBC::Decode ()
{
   return asn1PD_AttrObjectZoneNBC (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AttrObjectItineraireLogistique                            */
/*                                                            */
/**************************************************************/

ASN1C_AttrObjectItineraireLogistique::ASN1C_AttrObjectItineraireLogistique (
   ASN1MessageBuffer& msgBuf, ASN1T_AttrObjectItineraireLogistique& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AttrObjectItineraireLogistique (ASN1CTXT* ctxt_p, ASN1T_AttrObjectItineraireLogistique* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AttrObjectItineraireLogistique: start\n");

   /* encode itineraire_equipe */

   PU_PUSHNAME (ctxt_p, "itineraire_equipe");

   PU_NEWFIELD (ctxt_p, "boolean");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->itineraire_equipe);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);
   PU_POPNAME (ctxt_p);

   /* encode poids_max_supporte */

   PU_PUSHNAME (ctxt_p, "poids_max_supporte");

   stat = pe_UnconsInteger (ctxt_p, pvalue->poids_max_supporte);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode largeur */

   PU_PUSHNAME (ctxt_p, "largeur");

   stat = pe_UnconsInteger (ctxt_p, pvalue->largeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode longueur */

   PU_PUSHNAME (ctxt_p, "longueur");

   stat = pe_UnconsInteger (ctxt_p, pvalue->longueur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode debit */

   PU_PUSHNAME (ctxt_p, "debit");

   stat = pe_UnconsInteger (ctxt_p, pvalue->debit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_AttrObjectItineraireLogistique: end\n");
   return (stat);
}

int ASN1C_AttrObjectItineraireLogistique::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AttrObjectItineraireLogistique (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AttrObjectItineraireLogistique (ASN1CTXT* ctxt_p, ASN1T_AttrObjectItineraireLogistique* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AttrObjectItineraireLogistique: start\n");

   /* decode itineraire_equipe */

   PU_PUSHNAME (ctxt_p, "itineraire_equipe");

   PU_NEWFIELD (ctxt_p, "boolean");

   stat = pd_bit (ctxt_p, &pvalue->itineraire_equipe);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_POPNAME (ctxt_p);

   /* decode poids_max_supporte */

   PU_PUSHNAME (ctxt_p, "poids_max_supporte");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->poids_max_supporte);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode largeur */

   PU_PUSHNAME (ctxt_p, "largeur");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->largeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode longueur */

   PU_PUSHNAME (ctxt_p, "longueur");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->longueur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode debit */

   PU_PUSHNAME (ctxt_p, "debit");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->debit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_AttrObjectItineraireLogistique: end\n");

   return (stat);
}

int ASN1C_AttrObjectItineraireLogistique::Decode ()
{
   return asn1PD_AttrObjectItineraireLogistique (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AttrObjectCampPrisonniers                                 */
/*                                                            */
/**************************************************************/

ASN1C_AttrObjectCampPrisonniers::ASN1C_AttrObjectCampPrisonniers (
   ASN1MessageBuffer& msgBuf, ASN1T_AttrObjectCampPrisonniers& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AttrObjectCampPrisonniers (ASN1CTXT* ctxt_p, ASN1T_AttrObjectCampPrisonniers* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AttrObjectCampPrisonniers: start\n");

   /* encode tc2 */

   PU_PUSHNAME (ctxt_p, "tc2");

   stat = asn1PE_Automate (ctxt_p, pvalue->tc2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_AttrObjectCampPrisonniers: end\n");
   return (stat);
}

int ASN1C_AttrObjectCampPrisonniers::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AttrObjectCampPrisonniers (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AttrObjectCampPrisonniers (ASN1CTXT* ctxt_p, ASN1T_AttrObjectCampPrisonniers* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AttrObjectCampPrisonniers: start\n");

   /* decode tc2 */

   PU_PUSHNAME (ctxt_p, "tc2");

   stat = asn1PD_Automate (ctxt_p, &pvalue->tc2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_AttrObjectCampPrisonniers: end\n");

   return (stat);
}

int ASN1C_AttrObjectCampPrisonniers::Decode ()
{
   return asn1PD_AttrObjectCampPrisonniers (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AttrObjectCampRefugies                                    */
/*                                                            */
/**************************************************************/

ASN1C_AttrObjectCampRefugies::ASN1C_AttrObjectCampRefugies (
   ASN1MessageBuffer& msgBuf, ASN1T_AttrObjectCampRefugies& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AttrObjectCampRefugies (ASN1CTXT* ctxt_p, ASN1T_AttrObjectCampRefugies* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AttrObjectCampRefugies: start\n");

   /* encode tc2 */

   PU_PUSHNAME (ctxt_p, "tc2");

   stat = asn1PE_Automate (ctxt_p, pvalue->tc2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_AttrObjectCampRefugies: end\n");
   return (stat);
}

int ASN1C_AttrObjectCampRefugies::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AttrObjectCampRefugies (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AttrObjectCampRefugies (ASN1CTXT* ctxt_p, ASN1T_AttrObjectCampRefugies* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AttrObjectCampRefugies: start\n");

   /* decode tc2 */

   PU_PUSHNAME (ctxt_p, "tc2");

   stat = asn1PD_Automate (ctxt_p, &pvalue->tc2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_AttrObjectCampRefugies: end\n");

   return (stat);
}

int ASN1C_AttrObjectCampRefugies::Decode ()
{
   return asn1PD_AttrObjectCampRefugies (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AttrObjectSpecific                                        */
/*                                                            */
/**************************************************************/

ASN1C_AttrObjectSpecific::ASN1C_AttrObjectSpecific (
   ASN1MessageBuffer& msgBuf, ASN1T_AttrObjectSpecific& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AttrObjectSpecific (ASN1CTXT* ctxt_p, ASN1T_AttrObjectSpecific* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AttrObjectSpecific: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (ctxt_p, "t");

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* site_franchissement */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.site_franchissement");

         stat = asn1PE_AttrObjectSiteFranchissement (ctxt_p, pvalue->u.site_franchissement);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* nuage_nbc */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.nuage_nbc");

         stat = asn1PE_AttrObjectNuageNBC (ctxt_p, pvalue->u.nuage_nbc);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* rota */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.rota");

         stat = asn1PE_AttrObjectROTA (ctxt_p, pvalue->u.rota);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* zone_nbc */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.zone_nbc");

         stat = asn1PE_AttrObjectZoneNBC (ctxt_p, pvalue->u.zone_nbc);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* itineraire_logistique */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.itineraire_logistique");

         stat = asn1PE_AttrObjectItineraireLogistique (ctxt_p, pvalue->u.itineraire_logistique);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* camp_prisonniers */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.camp_prisonniers");

         stat = asn1PE_AttrObjectCampPrisonniers (ctxt_p, pvalue->u.camp_prisonniers);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* camp_refugies */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.camp_refugies");

         stat = asn1PE_AttrObjectCampRefugies (ctxt_p, pvalue->u.camp_refugies);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PE_AttrObjectSpecific: end\n");
   return (stat);
}

int ASN1C_AttrObjectSpecific::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AttrObjectSpecific (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AttrObjectSpecific (ASN1CTXT* ctxt_p, ASN1T_AttrObjectSpecific* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_AttrObjectSpecific: start\n");

   PU_PUSHNAME (ctxt_p, "t");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (ctxt_p);

   switch (ui) {
      /* site_franchissement */
      case 0:
         PU_PUSHNAME (ctxt_p, "u.site_franchissement");

         pvalue->u.site_franchissement = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AttrObjectSiteFranchissement);
         if (pvalue->u.site_franchissement == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AttrObjectSiteFranchissement (ctxt_p, pvalue->u.site_franchissement);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* nuage_nbc */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.nuage_nbc");

         pvalue->u.nuage_nbc = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AttrObjectNuageNBC);
         if (pvalue->u.nuage_nbc == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AttrObjectNuageNBC (ctxt_p, pvalue->u.nuage_nbc);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* rota */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.rota");

         pvalue->u.rota = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AttrObjectROTA);
         if (pvalue->u.rota == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AttrObjectROTA (ctxt_p, pvalue->u.rota);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* zone_nbc */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.zone_nbc");

         pvalue->u.zone_nbc = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AttrObjectZoneNBC);
         if (pvalue->u.zone_nbc == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AttrObjectZoneNBC (ctxt_p, pvalue->u.zone_nbc);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* itineraire_logistique */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.itineraire_logistique");

         pvalue->u.itineraire_logistique = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AttrObjectItineraireLogistique);
         if (pvalue->u.itineraire_logistique == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AttrObjectItineraireLogistique (ctxt_p, pvalue->u.itineraire_logistique);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* camp_prisonniers */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.camp_prisonniers");

         pvalue->u.camp_prisonniers = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AttrObjectCampPrisonniers);
         if (pvalue->u.camp_prisonniers == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AttrObjectCampPrisonniers (ctxt_p, pvalue->u.camp_prisonniers);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* camp_refugies */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.camp_refugies");

         pvalue->u.camp_refugies = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AttrObjectCampRefugies);
         if (pvalue->u.camp_refugies == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AttrObjectCampRefugies (ctxt_p, pvalue->u.camp_refugies);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PD_AttrObjectSpecific: end\n");

   return (stat);
}

int ASN1C_AttrObjectSpecific::Decode ()
{
   return asn1PD_AttrObjectSpecific (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectCreation                                         */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectCreation::ASN1C_MsgObjectCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectCreation (ASN1CTXT* ctxt_p, ASN1T_MsgObjectCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectCreation: start\n");

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.attributs_specifiquesPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "type_dotation_constructionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.type_dotation_constructionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "type_dotation_valorisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.type_dotation_valorisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumObjectType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode localisation */

   PU_PUSHNAME (ctxt_p, "localisation");

   stat = asn1PE_Localisation (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nom */

   PU_PUSHNAME (ctxt_p, "nom");

   stat = pe_VisibleString (ctxt_p, pvalue->nom, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode camp */

   PU_PUSHNAME (ctxt_p, "camp");

   stat = asn1PE_Camp (ctxt_p, pvalue->camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PE_AttrObjectSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode type_dotation_construction */

   if (pvalue->m.type_dotation_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "type_dotation_construction");

      stat = asn1PE_TypeDotation (ctxt_p, pvalue->type_dotation_construction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode type_dotation_valorisation */

   if (pvalue->m.type_dotation_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "type_dotation_valorisation");

      stat = asn1PE_TypeDotation (ctxt_p, pvalue->type_dotation_valorisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgObjectCreation: end\n");
   return (stat);
}

int ASN1C_MsgObjectCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectCreation (ASN1CTXT* ctxt_p, ASN1T_MsgObjectCreation* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgObjectCreation: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.attributs_specifiquesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "type_dotation_constructionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.type_dotation_constructionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "type_dotation_valorisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.type_dotation_valorisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumObjectType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode localisation */

   PU_PUSHNAME (ctxt_p, "localisation");

   stat = asn1PD_Localisation (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nom */

   PU_PUSHNAME (ctxt_p, "nom");

   stat = pd_VisibleString (ctxt_p, &pvalue->nom, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode camp */

   PU_PUSHNAME (ctxt_p, "camp");

   stat = asn1PD_Camp (ctxt_p, &pvalue->camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PD_AttrObjectSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode type_dotation_construction */

   if (pvalue->m.type_dotation_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "type_dotation_construction");

      stat = asn1PD_TypeDotation (ctxt_p, &pvalue->type_dotation_construction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode type_dotation_valorisation */

   if (pvalue->m.type_dotation_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "type_dotation_valorisation");

      stat = asn1PD_TypeDotation (ctxt_p, &pvalue->type_dotation_valorisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgObjectCreation: end\n");

   return (stat);
}

int ASN1C_MsgObjectCreation::Decode ()
{
   return asn1PD_MsgObjectCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectDestruction                                      */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectDestruction::ASN1C_MsgObjectDestruction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectDestruction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectDestruction value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectDestruction: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_MsgObjectDestruction: end\n");
   return (stat);
}

int ASN1C_MsgObjectDestruction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectDestruction (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgObjectDestruction: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_MsgObjectDestruction: end\n");

   return (stat);
}

int ASN1C_MsgObjectDestruction::Decode ()
{
   return asn1PD_MsgObjectDestruction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectUpdate                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectUpdate::ASN1C_MsgObjectUpdate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectUpdate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgObjectUpdate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectUpdate: start\n");

   PU_NEWFIELD (ctxt_p, "pourcentage_constructionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_constructionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_valorisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_valorisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_creation_contournementPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_creation_contournementPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "en_preparationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->en_preparation != FALSE));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_dotation_constructionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nb_dotation_constructionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_dotation_valorisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nb_dotation_valorisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "localisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.localisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.attributs_specifiquesPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode pourcentage_construction */

   if (pvalue->m.pourcentage_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_construction");

      if ( (pvalue->pourcentage_construction >= 0 && pvalue->pourcentage_construction <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_construction, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode pourcentage_valorisation */

   if (pvalue->m.pourcentage_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_valorisation");

      if ( (pvalue->pourcentage_valorisation >= 0 && pvalue->pourcentage_valorisation <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_valorisation, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode pourcentage_creation_contournement */

   if (pvalue->m.pourcentage_creation_contournementPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_creation_contournement");

      if ( (pvalue->pourcentage_creation_contournement >= 0 && pvalue->pourcentage_creation_contournement <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_creation_contournement, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode en_preparation */

   if (pvalue->en_preparation != FALSE) {
      PU_PUSHNAME (ctxt_p, "en_preparation");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->en_preparation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode nb_dotation_construction */

   if (pvalue->m.nb_dotation_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "nb_dotation_construction");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nb_dotation_construction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode nb_dotation_valorisation */

   if (pvalue->m.nb_dotation_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "nb_dotation_valorisation");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nb_dotation_valorisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode localisation */

   if (pvalue->m.localisationPresent) {
      PU_PUSHNAME (ctxt_p, "localisation");

      stat = asn1PE_Localisation (ctxt_p, &pvalue->localisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PE_AttrObjectSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgObjectUpdate: end\n");
   return (stat);
}

int ASN1C_MsgObjectUpdate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectUpdate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgObjectUpdate* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL en_preparationPresent;

   rtdiag ("asn1PD_MsgObjectUpdate: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "pourcentage_constructionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_constructionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_valorisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_valorisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_creation_contournementPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_creation_contournementPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "en_preparationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else en_preparationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_dotation_constructionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nb_dotation_constructionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_dotation_valorisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nb_dotation_valorisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "localisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.localisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.attributs_specifiquesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode pourcentage_construction */

   if (pvalue->m.pourcentage_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_construction");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_construction, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pourcentage_valorisation */

   if (pvalue->m.pourcentage_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_valorisation");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_valorisation, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pourcentage_creation_contournement */

   if (pvalue->m.pourcentage_creation_contournementPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_creation_contournement");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_creation_contournement, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode en_preparation */

   if (en_preparationPresent) {
      PU_PUSHNAME (ctxt_p, "en_preparation");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->en_preparation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->en_preparation = FALSE;
   }

   /* decode nb_dotation_construction */

   if (pvalue->m.nb_dotation_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "nb_dotation_construction");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nb_dotation_construction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode nb_dotation_valorisation */

   if (pvalue->m.nb_dotation_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "nb_dotation_valorisation");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nb_dotation_valorisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode localisation */

   if (pvalue->m.localisationPresent) {
      PU_PUSHNAME (ctxt_p, "localisation");

      stat = asn1PD_Localisation (ctxt_p, &pvalue->localisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PD_AttrObjectSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgObjectUpdate: end\n");

   return (stat);
}

int ASN1C_MsgObjectUpdate::Decode ()
{
   return asn1PD_MsgObjectUpdate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionCreateObject                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionCreateObject::ASN1C_MagicActionCreateObject (
   ASN1MessageBuffer& msgBuf, ASN1T_MagicActionCreateObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MagicActionCreateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionCreateObject* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MagicActionCreateObject: start\n");

   PU_NEWFIELD (ctxt_p, "nomPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nomPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.attributs_specifiquesPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_camp */

   PU_PUSHNAME (ctxt_p, "oid_camp");

   stat = asn1PE_Camp (ctxt_p, pvalue->oid_camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumObjectType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode localisation */

   PU_PUSHNAME (ctxt_p, "localisation");

   stat = asn1PE_Localisation (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nom */

   if (pvalue->m.nomPresent) {
      PU_PUSHNAME (ctxt_p, "nom");

      stat = pe_VisibleString (ctxt_p, pvalue->nom, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PE_AttrObjectSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MagicActionCreateObject: end\n");
   return (stat);
}

int ASN1C_MagicActionCreateObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionCreateObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MagicActionCreateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionCreateObject* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MagicActionCreateObject: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "nomPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nomPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.attributs_specifiquesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_camp */

   PU_PUSHNAME (ctxt_p, "oid_camp");

   stat = asn1PD_Camp (ctxt_p, &pvalue->oid_camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumObjectType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode localisation */

   PU_PUSHNAME (ctxt_p, "localisation");

   stat = asn1PD_Localisation (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nom */

   if (pvalue->m.nomPresent) {
      PU_PUSHNAME (ctxt_p, "nom");

      stat = pd_VisibleString (ctxt_p, &pvalue->nom, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PD_AttrObjectSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MagicActionCreateObject: end\n");

   return (stat);
}

int ASN1C_MagicActionCreateObject::Decode ()
{
   return asn1PD_MagicActionCreateObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionUpdateObject                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionUpdateObject::ASN1C_MagicActionUpdateObject (
   ASN1MessageBuffer& msgBuf, ASN1T_MagicActionUpdateObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MagicActionUpdateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionUpdateObject* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MagicActionUpdateObject: start\n");

   PU_NEWFIELD (ctxt_p, "pourcentage_constructionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_constructionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_valorisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_valorisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_creation_contournementPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_creation_contournementPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "en_preparationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.en_preparationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode pourcentage_construction */

   if (pvalue->m.pourcentage_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_construction");

      if ( (pvalue->pourcentage_construction >= 0 && pvalue->pourcentage_construction <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_construction, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode pourcentage_valorisation */

   if (pvalue->m.pourcentage_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_valorisation");

      if ( (pvalue->pourcentage_valorisation >= 0 && pvalue->pourcentage_valorisation <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_valorisation, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode pourcentage_creation_contournement */

   if (pvalue->m.pourcentage_creation_contournementPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_creation_contournement");

      if ( (pvalue->pourcentage_creation_contournement >= 0 && pvalue->pourcentage_creation_contournement <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_creation_contournement, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode en_preparation */

   if (pvalue->m.en_preparationPresent) {
      PU_PUSHNAME (ctxt_p, "en_preparation");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->en_preparation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MagicActionUpdateObject: end\n");
   return (stat);
}

int ASN1C_MagicActionUpdateObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionUpdateObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MagicActionUpdateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionUpdateObject* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MagicActionUpdateObject: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "pourcentage_constructionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_constructionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_valorisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_valorisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_creation_contournementPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_creation_contournementPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "en_preparationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.en_preparationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode pourcentage_construction */

   if (pvalue->m.pourcentage_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_construction");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_construction, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pourcentage_valorisation */

   if (pvalue->m.pourcentage_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_valorisation");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_valorisation, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pourcentage_creation_contournement */

   if (pvalue->m.pourcentage_creation_contournementPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_creation_contournement");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_creation_contournement, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode en_preparation */

   if (pvalue->m.en_preparationPresent) {
      PU_PUSHNAME (ctxt_p, "en_preparation");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->en_preparation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MagicActionUpdateObject: end\n");

   return (stat);
}

int ASN1C_MagicActionUpdateObject::Decode ()
{
   return asn1PD_MagicActionUpdateObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionDestroyObjet                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionDestroyObjet::ASN1C_MagicActionDestroyObjet (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_MagicActionDestroyObjet (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MagicActionDestroyObjet: start\n");

   /* NULL */

   rtdiag ("asn1PE_MagicActionDestroyObjet: end\n");
   return (stat);
}

int ASN1C_MagicActionDestroyObjet::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionDestroyObjet (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_MagicActionDestroyObjet (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MagicActionDestroyObjet: start\n");

   /* NULL */

   rtdiag ("asn1PD_MagicActionDestroyObjet: end\n");

   return (stat);
}

int ASN1C_MagicActionDestroyObjet::Decode ()
{
   return asn1PD_MagicActionDestroyObjet (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicAction_action                               */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicAction_action::ASN1C_MsgObjectMagicAction_action (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicAction_action& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicAction_action (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction_action* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectMagicAction_action: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (ctxt_p, "t");

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* create_object */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.create_object");

         stat = asn1PE_MagicActionCreateObject (ctxt_p, pvalue->u.create_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* update_object */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.update_object");

         stat = asn1PE_MagicActionUpdateObject (ctxt_p, pvalue->u.update_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* destroy_object */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.destroy_object");

         stat = asn1PE_MagicActionDestroyObjet (ctxt_p);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PE_MsgObjectMagicAction_action: end\n");
   return (stat);
}

int ASN1C_MsgObjectMagicAction_action::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicAction_action (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicAction_action (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction_action* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_MsgObjectMagicAction_action: start\n");

   PU_PUSHNAME (ctxt_p, "t");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (ctxt_p);

   switch (ui) {
      /* create_object */
      case 0:
         PU_PUSHNAME (ctxt_p, "u.create_object");

         pvalue->u.create_object = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MagicActionCreateObject);
         if (pvalue->u.create_object == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_MagicActionCreateObject (ctxt_p, pvalue->u.create_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* update_object */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.update_object");

         pvalue->u.update_object = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MagicActionUpdateObject);
         if (pvalue->u.update_object == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_MagicActionUpdateObject (ctxt_p, pvalue->u.update_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* destroy_object */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.destroy_object");

         stat = asn1PD_MagicActionDestroyObjet (ctxt_p);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PD_MsgObjectMagicAction_action: end\n");

   return (stat);
}

int ASN1C_MsgObjectMagicAction_action::Decode ()
{
   return asn1PD_MsgObjectMagicAction_action (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicAction                                      */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicAction::ASN1C_MsgObjectMagicAction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicAction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicAction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectMagicAction: start\n");

   /* encode oid_objet */

   PU_PUSHNAME (ctxt_p, "oid_objet");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_objet);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode action */

   PU_PUSHNAME (ctxt_p, "action");

   stat = asn1PE_MsgObjectMagicAction_action (ctxt_p, &pvalue->action);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgObjectMagicAction: end\n");
   return (stat);
}

int ASN1C_MsgObjectMagicAction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicAction (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicAction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgObjectMagicAction: start\n");

   /* decode oid_objet */

   PU_PUSHNAME (ctxt_p, "oid_objet");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_objet);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode action */

   PU_PUSHNAME (ctxt_p, "action");

   stat = asn1PD_MsgObjectMagicAction_action (ctxt_p, &pvalue->action);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgObjectMagicAction: end\n");

   return (stat);
}

int ASN1C_MsgObjectMagicAction::Decode ()
{
   return asn1PD_MsgObjectMagicAction (mpContext->GetPtr(), &msgData);
}

