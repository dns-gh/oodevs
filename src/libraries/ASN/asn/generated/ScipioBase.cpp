/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 20-Oct-2005.
 */
#include "ScipioBase.h"

/* Value assignments */


/**************************************************************/
/*                                                            */
/*  EnumTypeLocalisation                                      */
/*                                                            */
/**************************************************************/

ASN1C_EnumTypeLocalisation::ASN1C_EnumTypeLocalisation (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumTypeLocalisation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumTypeLocalisation (ASN1CTXT* ctxt_p, ASN1T_EnumTypeLocalisation value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumTypeLocalisation: start\n");

   switch (value) {
      case EnumTypeLocalisation::circle: ui = 0; break;
      case EnumTypeLocalisation::ellipse: ui = 1; break;
      case EnumTypeLocalisation::line: ui = 2; break;
      case EnumTypeLocalisation::polygon: ui = 3; break;
      case EnumTypeLocalisation::point: ui = 4; break;
      case EnumTypeLocalisation::sector: ui = 5; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 5);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumTypeLocalisation: end\n");
   return (stat);
}

int ASN1C_EnumTypeLocalisation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumTypeLocalisation (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumTypeLocalisation (ASN1CTXT* ctxt_p, ASN1T_EnumTypeLocalisation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumTypeLocalisation: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 5);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumTypeLocalisation::circle; break;
      case 1: *pvalue = EnumTypeLocalisation::ellipse; break;
      case 2: *pvalue = EnumTypeLocalisation::line; break;
      case 3: *pvalue = EnumTypeLocalisation::polygon; break;
      case 4: *pvalue = EnumTypeLocalisation::point; break;
      case 5: *pvalue = EnumTypeLocalisation::sector; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumTypeLocalisation: end\n");

   return (stat);
}

int ASN1C_EnumTypeLocalisation::Decode ()
{
   return asn1PD_EnumTypeLocalisation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  CoordUTM                                                  */
/*                                                            */
/**************************************************************/

ASN1C_CoordUTM::ASN1C_CoordUTM (
   ASN1MessageBuffer& msgBuf, ASN1T_CoordUTM& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_CoordUTM (ASN1CTXT* ctxt_p, ASN1T_CoordUTM value)
{
   Asn1SizeCnst lsize1 = { 0, 15, 15, 0 };
   int stat = ASN_OK;

   rtdiag ("asn1PE_CoordUTM: start\n");

   stat = pu_addSizeConstraint (ctxt_p, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   stat = pe_OctetString (ctxt_p, value.numocts, value.data);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_CoordUTM: end\n");
   return (stat);
}

int ASN1C_CoordUTM::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_CoordUTM (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_CoordUTM (ASN1CTXT* ctxt_p, ASN1T_CoordUTM* pvalue)
{
   Asn1SizeCnst lsize1 = { 0, 15, 15, 0 };
   int stat = ASN_OK;

   rtdiag ("asn1PD_CoordUTM: start\n");

   stat = pu_addSizeConstraint (ctxt_p, &lsize1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   stat = pd_OctetString (ctxt_p,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_CoordUTM: end\n");

   return (stat);
}

int ASN1C_CoordUTM::Decode ()
{
   return asn1PD_CoordUTM (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfCoordUTM                                            */
/*                                                            */
/**************************************************************/

ASN1C__SeqOfCoordUTM::ASN1C__SeqOfCoordUTM (
   ASN1MessageBuffer& msgBuf, ASN1T__SeqOfCoordUTM& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE__SeqOfCoordUTM (ASN1CTXT* ctxt_p, ASN1T__SeqOfCoordUTM* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE__SeqOfCoordUTM: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_CoordUTM (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE__SeqOfCoordUTM: end\n");
   return (stat);
}

int ASN1C__SeqOfCoordUTM::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE__SeqOfCoordUTM (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD__SeqOfCoordUTM (ASN1CTXT* ctxt_p, ASN1T__SeqOfCoordUTM* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD__SeqOfCoordUTM: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_CoordUTM);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_CoordUTM (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD__SeqOfCoordUTM: end\n");

   return (stat);
}

int ASN1C__SeqOfCoordUTM::Decode ()
{
   return asn1PD__SeqOfCoordUTM (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Localisation                                              */
/*                                                            */
/**************************************************************/

ASN1C_Localisation::ASN1C_Localisation (
   ASN1MessageBuffer& msgBuf, ASN1T_Localisation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Localisation (ASN1CTXT* ctxt_p, ASN1T_Localisation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Localisation: start\n");

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumTypeLocalisation (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode vecteur_point */

   PU_PUSHNAME (ctxt_p, "vecteur_point");

   stat = asn1PE__SeqOfCoordUTM (ctxt_p, &pvalue->vecteur_point);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_Localisation: end\n");
   return (stat);
}

int ASN1C_Localisation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Localisation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Localisation (ASN1CTXT* ctxt_p, ASN1T_Localisation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Localisation: start\n");

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumTypeLocalisation (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode vecteur_point */

   PU_PUSHNAME (ctxt_p, "vecteur_point");

   stat = asn1PD__SeqOfCoordUTM (ctxt_p, &pvalue->vecteur_point);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_Localisation: end\n");

   return (stat);
}

int ASN1C_Localisation::Decode ()
{
   return asn1PD_Localisation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Polygon                                                   */
/*                                                            */
/**************************************************************/

ASN1C_Polygon::ASN1C_Polygon (
   ASN1MessageBuffer& msgBuf, ASN1T_Polygon& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Polygon (ASN1CTXT* ctxt_p, ASN1T_Polygon* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Polygon: start\n");

   stat = asn1PE_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Polygon: end\n");
   return (stat);
}

int ASN1C_Polygon::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Polygon (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Polygon (ASN1CTXT* ctxt_p, ASN1T_Polygon* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Polygon: start\n");

   stat = asn1PD_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Polygon: end\n");

   return (stat);
}

int ASN1C_Polygon::Decode ()
{
   return asn1PD_Polygon (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  OID                                                       */
/*                                                            */
/**************************************************************/

ASN1C_OID::ASN1C_OID (
   ASN1MessageBuffer& msgBuf, ASN1T_OID& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_OID (ASN1CTXT* ctxt_p, ASN1T_OID value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_OID: start\n");

   stat = pe_ConsUnsigned (ctxt_p, value, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);


   rtdiag ("asn1PE_OID: end\n");
   return (stat);
}

int ASN1C_OID::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OID (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_OID (ASN1CTXT* ctxt_p, ASN1T_OID* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_OID: start\n");

   stat = pd_ConsUnsigned (ctxt_p, pvalue, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_OID: end\n");

   return (stat);
}

int ASN1C_OID::Decode ()
{
   return asn1PD_OID (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Automate                                                  */
/*                                                            */
/**************************************************************/

ASN1C_Automate::ASN1C_Automate (
   ASN1MessageBuffer& msgBuf, ASN1T_Automate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Automate (ASN1CTXT* ctxt_p, ASN1T_Automate value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Automate: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Automate: end\n");
   return (stat);
}

int ASN1C_Automate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Automate (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Automate (ASN1CTXT* ctxt_p, ASN1T_Automate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Automate: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Automate: end\n");

   return (stat);
}

int ASN1C_Automate::Decode ()
{
   return asn1PD_Automate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Itineraire                                                */
/*                                                            */
/**************************************************************/

ASN1C_Itineraire::ASN1C_Itineraire (
   ASN1MessageBuffer& msgBuf, ASN1T_Itineraire& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Itineraire (ASN1CTXT* ctxt_p, ASN1T_Itineraire* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Itineraire: start\n");

   stat = asn1PE_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Itineraire: end\n");
   return (stat);
}

int ASN1C_Itineraire::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Itineraire (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Itineraire (ASN1CTXT* ctxt_p, ASN1T_Itineraire* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Itineraire: start\n");

   stat = asn1PD_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Itineraire: end\n");

   return (stat);
}

int ASN1C_Itineraire::Decode ()
{
   return asn1PD_Itineraire (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Agent                                                     */
/*                                                            */
/**************************************************************/

ASN1C_Agent::ASN1C_Agent (
   ASN1MessageBuffer& msgBuf, ASN1T_Agent& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Agent (ASN1CTXT* ctxt_p, ASN1T_Agent value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Agent: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Agent: end\n");
   return (stat);
}

int ASN1C_Agent::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Agent (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Agent (ASN1CTXT* ctxt_p, ASN1T_Agent* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Agent: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Agent: end\n");

   return (stat);
}

int ASN1C_Agent::Decode ()
{
   return asn1PD_Agent (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListAgent                                                 */
/*                                                            */
/**************************************************************/

ASN1C_ListAgent::ASN1C_ListAgent (
   ASN1MessageBuffer& msgBuf, ASN1T_ListAgent& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListAgent (ASN1CTXT* ctxt_p, ASN1T_ListAgent* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListAgent: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_Agent (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListAgent: end\n");
   return (stat);
}

int ASN1C_ListAgent::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListAgent (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListAgent (ASN1CTXT* ctxt_p, ASN1T_ListAgent* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListAgent: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_Agent);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_Agent (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListAgent: end\n");

   return (stat);
}

int ASN1C_ListAgent::Decode ()
{
   return asn1PD_ListAgent (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Point                                                     */
/*                                                            */
/**************************************************************/

ASN1C_Point::ASN1C_Point (
   ASN1MessageBuffer& msgBuf, ASN1T_Point& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Point (ASN1CTXT* ctxt_p, ASN1T_Point* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Point: start\n");

   stat = asn1PE_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Point: end\n");
   return (stat);
}

int ASN1C_Point::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Point (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Point (ASN1CTXT* ctxt_p, ASN1T_Point* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Point: start\n");

   stat = asn1PD_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Point: end\n");

   return (stat);
}

int ASN1C_Point::Decode ()
{
   return asn1PD_Point (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  NatureAtlas                                               */
/*                                                            */
/**************************************************************/

ASN1C_NatureAtlas::ASN1C_NatureAtlas (
   ASN1MessageBuffer& msgBuf, ASN1T_NatureAtlas& data) :
   ASN1CBitStr (msgBuf, data.data, data.numbits, 16), msgData(data)
{}

EXTERN int asn1PE_NatureAtlas (ASN1CTXT* ctxt_p, ASN1T_NatureAtlas value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_NatureAtlas: start\n");

   stat = pe_BitString (ctxt_p, value.numbits, value.data);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_NatureAtlas: end\n");
   return (stat);
}

int ASN1C_NatureAtlas::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_NatureAtlas (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_NatureAtlas (ASN1CTXT* ctxt_p, ASN1T_NatureAtlas* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_NatureAtlas: start\n");

   stat = pd_BitString (ctxt_p,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_NatureAtlas: end\n");

   return (stat);
}

int ASN1C_NatureAtlas::Decode ()
{
   return asn1PD_NatureAtlas (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  KnowledgeObject                                           */
/*                                                            */
/**************************************************************/

ASN1C_KnowledgeObject::ASN1C_KnowledgeObject (
   ASN1MessageBuffer& msgBuf, ASN1T_KnowledgeObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_KnowledgeObject (ASN1CTXT* ctxt_p, ASN1T_KnowledgeObject value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_KnowledgeObject: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_KnowledgeObject: end\n");
   return (stat);
}

int ASN1C_KnowledgeObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_KnowledgeObject (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_KnowledgeObject (ASN1CTXT* ctxt_p, ASN1T_KnowledgeObject* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_KnowledgeObject: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_KnowledgeObject: end\n");

   return (stat);
}

int ASN1C_KnowledgeObject::Decode ()
{
   return asn1PD_KnowledgeObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListKnowledgeObject                                       */
/*                                                            */
/**************************************************************/

ASN1C_ListKnowledgeObject::ASN1C_ListKnowledgeObject (
   ASN1MessageBuffer& msgBuf, ASN1T_ListKnowledgeObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListKnowledgeObject (ASN1CTXT* ctxt_p, ASN1T_ListKnowledgeObject* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListKnowledgeObject: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_KnowledgeObject (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListKnowledgeObject: end\n");
   return (stat);
}

int ASN1C_ListKnowledgeObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListKnowledgeObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListKnowledgeObject (ASN1CTXT* ctxt_p, ASN1T_ListKnowledgeObject* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListKnowledgeObject: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_KnowledgeObject);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_KnowledgeObject (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListKnowledgeObject: end\n");

   return (stat);
}

int ASN1C_ListKnowledgeObject::Decode ()
{
   return asn1PD_ListKnowledgeObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListPoint                                                 */
/*                                                            */
/**************************************************************/

ASN1C_ListPoint::ASN1C_ListPoint (
   ASN1MessageBuffer& msgBuf, ASN1T_ListPoint& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListPoint (ASN1CTXT* ctxt_p, ASN1T_ListPoint* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListPoint: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_Point (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListPoint: end\n");
   return (stat);
}

int ASN1C_ListPoint::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListPoint (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListPoint (ASN1CTXT* ctxt_p, ASN1T_ListPoint* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListPoint: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_Point);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_Point (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListPoint: end\n");

   return (stat);
}

int ASN1C_ListPoint::Decode ()
{
   return asn1PD_ListPoint (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Angle                                                     */
/*                                                            */
/**************************************************************/

ASN1C_Angle::ASN1C_Angle (
   ASN1MessageBuffer& msgBuf, ASN1T_Angle& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Angle (ASN1CTXT* ctxt_p, ASN1T_Angle value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Angle: start\n");

   if ( (value >= 0 && value <= 360) ) {
      stat = pe_ConsInteger (ctxt_p, value, 0, 360);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   }
   else
      return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);


   rtdiag ("asn1PE_Angle: end\n");
   return (stat);
}

int ASN1C_Angle::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Angle (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Angle (ASN1CTXT* ctxt_p, ASN1T_Angle* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Angle: start\n");

   stat = pd_ConsInteger (ctxt_p, pvalue, 0, 360);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Angle: end\n");

   return (stat);
}

int ASN1C_Angle::Decode ()
{
   return asn1PD_Angle (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListItineraire                                            */
/*                                                            */
/**************************************************************/

ASN1C_ListItineraire::ASN1C_ListItineraire (
   ASN1MessageBuffer& msgBuf, ASN1T_ListItineraire& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListItineraire (ASN1CTXT* ctxt_p, ASN1T_ListItineraire* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListItineraire: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_Itineraire (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListItineraire: end\n");
   return (stat);
}

int ASN1C_ListItineraire::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListItineraire (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListItineraire (ASN1CTXT* ctxt_p, ASN1T_ListItineraire* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListItineraire: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_Itineraire);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_Itineraire (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListItineraire: end\n");

   return (stat);
}

int ASN1C_ListItineraire::Decode ()
{
   return asn1PD_ListItineraire (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListPolygon                                               */
/*                                                            */
/**************************************************************/

ASN1C_ListPolygon::ASN1C_ListPolygon (
   ASN1MessageBuffer& msgBuf, ASN1T_ListPolygon& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListPolygon (ASN1CTXT* ctxt_p, ASN1T_ListPolygon* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListPolygon: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_Polygon (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListPolygon: end\n");
   return (stat);
}

int ASN1C_ListPolygon::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListPolygon (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListPolygon (ASN1CTXT* ctxt_p, ASN1T_ListPolygon* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListPolygon: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_Polygon);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_Polygon (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListPolygon: end\n");

   return (stat);
}

int ASN1C_ListPolygon::Decode ()
{
   return asn1PD_ListPolygon (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListOID                                                   */
/*                                                            */
/**************************************************************/

ASN1C_ListOID::ASN1C_ListOID (
   ASN1MessageBuffer& msgBuf, ASN1T_ListOID& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListOID (ASN1CTXT* ctxt_p, ASN1T_ListOID* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListOID: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_OID (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListOID: end\n");
   return (stat);
}

int ASN1C_ListOID::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListOID (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListOID (ASN1CTXT* ctxt_p, ASN1T_ListOID* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListOID: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_OID);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_OID (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListOID: end\n");

   return (stat);
}

int ASN1C_ListOID::Decode ()
{
   return asn1PD_ListOID (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  KnowledgeAgent                                            */
/*                                                            */
/**************************************************************/

ASN1C_KnowledgeAgent::ASN1C_KnowledgeAgent (
   ASN1MessageBuffer& msgBuf, ASN1T_KnowledgeAgent& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_KnowledgeAgent (ASN1CTXT* ctxt_p, ASN1T_KnowledgeAgent value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_KnowledgeAgent: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_KnowledgeAgent: end\n");
   return (stat);
}

int ASN1C_KnowledgeAgent::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_KnowledgeAgent (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_KnowledgeAgent (ASN1CTXT* ctxt_p, ASN1T_KnowledgeAgent* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_KnowledgeAgent: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_KnowledgeAgent: end\n");

   return (stat);
}

int ASN1C_KnowledgeAgent::Decode ()
{
   return asn1PD_KnowledgeAgent (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListKnowledgeAgent                                        */
/*                                                            */
/**************************************************************/

ASN1C_ListKnowledgeAgent::ASN1C_ListKnowledgeAgent (
   ASN1MessageBuffer& msgBuf, ASN1T_ListKnowledgeAgent& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListKnowledgeAgent (ASN1CTXT* ctxt_p, ASN1T_ListKnowledgeAgent* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListKnowledgeAgent: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_KnowledgeAgent (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListKnowledgeAgent: end\n");
   return (stat);
}

int ASN1C_ListKnowledgeAgent::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListKnowledgeAgent (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListKnowledgeAgent (ASN1CTXT* ctxt_p, ASN1T_ListKnowledgeAgent* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListKnowledgeAgent: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_KnowledgeAgent);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_KnowledgeAgent (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListKnowledgeAgent: end\n");

   return (stat);
}

int ASN1C_ListKnowledgeAgent::Decode ()
{
   return asn1PD_ListKnowledgeAgent (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Line                                                      */
/*                                                            */
/**************************************************************/

ASN1C_Line::ASN1C_Line (
   ASN1MessageBuffer& msgBuf, ASN1T_Line& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Line (ASN1CTXT* ctxt_p, ASN1T_Line* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Line: start\n");

   stat = asn1PE_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Line: end\n");
   return (stat);
}

int ASN1C_Line::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Line (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Line (ASN1CTXT* ctxt_p, ASN1T_Line* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Line: start\n");

   stat = asn1PD_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Line: end\n");

   return (stat);
}

int ASN1C_Line::Decode ()
{
   return asn1PD_Line (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumGDH_Qualificatif                                      */
/*                                                            */
/**************************************************************/

ASN1C_EnumGDH_Qualificatif::ASN1C_EnumGDH_Qualificatif (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumGDH_Qualificatif& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumGDH_Qualificatif (ASN1CTXT* ctxt_p, ASN1T_EnumGDH_Qualificatif value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumGDH_Qualificatif: start\n");

   switch (value) {
      case EnumGDH_Qualificatif::at: ui = 0; break;
      case EnumGDH_Qualificatif::after: ui = 1; break;
      case EnumGDH_Qualificatif::as_of: ui = 2; break;
      case EnumGDH_Qualificatif::before: ui = 3; break;
      case EnumGDH_Qualificatif::cleared: ui = 4; break;
      case EnumGDH_Qualificatif::due: ui = 5; break;
      case EnumGDH_Qualificatif::end: ui = 6; break;
      case EnumGDH_Qualificatif::off: ui = 7; break;
      case EnumGDH_Qualificatif::on: ui = 8; break;
      case EnumGDH_Qualificatif::since: ui = 9; break;
      case EnumGDH_Qualificatif::start: ui = 10; break;
      case EnumGDH_Qualificatif::until: ui = 11; break;
      case EnumGDH_Qualificatif::wef: ui = 12; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 12);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumGDH_Qualificatif: end\n");
   return (stat);
}

int ASN1C_EnumGDH_Qualificatif::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumGDH_Qualificatif (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumGDH_Qualificatif (ASN1CTXT* ctxt_p, ASN1T_EnumGDH_Qualificatif* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumGDH_Qualificatif: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 12);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumGDH_Qualificatif::at; break;
      case 1: *pvalue = EnumGDH_Qualificatif::after; break;
      case 2: *pvalue = EnumGDH_Qualificatif::as_of; break;
      case 3: *pvalue = EnumGDH_Qualificatif::before; break;
      case 4: *pvalue = EnumGDH_Qualificatif::cleared; break;
      case 5: *pvalue = EnumGDH_Qualificatif::due; break;
      case 6: *pvalue = EnumGDH_Qualificatif::end; break;
      case 7: *pvalue = EnumGDH_Qualificatif::off; break;
      case 8: *pvalue = EnumGDH_Qualificatif::on; break;
      case 9: *pvalue = EnumGDH_Qualificatif::since; break;
      case 10: *pvalue = EnumGDH_Qualificatif::start; break;
      case 11: *pvalue = EnumGDH_Qualificatif::until; break;
      case 12: *pvalue = EnumGDH_Qualificatif::wef; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumGDH_Qualificatif: end\n");

   return (stat);
}

int ASN1C_EnumGDH_Qualificatif::Decode ()
{
   return asn1PD_EnumGDH_Qualificatif (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  GDH                                                       */
/*                                                            */
/**************************************************************/

ASN1C_GDH::ASN1C_GDH (
   ASN1MessageBuffer& msgBuf, ASN1T_GDH& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_GDH (ASN1CTXT* ctxt_p, ASN1T_GDH* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_GDH: start\n");

   /* encode datation */

   PU_PUSHNAME (ctxt_p, "datation");

   stat = pe_ConsUnsigned (ctxt_p, pvalue->datation, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode qualificatif */

   PU_PUSHNAME (ctxt_p, "qualificatif");

   stat = asn1PE_EnumGDH_Qualificatif (ctxt_p, pvalue->qualificatif);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_GDH: end\n");
   return (stat);
}

int ASN1C_GDH::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_GDH (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_GDH (ASN1CTXT* ctxt_p, ASN1T_GDH* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_GDH: start\n");

   /* decode datation */

   PU_PUSHNAME (ctxt_p, "datation");

   stat = pd_ConsUnsigned (ctxt_p, &pvalue->datation, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode qualificatif */

   PU_PUSHNAME (ctxt_p, "qualificatif");

   stat = asn1PD_EnumGDH_Qualificatif (ctxt_p, &pvalue->qualificatif);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_GDH: end\n");

   return (stat);
}

int ASN1C_GDH::Decode ()
{
   return asn1PD_GDH (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Direction                                                 */
/*                                                            */
/**************************************************************/

ASN1C_Direction::ASN1C_Direction (
   ASN1MessageBuffer& msgBuf, ASN1T_Direction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Direction (ASN1CTXT* ctxt_p, ASN1T_Direction value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Direction: start\n");

   if ( (value >= 0 && value <= 360) ) {
      stat = pe_ConsInteger (ctxt_p, value, 0, 360);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   }
   else
      return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);


   rtdiag ("asn1PE_Direction: end\n");
   return (stat);
}

int ASN1C_Direction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Direction (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Direction (ASN1CTXT* ctxt_p, ASN1T_Direction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Direction: start\n");

   stat = pd_ConsInteger (ctxt_p, pvalue, 0, 360);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Direction: end\n");

   return (stat);
}

int ASN1C_Direction::Decode ()
{
   return asn1PD_Direction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumUnitIdentificationLevel                               */
/*                                                            */
/**************************************************************/

ASN1C_EnumUnitIdentificationLevel::ASN1C_EnumUnitIdentificationLevel (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumUnitIdentificationLevel& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumUnitIdentificationLevel (ASN1CTXT* ctxt_p, ASN1T_EnumUnitIdentificationLevel value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumUnitIdentificationLevel: start\n");

   switch (value) {
      case EnumUnitIdentificationLevel::identifiee: ui = 0; break;
      case EnumUnitIdentificationLevel::reconnue: ui = 1; break;
      case EnumUnitIdentificationLevel::detectee: ui = 2; break;
      case EnumUnitIdentificationLevel::signale: ui = 3; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumUnitIdentificationLevel: end\n");
   return (stat);
}

int ASN1C_EnumUnitIdentificationLevel::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumUnitIdentificationLevel (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumUnitIdentificationLevel (ASN1CTXT* ctxt_p, ASN1T_EnumUnitIdentificationLevel* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumUnitIdentificationLevel: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumUnitIdentificationLevel::identifiee; break;
      case 1: *pvalue = EnumUnitIdentificationLevel::reconnue; break;
      case 2: *pvalue = EnumUnitIdentificationLevel::detectee; break;
      case 3: *pvalue = EnumUnitIdentificationLevel::signale; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumUnitIdentificationLevel: end\n");

   return (stat);
}

int ASN1C_EnumUnitIdentificationLevel::Decode ()
{
   return asn1PD_EnumUnitIdentificationLevel (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Segment                                                   */
/*                                                            */
/**************************************************************/

ASN1C_Segment::ASN1C_Segment (
   ASN1MessageBuffer& msgBuf, ASN1T_Segment& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Segment (ASN1CTXT* ctxt_p, ASN1T_Segment* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Segment: start\n");

   stat = asn1PE_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Segment: end\n");
   return (stat);
}

int ASN1C_Segment::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Segment (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Segment (ASN1CTXT* ctxt_p, ASN1T_Segment* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Segment: start\n");

   stat = asn1PD_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Segment: end\n");

   return (stat);
}

int ASN1C_Segment::Decode ()
{
   return asn1PD_Segment (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Circle                                                    */
/*                                                            */
/**************************************************************/

ASN1C_Circle::ASN1C_Circle (
   ASN1MessageBuffer& msgBuf, ASN1T_Circle& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Circle (ASN1CTXT* ctxt_p, ASN1T_Circle* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Circle: start\n");

   stat = asn1PE_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Circle: end\n");
   return (stat);
}

int ASN1C_Circle::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Circle (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Circle (ASN1CTXT* ctxt_p, ASN1T_Circle* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Circle: start\n");

   stat = asn1PD_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Circle: end\n");

   return (stat);
}

int ASN1C_Circle::Decode ()
{
   return asn1PD_Circle (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Ellipse                                                   */
/*                                                            */
/**************************************************************/

ASN1C_Ellipse::ASN1C_Ellipse (
   ASN1MessageBuffer& msgBuf, ASN1T_Ellipse& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Ellipse (ASN1CTXT* ctxt_p, ASN1T_Ellipse* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Ellipse: start\n");

   stat = asn1PE_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Ellipse: end\n");
   return (stat);
}

int ASN1C_Ellipse::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Ellipse (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Ellipse (ASN1CTXT* ctxt_p, ASN1T_Ellipse* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Ellipse: start\n");

   stat = asn1PD_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Ellipse: end\n");

   return (stat);
}

int ASN1C_Ellipse::Decode ()
{
   return asn1PD_Ellipse (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Sector                                                    */
/*                                                            */
/**************************************************************/

ASN1C_Sector::ASN1C_Sector (
   ASN1MessageBuffer& msgBuf, ASN1T_Sector& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Sector (ASN1CTXT* ctxt_p, ASN1T_Sector* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Sector: start\n");

   stat = asn1PE_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Sector: end\n");
   return (stat);
}

int ASN1C_Sector::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Sector (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_Sector (ASN1CTXT* ctxt_p, ASN1T_Sector* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Sector: start\n");

   stat = asn1PD_Localisation (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Sector: end\n");

   return (stat);
}

int ASN1C_Sector::Decode ()
{
   return asn1PD_Sector (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListLocalisation                                          */
/*                                                            */
/**************************************************************/

ASN1C_ListLocalisation::ASN1C_ListLocalisation (
   ASN1MessageBuffer& msgBuf, ASN1T_ListLocalisation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListLocalisation (ASN1CTXT* ctxt_p, ASN1T_ListLocalisation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListLocalisation: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_Localisation (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListLocalisation: end\n");
   return (stat);
}

int ASN1C_ListLocalisation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListLocalisation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListLocalisation (ASN1CTXT* ctxt_p, ASN1T_ListLocalisation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListLocalisation: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_Localisation);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_Localisation (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListLocalisation: end\n");

   return (stat);
}

int ASN1C_ListLocalisation::Decode ()
{
   return asn1PD_ListLocalisation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  TirIndirect                                               */
/*                                                            */
/**************************************************************/

ASN1C_TirIndirect::ASN1C_TirIndirect (
   ASN1MessageBuffer& msgBuf, ASN1T_TirIndirect& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_TirIndirect (ASN1CTXT* ctxt_p, ASN1T_TirIndirect value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_TirIndirect: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_TirIndirect: end\n");
   return (stat);
}

int ASN1C_TirIndirect::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_TirIndirect (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_TirIndirect (ASN1CTXT* ctxt_p, ASN1T_TirIndirect* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_TirIndirect: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_TirIndirect: end\n");

   return (stat);
}

int ASN1C_TirIndirect::Decode ()
{
   return asn1PD_TirIndirect (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  TirDirect                                                 */
/*                                                            */
/**************************************************************/

ASN1C_TirDirect::ASN1C_TirDirect (
   ASN1MessageBuffer& msgBuf, ASN1T_TirDirect& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_TirDirect (ASN1CTXT* ctxt_p, ASN1T_TirDirect value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_TirDirect: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_TirDirect: end\n");
   return (stat);
}

int ASN1C_TirDirect::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_TirDirect (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_TirDirect (ASN1CTXT* ctxt_p, ASN1T_TirDirect* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_TirDirect: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_TirDirect: end\n");

   return (stat);
}

int ASN1C_TirDirect::Decode ()
{
   return asn1PD_TirDirect (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Population                                                */
/*                                                            */
/**************************************************************/

ASN1C_Population::ASN1C_Population (
   ASN1MessageBuffer& msgBuf, ASN1T_Population& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Population (ASN1CTXT* ctxt_p, ASN1T_Population value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Population: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_Population: end\n");
   return (stat);
}

int ASN1C_Population::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Population (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Population (ASN1CTXT* ctxt_p, ASN1T_Population* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Population: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Population: end\n");

   return (stat);
}

int ASN1C_Population::Decode ()
{
   return asn1PD_Population (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListAutomate                                              */
/*                                                            */
/**************************************************************/

ASN1C_ListAutomate::ASN1C_ListAutomate (
   ASN1MessageBuffer& msgBuf, ASN1T_ListAutomate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListAutomate (ASN1CTXT* ctxt_p, ASN1T_ListAutomate* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListAutomate: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_Automate (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListAutomate: end\n");
   return (stat);
}

int ASN1C_ListAutomate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListAutomate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListAutomate (ASN1CTXT* ctxt_p, ASN1T_ListAutomate* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListAutomate: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_Automate);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_Automate (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListAutomate: end\n");

   return (stat);
}

int ASN1C_ListAutomate::Decode ()
{
   return asn1PD_ListAutomate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  TypeEquipement                                            */
/*                                                            */
/**************************************************************/

ASN1C_TypeEquipement::ASN1C_TypeEquipement (
   ASN1MessageBuffer& msgBuf, ASN1T_TypeEquipement& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_TypeEquipement (ASN1CTXT* ctxt_p, ASN1T_TypeEquipement value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_TypeEquipement: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_TypeEquipement: end\n");
   return (stat);
}

int ASN1C_TypeEquipement::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_TypeEquipement (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_TypeEquipement (ASN1CTXT* ctxt_p, ASN1T_TypeEquipement* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_TypeEquipement: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_TypeEquipement: end\n");

   return (stat);
}

int ASN1C_TypeEquipement::Decode ()
{
   return asn1PD_TypeEquipement (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  TypeDotation                                              */
/*                                                            */
/**************************************************************/

ASN1C_TypeDotation::ASN1C_TypeDotation (
   ASN1MessageBuffer& msgBuf, ASN1T_TypeDotation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_TypeDotation (ASN1CTXT* ctxt_p, ASN1T_TypeDotation value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_TypeDotation: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_TypeDotation: end\n");
   return (stat);
}

int ASN1C_TypeDotation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_TypeDotation (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_TypeDotation (ASN1CTXT* ctxt_p, ASN1T_TypeDotation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_TypeDotation: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_TypeDotation: end\n");

   return (stat);
}

int ASN1C_TypeDotation::Decode ()
{
   return asn1PD_TypeDotation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  TypePanne                                                 */
/*                                                            */
/**************************************************************/

ASN1C_TypePanne::ASN1C_TypePanne (
   ASN1MessageBuffer& msgBuf, ASN1T_TypePanne& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_TypePanne (ASN1CTXT* ctxt_p, ASN1T_TypePanne value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_TypePanne: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_TypePanne: end\n");
   return (stat);
}

int ASN1C_TypePanne::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_TypePanne (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_TypePanne (ASN1CTXT* ctxt_p, ASN1T_TypePanne* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_TypePanne: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_TypePanne: end\n");

   return (stat);
}

int ASN1C_TypePanne::Decode ()
{
   return asn1PD_TypePanne (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  TypePion                                                  */
/*                                                            */
/**************************************************************/

ASN1C_TypePion::ASN1C_TypePion (
   ASN1MessageBuffer& msgBuf, ASN1T_TypePion& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_TypePion (ASN1CTXT* ctxt_p, ASN1T_TypePion value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_TypePion: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_TypePion: end\n");
   return (stat);
}

int ASN1C_TypePion::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_TypePion (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_TypePion (ASN1CTXT* ctxt_p, ASN1T_TypePion* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_TypePion: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_TypePion: end\n");

   return (stat);
}

int ASN1C_TypePion::Decode ()
{
   return asn1PD_TypePion (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  TypeAutomate                                              */
/*                                                            */
/**************************************************************/

ASN1C_TypeAutomate::ASN1C_TypeAutomate (
   ASN1MessageBuffer& msgBuf, ASN1T_TypeAutomate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_TypeAutomate (ASN1CTXT* ctxt_p, ASN1T_TypeAutomate value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_TypeAutomate: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_TypeAutomate: end\n");
   return (stat);
}

int ASN1C_TypeAutomate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_TypeAutomate (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_TypeAutomate (ASN1CTXT* ctxt_p, ASN1T_TypeAutomate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_TypeAutomate: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_TypeAutomate: end\n");

   return (stat);
}

int ASN1C_TypeAutomate::Decode ()
{
   return asn1PD_TypeAutomate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  TypePopulation                                            */
/*                                                            */
/**************************************************************/

ASN1C_TypePopulation::ASN1C_TypePopulation (
   ASN1MessageBuffer& msgBuf, ASN1T_TypePopulation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_TypePopulation (ASN1CTXT* ctxt_p, ASN1T_TypePopulation value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_TypePopulation: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_TypePopulation: end\n");
   return (stat);
}

int ASN1C_TypePopulation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_TypePopulation (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_TypePopulation (ASN1CTXT* ctxt_p, ASN1T_TypePopulation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_TypePopulation: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_TypePopulation: end\n");

   return (stat);
}

int ASN1C_TypePopulation::Decode ()
{
   return asn1PD_TypePopulation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Pourcentage                                               */
/*                                                            */
/**************************************************************/

ASN1C_Pourcentage::ASN1C_Pourcentage (
   ASN1MessageBuffer& msgBuf, ASN1T_Pourcentage& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Pourcentage (ASN1CTXT* ctxt_p, ASN1T_Pourcentage value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Pourcentage: start\n");

   if ( (value >= 0 && value <= 100) ) {
      stat = pe_ConsInteger (ctxt_p, value, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   }
   else
      return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);


   rtdiag ("asn1PE_Pourcentage: end\n");
   return (stat);
}

int ASN1C_Pourcentage::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Pourcentage (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Pourcentage (ASN1CTXT* ctxt_p, ASN1T_Pourcentage* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Pourcentage: start\n");

   stat = pd_ConsInteger (ctxt_p, pvalue, 0, 100);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Pourcentage: end\n");

   return (stat);
}

int ASN1C_Pourcentage::Decode ()
{
   return asn1PD_Pourcentage (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  PourcentageLibre                                          */
/*                                                            */
/**************************************************************/

ASN1C_PourcentageLibre::ASN1C_PourcentageLibre (
   ASN1MessageBuffer& msgBuf, ASN1T_PourcentageLibre& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_PourcentageLibre (ASN1CTXT* ctxt_p, ASN1T_PourcentageLibre value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_PourcentageLibre: start\n");

   stat = pe_ConsUnsigned (ctxt_p, value, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);


   rtdiag ("asn1PE_PourcentageLibre: end\n");
   return (stat);
}

int ASN1C_PourcentageLibre::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PourcentageLibre (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_PourcentageLibre (ASN1CTXT* ctxt_p, ASN1T_PourcentageLibre* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_PourcentageLibre: start\n");

   stat = pd_ConsUnsigned (ctxt_p, pvalue, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_PourcentageLibre: end\n");

   return (stat);
}

int ASN1C_PourcentageLibre::Decode ()
{
   return asn1PD_PourcentageLibre (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Hauteur                                                   */
/*                                                            */
/**************************************************************/

ASN1C_Hauteur::ASN1C_Hauteur (
   ASN1MessageBuffer& msgBuf, ASN1T_Hauteur& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Hauteur (ASN1CTXT* ctxt_p, ASN1T_Hauteur value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Hauteur: start\n");

   stat = pe_ConsUnsigned (ctxt_p, value, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);


   rtdiag ("asn1PE_Hauteur: end\n");
   return (stat);
}

int ASN1C_Hauteur::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Hauteur (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Hauteur (ASN1CTXT* ctxt_p, ASN1T_Hauteur* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Hauteur: start\n");

   stat = pd_ConsUnsigned (ctxt_p, pvalue, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Hauteur: end\n");

   return (stat);
}

int ASN1C_Hauteur::Decode ()
{
   return asn1PD_Hauteur (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Altitude                                                  */
/*                                                            */
/**************************************************************/

ASN1C_Altitude::ASN1C_Altitude (
   ASN1MessageBuffer& msgBuf, ASN1T_Altitude& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Altitude (ASN1CTXT* ctxt_p, ASN1T_Altitude value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Altitude: start\n");

   stat = pe_ConsUnsigned (ctxt_p, value, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);


   rtdiag ("asn1PE_Altitude: end\n");
   return (stat);
}

int ASN1C_Altitude::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Altitude (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Altitude (ASN1CTXT* ctxt_p, ASN1T_Altitude* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Altitude: start\n");

   stat = pd_ConsUnsigned (ctxt_p, pvalue, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Altitude: end\n");

   return (stat);
}

int ASN1C_Altitude::Decode ()
{
   return asn1PD_Altitude (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  Vitesse                                                   */
/*                                                            */
/**************************************************************/

ASN1C_Vitesse::ASN1C_Vitesse (
   ASN1MessageBuffer& msgBuf, ASN1T_Vitesse& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_Vitesse (ASN1CTXT* ctxt_p, ASN1T_Vitesse value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_Vitesse: start\n");

   stat = pe_ConsUnsigned (ctxt_p, value, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);


   rtdiag ("asn1PE_Vitesse: end\n");
   return (stat);
}

int ASN1C_Vitesse::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_Vitesse (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_Vitesse (ASN1CTXT* ctxt_p, ASN1T_Vitesse* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_Vitesse: start\n");

   stat = pd_ConsUnsigned (ctxt_p, pvalue, 0U, ASN1UINT_MAX);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_Vitesse: end\n");

   return (stat);
}

int ASN1C_Vitesse::Decode ()
{
   return asn1PD_Vitesse (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumFamilleDotation                                       */
/*                                                            */
/**************************************************************/

ASN1C_EnumFamilleDotation::ASN1C_EnumFamilleDotation (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumFamilleDotation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumFamilleDotation (ASN1CTXT* ctxt_p, ASN1T_EnumFamilleDotation value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumFamilleDotation: start\n");

   switch (value) {
      case EnumFamilleDotation::munition: ui = 0; break;
      case EnumFamilleDotation::carburant: ui = 1; break;
      case EnumFamilleDotation::explosif: ui = 2; break;
      case EnumFamilleDotation::mine: ui = 3; break;
      case EnumFamilleDotation::barbele: ui = 4; break;
      case EnumFamilleDotation::piece: ui = 5; break;
      case EnumFamilleDotation::ration: ui = 6; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumFamilleDotation: end\n");
   return (stat);
}

int ASN1C_EnumFamilleDotation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumFamilleDotation (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumFamilleDotation (ASN1CTXT* ctxt_p, ASN1T_EnumFamilleDotation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumFamilleDotation: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumFamilleDotation::munition; break;
      case 1: *pvalue = EnumFamilleDotation::carburant; break;
      case 2: *pvalue = EnumFamilleDotation::explosif; break;
      case 3: *pvalue = EnumFamilleDotation::mine; break;
      case 4: *pvalue = EnumFamilleDotation::barbele; break;
      case 5: *pvalue = EnumFamilleDotation::piece; break;
      case 6: *pvalue = EnumFamilleDotation::ration; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumFamilleDotation: end\n");

   return (stat);
}

int ASN1C_EnumFamilleDotation::Decode ()
{
   return asn1PD_EnumFamilleDotation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumFamilleMunition                                       */
/*                                                            */
/**************************************************************/

ASN1C_EnumFamilleMunition::ASN1C_EnumFamilleMunition (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumFamilleMunition& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumFamilleMunition (ASN1CTXT* ctxt_p, ASN1T_EnumFamilleMunition value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumFamilleMunition: start\n");

   switch (value) {
      case EnumFamilleMunition::obus: ui = 0; break;
      case EnumFamilleMunition::missile_air: ui = 1; break;
      case EnumFamilleMunition::missile_sol: ui = 2; break;
      case EnumFamilleMunition::mitraille: ui = 3; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumFamilleMunition: end\n");
   return (stat);
}

int ASN1C_EnumFamilleMunition::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumFamilleMunition (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumFamilleMunition (ASN1CTXT* ctxt_p, ASN1T_EnumFamilleMunition* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumFamilleMunition: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumFamilleMunition::obus; break;
      case 1: *pvalue = EnumFamilleMunition::missile_air; break;
      case 2: *pvalue = EnumFamilleMunition::missile_sol; break;
      case 3: *pvalue = EnumFamilleMunition::mitraille; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumFamilleMunition: end\n");

   return (stat);
}

int ASN1C_EnumFamilleMunition::Decode ()
{
   return asn1PD_EnumFamilleMunition (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumUnitNatureWeapon                                      */
/*                                                            */
/**************************************************************/

ASN1C_EnumUnitNatureWeapon::ASN1C_EnumUnitNatureWeapon (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumUnitNatureWeapon& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumUnitNatureWeapon (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureWeapon value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumUnitNatureWeapon: start\n");

   switch (value) {
      case EnumUnitNatureWeapon::none: ui = 0; break;
      case EnumUnitNatureWeapon::antichar: ui = 1; break;
      case EnumUnitNatureWeapon::administration: ui = 2; break;
      case EnumUnitNatureWeapon::defense_aerienne: ui = 3; break;
      case EnumUnitNatureWeapon::centre_soutien_operations_aeriennes: ui = 4; break;
      case EnumUnitNatureWeapon::blinde: ui = 5; break;
      case EnumUnitNatureWeapon::aviation: ui = 6; break;
      case EnumUnitNatureWeapon::cavalerie: ui = 7; break;
      case EnumUnitNatureWeapon::genie: ui = 8; break;
      case EnumUnitNatureWeapon::deminage: ui = 9; break;
      case EnumUnitNatureWeapon::soutien_artillerie: ui = 10; break;
      case EnumUnitNatureWeapon::artillerie: ui = 11; break;
      case EnumUnitNatureWeapon::infanterie: ui = 12; break;
      case EnumUnitNatureWeapon::guerre_information: ui = 13; break;
      case EnumUnitNatureWeapon::forces_securite_interne: ui = 14; break;
      case EnumUnitNatureWeapon::execution_loi: ui = 15; break;
      case EnumUnitNatureWeapon::soutien_atterrissage: ui = 16; break;
      case EnumUnitNatureWeapon::logistique: ui = 17; break;
      case EnumUnitNatureWeapon::reparation: ui = 18; break;
      case EnumUnitNatureWeapon::manoeuvre: ui = 19; break;
      case EnumUnitNatureWeapon::medical: ui = 20; break;
      case EnumUnitNatureWeapon::renseignement_militaire: ui = 21; break;
      case EnumUnitNatureWeapon::missile: ui = 22; break;
      case EnumUnitNatureWeapon::nbc: ui = 23; break;
      case EnumUnitNatureWeapon::inconnue: ui = 24; break;
      case EnumUnitNatureWeapon::non_specifiee: ui = 25; break;
      case EnumUnitNatureWeapon::reconnaissance: ui = 26; break;
      case EnumUnitNatureWeapon::transmissions: ui = 27; break;
      case EnumUnitNatureWeapon::ravitaillement: ui = 28; break;
      case EnumUnitNatureWeapon::tactical_air_control_party: ui = 29; break;
      case EnumUnitNatureWeapon::transport: ui = 30; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 30);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumUnitNatureWeapon: end\n");
   return (stat);
}

int ASN1C_EnumUnitNatureWeapon::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumUnitNatureWeapon (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumUnitNatureWeapon (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureWeapon* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumUnitNatureWeapon: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 30);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumUnitNatureWeapon::none; break;
      case 1: *pvalue = EnumUnitNatureWeapon::antichar; break;
      case 2: *pvalue = EnumUnitNatureWeapon::administration; break;
      case 3: *pvalue = EnumUnitNatureWeapon::defense_aerienne; break;
      case 4: *pvalue = EnumUnitNatureWeapon::centre_soutien_operations_aeriennes; break;
      case 5: *pvalue = EnumUnitNatureWeapon::blinde; break;
      case 6: *pvalue = EnumUnitNatureWeapon::aviation; break;
      case 7: *pvalue = EnumUnitNatureWeapon::cavalerie; break;
      case 8: *pvalue = EnumUnitNatureWeapon::genie; break;
      case 9: *pvalue = EnumUnitNatureWeapon::deminage; break;
      case 10: *pvalue = EnumUnitNatureWeapon::soutien_artillerie; break;
      case 11: *pvalue = EnumUnitNatureWeapon::artillerie; break;
      case 12: *pvalue = EnumUnitNatureWeapon::infanterie; break;
      case 13: *pvalue = EnumUnitNatureWeapon::guerre_information; break;
      case 14: *pvalue = EnumUnitNatureWeapon::forces_securite_interne; break;
      case 15: *pvalue = EnumUnitNatureWeapon::execution_loi; break;
      case 16: *pvalue = EnumUnitNatureWeapon::soutien_atterrissage; break;
      case 17: *pvalue = EnumUnitNatureWeapon::logistique; break;
      case 18: *pvalue = EnumUnitNatureWeapon::reparation; break;
      case 19: *pvalue = EnumUnitNatureWeapon::manoeuvre; break;
      case 20: *pvalue = EnumUnitNatureWeapon::medical; break;
      case 21: *pvalue = EnumUnitNatureWeapon::renseignement_militaire; break;
      case 22: *pvalue = EnumUnitNatureWeapon::missile; break;
      case 23: *pvalue = EnumUnitNatureWeapon::nbc; break;
      case 24: *pvalue = EnumUnitNatureWeapon::inconnue; break;
      case 25: *pvalue = EnumUnitNatureWeapon::non_specifiee; break;
      case 26: *pvalue = EnumUnitNatureWeapon::reconnaissance; break;
      case 27: *pvalue = EnumUnitNatureWeapon::transmissions; break;
      case 28: *pvalue = EnumUnitNatureWeapon::ravitaillement; break;
      case 29: *pvalue = EnumUnitNatureWeapon::tactical_air_control_party; break;
      case 30: *pvalue = EnumUnitNatureWeapon::transport; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumUnitNatureWeapon: end\n");

   return (stat);
}

int ASN1C_EnumUnitNatureWeapon::Decode ()
{
   return asn1PD_EnumUnitNatureWeapon (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumUnitNatureSpecialization                              */
/*                                                            */
/**************************************************************/

ASN1C_EnumUnitNatureSpecialization::ASN1C_EnumUnitNatureSpecialization (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumUnitNatureSpecialization& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumUnitNatureSpecialization (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureSpecialization value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumUnitNatureSpecialization: start\n");

   switch (value) {
      case EnumUnitNatureSpecialization::none: ui = 0; break;
      case EnumUnitNatureSpecialization::aerien: ui = 1; break;
      case EnumUnitNatureSpecialization::attaque_aerienne: ui = 2; break;
      case EnumUnitNatureSpecialization::aeroporte: ui = 3; break;
      case EnumUnitNatureSpecialization::blinde: ui = 4; break;
      case EnumUnitNatureSpecialization::compose: ui = 5; break;
      case EnumUnitNatureSpecialization::construction: ui = 6; break;
      case EnumUnitNatureSpecialization::dentiste: ui = 7; break;
      case EnumUnitNatureSpecialization::guerre_electronique: ui = 8; break;
      case EnumUnitNatureSpecialization::finance: ui = 9; break;
      case EnumUnitNatureSpecialization::voilure_fixe: ui = 10; break;
      case EnumUnitNatureSpecialization::terrestre: ui = 11; break;
      case EnumUnitNatureSpecialization::helicoptere: ui = 12; break;
      case EnumUnitNatureSpecialization::jag: ui = 13; break;
      case EnumUnitNatureSpecialization::mecanise: ui = 14; break;
      case EnumUnitNatureSpecialization::police_militaire: ui = 15; break;
      case EnumUnitNatureSpecialization::motorise: ui = 16; break;
      case EnumUnitNatureSpecialization::naval: ui = 17; break;
      case EnumUnitNatureSpecialization::service_du_personnel: ui = 18; break;
      case EnumUnitNatureSpecialization::courrier: ui = 19; break;
      case EnumUnitNatureSpecialization::psychologique: ui = 20; break;
      case EnumUnitNatureSpecialization::chemin_de_fer: ui = 21; break;
      case EnumUnitNatureSpecialization::religieux: ui = 22; break;
      case EnumUnitNatureSpecialization::riverine: ui = 23; break;
      case EnumUnitNatureSpecialization::security_police: ui = 24; break;
      case EnumUnitNatureSpecialization::patrouille_cotiere: ui = 25; break;
      case EnumUnitNatureSpecialization::chirurgie: ui = 26; break;
      case EnumUnitNatureSpecialization::veterinaire: ui = 27; break;
      case EnumUnitNatureSpecialization::decollage_atterissage_vertical_court: ui = 28; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 28);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumUnitNatureSpecialization: end\n");
   return (stat);
}

int ASN1C_EnumUnitNatureSpecialization::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumUnitNatureSpecialization (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumUnitNatureSpecialization (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureSpecialization* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumUnitNatureSpecialization: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 28);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumUnitNatureSpecialization::none; break;
      case 1: *pvalue = EnumUnitNatureSpecialization::aerien; break;
      case 2: *pvalue = EnumUnitNatureSpecialization::attaque_aerienne; break;
      case 3: *pvalue = EnumUnitNatureSpecialization::aeroporte; break;
      case 4: *pvalue = EnumUnitNatureSpecialization::blinde; break;
      case 5: *pvalue = EnumUnitNatureSpecialization::compose; break;
      case 6: *pvalue = EnumUnitNatureSpecialization::construction; break;
      case 7: *pvalue = EnumUnitNatureSpecialization::dentiste; break;
      case 8: *pvalue = EnumUnitNatureSpecialization::guerre_electronique; break;
      case 9: *pvalue = EnumUnitNatureSpecialization::finance; break;
      case 10: *pvalue = EnumUnitNatureSpecialization::voilure_fixe; break;
      case 11: *pvalue = EnumUnitNatureSpecialization::terrestre; break;
      case 12: *pvalue = EnumUnitNatureSpecialization::helicoptere; break;
      case 13: *pvalue = EnumUnitNatureSpecialization::jag; break;
      case 14: *pvalue = EnumUnitNatureSpecialization::mecanise; break;
      case 15: *pvalue = EnumUnitNatureSpecialization::police_militaire; break;
      case 16: *pvalue = EnumUnitNatureSpecialization::motorise; break;
      case 17: *pvalue = EnumUnitNatureSpecialization::naval; break;
      case 18: *pvalue = EnumUnitNatureSpecialization::service_du_personnel; break;
      case 19: *pvalue = EnumUnitNatureSpecialization::courrier; break;
      case 20: *pvalue = EnumUnitNatureSpecialization::psychologique; break;
      case 21: *pvalue = EnumUnitNatureSpecialization::chemin_de_fer; break;
      case 22: *pvalue = EnumUnitNatureSpecialization::religieux; break;
      case 23: *pvalue = EnumUnitNatureSpecialization::riverine; break;
      case 24: *pvalue = EnumUnitNatureSpecialization::security_police; break;
      case 25: *pvalue = EnumUnitNatureSpecialization::patrouille_cotiere; break;
      case 26: *pvalue = EnumUnitNatureSpecialization::chirurgie; break;
      case 27: *pvalue = EnumUnitNatureSpecialization::veterinaire; break;
      case 28: *pvalue = EnumUnitNatureSpecialization::decollage_atterissage_vertical_court; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumUnitNatureSpecialization: end\n");

   return (stat);
}

int ASN1C_EnumUnitNatureSpecialization::Decode ()
{
   return asn1PD_EnumUnitNatureSpecialization (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumUnitNatureQualifier                                   */
/*                                                            */
/**************************************************************/

ASN1C_EnumUnitNatureQualifier::ASN1C_EnumUnitNatureQualifier (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumUnitNatureQualifier& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumUnitNatureQualifier (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureQualifier value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumUnitNatureQualifier: start\n");

   switch (value) {
      case EnumUnitNatureQualifier::none: ui = 0; break;
      case EnumUnitNatureQualifier::lourd: ui = 1; break;
      case EnumUnitNatureQualifier::leger: ui = 2; break;
      case EnumUnitNatureQualifier::moyen: ui = 3; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumUnitNatureQualifier: end\n");
   return (stat);
}

int ASN1C_EnumUnitNatureQualifier::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumUnitNatureQualifier (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumUnitNatureQualifier (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureQualifier* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumUnitNatureQualifier: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumUnitNatureQualifier::none; break;
      case 1: *pvalue = EnumUnitNatureQualifier::lourd; break;
      case 2: *pvalue = EnumUnitNatureQualifier::leger; break;
      case 3: *pvalue = EnumUnitNatureQualifier::moyen; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumUnitNatureQualifier: end\n");

   return (stat);
}

int ASN1C_EnumUnitNatureQualifier::Decode ()
{
   return asn1PD_EnumUnitNatureQualifier (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumUnitNatureCategory                                    */
/*                                                            */
/**************************************************************/

ASN1C_EnumUnitNatureCategory::ASN1C_EnumUnitNatureCategory (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumUnitNatureCategory& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumUnitNatureCategory (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureCategory value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumUnitNatureCategory: start\n");

   switch (value) {
      case EnumUnitNatureCategory::none: ui = 0; break;
      case EnumUnitNatureCategory::combat: ui = 1; break;
      case EnumUnitNatureCategory::soutien_logistique: ui = 2; break;
      case EnumUnitNatureCategory::combat_support: ui = 3; break;
      case EnumUnitNatureCategory::inconnu: ui = 4; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 4);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumUnitNatureCategory: end\n");
   return (stat);
}

int ASN1C_EnumUnitNatureCategory::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumUnitNatureCategory (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumUnitNatureCategory (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureCategory* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumUnitNatureCategory: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 4);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumUnitNatureCategory::none; break;
      case 1: *pvalue = EnumUnitNatureCategory::combat; break;
      case 2: *pvalue = EnumUnitNatureCategory::soutien_logistique; break;
      case 3: *pvalue = EnumUnitNatureCategory::combat_support; break;
      case 4: *pvalue = EnumUnitNatureCategory::inconnu; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumUnitNatureCategory: end\n");

   return (stat);
}

int ASN1C_EnumUnitNatureCategory::Decode ()
{
   return asn1PD_EnumUnitNatureCategory (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumUnitNatureMobility                                    */
/*                                                            */
/**************************************************************/

ASN1C_EnumUnitNatureMobility::ASN1C_EnumUnitNatureMobility (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumUnitNatureMobility& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumUnitNatureMobility (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureMobility value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumUnitNatureMobility: start\n");

   switch (value) {
      case EnumUnitNatureMobility::none: ui = 0; break;
      case EnumUnitNatureMobility::aeroporte: ui = 1; break;
      case EnumUnitNatureMobility::aerien_compose: ui = 2; break;
      case EnumUnitNatureMobility::aerien_voilure_fixe: ui = 3; break;
      case EnumUnitNatureMobility::aerien_plus_leger_que_air: ui = 4; break;
      case EnumUnitNatureMobility::aerien_ailes_rotatives: ui = 5; break;
      case EnumUnitNatureMobility::aerien_amphibie: ui = 6; break;
      case EnumUnitNatureMobility::animal_monte: ui = 7; break;
      case EnumUnitNatureMobility::demonte: ui = 8; break;
      case EnumUnitNatureMobility::terrestre_chemin_de_fer: ui = 9; break;
      case EnumUnitNatureMobility::terrestre_auto_propulse: ui = 10; break;
      case EnumUnitNatureMobility::terrestre_chenille: ui = 11; break;
      case EnumUnitNatureMobility::terrestre_remorque: ui = 12; break;
      case EnumUnitNatureMobility::terrestre_roues: ui = 13; break;
      case EnumUnitNatureMobility::maritime_sous_marin: ui = 14; break;
      case EnumUnitNatureMobility::maritime_surface: ui = 15; break;
      case EnumUnitNatureMobility::inconnu: ui = 16; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 16);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumUnitNatureMobility: end\n");
   return (stat);
}

int ASN1C_EnumUnitNatureMobility::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumUnitNatureMobility (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumUnitNatureMobility (ASN1CTXT* ctxt_p, ASN1T_EnumUnitNatureMobility* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumUnitNatureMobility: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 16);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumUnitNatureMobility::none; break;
      case 1: *pvalue = EnumUnitNatureMobility::aeroporte; break;
      case 2: *pvalue = EnumUnitNatureMobility::aerien_compose; break;
      case 3: *pvalue = EnumUnitNatureMobility::aerien_voilure_fixe; break;
      case 4: *pvalue = EnumUnitNatureMobility::aerien_plus_leger_que_air; break;
      case 5: *pvalue = EnumUnitNatureMobility::aerien_ailes_rotatives; break;
      case 6: *pvalue = EnumUnitNatureMobility::aerien_amphibie; break;
      case 7: *pvalue = EnumUnitNatureMobility::animal_monte; break;
      case 8: *pvalue = EnumUnitNatureMobility::demonte; break;
      case 9: *pvalue = EnumUnitNatureMobility::terrestre_chemin_de_fer; break;
      case 10: *pvalue = EnumUnitNatureMobility::terrestre_auto_propulse; break;
      case 11: *pvalue = EnumUnitNatureMobility::terrestre_chenille; break;
      case 12: *pvalue = EnumUnitNatureMobility::terrestre_remorque; break;
      case 13: *pvalue = EnumUnitNatureMobility::terrestre_roues; break;
      case 14: *pvalue = EnumUnitNatureMobility::maritime_sous_marin; break;
      case 15: *pvalue = EnumUnitNatureMobility::maritime_surface; break;
      case 16: *pvalue = EnumUnitNatureMobility::inconnu; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumUnitNatureMobility: end\n");

   return (stat);
}

int ASN1C_EnumUnitNatureMobility::Decode ()
{
   return asn1PD_EnumUnitNatureMobility (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumUnitCapaciteMission                                   */
/*                                                            */
/**************************************************************/

ASN1C_EnumUnitCapaciteMission::ASN1C_EnumUnitCapaciteMission (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumUnitCapaciteMission& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumUnitCapaciteMission (ASN1CTXT* ctxt_p, ASN1T_EnumUnitCapaciteMission value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumUnitCapaciteMission: start\n");

   switch (value) {
      case EnumUnitCapaciteMission::civilian_law_enforcement: ui = 0; break;
      case EnumUnitCapaciteMission::command_operations: ui = 1; break;
      case EnumUnitCapaciteMission::couverture_aerienne: ui = 2; break;
      case EnumUnitCapaciteMission::joint_intelligence: ui = 3; break;
      case EnumUnitCapaciteMission::morale_welfare_recreation: ui = 4; break;
      case EnumUnitCapaciteMission::reglage_electronique: ui = 5; break;
      case EnumUnitCapaciteMission::remplacement: ui = 6; break;
      case EnumUnitCapaciteMission::service_mortuaire: ui = 7; break;
      case EnumUnitCapaciteMission::signals_intelligence: ui = 8; break;
      case EnumUnitCapaciteMission::theatre_missile_defence: ui = 9; break;
      case EnumUnitCapaciteMission::utilitaire: ui = 10; break;
      case EnumUnitCapaciteMission::aeroporte: ui = 11; break;
      case EnumUnitCapaciteMission::affaires_publiques: ui = 12; break;
      case EnumUnitCapaciteMission::affaires_publiques_communication: ui = 13; break;
      case EnumUnitCapaciteMission::affaires_publiques_joint_information: ui = 14; break;
      case EnumUnitCapaciteMission::alpin: ui = 15; break;
      case EnumUnitCapaciteMission::amphibie: ui = 16; break;
      case EnumUnitCapaciteMission::arctique: ui = 17; break;
      case EnumUnitCapaciteMission::artillerie_reconnaissance: ui = 18; break;
      case EnumUnitCapaciteMission::attaque: ui = 19; break;
      case EnumUnitCapaciteMission::attaque_aerienne: ui = 20; break;
      case EnumUnitCapaciteMission::c2: ui = 21; break;
      case EnumUnitCapaciteMission::chemin_de_fer: ui = 22; break;
      case EnumUnitCapaciteMission::ciblage: ui = 23; break;
      case EnumUnitCapaciteMission::contre_espionnage: ui = 24; break;
      case EnumUnitCapaciteMission::eclairage: ui = 25; break;
      case EnumUnitCapaciteMission::entretien: ui = 26; break;
      case EnumUnitCapaciteMission::entretien_materiel: ui = 27; break;
      case EnumUnitCapaciteMission::entretien_missile: ui = 28; break;
      case EnumUnitCapaciteMission::entretien_opto_electronique: ui = 29; break;
      case EnumUnitCapaciteMission::espionnage: ui = 30; break;
      case EnumUnitCapaciteMission::espionnage_militaire_aerial_exploitation: ui = 31; break;
      case EnumUnitCapaciteMission::espionnage_militaire_operation: ui = 32; break;
      case EnumUnitCapaciteMission::espionnage_militaire_tactical_exploitation: ui = 33; break;
      case EnumUnitCapaciteMission::evacuation_sanitaire: ui = 34; break;
      case EnumUnitCapaciteMission::finance: ui = 35; break;
      case EnumUnitCapaciteMission::genie_combat: ui = 36; break;
      case EnumUnitCapaciteMission::genie_construction: ui = 37; break;
      case EnumUnitCapaciteMission::genie_construction_navale: ui = 38; break;
      case EnumUnitCapaciteMission::guerre_electronique: ui = 39; break;
      case EnumUnitCapaciteMission::guerre_electronique_interception: ui = 40; break;
      case EnumUnitCapaciteMission::guerre_electronique_brouillage: ui = 41; break;
      case EnumUnitCapaciteMission::guerre_electronique_detection: ui = 42; break;
      case EnumUnitCapaciteMission::interrogation: ui = 43; break;
      case EnumUnitCapaciteMission::main_d_oeuvre: ui = 44; break;
      case EnumUnitCapaciteMission::maintien_de_la_paix: ui = 45; break;
      case EnumUnitCapaciteMission::marine: ui = 46; break;
      case EnumUnitCapaciteMission::mine_de_contre_mesure: ui = 47; break;
      case EnumUnitCapaciteMission::nbc_biologique: ui = 48; break;
      case EnumUnitCapaciteMission::nbc_chimique: ui = 49; break;
      case EnumUnitCapaciteMission::nbc_chimique_fumee: ui = 50; break;
      case EnumUnitCapaciteMission::nbc_decontamination: ui = 51; break;
      case EnumUnitCapaciteMission::nbc_decontamination_chimique: ui = 52; break;
      case EnumUnitCapaciteMission::nbc_nucleaire: ui = 53; break;
      case EnumUnitCapaciteMission::non_renseigne: ui = 54; break;
      case EnumUnitCapaciteMission::observation: ui = 55; break;
      case EnumUnitCapaciteMission::observation_capteur: ui = 56; break;
      case EnumUnitCapaciteMission::observation_longue_portee: ui = 57; break;
      case EnumUnitCapaciteMission::observation_meteo: ui = 58; break;
      case EnumUnitCapaciteMission::observation_module_terrestre: ui = 59; break;
      case EnumUnitCapaciteMission::purification_de_l_eau: ui = 60; break;
      case EnumUnitCapaciteMission::ravitaillement_class_i: ui = 61; break;
      case EnumUnitCapaciteMission::ravitaillement_class_ii: ui = 62; break;
      case EnumUnitCapaciteMission::ravitaillement_class_iii_aviation: ui = 63; break;
      case EnumUnitCapaciteMission::ravitaillement_class_iii: ui = 64; break;
      case EnumUnitCapaciteMission::ravitaillement_class_iv: ui = 65; break;
      case EnumUnitCapaciteMission::ravitaillement_class_v: ui = 66; break;
      case EnumUnitCapaciteMission::ravitaillement_eau: ui = 67; break;
      case EnumUnitCapaciteMission::ravitaillement_blanchisserie_bain: ui = 68; break;
      case EnumUnitCapaciteMission::recherche_et_sauvetage: ui = 69; break;
      case EnumUnitCapaciteMission::reconnaissance: ui = 70; break;
      case EnumUnitCapaciteMission::reconnaissance_aerienne_tactique: ui = 71; break;
      case EnumUnitCapaciteMission::recuperation: ui = 72; break;
      case EnumUnitCapaciteMission::service_du_personnel: ui = 73; break;
      case EnumUnitCapaciteMission::service_juridique: ui = 74; break;
      case EnumUnitCapaciteMission::support_aerien_rapproche: ui = 75; break;
      case EnumUnitCapaciteMission::transmissions_forward_communications: ui = 76; break;
      case EnumUnitCapaciteMission::transmissions_node_centre: ui = 77; break;
      case EnumUnitCapaciteMission::transmissions_node_large_extension: ui = 78; break;
      case EnumUnitCapaciteMission::transmissions_node_small_extension: ui = 79; break;
      case EnumUnitCapaciteMission::transmissions_radio_relay: ui = 80; break;
      case EnumUnitCapaciteMission::transmissions_radio_tactical_satellite: ui = 81; break;
      case EnumUnitCapaciteMission::transmissions_radio_teletype: ui = 82; break;
      case EnumUnitCapaciteMission::transmissions_support: ui = 83; break;
      case EnumUnitCapaciteMission::transmissions_radio: ui = 84; break;
      case EnumUnitCapaciteMission::transport_allocation_des_mouvements: ui = 85; break;
      case EnumUnitCapaciteMission::transport_apod_apoe: ui = 86; break;
      case EnumUnitCapaciteMission::transport_spod_spoe: ui = 87; break;
      case EnumUnitCapaciteMission::transport_missile: ui = 88; break;
      case EnumUnitCapaciteMission::verrouillage_de_cible: ui = 89; break;
      case EnumUnitCapaciteMission::verrouillage_de_cible_flash: ui = 90; break;
      case EnumUnitCapaciteMission::verrouillage_de_cible_radar: ui = 91; break;
      case EnumUnitCapaciteMission::verrouillage_de_cible_sonore: ui = 92; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 92);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumUnitCapaciteMission: end\n");
   return (stat);
}

int ASN1C_EnumUnitCapaciteMission::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumUnitCapaciteMission (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumUnitCapaciteMission (ASN1CTXT* ctxt_p, ASN1T_EnumUnitCapaciteMission* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumUnitCapaciteMission: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 92);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumUnitCapaciteMission::civilian_law_enforcement; break;
      case 1: *pvalue = EnumUnitCapaciteMission::command_operations; break;
      case 2: *pvalue = EnumUnitCapaciteMission::couverture_aerienne; break;
      case 3: *pvalue = EnumUnitCapaciteMission::joint_intelligence; break;
      case 4: *pvalue = EnumUnitCapaciteMission::morale_welfare_recreation; break;
      case 5: *pvalue = EnumUnitCapaciteMission::reglage_electronique; break;
      case 6: *pvalue = EnumUnitCapaciteMission::remplacement; break;
      case 7: *pvalue = EnumUnitCapaciteMission::service_mortuaire; break;
      case 8: *pvalue = EnumUnitCapaciteMission::signals_intelligence; break;
      case 9: *pvalue = EnumUnitCapaciteMission::theatre_missile_defence; break;
      case 10: *pvalue = EnumUnitCapaciteMission::utilitaire; break;
      case 11: *pvalue = EnumUnitCapaciteMission::aeroporte; break;
      case 12: *pvalue = EnumUnitCapaciteMission::affaires_publiques; break;
      case 13: *pvalue = EnumUnitCapaciteMission::affaires_publiques_communication; break;
      case 14: *pvalue = EnumUnitCapaciteMission::affaires_publiques_joint_information; break;
      case 15: *pvalue = EnumUnitCapaciteMission::alpin; break;
      case 16: *pvalue = EnumUnitCapaciteMission::amphibie; break;
      case 17: *pvalue = EnumUnitCapaciteMission::arctique; break;
      case 18: *pvalue = EnumUnitCapaciteMission::artillerie_reconnaissance; break;
      case 19: *pvalue = EnumUnitCapaciteMission::attaque; break;
      case 20: *pvalue = EnumUnitCapaciteMission::attaque_aerienne; break;
      case 21: *pvalue = EnumUnitCapaciteMission::c2; break;
      case 22: *pvalue = EnumUnitCapaciteMission::chemin_de_fer; break;
      case 23: *pvalue = EnumUnitCapaciteMission::ciblage; break;
      case 24: *pvalue = EnumUnitCapaciteMission::contre_espionnage; break;
      case 25: *pvalue = EnumUnitCapaciteMission::eclairage; break;
      case 26: *pvalue = EnumUnitCapaciteMission::entretien; break;
      case 27: *pvalue = EnumUnitCapaciteMission::entretien_materiel; break;
      case 28: *pvalue = EnumUnitCapaciteMission::entretien_missile; break;
      case 29: *pvalue = EnumUnitCapaciteMission::entretien_opto_electronique; break;
      case 30: *pvalue = EnumUnitCapaciteMission::espionnage; break;
      case 31: *pvalue = EnumUnitCapaciteMission::espionnage_militaire_aerial_exploitation; break;
      case 32: *pvalue = EnumUnitCapaciteMission::espionnage_militaire_operation; break;
      case 33: *pvalue = EnumUnitCapaciteMission::espionnage_militaire_tactical_exploitation; break;
      case 34: *pvalue = EnumUnitCapaciteMission::evacuation_sanitaire; break;
      case 35: *pvalue = EnumUnitCapaciteMission::finance; break;
      case 36: *pvalue = EnumUnitCapaciteMission::genie_combat; break;
      case 37: *pvalue = EnumUnitCapaciteMission::genie_construction; break;
      case 38: *pvalue = EnumUnitCapaciteMission::genie_construction_navale; break;
      case 39: *pvalue = EnumUnitCapaciteMission::guerre_electronique; break;
      case 40: *pvalue = EnumUnitCapaciteMission::guerre_electronique_interception; break;
      case 41: *pvalue = EnumUnitCapaciteMission::guerre_electronique_brouillage; break;
      case 42: *pvalue = EnumUnitCapaciteMission::guerre_electronique_detection; break;
      case 43: *pvalue = EnumUnitCapaciteMission::interrogation; break;
      case 44: *pvalue = EnumUnitCapaciteMission::main_d_oeuvre; break;
      case 45: *pvalue = EnumUnitCapaciteMission::maintien_de_la_paix; break;
      case 46: *pvalue = EnumUnitCapaciteMission::marine; break;
      case 47: *pvalue = EnumUnitCapaciteMission::mine_de_contre_mesure; break;
      case 48: *pvalue = EnumUnitCapaciteMission::nbc_biologique; break;
      case 49: *pvalue = EnumUnitCapaciteMission::nbc_chimique; break;
      case 50: *pvalue = EnumUnitCapaciteMission::nbc_chimique_fumee; break;
      case 51: *pvalue = EnumUnitCapaciteMission::nbc_decontamination; break;
      case 52: *pvalue = EnumUnitCapaciteMission::nbc_decontamination_chimique; break;
      case 53: *pvalue = EnumUnitCapaciteMission::nbc_nucleaire; break;
      case 54: *pvalue = EnumUnitCapaciteMission::non_renseigne; break;
      case 55: *pvalue = EnumUnitCapaciteMission::observation; break;
      case 56: *pvalue = EnumUnitCapaciteMission::observation_capteur; break;
      case 57: *pvalue = EnumUnitCapaciteMission::observation_longue_portee; break;
      case 58: *pvalue = EnumUnitCapaciteMission::observation_meteo; break;
      case 59: *pvalue = EnumUnitCapaciteMission::observation_module_terrestre; break;
      case 60: *pvalue = EnumUnitCapaciteMission::purification_de_l_eau; break;
      case 61: *pvalue = EnumUnitCapaciteMission::ravitaillement_class_i; break;
      case 62: *pvalue = EnumUnitCapaciteMission::ravitaillement_class_ii; break;
      case 63: *pvalue = EnumUnitCapaciteMission::ravitaillement_class_iii_aviation; break;
      case 64: *pvalue = EnumUnitCapaciteMission::ravitaillement_class_iii; break;
      case 65: *pvalue = EnumUnitCapaciteMission::ravitaillement_class_iv; break;
      case 66: *pvalue = EnumUnitCapaciteMission::ravitaillement_class_v; break;
      case 67: *pvalue = EnumUnitCapaciteMission::ravitaillement_eau; break;
      case 68: *pvalue = EnumUnitCapaciteMission::ravitaillement_blanchisserie_bain; break;
      case 69: *pvalue = EnumUnitCapaciteMission::recherche_et_sauvetage; break;
      case 70: *pvalue = EnumUnitCapaciteMission::reconnaissance; break;
      case 71: *pvalue = EnumUnitCapaciteMission::reconnaissance_aerienne_tactique; break;
      case 72: *pvalue = EnumUnitCapaciteMission::recuperation; break;
      case 73: *pvalue = EnumUnitCapaciteMission::service_du_personnel; break;
      case 74: *pvalue = EnumUnitCapaciteMission::service_juridique; break;
      case 75: *pvalue = EnumUnitCapaciteMission::support_aerien_rapproche; break;
      case 76: *pvalue = EnumUnitCapaciteMission::transmissions_forward_communications; break;
      case 77: *pvalue = EnumUnitCapaciteMission::transmissions_node_centre; break;
      case 78: *pvalue = EnumUnitCapaciteMission::transmissions_node_large_extension; break;
      case 79: *pvalue = EnumUnitCapaciteMission::transmissions_node_small_extension; break;
      case 80: *pvalue = EnumUnitCapaciteMission::transmissions_radio_relay; break;
      case 81: *pvalue = EnumUnitCapaciteMission::transmissions_radio_tactical_satellite; break;
      case 82: *pvalue = EnumUnitCapaciteMission::transmissions_radio_teletype; break;
      case 83: *pvalue = EnumUnitCapaciteMission::transmissions_support; break;
      case 84: *pvalue = EnumUnitCapaciteMission::transmissions_radio; break;
      case 85: *pvalue = EnumUnitCapaciteMission::transport_allocation_des_mouvements; break;
      case 86: *pvalue = EnumUnitCapaciteMission::transport_apod_apoe; break;
      case 87: *pvalue = EnumUnitCapaciteMission::transport_spod_spoe; break;
      case 88: *pvalue = EnumUnitCapaciteMission::transport_missile; break;
      case 89: *pvalue = EnumUnitCapaciteMission::verrouillage_de_cible; break;
      case 90: *pvalue = EnumUnitCapaciteMission::verrouillage_de_cible_flash; break;
      case 91: *pvalue = EnumUnitCapaciteMission::verrouillage_de_cible_radar; break;
      case 92: *pvalue = EnumUnitCapaciteMission::verrouillage_de_cible_sonore; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumUnitCapaciteMission: end\n");

   return (stat);
}

int ASN1C_EnumUnitCapaciteMission::Decode ()
{
   return asn1PD_EnumUnitCapaciteMission (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumNatureLevel                                           */
/*                                                            */
/**************************************************************/

ASN1C_EnumNatureLevel::ASN1C_EnumNatureLevel (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumNatureLevel& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumNatureLevel (ASN1CTXT* ctxt_p, ASN1T_EnumNatureLevel value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumNatureLevel: start\n");

   switch (value) {
      case EnumNatureLevel::none: ui = 0; break;
      case EnumNatureLevel::o: ui = 1; break;
      case EnumNatureLevel::oo: ui = 2; break;
      case EnumNatureLevel::ooo: ui = 3; break;
      case EnumNatureLevel::i: ui = 4; break;
      case EnumNatureLevel::ii: ui = 5; break;
      case EnumNatureLevel::iii: ui = 6; break;
      case EnumNatureLevel::x: ui = 7; break;
      case EnumNatureLevel::xx: ui = 8; break;
      case EnumNatureLevel::xxx: ui = 9; break;
      case EnumNatureLevel::xxxx: ui = 10; break;
      case EnumNatureLevel::xxxxx: ui = 11; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 11);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumNatureLevel: end\n");
   return (stat);
}

int ASN1C_EnumNatureLevel::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumNatureLevel (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumNatureLevel (ASN1CTXT* ctxt_p, ASN1T_EnumNatureLevel* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumNatureLevel: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 11);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumNatureLevel::none; break;
      case 1: *pvalue = EnumNatureLevel::o; break;
      case 2: *pvalue = EnumNatureLevel::oo; break;
      case 3: *pvalue = EnumNatureLevel::ooo; break;
      case 4: *pvalue = EnumNatureLevel::i; break;
      case 5: *pvalue = EnumNatureLevel::ii; break;
      case 6: *pvalue = EnumNatureLevel::iii; break;
      case 7: *pvalue = EnumNatureLevel::x; break;
      case 8: *pvalue = EnumNatureLevel::xx; break;
      case 9: *pvalue = EnumNatureLevel::xxx; break;
      case 10: *pvalue = EnumNatureLevel::xxxx; break;
      case 11: *pvalue = EnumNatureLevel::xxxxx; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumNatureLevel: end\n");

   return (stat);
}

int ASN1C_EnumNatureLevel::Decode ()
{
   return asn1PD_EnumNatureLevel (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumHumanWound                                            */
/*                                                            */
/**************************************************************/

ASN1C_EnumHumanWound::ASN1C_EnumHumanWound (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumHumanWound& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumHumanWound (ASN1CTXT* ctxt_p, ASN1T_EnumHumanWound value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumHumanWound: start\n");

   switch (value) {
      case EnumHumanWound::non_blesse: ui = 0; break;
      case EnumHumanWound::mort: ui = 1; break;
      case EnumHumanWound::blesse_urgence_1: ui = 2; break;
      case EnumHumanWound::blesse_urgence_2: ui = 3; break;
      case EnumHumanWound::blesse_urgence_3: ui = 4; break;
      case EnumHumanWound::blesse_urgence_extreme: ui = 5; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 5);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumHumanWound: end\n");
   return (stat);
}

int ASN1C_EnumHumanWound::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumHumanWound (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumHumanWound (ASN1CTXT* ctxt_p, ASN1T_EnumHumanWound* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumHumanWound: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 5);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumHumanWound::non_blesse; break;
      case 1: *pvalue = EnumHumanWound::mort; break;
      case 2: *pvalue = EnumHumanWound::blesse_urgence_1; break;
      case 3: *pvalue = EnumHumanWound::blesse_urgence_2; break;
      case 4: *pvalue = EnumHumanWound::blesse_urgence_3; break;
      case 5: *pvalue = EnumHumanWound::blesse_urgence_extreme; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumHumanWound: end\n");

   return (stat);
}

int ASN1C_EnumHumanWound::Decode ()
{
   return asn1PD_EnumHumanWound (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumHumanRank                                             */
/*                                                            */
/**************************************************************/

ASN1C_EnumHumanRank::ASN1C_EnumHumanRank (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumHumanRank& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumHumanRank (ASN1CTXT* ctxt_p, ASN1T_EnumHumanRank value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumHumanRank: start\n");

   switch (value) {
      case EnumHumanRank::officier: ui = 0; break;
      case EnumHumanRank::sous_officer: ui = 1; break;
      case EnumHumanRank::mdr: ui = 2; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumHumanRank: end\n");
   return (stat);
}

int ASN1C_EnumHumanRank::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumHumanRank (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumHumanRank (ASN1CTXT* ctxt_p, ASN1T_EnumHumanRank* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumHumanRank: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumHumanRank::officier; break;
      case 1: *pvalue = EnumHumanRank::sous_officer; break;
      case 2: *pvalue = EnumHumanRank::mdr; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumHumanRank: end\n");

   return (stat);
}

int ASN1C_EnumHumanRank::Decode ()
{
   return asn1PD_EnumHumanRank (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumTempsBordee                                           */
/*                                                            */
/**************************************************************/

ASN1C_EnumTempsBordee::ASN1C_EnumTempsBordee (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumTempsBordee& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumTempsBordee (ASN1CTXT* ctxt_p, ASN1T_EnumTempsBordee value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumTempsBordee: start\n");

   switch (value) {
      case EnumTempsBordee::temps_8_heures: ui = 0; break;
      case EnumTempsBordee::temps_12_heures: ui = 1; break;
      case EnumTempsBordee::temps_16_heures: ui = 2; break;
      case EnumTempsBordee::temps_20_heures: ui = 3; break;
      case EnumTempsBordee::temps_24_heures: ui = 4; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 4);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumTempsBordee: end\n");
   return (stat);
}

int ASN1C_EnumTempsBordee::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumTempsBordee (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumTempsBordee (ASN1CTXT* ctxt_p, ASN1T_EnumTempsBordee* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumTempsBordee: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 4);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumTempsBordee::temps_8_heures; break;
      case 1: *pvalue = EnumTempsBordee::temps_12_heures; break;
      case 2: *pvalue = EnumTempsBordee::temps_16_heures; break;
      case 3: *pvalue = EnumTempsBordee::temps_20_heures; break;
      case 4: *pvalue = EnumTempsBordee::temps_24_heures; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumTempsBordee: end\n");

   return (stat);
}

int ASN1C_EnumTempsBordee::Decode ()
{
   return asn1PD_EnumTempsBordee (mpContext->GetPtr(), &msgData);
}

