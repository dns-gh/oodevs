/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 20-Nov-2006.
 */
#include "ScipioOrder.h"

/**************************************************************/
/*                                                            */
/*  EnumOrderErrorCode                                        */
/*                                                            */
/**************************************************************/

ASN1C_EnumOrderErrorCode::ASN1C_EnumOrderErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumOrderErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumOrderErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumOrderErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumOrderErrorCode: start\n");

   switch (value) {
      case EnumOrderErrorCode::no_error: ui = 0; break;
      case EnumOrderErrorCode::error_invalid_unit: ui = 1; break;
      case EnumOrderErrorCode::error_invalid_limit: ui = 2; break;
      case EnumOrderErrorCode::error_invalid_lima: ui = 3; break;
      case EnumOrderErrorCode::error_invalid_mission: ui = 4; break;
      case EnumOrderErrorCode::error_invalid_mission_parameters: ui = 5; break;
      case EnumOrderErrorCode::error_unit_cannot_receive_order: ui = 6; break;
      case EnumOrderErrorCode::error_invalid_order_conduite: ui = 7; break;
      case EnumOrderErrorCode::error_invalid_order_mission: ui = 8; break;
      case EnumOrderErrorCode::error_invalid_order_initial: ui = 9; break;
      case EnumOrderErrorCode::error_invalid_order_conduite_parameters: ui = 10; break;
      case EnumOrderErrorCode::error_unit_surrendered: ui = 11; break;
      case EnumOrderErrorCode::error_invalid_lima_function: ui = 12; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 12);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumOrderErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumOrderErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumOrderErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumOrderErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumOrderErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumOrderErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 12);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumOrderErrorCode::no_error; break;
      case 1: *pvalue = EnumOrderErrorCode::error_invalid_unit; break;
      case 2: *pvalue = EnumOrderErrorCode::error_invalid_limit; break;
      case 3: *pvalue = EnumOrderErrorCode::error_invalid_lima; break;
      case 4: *pvalue = EnumOrderErrorCode::error_invalid_mission; break;
      case 5: *pvalue = EnumOrderErrorCode::error_invalid_mission_parameters; break;
      case 6: *pvalue = EnumOrderErrorCode::error_unit_cannot_receive_order; break;
      case 7: *pvalue = EnumOrderErrorCode::error_invalid_order_conduite; break;
      case 8: *pvalue = EnumOrderErrorCode::error_invalid_order_mission; break;
      case 9: *pvalue = EnumOrderErrorCode::error_invalid_order_initial; break;
      case 10: *pvalue = EnumOrderErrorCode::error_invalid_order_conduite_parameters; break;
      case 11: *pvalue = EnumOrderErrorCode::error_unit_surrendered; break;
      case 12: *pvalue = EnumOrderErrorCode::error_invalid_lima_function; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumOrderErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumOrderErrorCode::Decode ()
{
   return asn1PD_EnumOrderErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumOrderState                                            */
/*                                                            */
/**************************************************************/

ASN1C_EnumOrderState::ASN1C_EnumOrderState (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumOrderState& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumOrderState (ASN1CTXT* ctxt_p, ASN1T_EnumOrderState value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumOrderState: start\n");

   switch (value) {
      case EnumOrderState::started: ui = 0; break;
      case EnumOrderState::cancelled: ui = 1; break;
      case EnumOrderState::stopped: ui = 2; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumOrderState: end\n");
   return (stat);
}

int ASN1C_EnumOrderState::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumOrderState (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumOrderState (ASN1CTXT* ctxt_p, ASN1T_EnumOrderState* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumOrderState: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumOrderState::started; break;
      case 1: *pvalue = EnumOrderState::cancelled; break;
      case 2: *pvalue = EnumOrderState::stopped; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumOrderState: end\n");

   return (stat);
}

int ASN1C_EnumOrderState::Decode ()
{
   return asn1PD_EnumOrderState (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  OrderContext                                              */
/*                                                            */
/**************************************************************/

ASN1C_OrderContext::ASN1C_OrderContext (
   ASN1MessageBuffer& msgBuf, ASN1T_OrderContext& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_OrderContext (ASN1CTXT* ctxt_p, ASN1T_OrderContext* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_OrderContext: start\n");

   PU_NEWFIELD (ctxt_p, "limite_gauchePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.limite_gauchePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "limite_droitePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.limite_droitePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode limite_gauche */

   if (pvalue->m.limite_gauchePresent) {
      PU_PUSHNAME (ctxt_p, "limite_gauche");

      stat = asn1PE_Line (ctxt_p, &pvalue->limite_gauche);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode limite_droite */

   if (pvalue->m.limite_droitePresent) {
      PU_PUSHNAME (ctxt_p, "limite_droite");

      stat = asn1PE_Line (ctxt_p, &pvalue->limite_droite);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode limas */

   PU_PUSHNAME (ctxt_p, "limas");

   stat = asn1PE_LimasOrder (ctxt_p, &pvalue->limas);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode direction_dangereuse */

   PU_PUSHNAME (ctxt_p, "direction_dangereuse");

   stat = asn1PE_Direction (ctxt_p, pvalue->direction_dangereuse);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_OrderContext: end\n");
   return (stat);
}

int ASN1C_OrderContext::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderContext (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_OrderContext (ASN1CTXT* ctxt_p, ASN1T_OrderContext* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_OrderContext: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "limite_gauchePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.limite_gauchePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "limite_droitePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.limite_droitePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode limite_gauche */

   if (pvalue->m.limite_gauchePresent) {
      PU_PUSHNAME (ctxt_p, "limite_gauche");

      stat = asn1PD_Line (ctxt_p, &pvalue->limite_gauche);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode limite_droite */

   if (pvalue->m.limite_droitePresent) {
      PU_PUSHNAME (ctxt_p, "limite_droite");

      stat = asn1PD_Line (ctxt_p, &pvalue->limite_droite);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode limas */

   PU_PUSHNAME (ctxt_p, "limas");

   stat = asn1PD_LimasOrder (ctxt_p, &pvalue->limas);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode direction_dangereuse */

   PU_PUSHNAME (ctxt_p, "direction_dangereuse");

   stat = asn1PD_Direction (ctxt_p, &pvalue->direction_dangereuse);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_OrderContext: end\n");

   return (stat);
}

int ASN1C_OrderContext::Decode ()
{
   return asn1PD_OrderContext (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameter_value                                    */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameter_value::ASN1C_MissionParameter_value (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameter_value& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameter_value (ASN1CTXT* ctxt_p, ASN1T_MissionParameter_value* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MissionParameter_value: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (ctxt_p, "t");

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 10);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* agent */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.agent");

         stat = asn1PE_Agent (ctxt_p, pvalue->u.agent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listAgent */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.listAgent");

         stat = asn1PE_ListAgent (ctxt_p, pvalue->u.listAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* automate */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.automate");

         stat = asn1PE_Automate (ctxt_p, pvalue->u.automate);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listAutomate */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.listAutomate");

         stat = asn1PE_ListAutomate (ctxt_p, pvalue->u.listAutomate);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* aBool */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.aBool");

         PU_NEWFIELD (ctxt_p, "boolean");

         stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->u.aBool);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_SETBITCOUNT (ctxt_p);
         PU_POPNAME (ctxt_p);

         break;

      /* direction */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.direction");

         stat = asn1PE_Direction (ctxt_p, pvalue->u.direction);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* knowledgeAgent */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.knowledgeAgent");

         stat = asn1PE_KnowledgeAgent (ctxt_p, pvalue->u.knowledgeAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listKnowledgeAgent */
      case 8:
         PU_PUSHNAME (ctxt_p, "u.listKnowledgeAgent");

         stat = asn1PE_ListKnowledgeAgent (ctxt_p, pvalue->u.listKnowledgeAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* knowledgeObject */
      case 9:
         PU_PUSHNAME (ctxt_p, "u.knowledgeObject");

         stat = asn1PE_KnowledgeObject (ctxt_p, pvalue->u.knowledgeObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listKnowledgeObject */
      case 10:
         PU_PUSHNAME (ctxt_p, "u.listKnowledgeObject");

         stat = asn1PE_ListKnowledgeObject (ctxt_p, pvalue->u.listKnowledgeObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* knowledgePopulation */
      case 11:
         PU_PUSHNAME (ctxt_p, "u.knowledgePopulation");

         stat = asn1PE_KnowledgePopulation (ctxt_p, pvalue->u.knowledgePopulation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PE_MissionParameter_value: end\n");
   return (stat);
}

int ASN1C_MissionParameter_value::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameter_value (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameter_value (ASN1CTXT* ctxt_p, ASN1T_MissionParameter_value* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_MissionParameter_value: start\n");

   PU_PUSHNAME (ctxt_p, "t");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 10);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (ctxt_p);

   switch (ui) {
      /* agent */
      case 0:
         PU_PUSHNAME (ctxt_p, "u.agent");

         stat = asn1PD_Agent (ctxt_p, &pvalue->u.agent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listAgent */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.listAgent");

         pvalue->u.listAgent = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListAgent);
         if (pvalue->u.listAgent == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListAgent (ctxt_p, pvalue->u.listAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* automate */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.automate");

         stat = asn1PD_Automate (ctxt_p, &pvalue->u.automate);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listAutomate */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.listAutomate");

         pvalue->u.listAutomate = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListAutomate);
         if (pvalue->u.listAutomate == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListAutomate (ctxt_p, pvalue->u.listAutomate);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* aBool */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.aBool");

         PU_NEWFIELD (ctxt_p, "boolean");

         stat = pd_bit (ctxt_p, &pvalue->u.aBool);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_SETBITCOUNT (ctxt_p);

         PU_POPNAME (ctxt_p);

         break;

      /* direction */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.direction");

         stat = asn1PD_Direction (ctxt_p, &pvalue->u.direction);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* knowledgeAgent */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.knowledgeAgent");

         stat = asn1PD_KnowledgeAgent (ctxt_p, &pvalue->u.knowledgeAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listKnowledgeAgent */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.listKnowledgeAgent");

         pvalue->u.listKnowledgeAgent = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListKnowledgeAgent);
         if (pvalue->u.listKnowledgeAgent == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListKnowledgeAgent (ctxt_p, pvalue->u.listKnowledgeAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* knowledgeObject */
      case 8:
         PU_PUSHNAME (ctxt_p, "u.knowledgeObject");

         stat = asn1PD_KnowledgeObject (ctxt_p, &pvalue->u.knowledgeObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listKnowledgeObject */
      case 9:
         PU_PUSHNAME (ctxt_p, "u.listKnowledgeObject");

         pvalue->u.listKnowledgeObject = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListKnowledgeObject);
         if (pvalue->u.listKnowledgeObject == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListKnowledgeObject (ctxt_p, pvalue->u.listKnowledgeObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* knowledgePopulation */
      case 10:
         PU_PUSHNAME (ctxt_p, "u.knowledgePopulation");

         stat = asn1PD_KnowledgePopulation (ctxt_p, &pvalue->u.knowledgePopulation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PD_MissionParameter_value: end\n");

   return (stat);
}

int ASN1C_MissionParameter_value::Decode ()
{
   return asn1PD_MissionParameter_value (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameter                                          */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameter::ASN1C_MissionParameter (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameter& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameter (ASN1CTXT* ctxt_p, ASN1T_MissionParameter* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MissionParameter: start\n");

   PU_NEWFIELD (ctxt_p, "null_valuePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->null_value != FALSE));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode null_value */

   if (pvalue->null_value != FALSE) {
      PU_PUSHNAME (ctxt_p, "null_value");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->null_value);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode value */

   PU_PUSHNAME (ctxt_p, "value");

   stat = asn1PE_MissionParameter_value (ctxt_p, &pvalue->value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MissionParameter: end\n");
   return (stat);
}

int ASN1C_MissionParameter::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameter (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameter (ASN1CTXT* ctxt_p, ASN1T_MissionParameter* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL null_valuePresent;

   rtdiag ("asn1PD_MissionParameter: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "null_valuePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else null_valuePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode null_value */

   if (null_valuePresent) {
      PU_PUSHNAME (ctxt_p, "null_value");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->null_value);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->null_value = FALSE;
   }

   /* decode value */

   PU_PUSHNAME (ctxt_p, "value");

   stat = asn1PD_MissionParameter_value (ctxt_p, &pvalue->value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MissionParameter: end\n");

   return (stat);
}

int ASN1C_MissionParameter::Decode ()
{
   return asn1PD_MissionParameter (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameters                                         */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameters::ASN1C_MissionParameters (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameters& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameters (ASN1CTXT* ctxt_p, ASN1T_MissionParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_MissionParameters: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_MissionParameter (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_MissionParameters: end\n");
   return (stat);
}

int ASN1C_MissionParameters::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameters (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameters (ASN1CTXT* ctxt_p, ASN1T_MissionParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_MissionParameters: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_MissionParameter);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_MissionParameter (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MissionParameters: end\n");

   return (stat);
}

int ASN1C_MissionParameters::Decode ()
{
   return asn1PD_MissionParameters (mpContext->GetPtr(), &msgData);
}

