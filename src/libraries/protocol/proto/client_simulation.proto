// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2010 MASA Group
//
// *****************************************************************************

import "common.proto";

package sword;

/** @file
 *  @brief Messages from clients to the simulation
 *  @addtogroup Simulation
 *  @{
 */

/** @struct ControlDateTimeChange
    @brief A date and/or time change request
    @see ControlDateTimeChangeAck
*/
message ControlDateTimeChange {
    //! The new date and/or time
    required DateTime date_time = 1;
}

/** @struct ControlCheckPointSaveNow
    @brief A checkpoint save request
    @see ControlCheckPointSaveNowAck
*/
message ControlCheckPointSaveNow {
    //! The checkpoint name
    optional string name = 1;
}

//! Engage or disengage an automat.
//! When engaged, missions cannot be sent directly to its units, they
//! have to be given to the automat which dispatches them afterwards.
//! The operation is acknowledged with a SetAutomatModeAck.
message SetAutomatMode {
    required AutomatId       automate = 1;
    required EnumAutomatMode mode     = 2;
    optional string          name     = 3;
}

/** @struct UnitCreationRequest
    @brief An agent creation request
    @see UnitCreationRequestAck
    @todo rename into AgentCreationRequest
    @todo no clue what the fields are exactly...
*/
message UnitCreationRequest {
    //! The agent type
    required UnitType     type     = 1;
    //! The superior identifier
    required AutomatId    superior = 2;
    //! The position
    required CoordLatLong position = 3;
}

message KnowledgeMagicAction {
    //! A KnowledgeGroupMagicActionAck message is returned in response.
    enum Type {
        //! Enables or disables the knowledge group
        //! parameters[0], BooleanValue: whether to enable or disable the group.
        enable              = 0;
        //! Changes the knowledge group parent to a party
        //! parameters[0], PartyId: new parent identifier.
        //!   Must be the same as the knowledge group top party.
        //!   Used when the group was under another group, to put it at top
        //!   level.
        update_party        = 1;
        //! Changes the knowledge group parent to another knowledge group.
        //! parameters[0], PartyId: the parent party.
        //!   Must be the same as the knowledge group top party.
        //! parameters[1], KnowledgeGroupId: the new parent knowledge group.
        //!   Must be from the same party.
        //!   Used when the group was at top level, to put it under another
        //!   group.
        update_party_parent = 2;
        //! Changes the knowledge group type
        //! parameters[0], ACharStr: The new knowledge group type according to
        //!   those defined in the physical database.
        update_type         = 3;
        //! Adds a new unit/object/population knowledge in the knowledge group.
        //! parameters[0], Identifier: The id of the real entity from which a 
        //!   knowledge should be created.
        //! Can be the id of an agent, an object, a population or a urban block.
        //! parameters[1], Enumeration: The perception level according enum 
        //!   UnitIdentification::Level as defined in simulation_client.proto
        //!   This parameter can also be an Quantity (deprecated)
        add_knowledge       = 4;
    }
    required KnowledgeGroupId  knowledge_group = 1;
    required Type              type            = 2;
    required MissionParameters parameters      = 3;
    //! optional name
    optional string            name            = 4;
}

/** @struct ObjectMagicAction
    @brief An object magic action request
    @see ObjectMagicActionAck
*/
message ObjectMagicAction {
    /** @enum Type
        @brief The type of magic action.

        Specific parameters are expected for each type.

        @todo Explain what parameters are expected for each type
    */
    enum Type {
        /** @brief A create object magic action.
        */
        create  = 0;
        /** @brief An update object magic action.
        */
        update  = 1;
        /** @brief A destroy object magic action.
        */
        destroy = 2;
    }
    /** @enum Attribute
        @brief The type of object.

        The first parameter among the parameters actually is of type
        MissionParameter::Value::identifier and must be reinterpreted as
        a value of this enumeration.

        @todo to be refactored
    */
    enum Attribute {
        construction       = 0;
        obstacle           = 1;
        mine               = 2;
        time_limit         = 3;
        bypass             = 4;
        logistic           = 5;
        nbc                = 6;
        crossing_site      = 7;
        supply_route       = 8;
        toxic_cloud        = 9;
        fire               = 10;
        medical_treatment  = 11;
        interaction_height = 12;
        stock              = 13;
        nbc_agent          = 14;
        effect_delay       = 15;
        flood              = 16;
        structural_state   = 18;
        infrastructure     = 19;
        usages             = 20;
        lodging            = 21;
        trafficability     = 22;
        underground        = 23;
        confined           = 24;
        alerted            = 25;
        evacuated          = 26;
        resource_network   = 27;
        altitude_modifier  = 28;
        disaster           = 29;
        density            = 30;
    }
    //! The object identifier
    required ObjectId          object     = 1;
    //! The type of magic action
    required Type              type       = 2;
    //! The parameters of the magic action : the first parameter must
    //! be the object type name and the second parameter must be the
    //! object location
    required MissionParameters parameters = 3;
    //! optional name
    optional string            name       = 4;
}

message MagicAction {

    enum Type {
        //! Update global weather parameters. A ControlGlobalWeather
        //! will be emitted to notify the weather changes.
        //! parameters[0], AReal: temperature.
        //! parameters[1], AReal: wind speed in km/h.
        //! parameters[2], Heading: the direction where the wind flows
        //!   in degrees.
        //! parameters[3], AReal: cloud layer bottom altitude in meters.
        //! parameters[4], AReal: cloud layer top altitude in meters.
        //! parameters[5], AReal: cloud density.
        //! parameters[6], Enumeration: a value within PrecipitationType.
        global_weather                     = 0;
        //! Create or update a local weather. In both cases, a
        //! ControlLocalWeatherCreation message is sent will local weather
        //! attributes.
        //! parameters[0], AReal: temperature.
        //! parameters[1], AReal: wind speed in km/h.
        //! parameters[2], Heading: the direction where the wind flows
        //!   in degrees.
        //! parameters[3], AReal: cloud layer bottom altitude in meters.
        //! parameters[4], AReal: cloud layer top altitude in meters.
        //! parameters[5], AReal: cloud density.
        //! parameters[6], Enumeration: a value within PrecipitationType.
        //! parameters[7], Datetime: start time.
        //! parameters[8], Datetime: end time.
        //! parameters[9], Location: a location with two points defining
        //!   the area top-left and bottom right corners.
        //! parameters[10], Identifier, optional: the identifier of a
        //!   local weather to update. If not passed, a local weather is
        //!   created instead.
        //! result[0], Identifier: on success, created local weather identifier.
        local_weather                      = 1;
        //! Remove a local weather. A ControlLocalWeatherDestruction
        //! message is emitted on success.
        //! parameters[0], Identifier: identifier of the local weather
        //!   to remove.
        local_weather_destruction          = 2;
        //! Change diplomacy between two parties.
        //! Trigger a ChangeDiplomacy on success
        //! parameters[0], Identifier: first party identifier
        //! parameters[1], Identifier: second party identifier
        //! parameters[2], Enumeration: new diplomacy as EnumDiplomacy
        change_diplomacy                   = 3;
        //! Create a knowledge group.
        //! parameters[0], Identifier: parent party or knowledge
        //!   group identifier.
        //! parameters[1], ACharStr: group type identifier as defined in
        //!   the physical database.
        //! result[0], Identifier: created group identifier.
        create_knowledge_group             = 4;
        //! A change resource network properties magic action
        //! parameters[0], Identifier : urban object id
        //! parameters[1], value parameters of lists of resource data(list)
        //!   resource data list : resource (string), consumption(quantity),
        //!     critical(bool), enabled(bool), production(quantity),
        //!     maxstock(quantity), links
        //!   links: list of list with a "identifier,quantity" format        
        change_resource_network_properties = 5;
        //! Initiate a fire order on a specific location.
        //! parameters[0], Location or Point: fire location.
        //! parameters[1], ResourceType: resource type.
        //! parameters[2], AReal: real multiplied by an intervention type
        //!  of a resource type to calculate the iterations number.
        create_fire_order_on_location      = 6;
    }
    required Type              type       = 1;
    required MissionParameters parameters = 2;
    //! The action name is mostly used as a label by third-party systems
    //! listening and displaying simulation events.
    optional string            name       = 3;
}

/** @struct ControlCheckPointSetFrequency
    @brief Requests a checkpoint frequency change
    @see ControlCheckPointSetFrequencyAck
    @todo rename to ControlCheckpointSetFrequency
*/
message ControlCheckPointSetFrequency {
    //! The frequency of checkpoints in minutes
    required int32 frequency = 1;
}

/** @struct ControlCheckPointDeleteRequest
    @brief Request the deletion of a checkpoint
    @see ControlCheckPointDeleteAck
*/
message ControlCheckPointDeleteRequest {
    //! The checkpoint identifier
    required string checkpoint = 1;
}

/** @struct ControlCheckPointListRequest
    @brief Request the list of previously saved checkpoints
    @see ControlCheckPointListAck
    @see ControlCheckPointList
*/
message ControlCheckPointListRequest {
}

/** @struct ControlEnableVisionCones
    @brief A vision cones toggle request.

    This message is sent by a client to toggle the sending of vision
    cones. Enabling vision cones will produce UnitVisionCones messages.

    @see UnitVisionCones
    @todo see how it is related to ControlInformation::send_vision_cones
*/
message ControlEnableVisionCones {
    //! Whether to activate vision cones or not
    required bool vision_cones = 1;
}

/** @struct ChangePopulationMagicAction
    @brief A change population magic action.
    @see UnitMagicActionAck
*/
message ChangePopulationMagicAction {
    //! The population identifier @todo rename to population
    required PopulationId   tasker     = 1;
    //! The party adhesions
    repeated PartyAdhesion  adhesions  = 2;
    //! The number of healthy persons
    optional int32          healthy    = 3;
    //! The number of wounded persons
    optional int32          wounded    = 4;
    //! The number of dead persons
    optional int32          dead       = 5;
    //! The motivation @todo What is that ?
    optional string         motivation = 6;
    //! Whether the population have received an alert
    optional bool           alerted    = 7;
}

/** @struct BurningCellRequest
    @brief Request details of a burning cell.

    This message is sent by a client to request burning cell details.

    @see BurningCellRequestAck
*/
message BurningCellRequest {

    /** @property object
        @brief Id of the burning object
    */
    required ObjectId object = 1;

    /** @property x
        @brief X coordinates of the burning cell.
    */
    required float x = 2;
    /** @property y
        @brief Y coordinates of the burning cell.
    */
    required float y = 3;
}

/** @struct OrderStream
*/
message OrderStream {
    //! The serialized order
    required string serialized_order = 1;
}

/** @struct ClientToSim
    @brief Wraps messages from clients to the simulation
*/
message ClientToSim {
    /** @struct Content
        @brief The possible messages contained in a client to simulation
               message.
        @warning Each Content message must contain exactly one of the
                 possible messages.
    */
    message Content {
        //! @copybrief ControlStop
        optional ControlStop              control_stop                    = 1;
        //! @copybrief ControlPause
        optional ControlPause             control_pause                   = 2;
        //! @copybrief ControlResume
        optional ControlResume            control_resume                  = 3;
        //! @copybrief ControlChangeTimeFactor
        optional ControlChangeTimeFactor  control_change_time_factor      = 4;
        //! @copybrief ControlDateTimeChange
        optional ControlDateTimeChange    control_date_time_change        = 5;
        //! @copybrief ControlCheckPointSaveNow
        optional ControlCheckPointSaveNow control_checkpoint_save_now     = 6;
        //! @copybrief ControlCheckPointSetFrequency
        optional ControlCheckPointSetFrequency
            control_checkpoint_set_frequency  = 7;
        //! @copybrief ControlEnableVisionCones
        optional ControlEnableVisionCones control_toggle_vision_cones     = 8;
        //! @copybrief UnitOrder
        optional UnitOrder                unit_order                      = 9;
        //! @copybrief AutomatOrder
        optional AutomatOrder             automat_order                   = 10;
        //! @copybrief CrowdOrder
        optional CrowdOrder               crowd_order                     = 11;
        //! @copybrief FragOrder
        optional FragOrder                frag_order                      = 12;
        //! @copybrief SetAutomatMode
        optional SetAutomatMode           set_automat_mode                = 13;
        //! @copybrief UnitCreationRequest
        optional UnitCreationRequest      unit_creation_request           = 14;
        //! @copybrief UnitCreationRequest
        optional UnitMagicAction          unit_magic_action               = 15;
        //! @copybrief ObjectMagicAction
        optional ObjectMagicAction        object_magic_action             = 16;
        //! @copybrief KnowledgeMagicAction
        optional KnowledgeMagicAction     knowledge_magic_action          = 17;
        //! @copybrief MagicAction
        optional MagicAction              magic_action                    = 18;
        //! @copybrief ControlCheckPointListRequest
        optional ControlCheckPointListRequest
            control_checkpoint_list_request   = 19;
        //! @copybrief ControlCheckPointDeleteRequest
        optional ControlCheckPointDeleteRequest
            control_checkpoint_delete_request = 20;
        //! @copybrief ChangePopulationMagicAction
        optional ChangePopulationMagicAction
            change_population_magic_action = 21;
        /** @property burning_cell_request
            @brief @copybrief BurningCellRequest
            @see BurningCellRequest
        */
        optional BurningCellRequest       burning_cell_request            = 23;
        optional OrderStream              order_stream                    = 24;
    }
    /** @property context
        @brief Identifies the request matching the response

        This field is used to fill the "context" fields in the response
        message (from SimToClient). This context allows the client
        application to put an unique identifier (based for instance on
        MAC address), thus allowing to track response message matching a
        specific request emitted by the client.
    */
    optional int32   context = 1;
    //! The content of the message
    required Content message = 2;
    //! specific messages, mostly requests acknowledgements.
    optional int32   client_id = 3;
}

/** @}*/
