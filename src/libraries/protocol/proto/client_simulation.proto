// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2010 MASA Group
//
// *****************************************************************************

import "common.proto";

package sword;

/** @file
 *  @brief Messages from clients to the simulation
 *  @addtogroup Simulation
 *  @{
 */

/** @struct ControlDateTimeChange
    @brief A date and/or time change request
    @see ControlDateTimeChangeAck
*/
message ControlDateTimeChange {
    //! The new date and/or time
    required DateTime date_time = 1;
}

//! Creates a new checkpoint. If "name" is not supplied, generates one
//! based on the current date and time. Returns a
//! ControlCheckPointSaveNowAck message, containing the generated
//! checkpoint name on success. Between both messages, a
//! ControlCheckPointSaveBegin matched by a ControlCheckPointSaveEnd may
//! be sent if the checkpoint creation is successful or at least
//! initiated.
message ControlCheckPointSaveNow {
    //! Checkpoint name, contains only alphanumeric characters, spaces
    //! or underscores.
    optional string name = 1;
    //! If true, the simulation state will be sent like it is upon new
    //! connections, right after the ControlCheckPointSaveBegin message.
    //! Note: this option is currently only used for testing purpose,
    //! its behaviour may change in future versions.
    optional bool   send_state = 2;
}

/** @struct UnitCreationRequest
    @brief An agent creation request
    @see UnitCreationRequestAck
    @todo rename into AgentCreationRequest
    @todo no clue what the fields are exactly...
*/
message UnitCreationRequest {
    //! The agent type
    required Id           type     = 1;
    //! The superior identifier
    required Id           superior = 2;
    //! The position
    required CoordLatLong position = 3;
}

// Returns ControlCheckPointsSetFrequencyAck.
message ControlCheckPointSetFrequency {
    //! The frequency of checkpoints in minutes, positive or null.
    required int32 frequency = 1;
}

/** @struct ControlCheckPointDeleteRequest
    @brief Request the deletion of a checkpoint
    @see ControlCheckPointDeleteAck
*/
message ControlCheckPointDeleteRequest {
    //! The checkpoint identifier
    required string checkpoint = 1;
}

/** @struct ControlCheckPointListRequest
    @brief Request the list of previously saved checkpoints
    @see ControlCheckPointListAck
    @see ControlCheckPointList
*/
message ControlCheckPointListRequest {
}

/** @struct ChangePopulationMagicAction
    @brief A change population magic action.
    @see UnitMagicActionAck
*/
message ChangePopulationMagicAction {
    //! The population identifier @todo rename to population
    required Id             tasker     = 1;
    //! The party adhesions
    repeated PartyAdhesion  adhesions  = 2;
    //! The number of healthy persons
    optional int32          healthy    = 3;
    //! The number of wounded persons
    optional int32          wounded    = 4;
    //! The number of dead persons
    optional int32          dead       = 5;
    //! The motivation @todo What is that ?
    optional string         motivation = 6;
    //! Whether the population have received an alert
    optional bool           alerted    = 7;
}

/** @struct BurningCellRequest
    @brief Request details of a burning cell.

    This message is sent by a client to request burning cell details.

    @see BurningCellRequestAck
*/
message BurningCellRequest {
    //! Identifier of the burning object
    required Id    object = 1;
    //! X coordinates of the burning cell
    required float x      = 2;
    //! Y coordinates of the burning cell
    required float y      = 3;
}

/** @struct OrderStream
*/
message OrderStream {
    //! The serialized order
    required string serialized_order = 1;
}

/** List of supported terrain types
*/
enum TerrainType {
    forest         = 0;
    orchard        = 1;
    swamp          = 2;
    urban          = 3;
    water          = 4;
    dune           = 5;
    ice            = 6;
    mountain       = 7;
    forest_edge    = 8;
    orchard_edge   = 9;
    swamp_edge     = 10;
    urban_edge     = 11;
    dune_edge      = 12;
    ice_edge       = 13;
    mountain_edge  = 14;
    cliff          = 15;
    highway        = 16;
    large_road     = 17;
    medium_road    = 18;
    small_road     = 19;
    bridge         = 20;
    railroad       = 21;
    large_river    = 22;
    medium_river   = 23;
    small_river    = 24;
    crossroad      = 25;
    street         = 26;
    avenue         = 27;
    underpass      = 28;
    metro          = 29;
}

/** Performs a search among terrain graph segments to locate the closest from
    a given position up to a certain count with terrain types intersecting a
    given list of types.
*/
message SegmentRequest {
    //! The position near which to search
    required CoordLatLong position = 1;
    //! The terrain types to consider, if empty it defaults to all combined
    //! terrain types
    repeated TerrainType  terrains  = 2;
    //! The maximum number of segments to return
    optional uint32       count     = 3;
    //! The maximum radius into which to consider terrain graph nodes in
    //! meters, defaults to 10 km
    optional float        radius    = 4;
}

/** "ListReports(max_count=10)" returns at most the 10 most recent list_reports
    and a next_report identifier. Use the latter to continue the enumeration: ListReports(max_count=10, next_report=X)
    returns at most ten reports following the first set in reverse chronological order".
*/
message ListReports {
    //! Maximum number of reports to send
    required uint32 max_count = 1;
    //! Report identifier to start enumeration
    optional uint32 report    = 2;
}

/** @struct ClientToSim
    @brief Wraps messages from clients to the simulation
*/
message ClientToSim {
    /** @struct Content
        @brief The possible messages contained in a client to simulation
               message.
        @warning Each Content message must contain exactly one of the
                 possible messages.
    */
    message Content {
        //! @copybrief ControlStop
        optional ControlStop              control_stop                    = 1;
        //! @copybrief ControlPause
        optional ControlPause             control_pause                   = 2;
        //! @copybrief ControlResume
        optional ControlResume            control_resume                  = 3;
        //! @copybrief ControlChangeTimeFactor
        optional ControlChangeTimeFactor  control_change_time_factor      = 4;
        //! @copybrief ControlDateTimeChange
        optional ControlDateTimeChange    control_date_time_change        = 5;
        //! @copybrief ControlCheckPointSaveNow
        optional ControlCheckPointSaveNow control_checkpoint_save_now     = 6;
        //! @copybrief ControlCheckPointSetFrequency
        optional ControlCheckPointSetFrequency
            control_checkpoint_set_frequency                              = 7;
        //! @copybrief ControlEnableVisionCones
        optional ControlEnableVisionCones control_toggle_vision_cones     = 8;
        //! @copybrief UnitOrder
        optional UnitOrder                unit_order                      = 9;
        //! @copybrief AutomatOrder
        optional AutomatOrder             automat_order                   = 10;
        //! @copybrief CrowdOrder
        optional CrowdOrder               crowd_order                     = 11;
        //! @copybrief FragOrder
        optional FragOrder                frag_order                      = 12;
        //! @copybrief SetAutomatMode
        optional SetAutomatMode           set_automat_mode                = 13;
        //! @copybrief UnitCreationRequest
        optional UnitCreationRequest      unit_creation_request           = 14;
        //! @copybrief UnitCreationRequest
        optional UnitMagicAction          unit_magic_action               = 15;
        //! @copybrief ObjectMagicAction
        optional ObjectMagicAction        object_magic_action             = 16;
        //! @copybrief KnowledgeMagicAction
        optional KnowledgeMagicAction     knowledge_magic_action          = 17;
        //! @copybrief MagicAction
        optional MagicAction              magic_action                    = 18;
        //! @copybrief ControlCheckPointListRequest
        optional ControlCheckPointListRequest
            control_checkpoint_list_request                               = 19;
        //! @copybrief ControlCheckPointDeleteRequest
        optional ControlCheckPointDeleteRequest
            control_checkpoint_delete_request                             = 20;
        //! @copybrief ChangePopulationMagicAction
        optional ChangePopulationMagicAction
            change_population_magic_action                                = 21;
        //! @copybrief BurningCellRequest
        optional BurningCellRequest       burning_cell_request            = 23;
        //! @copybrief OrderStream
        optional OrderStream              order_stream                    = 24;
        //! @copybrief ListEnabledVisionCones
        optional ListEnabledVisionCones   list_enabled_vision_cones       = 25;
        optional LogisticHistoryRequest   logistic_history_request        = 26;
        optional ListLogisticRequests     list_logistic_requests          = 27;
        optional ComputePathfind          compute_pathfind                = 28;
        optional SegmentRequest           segment_request                 = 29;
        optional ListReports              list_reports                    = 30;
    }
    /** @property context
        @brief Identifies the request matching the response.

        This field is filled using the "context" fields provided in the
        request message.

        This context allows the client application to differentiate
        acknowledgements to similar messages.

        @see ClientToAuthentication
    */
    optional int32   context = 1;
    //! A field containing one of the messages to be sent
    required Content message = 2;
    /** @property client_id

        This field is filled using the "client_id" field set by the
        dispatcher after a successful authentication in order to
        identify which request was done by which client.

        @see AuthenticationToClient
    */
    optional int32   client_id = 3;
}

/** @}*/
