// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2010 MASA Group
//
// *****************************************************************************

import "common.proto";

package sword;

/** @file
 *  @brief Messages from the simulation to clients
 *  @addtogroup Simulation
 *  @{
 */

/** @struct OrderAck
    @brief Defines order acknowledgement error codes
    @see UnitOrder AutomatOrder CrowdOrder FragOrder
*/
message OrderAck {
    /** @enum ErrorCode
        @brief Reason for the failure of order/mission assignment
        @todo Move long descriptions to the corresponding field in
              BlablaOrder and use @@see tags here
    */
    enum ErrorCode {
        //! Operation succeeded @todo As error codes are optional,
        //! no_error should not exist
        no_error                        = 0;
        //! Operation failed because of an invalid tasker identifier
        //! e.g. an existing agent/automat/crowd identifier @todo rename
        //! to error_invalid_tasker
        error_invalid_unit              = 1;
        //! Operation failed because of an invalid limit : limit
        //! parameters are required for automat missions @deprecated
        //! should be handled using invalid_mission_parameters
        error_invalid_limit             = 2;
        //! Operation failed because of an invalid phase line : phase
        //! line parameters are required for some missions @deprecated
        //! should be handled using invalid_mission_parameters
        error_invalid_lima              = 3;
        //! Operation failed because of an invalid mission identifier :
        //! the mission must exist and be available for the specified
        //! tasker unit
        error_invalid_mission           = 4;
        //! Operation failed because of an invalid mission parameter :
        //! parameters are defined in the file "Missions.xml"
        error_invalid_parameter         = 5;
        //! Operation failed because the unit is not in a state where
        //! it can execute the order : it must be alive and disengaged
        //! (for an agent) @todo rename to
        //! error_tasker_cannot_receive_order
        error_unit_cannot_receive_order = 6;
        //! Operation failed because of an invalid fragmentary order
        //! identifier : valid identifiers can be found in the file
        //! "Missions.xml"
        error_invalid_frag_order        = 7;
        //! Operation failed because of an invalid mission identifier :
        //! valid identifiers can be found in the file "Missions.xml"
        error_invalid_order_mission     = 8;
        //! Operation failed because the unit is not in a state where
        //! it can execute the order : it must not have surrendered and be
        //! able to receive orders @todo rename to
        //! error_tasker_surrendered
        error_unit_surrendered          = 11;
        //! Operation failed because of an invalid phase line function:
        //! phase line parameters are required for some missions, each
        //! phase line is assigned one or more functions in the context of
        //! the mission @deprecated should be handled using
        //! invalid_mission_parameters
        error_invalid_lima_function     = 12;
    }
}

/** @struct TaskCreationRequestAck
    @brief Acknowledges an agent task creation request
    @see UnitOrder
    @todo gather UnitOrder, AutomatOrder and CrowdOrder into one message
*/
message TaskCreationRequestAck {
    //! Identifier of the agent, automat, crowd on which the order was
    //! issued
    required Tasker             tasker     = 1;
    //! Reason for the failure of an agent order execution operation
    required OrderAck.ErrorCode error_code = 2;
    //! Unique order identifier
    optional uint32             id         = 3;
    //! More detailed account of the returned error
    optional string             error_msg  = 4;
}

/** @struct FragOrderAck
    @brief A fragmentary order execution request acknowledgement message
    @see FragOrder
    @todo gather with UnitOrder, AutomatOrder and CrowdOrder into one
          message ?
*/
message FragOrderAck {
    //! Identifier of the agent, automat or crowd on which the
    //! fragmentary order was issued
    required Tasker             tasker     = 1;
    //! Reason for the failure of a fragmentary order execution
    //! operation
    required OrderAck.ErrorCode error_code = 2;
    //! More detailed account of the returned error
    optional string             error_msg  = 3;
    //! Unique order identifier
    optional uint32             id         = 4;
}

//! Acknowledges an automat being engaged or disengaged.
message SetAutomatModeAck {
    enum ErrorCode {
        no_error           = 0;
        //! Operation failed because of an invalid automat identifier
        error_invalid_unit = 1;
        //! Operation failed because the parent automat is engaged
        error_not_allowed  = 2;
    }
    required Id        automate   = 1;
    required ErrorCode error_code = 2;
    //! Unique order identifier
    optional uint32    id         = 3;
}

/** @struct UnitActionAck
    @brief Acknowledges an agent action request
    @todo rename to AgentActionAck
*/
message UnitActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of agent action operation
    */
    enum ErrorCode {
        //! Operation succeeded
        no_error                = 0;
        //! Operation failed because of an invalid agent identifier
        //! @todo rename to error_invalid_agent
        error_invalid_unit      = 1;
        //! Operation failed because the target agent is currently
        //! controlled by its parent automat
        error_automat_engaged   = 2;
        //! Operation failed because the provided action parameters
        //! were invalid
        error_invalid_parameter = 3;
        //! Operation failed because the agent is not in a state where
        //! it can execute the order : it must not have surrendered to be
        //! able to receive orders @todo rename to error_agent_surrendered
        error_unit_surrendered  = 4;
        //! Operation failed because the supply flow was denied
        error_supply_denied     = 5;
        //! Operation failed because the target is undeployed
        error_undeployed        = 6;
        //! Operation failed because the parameter is not a logistics automat
        error_not_log_automat   = 7;
        //! Operation failed because it would create a cycle in a hierarchy
        error_hierarchy_cycle   = 8;
    }
}

/** @struct UnitCreationRequestAck
    @brief Acknowledges an agent creation request
    @see UnitCreationRequest
    @todo rename to AgentCreationRequestAck
*/
message UnitCreationRequestAck {
    //! Reason for the failure of the agent creation operation @see
    //! UnitActionAck.ErrorCode
    required int32 error_code = 1;
}

/** @struct UnitMagicActionAck
    @brief Acknowledges an agent magic action request
    @see UnitMagicAction
    @todo rename to AgentMagicActionRequestAck
*/
message UnitMagicActionAck {
    //! Identifier of the agent on which the magic action was requested
    //! to be executed @todo rename to agent
    required Id                      unit       = 1;
    //! Reason for the failure of the agent magic action execution
    //! operation. @see UnitActionAck.ErrorCode
    required int32                   error_code = 2;
    //! More detailed account of the returned error
    optional string                  error_msg  = 3;
    //! Action results, depends on the action type and outcome.
    //! In case type is log_supply_pull_flow or log_supply_push_flow for each
    //! transporter in the original supply request a list of 4 boolean values
    //! are added to the result indicating whether:
    //! . the transporter is underloaded in weight
    //! . the transporter is overloaded in weight
    //! . the transporter is underloaded in volume
    //! . the transporter is overloaded in volume
    optional MissionParameters       result     = 4;
     //! Action parameters, copied from UnitMagicAction
    optional MissionParameters       parameters = 5;
    //! The tasker @todo remove unit id and use one tasker only
    optional Tasker                  tasker     = 6;
    //! The magic action type
    optional int32                   type       = 7;
    //! optional name
    optional string                  name       = 8;
    //! Unique order identifier
    optional uint32                  id         = 9;
}

/** @struct MagicActionAck
    @brief Acknowledges a magic action request
    @see MagicAction
    @todo rename to MagicActionRequestAck
*/
message MagicActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the magic action operation
    */
    enum ErrorCode {
        //! Operation succeeded
        no_error                = 0;
        //! Operation failed because the provided action parameters
        //! were invalid
        error_invalid_parameter = 1;
    }
    //! Reason for the failure of the magic action execution operation
    //! @see ErrorCode
    required ErrorCode error_code     = 1;
    //! Deprecated attribute
    optional Id        weather        = 2;
    //! Action results, depends on the action type and outcome.
    optional MissionParameters result = 3;
    //! More detailed account of the returned error
    optional string    error_msg      = 4;
    //! Unique order identifier
    optional uint32    id             = 5;
}

/** @struct ObjectMagicActionAck
    @brief Acknowledges an object magic action request
    @see ObjectMagicAction
    @todo rename to ObjectMagicActionRequestAck
*/
message ObjectMagicActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the object magic action operation
    */
    enum ErrorCode {
        //! Operation succeeded
        no_error                          = 0;
        //! Operation failed because the provided object identifier was
        //! invalid
        error_invalid_object              = 1;
        //! Operation failed because the provided party identifier was
        //! invalid
        error_invalid_party               = 3;
        //! Operation failed because object specific attributes are
        //! missing : they must meet the requirements associated with the
        //! object type
        error_missing_specific_attributes = 5;
        //! Operation failed because object specific attributes are
        //! invalid : they must meet the requirements associated with the
        //! object type
        error_invalid_specific_attributes = 6;
    }
    //! Reason for the failure of the object magic action execution
    //! operation @see ErrorCode
    required ErrorCode error_code = 1;
    //! Identifier of the object on which the magic action was requested
    //! to be executed
    optional Id        object     = 2;
    //! More detailed account of the returned error
    optional string    error_msg  = 3;
    //! Unique order identifier
    optional uint32    id         = 4;
}

/** @struct CrowdMagicActionAck
    @brief Acknowledges a crowd magic action request
    @see CrowdMagicAction
    @todo rename to CrowdMagicActionRequestAck
*/
message CrowdMagicActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the crowd magic action operation
    */
    enum ErrorCode {
        //! Operation succeeded
        no_error                = 0;
        //! Operation failed because the provided crowd identifier was
        //! invalid @todo rename to error_invalid_crowd
        error_invalid_unit      = 1;
        //! Operation failed because the provided action parameters
        //! were invalid
        error_invalid_parameter = 2;
    }
    //! Identifier of the crowd on which the magic action was requested
    //! to be executed
    required Id        crowd      = 1;
    //! Reason for the failure of the crowd magic action execution
    //! operation @see ErrorCode
    required ErrorCode error_code = 2;
}

//! Defines the diplomatic relationship of party1 with party2. These
//! relationships are not symmetric, the relation of party1 with party2
//! may be different from the one of party2 with party1.
message ChangeDiplomacy {
    required Id            party1    = 1;
    required Id            party2    = 2;
    //! Relationship from party1 to party2.
    required EnumDiplomacy diplomacy = 3;
}

//! DEPRECATED in 5.3
//!
//! This message was sent in response to a diplomacy change made through
//! a magic action. A regular DiplomacyChange message is now sent as
//! well.
message ChangeDiplomacyAck {
    enum ErrorCode {
        //! Operation succeeded @todo rename to no_error
        no_error_diplomacy            = 0;
        //! Operation failed because the provided diplomacy is invalid
        error_invalid_party_diplomacy = 1;
    }
    //! Identifier of the party from which the diplomacy is defined
    required Id            party1     = 1;
    //! Identifier of the party to which the diplomacy is defined
    required Id            party2     = 2;
    //! Definition of the diplomacy between specified parties
    required EnumDiplomacy diplomacy  = 3;
    //! Reason for the failure of the diplomacy change operation
    required ErrorCode     error_code = 4;
}

/** @struct HierarchyModificationAck
    @brief Factorizes hierarchy modification action acknowledgement errors
    @todo split into different types
*/
message HierarchyModificationAck {
    /** @enum ErrorCode
        @brief Reason for the failure of a hierarchy modification operation
    */
    enum ErrorCode {
        //! Operation succeeded @todo rename to no_error
        no_error_hierarchy            = 0;
        //! Operation failed because no existing agent with the
        //! provided identifier could be found
        error_invalid_agent           = 1;
        //! Operation failed because no existing automat with the
        //! provided identifier could be found @todo rename to
        //! error_invalid_automat
        error_invalid_automate        = 2;
        //! Operation failed because no existing formation with the
        //! provided identifier could be found
        error_invalid_formation       = 3;
        //! Operation failed because no existing supply automat with
        //! the provided identifier could be found
        error_invalid_supply_automat  = 4;
        //! Operation failed because the unit is not in a state where
        //! it can execute the order : it must not have surrendered to be
        //! able to receive orders
        error_agent_surrendered       = 8;
        //! Operation failed because no existing party with the
        //! provided identifier could be found
        error_invalid_party           = 9;
        //! Operation failed because no existing knowledge group with
        //! the provided identifier could be found
        error_invalid_knowledge_group = 10;
        //! Operation failed because an agent cannot be moved from a
        //! party to another
        error_parties_mismatched      = 11;
    }
}

//! DEPRECATED in 5.3
//!
//! This message was sent upon a successful UnitMagicAction changing an
//! automat knowledgegroup. Look for a regular UnitMagicActionAck
//! instead.
message AutomatChangeKnowledgeGroupAck {
    required HierarchyModificationAck.ErrorCode error_code = 1;
}

//! Notifies an automat belongs to a new knowledge group.
message AutomatChangeKnowledgeGroup {
    required Id automat         = 1;
    required Id party           = 2;
    required Id knowledge_group = 3;
}

//! DEPRECATED in 5.3
//!
//! This message was sent on an automat logistic links change request
message ChangeLogisticLinksAck {
    //! Reason for the failure of the automat logistic links change
    //! operation @see HierarchyModificationAck.ErrorCode
    required HierarchyModificationAck.ErrorCode error_code = 1;
}

/** @struct ChangeLogisticLinks
    @brief Notifies a change to the logistic links of an automat
*/
message ChangeLogisticLinks {
    //! Identifier of the automat or formation concerned by the
    //! logistic links update
    required ParentEntity requester = 1;
    //! The new logistic superiors
    repeated ParentEntity superior = 2;
}

/** @struct AutomatChangeSuperiorAck
    @brief Acknowledges an automat superior change request
    @see UnitMagicAction of UnitMagiAction.Type.change_automat_superior
    @todo gather magic action acks
*/
message AutomatChangeSuperiorAck {
    //! Reason for the failure of the automat superior change operation
    //! @see HierarchyModificationAck.ErrorCode
    required HierarchyModificationAck.ErrorCode error_code = 1;
}

//! DEPRECATED in 5.3
//!
/** @struct UnitChangeSuperiorAck
    @brief Acknowledges an agent superior change request
    @see UnitMagicAction of UnitMagiAction.Type.unit_change_superior
    @todo gather magic action acks
*/
message UnitChangeSuperiorAck {
    //! Reason for the failure of the agent superior change operation
    //! @see HierarchyModificationAck.ErrorCode
    required HierarchyModificationAck.ErrorCode error_code = 1;
}

//! DEPRECATED in 5.3
//!
//! This message was sent on a push flow request
message LogSupplyPushFlowAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the pushed flow creation
    */
    enum ErrorCode {
        //! Operation succeeded @todo As error codes are optional,
        //! no_error should not exist
        no_error_pushflow      = 0;
        //! Operation failed because no existing supplying automat with
        //! the provided identifier could be found
        error_invalid_supplier = 1;
        //! Operation failed because no existing receiving automat with
        //! the provided identifier could be found
        error_invalid_receiver = 2;
    }
    //! Reason for the failure of the request @see ErrorCode
    optional ErrorCode error_code = 1;
}

//! DEPRECATED in 5.3
//!
//! This message was sent on a pull flow request
message LogSupplyPullFlowAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the pulled flow creation
    */
    enum ErrorCode {
        //! Operation succeeded @todo As error codes are optional,
        //! no_error should not exist
        no_error_pullflow      = 0;
        //! Operation failed because no existing supplying automat with
        //! the provided identifier could be found
        error_invalid_supplier = 1;
        //! Operation failed because no existing receiving automat with
        //! the provided identifier could be found
        error_invalid_receiver = 2;
    }
    //! Reason for the failure of the request @see ErrorCode
    optional ErrorCode error_code = 1;
}

//! DEPRECATED in 5.3
//!
//! This message was sent on a quota allocation change request
message LogSupplyChangeQuotasAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the quota allocation.
    */
    enum ErrorCode {
        //! Operation succeeded @todo rename to no_error @todo As error
        //! codes are optional, no_error should not exist
        no_error_quotas        = 0;
        //! Operation failed because no existing supplying automat with
        //! the provided identifier could be found
        error_invalid_supplier = 1;
        //! Operation failed because no existing receiving automat with
        //! the provided identifier could be found
        error_invalid_receiver = 2;
        /** @brief Operation failed because of an dotation parameter.
            An invalid (non existing) dotation was specified.
            @todo rename to error_invalid_receiver
        */
        error_invalid_dotation = 3;
    }
    //! Reason for the failure of the request @see ErrorCode
    optional ErrorCode error_code = 1;
}

//! DEPRECATED in 5.3
//!
//! This message is replaced by UnitActionAck.
message ActionCreateFireOrderAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the create fire order.
    */
    enum ErrorCode {
        //! Operation succeeded @todo make error_code optional and
        //! remove no_error
        no_error                     = 0;
        //! Operation failed because no existing reporter with the
        //! provided identifier could be found
        error_invalid_reporter       = 1;
        //! Operation failed because no existing target with the
        //! provided identifier could be found
        error_invalid_target         = 2;
        //! Operation failed because no existing ammunition with the
        //! provided identifier could be found
        error_invalid_ammunition     = 3;
        //! Operation failed because iterations should be greater than 0
        error_invalid_iteration      = 4;
        //! Operation failed because of the target not being illuminated
        error_target_not_illuminated = 5;
    }
    //! Reason for the failure of the request @see ErrorCode @todo
    //! change field index to 1
    required ErrorCode error_code = 2;
    //! More detailed account of the returned error
    optional string    error_msg  = 3;
}

/** @struct BurningCellRequestAck
    @brief An acknowledgement message to a burning cell request
    @see BurningCellRequest
*/
message BurningCellRequestAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the burning cell request
    */
    enum ErrorCode {
        no_error                  = 0;
    }
    //! Reason for the failure of the request
    required ErrorCode error_code = 1;
}

/** @struct ControlInformation
    @brief Provides various global informations
    @todo Find when and why this is sent (probably when a client connects ?)
*/
message ControlInformation {
    //! The current tick number
    required int32               current_tick         = 1;
    //! The initial date and time @see DateTime
    required DateTime            initial_date_time    = 2;
    //! The current date and time @see DateTime @see ControlDateTimeChange
    required DateTime            date_time            = 3;
    //! The duration of a simulation tick in seconds
    required int32               tick_duration        = 4;
    //! The simulation time multiplier @see ControlChangeTimeFactor
    required int32               time_factor          = 5;
    //! The number of seconds between automatic checkpoints saves
    //! @see ControlCheckPointSetFrequency @see ControlCheckPointSaveNow
    required int32               checkpoint_frequency = 6;
    //! The current status of the simulation @see EnumSimulationState
    //! @see ControlStop ControlPause ControlResume
    required EnumSimulationState status               = 7;
    //! Whether the vision cones for units is currently being sent or not
    //! @see SimToClient::Content::unit_vision_cones
    //! @deprecated Will always be false
    required bool                send_vision_cones    = 8;
    //! Whether the profiling information is currently being sent or not
    //! @see SimToClient::Content::control_profiling_information
    required bool                profiling_enabled    = 9;
    //! The local date when checkpoint saved
    optional DateTime            checkpoint_real_time = 10;
}

/** @struct ControlProfilingInformation
    @brief Provides profiling information message
    @deprecated The message seems to never be actually sent by the
                simulation
*/
message ControlProfilingInformation {
    //! The amount of time spent for computing perceptions @todo unit ?
    required float perception = 1;
    //! The amount of time spent for computing decisions @todo unit ?
    required float decision   = 2;
    //! The amount of time spent for performing actions @todo unit ?
    required float action     = 3;
    //! The amount of time spent for the whole tick @todo unit ?
    required float main_loop  = 4;
}

/** @struct ControlBeginTick
    @brief A control begin tick message
    @see ControlEndTick
*/
message ControlBeginTick {
    //! The current tick number
    required int32    current_tick   = 1;
    //! The simulated date and time @see DateTime
    required DateTime date_time      = 2;
    //! The real date and time in UTC
    //! @see DateTime
    optional DateTime real_date_time = 3;
}

/** @struct ControlEndTick
    @brief A control end tick message
    @see ControlBeginTick
*/
message ControlEndTick {
    //! The current tick number
    required int32 current_tick    = 1;
    //! The current tick duration in seconds
    required int32 tick_duration   = 2;
    //! The number of pending long path finding requests @todo explain
    //! how and why is a path considered long
    required int32 long_pathfinds  = 3;
    //! The number of pending short path finding requests @todo explain
    //! how and why is a path considered short
    required int32 short_pathfinds = 4;
    //! The memory size in use in bytes
    required int32 memory          = 5;
    //! The virtual memory size in use in bytes
    required int32 virtual_memory  = 6;
}

/** @struct ControlAck
    @brief A control acknowledgement message
    @see ControlStop ControlPause ControlResume
    @see ControlChangeTimeFactor
    @see ControlDateTimeChange
    @todo split into different acks
*/
message ControlAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the control request
    */
    enum ErrorCode {
        //! Operation succeeded
        no_error                  = 0;
        //! @deprecated never used
        error_already_started     = 1;
        //! Stop request failed because the simulation is already stopped
        error_not_started         = 2;
        //! Resume request failed because the simulation is running
        error_not_paused          = 3;
        //! Pause request failed because the simulation is already paused
        error_already_paused      = 4;
        //! The time factor must be strictly positive
        error_invalid_time_factor = 5;
        //! The new date/time must be after the current date/time
        error_invalid_date_time   = 6;
        //! Caller has not enough privileges for this operation
        error_forbidden           = 7;
    }
}

/** @struct ControlDateTimeChangeAck
    @brief A data time change acknowledgement message
    @see ControlDateTimeChange
*/
message ControlDateTimeChangeAck {
    //! Reason for the failure of the request
    required ControlAck.ErrorCode error_code = 1;
}

//! ControlChangeTimeFactor response.
message ControlChangeTimeFactorAck {
    //! The simulation time factor after the change command was applied.
    required int32                time_factor = 1;
    required ControlAck.ErrorCode error_code  = 2;
}

/** @struct ControlStopAck
    @brief A stop acknowledgement message
    @see ControlStop
*/
message ControlStopAck {
    //! Reason for the failure of the request
    required ControlAck.ErrorCode error_code = 1;
}

//! Broadcast when the simulation enters paused state.
message ControlPauseAck {
    //! Reason for the failure of the request
    required ControlAck.ErrorCode error_code   = 1;
    optional int32                current_tick = 2;
}

//! Broadcast when the simulation leaves paused state.
message ControlResumeAck {
    //! Reason for the failure of the request
    required ControlAck.ErrorCode error_code   = 1;
    optional int32                current_tick = 2;
    //! If set and greater than zero, the number of ticks after which
    //! the simulation will pause again.
    optional int32                delay        = 3;
}

/** @struct PartyCreation
    @brief A party creation message
*/
message PartyCreation {
    //! The party identifier
    required Id            party     = 1;
    //! The party name
    required string        name      = 2;
    //! @todo Relation to what ?
    required EnumDiplomacy type      = 3;
    //! The extension fields
    optional Extension     extension = 4;
    //! The party color @see RgbColor
    optional RgbColor      color     = 5;
}

/** @struct PartyUpdate
    @brief Notifies of the update of a party
*/
message PartyUpdate {
    //! The party identifier
    required Id     party = 1;
    //! The party name
    optional string name  = 2;
}

/** @enum EnumLogisticLevel
    @brief Defines the different levels of logistic
*/
enum EnumLogisticLevel {
    //! No logistic @todo rename to no_logistic
    none          = 0;
    //! Logistic base
    logistic_base = 1;
}

/** @struct FormationCreation
    @brief A formation creation message
*/
message FormationCreation {
    //! The formation identifier @see FormationId
    required Id                formation              = 1;
    //! The party identifier
    required Id                party                  = 2;
    //! The parent formation identifier @see FormationId
    optional Id                parent                 = 3;
    //! The formation nature level @see EnumNatureLevel
    required EnumNatureLevel   level                  = 4;
    //! The formation name
    required string            name                   = 5;
    //! The formation APP-6 symbol
    required string            app6symbol             = 7;
    //! @todo What's this ?
    required EnumLogisticLevel logistic_level         = 8;
    //! The formation color @see RgbColor
    optional RgbColor          color                  = 9;
    //! The automat APP-6 symbol @deprecated Use app6symbol instead
    required string            symbol                 = 10;
    //! The extension fields
    optional Extension         extension              = 11;
    //! The logistic maintenance mode: true for manual,
    //! false for automatic (by default)
    optional bool              log_maintenance_manual = 12;
    //! The logistic supply mode: true for manual,
    //! false for automatic (by default)
    optional bool              log_supply_manual      = 13;
}

/** @struct FormationUpdate
    @brief A formation update message
*/
message FormationUpdate {
    //! The formation identifier @see FormationId
    required Id        formation                = 1;
    //! The extension fields
    optional Extension extension                = 2;
    //! The logistic maintenance mode: true for manual,
    //! false for automatic, unchanged if omitted.
    optional bool      log_maintenance_manual   = 3;
    //! The logistic supply mode: true for manual,
    //! false for automatic, unchanged if omitted.
    optional bool      log_supply_manual        = 4;
    //! The formation name
    optional string    name                     = 5;
}

/** @struct FormationDestruction
    @brief A formation destruction message
*/
message FormationDestruction {
    required Id formation = 1;
}

/** @struct AutomatCreation
    @brief An automat creation message
*/
message AutomatCreation {
    //! The automat identifier
    required Id                automat                = 1;
    //! The automat type @see AutomatType
    required Id                type                   = 2;
    //! The automat name
    required string            name                   = 3;
    //! The automat parent @see ParentEntity
    required ParentEntity      parent                 = 4;
    //! The automat party
    required Id                party                  = 5;
    //! The automat knowledge group
    optional Id                knowledge_group        = 6;
    //! The automat APP-6 symbol
    required string            app6symbol             = 7;
    //! The automat logistic level @see EnumLogisticLevel
    required EnumLogisticLevel logistic_level         = 8;
    //! The automat color @see RgbColor
    optional RgbColor          color                  = 9;
    //! The automat APP-6 symbol @deprecated Use app6symbol instead
    required string            symbol                 = 10;
    //! The extension fields
    optional Extension         extension              = 11;
    //! The logistic maintenance mode: true for manual,
    //! false for automatic (by default)
    optional bool              log_maintenance_manual = 12;
    //! The logistic supply mode: true for manual,
    //! false for automatic (by default)
    optional bool              log_supply_manual      = 13;
}

/** @struct RulesOfEngagement
    @brief A rules of engagement message
*/
message RulesOfEngagement {
    /** @enum Value
        @brief Value of the rules of engagement
        @todo make RulesOfEngagement the enum or move the value field in
              this message
    */
    enum Value {

        //! Fire permitted
        free_fire        = 0;
        //! Fire back permitted
        retaliation_only = 1;
        //! Fire forbidden
        fire_upon_order  = 2;
    }
}

/** @struct ForceRatio
    @brief A force ratio message
*/
message ForceRatio {
    /** @enum Value
        @brief Value of the force ratio
        @todo make ForceRatio the enum
    */
    enum Value {
        //! No force ratio
        none        = 0;
        //! Neutral
        neutral     = 1;
        //! Favorable
        favorable   = 2;
        //! Unfavorable
        unfavorable = 3;
    }
}

/** @enum EnumMeetingEngagementStatus
    @brief Defines the states of a meeting engagement
*/
enum EnumMeetingEngagementStatus {
    //! No engagement
    no_contact              = 0;
    //! Avoiding engagement
    avoiding                = 1;
    //! Pinned down
    pinned_down             = 2;
    //! Proceeding with the mission
    proceeding_with_mission = 3;
}

/** @enum EnumOperationalStatus
    @brief Defines the states of the operational status
*/
enum EnumOperationalStatus {
    //! Totally destroyed
    totally_destroyed    = 0;
    //! Tactically Destroyed
    tactically_destroyed = 1;
    //! Operational
    operational          = 2;
}

/** @struct AutomatAttributes
    @brief An automat attributes update message
*/
message AutomatAttributes {
    //! The automat identifier
    required Id                          automat                = 1;
    //! The automat mode
    optional EnumAutomatMode             mode                   = 2;
    //! The automat force ratio
    optional ForceRatio.Value            force_ratio            = 3;
    //! The meeting engagement status
    optional EnumMeetingEngagementStatus meeting_engagement     = 4;
    //! The automat operational state
    optional EnumOperationalStatus       operational_state      = 5;
    //! The automat rules of engagement
    optional RulesOfEngagement.Value     roe                    = 6;
    //! The extension fields
    optional Extension                   extension              = 9;
    //! The decisional model
    optional string                      decisional_model       = 10;
    //! The brain debug activation
    optional bool                        brain_debug            = 11;
    //! The logistic maintenance mode: true for manual,
    //! false for automatic, unchanged if omitted.
    optional bool                        log_maintenance_manual = 12;
    //! The logistic supply mode: true for manual,
    //! false for automatic, unchanged if omitted
    optional bool                        log_supply_manual      = 13;
    //! The automat name
    optional string                      name                   = 14;
}

/** @struct AutomatDestruction
    @brief An automat destruction message
*/
message AutomatDestruction {
    //! The automat identifier
    required Id        automat = 1;
}

/** @struct UnitCreation
    @brief A unit creation message
*/
message UnitCreation {
    //! The unit identifier
    required Id               unit        = 1;
    //! The unit type
    required Id               type        = 2;
    //! The unit name
    required string           name        = 3;
    //! The automata the unit belongs to
    required Id               automat     = 4;
    //! Whether the unit is headquarters of its automata
    required bool             pc          = 5;
    //! The unit color @see RgbColor
    optional RgbColor         color       = 6;
    //! The unit human repartition @see HumanRepartition
    optional HumanRepartition repartition = 7;
    //! The unit nature level @see EnumNatureLevel
    optional EnumNatureLevel  level       = 8;
    //! The unit APP-6 symbol
    optional string           app6symbol  = 9;
    //! The extension fields
    optional Extension        extension   = 10;
}

//! Lists equipments current unit borrowed from another unit.
message BorrowedEquipments {

    message BorrowedEquipment {
        required Id            owner    = 1;
        required Id            type     = 2;
        required int32         quantity = 3;
    }
    repeated BorrowedEquipment elem = 1;
}

//! Lists the equipments lent from the current unit to another.
message LentEquipments {

    message LentEquipment {
        required Id            borrower = 1;
        required Id            type     = 2;
        required int32         quantity = 3;
    }
    repeated LentEquipment elem = 1;
}

//! Describes unit resources
message ResourceDotations {

    message ResourceDotation {
        required Id           type      = 1;
        required int32        quantity  = 2;
        //! DEPRECATED
        optional float        threshold = 3;
        //! The low logistic threshold between 0 and high threshold.
        optional float        low_threshold = 4;
        //! The high logistic threshold between low threshold and 100.
        optional float        high_threshold = 5;
    }
    repeated ResourceDotation elem = 1;
}

//! Describes unit equipments.
message EquipmentDotations {

    message EquipmentDotation {
        required Id            type            = 1;
        //! The number of available equipments
        required int32         available       = 2;
        //! The number of unavailable equipments
        required int32         unavailable     = 3;
        //! The number of fixable equipments
        required int32         repairable      = 4;
        //! The number of equipments fixable on site
        required int32         on_site_fixable = 5;
        //! The number of equipments under maintenance
        required int32         repairing       = 6;
        //! The number of captured equipments
        required int32         captured        = 7;
        //! The detail of breakdowns. There is one entry per
        //! "repairable" element, matching a breakdown identifier
        //! defined in the physical database.
        repeated int32         breakdowns      = 8;
        //! The number of equipments away. Equipments are away when
        //! their owner is being transported by another unit but the
        //! equipment is not transportable.
        optional int32         away            = 9;
    }
    repeated EquipmentDotation elem = 1;
}

enum EnumHumanState {
    healthy = 0;
    injured = 1;
    //! Dead state
    deadly  = 2;
}

//! Defines the status of crew members on the battlefield.
enum EnumHumanLocation {
    //! Located on the battlefield
    battlefield         = 0;
    //! Assigned to maintenance
    maintenance         = 1;
    //! In treatment
    medical             = 2;
    //! In funeral system
    funeral             = 3;
    //! unknown location
    unknown_location    = 4;
}

enum EnumInjuriesSeriousness {
    //! Wounded emergency level 1
    wounded_u1 = 0;
    //! Wounded emergency level 2
    wounded_u2 = 1;
    //! Wounded emergency level 3
    wounded_u3 = 2;
    //! Wounded extreme emergency
    wounded_ue = 3;
}

message Injury {
    //! DEPRECATED, this identifier is set to zero.
    required int32                   id          = 1;
    required EnumInjuriesSeriousness seriousness = 2;
}

//! Describes the state of a unit equipments crew members.
message HumanDotations {

    message HumanDotation {
        //! Number of persons in this set.
        required int32               quantity         = 1;
        required EnumHumanRank       rank             = 2;
        required EnumHumanState      state            = 3;
        required EnumHumanLocation   location_DEPRECATED = 4;
        repeated Injury              injuries         = 5;
        //! Whether the group is mentally wounded or not
        optional bool                mentally_wounded = 6;
        //! Whether the group is NBC contaminated or not
        optional bool                contaminated     = 7;
        optional EnumHumanLocation   location         = 8
            [default = unknown_location];
    }
    //! Each element describes a set of humans sharing the same state,
    //! that is the same attributes combination.
    repeated HumanDotation elem = 1;
}

/** @struct ContaminationState
    @brief A contamination state message
    @todo move into UnitAttributes
*/
message ContaminationState {
    //! deprecated
    optional int32 percentage               = 1;
    //! @todo What's this ?
    optional float quantity                 = 2;
    //! The contamination dose
    optional float dose                     = 3;
    //! Whether the group is NBC contaminated or not
    optional bool contaminated              = 4;
    //! The decontamination process
    optional int32 decontamination_process  = 5;
}

/** @struct Communication
    @brief A communication message
    @todo move into UnitAttributes
    @todo rename to Communications with an s
*/
message Communication {
    //! Whether the communications are jammed or not
    optional bool              jammed          = 1;
    //! The knowledge group identifier
    optional Id                knowledge_group = 2;
}

//! Unit attributes update notification.
message UnitAttributes {

    enum Posture {
        moving                           = 0;
        infiltrating                     = 1;
        stopping                         = 2;
        short_stopping                   = 3;
        parked                           = 4;
        parked_on_self_prepared_area     = 5;
        parked_on_engineer_prepared_area = 6;
    }

    enum FireAvailability {
        no_fire          = 0;
        fire_ready       = 1;
        fire_unavailable = 2;
        engaged          = 3;
    }

    //! Rules of engagment against crowds.
    enum CrowdRoe {
        //! No rule
        no_rule          = 0;
        //! Use of force forbidden
        no_force         = 1;
        //! Hold back civilians by the use of non lethal means
        non_lethal_force = 2;
        //! Lethal weapons authorized for use
        lethal_force     = 3;
    }

    enum EnumUnitTiredness {
        rested     = 0;
        tired      = 1;
        exhausted  = 2;
    }

    enum EnumUnitMorale {
        fanatical = 0;
        high      = 1;
        standard  = 2;
        low       = 3;
    }

    enum EnumUnitExperience {
        veteran = 0;
        expert  = 1;
        novice  = 2;
    }

    enum EnumUnitStress {
        calm     = 0;
        worried  = 1;
        stressed = 2;
    }

    message Satisfaction {
        optional float safety                = 1;
        optional float lodging               = 2;
        optional float access_to_health_care = 3;
    }

    required Id                          unit                       = 1;
    //! Human composition of this unit, with their current states.
    optional HumanDotations              human_dotations            = 2;
    //! Unit equipments, mostly vehicles or human surrogates.
    optional EquipmentDotations          equipment_dotations        = 3;
    //! Resource dotations are unique by type and only new or updated
    //! entries are sent.
    optional ResourceDotations           resource_dotations         = 4;
    //! Unit equipments lent to another unit.
    optional LentEquipments              lent_equipments            = 5;
    //! Unit equipment borrowed from another unit.
    optional BorrowedEquipments          borrowed_equipments        = 6;
    //! The current position @see CoordLatLong
    optional CoordLatLong                position                   = 7;
    //! The current heading @see Heading @todo rename to heading
    optional Heading                     direction                  = 8;
    //! The current height from the ground in meters
    optional int32                       height                     = 9;
    //! The current altitude on the geoid model of the earth in meters
    optional int32                       altitude                   = 10;
    //! The current speed in kilometers per hour
    optional int32                       speed                      = 11;
    //! The operational state as a percentage
    optional int32                       raw_operational_state      = 12;
    //! The reinforcements
    optional IdList                      reinforcements             = 13;
    //! The reinforced unit
    optional Id                          reinforced_unit            = 14;
    //! Whether the unit is dead or not
    optional bool                        dead                       = 15;
    //! Whether the unit has been neutralized or not
    optional bool                        neutralized                = 16;
    //! Whether the unit is in stealth mode
    optional bool                        stealth                    = 17;
    //! Whether the unit is underground
    optional bool                        underground                = 18;
    //! Whether the unit has been embarked or not
    optional bool                        embarked                   = 19;
    //! Whether the unit has transporters available or not
    optional bool                        transporters_available     = 20;
    //! The posture which the unit is transitioning from
    optional Posture                     old_posture                = 21;
    //! The posture which the unit is transitioning to
    optional Posture                     new_posture                = 22;
    //! The completion of the posture transition in percent
    optional int32                       posture_transition         = 23;
    //! The completion of the installation in percent
    optional int32                       installation               = 24;
    //! Whether the unit is wearing NBC protective suits or not
    optional bool                        protective_suits           = 25;
    //! The NBC contamination agents
    optional IdList                      contamination_agents       = 26;
    //! The NBC contamination state @see ContaminationState
    optional ContaminationState          contamination_state        = 27;
    //! The communication state @see Communication
    optional Communication               communications             = 28;
    //! Whether the radio emitter is disabled or not
    optional bool                        radio_emitter_disabled     = 29;
    //! Whether the radio receiver is disabled or not
    optional bool                        radio_receiver_disabled    = 30;
    //! Whether the radar is active or not
    optional bool                        radar_active               = 31;
    //! The transported units
    optional IdList                      transported_units          = 32;
    //! The transporting unit
    optional Id                          transporting_unit          = 33;
    //! The force ratio @see ForceRatio
    optional ForceRatio.Value            force_ratio                = 34;
    //! The meeting engagement status
    optional EnumMeetingEngagementStatus meeting_engagement         = 35;
    //! The operational state
    optional EnumOperationalStatus       operational_state          = 36;
    //! The indirect fire availability
    optional FireAvailability            indirect_fire_availability = 37;
    //! The rules of engagement @see RulesOfEngagement @todo rename to
    //! rules_of_engagement
    optional RulesOfEngagement.Value     roe                        = 38;
    //! The rules of engagement against crowds @see CrowdRoe @todo rename to ?
    optional CrowdRoe                    roe_crowd                  = 39;
    //! The tiredness @see EnumUnitTiredness
    optional EnumUnitTiredness           tiredness                  = 40;
    //! The morale @see EnumUnitMorale
    optional EnumUnitMorale              morale                     = 41;
    //! The experience @see EnumUnitExperience
    optional EnumUnitExperience          experience                 = 42;
    //! The identifier of the party the unit surrendered to. This field
    //! remains as a Id     for backward compatibility reasons.
    optional Id                          surrendered_unit           = 43;
    //! Whether the unit has been made prisoner or not
    optional bool                        prisoner                   = 44;
    //! Whether refugees are being handled by the unit or not
    optional bool                        refugees_managed           = 45;
    //! The satisfaction @see Satisfaction
    optional Satisfaction                satisfaction               = 46;
    //! The current critical intelligence
    optional string                      critical_intelligence      = 47;
    //! The party adhesions
    optional PartyAdhesions              adhesions                  = 48;
    //! The extension fields
    optional Extension                   extension                  = 49;
    //! The stress @see EnumUnitStress
    optional EnumUnitStress              stress                     = 50;
    //! The number of transported humans from a crowd
    optional int32                       transported_crowd          = 51;
    //! The decisional model
    optional string                      decisional_model           = 52;
    //! Whether the unit is the headquarters of its automata
    optional bool                        headquarters               = 53;
    //! The direction of sensors
    optional Heading                     sensors_direction          = 54;
    //! The unit ambiance safety mode
    optional bool                        ambiance_safety            = 55;
    //! The brain debug activation
    optional bool                        brain_debug                = 56;
    //! The unit name
    optional string                      name                       = 57;
}

/** @struct UnitPathFind
    @brief Notifies of a path change for a unit
*/
message UnitPathFind {
    //! The unit identifier
    required Id     unit = 1;
    //! The unit path @see Path
    required Path   path = 2;
}

/** @struct UnitDestruction
    @brief Notifies of the destruction a unit
*/
message UnitDestruction {
    //! The unit identifier
    required Id     unit = 1;
}

/** @struct UnitEnvironmentType
    @brief Notifies of a change in the environment for a given unit
*/
message UnitEnvironmentType {
    //! The unit identifier
    required Id     unit   = 1;
    //! @todo What's this ?
    required int32  area   = 2;
    //! @todo What's this ?
    required int32  left   = 3;
    //! @todo What's this ?
    required int32  right  = 4;
    //! @todo What's this ?
    required int32  linear = 5;
}

/** @struct UnitKnowledgeCreation
    @brief Notifies of the creation of a unit knowledge
*/
message UnitKnowledgeCreation {
    //! The unit knowledge identifier
    required Id               knowledge       = 1;
    //! The knowledge group identifier
    required Id               knowledge_group = 2;
    //! The unit identifier
    required Id               unit            = 3;
    //! The unit type
    required Id               type            = 4;
}

/** @struct UnitIdentification
    @brief Encapsulates the unit identification levels
*/
message UnitIdentification {
    /** @enum Level
        @brief Indicates the level of identification of a unit
    */
    enum Level {
        //! The unit has been identified
        identified = 0;
        //! The unit has been recognized
        recognized = 1;
        //! The unit has been detected
        detected   = 2;
        //! The unit has not been seen
        unseen     = 3;
    }
}

/** @struct AutomatPerception
    @brief Describes the perception of an automat
*/
message AutomatPerception {
    //! The automat identifier
    required Id                          automat           = 1;
    //! The identification level @see UnitIdentification.Level
    required UnitIdentification.Level identification_level = 2;
}

/** @struct SeqOfAutomatPerception
    @brief Regroups the perceptions of several automats
*/
message SeqOfAutomatPerception {
    //! The perceptions @see AutomatPerception
    repeated AutomatPerception elem = 1;
}

/** @struct UnitKnowledgeUpdate
    @brief Notifies of an update in the knowledge of a unit
*/
message UnitKnowledgeUpdate {
    //! The unit knowledge
    required Id                       knowledge                = 1;
    //! The knowledge group identifier
    required Id                       knowledge_group          = 2;
    //! The relevance of the knowledge in percent
    optional int32                    pertinence               = 3;
    //! The identification level @see UnitIdentification.Level
    optional UnitIdentification.Level identification_level     = 4;
    //! The maximum identification level @see UnitIdentification.Level
    optional UnitIdentification.Level max_identification_level = 5;
    //! The operational state of the unit in percent
    optional int32                    operational_state        = 6;
    //! Whether the unit is dead or not
    optional bool                     dead                     = 7;
    //! The unit position @see CoordLatLong
    optional CoordLatLong             position                 = 8;
    //! The unit heading @see Heading
    optional Heading                  direction                = 9;
    //! The unit speed in kilometers per hour
    optional int32                    speed                    = 10;
    //! The unit party identifier
    optional Id                       party                    = 11;
    //! Whether the unit is a command post or not
    optional bool                     command_post             = 12;
    //! The perceptions for each automat
    optional SeqOfAutomatPerception   perceptions              = 13;
    //! The unit to which this unit has surrendered
    optional Id                       surrendered_unit         = 14;
    //! Whether the unit has been made prisoner or not
    optional bool                     prisoner                 = 15;
    //! Whether refugees are being handled by the unit or not
    optional bool                     refugees_managed         = 16;
    //! The unit critical intelligence
    optional string                   critical_intelligence    = 17;
    //! The unit posture
    optional UnitAttributes.Posture   posture                  = 18;
}

/** @struct UnitKnowledgeDestruction
    @brief Notifies of the destruction of a unit knowledge
*/
message UnitKnowledgeDestruction {
    //! The unit knowledge
    required Id               knowledge       = 1;
    //! The knowledge group identifier
    required Id               knowledge_group = 2;
}

/** @struct StartUnitFire
    @brief Notifies of the beginning of a unit firing
*/
message StartUnitFire {
    /** @struct UnitFireTarget
        @brief Defines the target
    */
    message UnitFireTarget {
        //! The target unit
        optional Id           unit            = 1;
        //! The target crowd
        optional Id           crowd           = 2;
        //! The target position
        optional CoordLatLong position        = 3;
        //! The target crowd
        optional Id           crowd_element   = 4;
    }
    /** @enum UnitFireType
        @brief Defines the fire type
    */
    enum UnitFireType {
        //! Direct fire
        direct   = 0;
        //! Indirect fire
        indirect = 1;
    }
    //! The fire identifier
    required Id             fire        = 1;
    //! The firing unit identifier
    required Id             firing_unit = 2;
    //! The target
    required UnitFireTarget target      = 3;
    //! The fire type
    required UnitFireType   type        = 4;
    //! The ammunition type
    optional Id             ammunition  = 5;
}

/** @struct StartUnitFireDetection
    @brief Notifies of the beginning of a fire detection

    This is only for indirect fires.
*/
message StartUnitFireDetection {
    //! The fire identifier
    required Id             fire        = 1;
    //! A list of detecting unit identifiers
    repeated Id             units       = 2;
    //! The firing unit identifier
    required Id             firer       = 3;
    //! The target position
    required CoordLatLong   target      = 4;
}

/** @struct StopUnitFireDetection
    @brief Notifies of the end of a fire detection

    This is only for indirect fires.
*/
message StopUnitFireDetection {
    //! The fire identifier
    required Id             fire        = 1;
    //! A list of detecting unit identifiers
    repeated Id             units       = 2;
}

/** @struct UnitHumanFireDamage
    @brief Defines the damage inflicted the humans of a unit
*/
message UnitHumanFireDamage {
    //! The unit rank
    required EnumHumanRank rank       = 1;
    //! The number of alive humans
    required int32         alive      = 2;
    //! The number of dead humans
    required int32         dead       = 3;
    //! The number of wounded humans urgency level 1
    required int32         wounded_u1 = 4;
    //! The number of wounded humans urgency level 2
    required int32         wounded_u2 = 5;
    //! The number of wounded humans urgency level 3
    required int32         wounded_u3 = 6;
    //! The number of wounded humans urgency level extreme
    required int32         wounded_ue = 7;
}

/** @struct SeqOfUnitHumanFireDamage
    @brief Defines a list of damages inflicted the humans of a unit
*/
message SeqOfUnitHumanFireDamage {
    //! The list of human damages
    repeated UnitHumanFireDamage elem = 1;
}

/** @struct UnitEquipmentFireDamage
    @brief Defines the damage inflicted the equipment of a unit
*/
message UnitEquipmentFireDamage {
    //! The equipment
    required Id           equipement   = 1;
    //! The number of available equipements
    required int32        available    = 2;
    //! The number of unavailable equipements
    required int32        unavailable  = 3;
    //! The number of repairable equipements
    required int32        repairable   = 4;
}

/** @struct SeqOfUnitEquipmentFireDamage
    @brief Defines a list of damages inflicted to the equipments of a unit
*/
message SeqOfUnitEquipmentFireDamage {
    //! The list of equipment damages
    repeated UnitEquipmentFireDamage elem = 1;
}

/** @struct UnitFireDamages
    @brief Aggregates the damages to a unit
*/
message UnitFireDamages {
    //! The unit identifier
    required Id                           target     = 1;
    //! The damages to the humans
    required SeqOfUnitHumanFireDamage     humans     = 2;
    //! The damages to the equipments
    required SeqOfUnitEquipmentFireDamage equipments = 3;
}

/** @struct UnitsFireDamages
    @brief Defines a list of damages to several units
*/
message UnitsFireDamages {
    //! The list of damages
    repeated UnitFireDamages elem = 1;
}

/** @struct CrowdFireDamages
    @brief Defines the damage inflicted to a crowd
*/
message CrowdFireDamages {
    //! The crowd identifier
    required Id      target    = 1;
    //! The number of dead persons
    required int32   dead      = 2;
    //! The number of wounded persons
    required int32   wounded   = 3;
    //! The number of scattered persons
    required int32   scattered = 4;
}

/** @struct CrowdsFireDamages
    @brief Defines the damage inflicted to several crowds
*/
message CrowdsFireDamages {
    //! The list of damages
    repeated CrowdFireDamages elem = 1;
}

/** @struct StopUnitFire
    @brief Notifies of the end of a unit firing
*/
message StopUnitFire {
    //! The fire identifier
    required Id                fire           = 1;
    //! The resulting damages dealt to units
    optional UnitsFireDamages  units_damages  = 2;
    //! The resulting damages dealt to crowds
    optional CrowdsFireDamages crowds_damages = 3;
}

/** @struct StartCrowdFire
    @brief Notifies of the beginning of a crowd firing
*/
message StartCrowdFire {
    //! The fire identifier
    required Id      fire         = 1;
    //! The crowd identifier
    required Id      firing_crowd = 2;
}

/** @struct StopCrowdFire
    @brief Notifies of the end of a crowd firing
*/
message StopCrowdFire {
    //! The fire identifier
    required Id               fire          = 1;
    //! The resulting damages dealt to units
    required UnitsFireDamages units_damages = 2;
}

/** @struct Explosion
    @brief Notifies of an explosion
*/
message Explosion {
    //! The explosion object identifier
    required Id                object         = 1;
    //! The resulting damages dealt to units
    optional UnitsFireDamages  units_damages  = 2;
    //! The resulting damages dealt to crowds
    optional CrowdsFireDamages crowds_damages = 3;
}

message UnitDamagedByUnitFire {
    //! The target unit identifier
    required Id                           unit        = 1;
    //! The target party identifier
    required Id                           party       = 2;
    //! The firer unit identifier
    required Id                           firer       = 3;
    //! The fire identifier
    required Id                           fire        = 4;
    //! Whether the fire is direct or not
    required bool                         direct_fire = 5;
    //! Whether the fire is fratricide or not
    required bool                         fratricide  = 6;
    //! The damages to the humans
    required SeqOfUnitHumanFireDamage     humans      = 7;
    //! The damages to the equipments
    required SeqOfUnitEquipmentFireDamage equipments  = 8;
}

message CrowdDamagedByUnitFire {
    //! The target crowd identifier
    required Id      crowd       = 1;
    //! The target party identifier
    required Id      party       = 2;
    //! The firer unit identifier
    required Id      firer       = 3;
    //! The fire identifier
    required Id      fire        = 4;
    //! Whether the fire is direct or not
    required bool    direct_fire = 5;
    //! Whether the fire is fratricide or not
    required bool    fratricide  = 6;
    //! The number of dead persons
    required int32   dead        = 7;
    //! The number of wounded persons
    required int32   wounded     = 8;
    //! The number of scattered persons
    required int32   scattered   = 9;
}

message UnitDamagedByCrowdFire {
    //! The target unit identifier
    required Id                           unit       = 1;
    //! The target party identifier
    required Id                           party      = 2;
    //! The firer crowd identifier
    required Id                           firer      = 3;
    //! The fire identifier
    required Id                           fire       = 4;
    //! Whether the fire is fratricide or not
    required bool                         fratricide = 5;
    //! The damages to the humans
    required SeqOfUnitHumanFireDamage     humans     = 6;
    //! The damages to the equipments
    required SeqOfUnitEquipmentFireDamage equipments = 7;
}

/** @struct StartFireEffect
    @brief Notifies of a start fire effect
*/
message StartFireEffect {
    /** @enum EnumFireEffectType
        @brief Defines the fire type
    */
    enum EnumFireEffectType {
        //! Smoke effect
        smoke          = 0;
        //! Light effect
        light          = 1;
        //! Explosion effect
        explosion      = 2;
        //! Neutralization effect
        neutralization = 3;
    }
    //! The fire effect identifier
    required Id                 fire_effect = 1;
    //! The fire location
    required Location           location    = 2;
    //! The fire type
    required EnumFireEffectType type        = 3;
}

/** @struct StopFireEffect
    @brief Notifies of a stop fire effect
*/
message StopFireEffect {
    //! The fire effect identifier
    required Id fire_effect = 1;
}

/** @struct IndirectFirePerception
    @brief Notifies which units perceive an indirect fire
*/
message IndirectFirePerception {
    //! The perceivers (list can be empty)
    repeated Id perceivers   = 1;
    //! The ammunition fired
    required Id ammunition   = 2;
    //! The fire effects (list cannot be empty)
    repeated Id fire_effects = 3;
}

/** @struct ControlEnableVisionConesAck
    @brief Acknowledges a request to toggle the vision cones updates
    @see ControlEnableVisionCones
*/
message ControlEnableVisionConesAck {
    enum ErrorCode {
        no_error = 0;
        error_invalid_unit = 1;
    }
    required ErrorCode error_code = 1;
    optional string error_msg = 2;
}

/** @struct ListEnabledVisionConesAck
    @brief Acknowledges a request to list the units for which vision cones are
           being listened to
    @see ListEnabledVisionCones
*/
message ListEnabledVisionConesAck {
    //! Whether vision cones are enabled for all units or not
    optional bool all     = 1;
    //! List of unit identifiers in ascending order for which vision cone
    //! updates are being sent
    repeated Id     units = 2;
    //! Identifier to start from (included), if omitted it starts from the
    //! beginning
    optional Id     start = 3;
    //! Total number of units listened to
    optional uint32 count = 4;
}

/** @struct InvalidateReport
    @brief Notifies a report has become invalid
*/
message InvalidateReport {
    //! The report identifier
    required Id       report = 1;
    //! The report source
    required Tasker   source = 2;
}

/** @struct Trace
    @brief Describes a trace
*/
message Trace {
    //! The trace source
    required Tasker source  = 1;
    //! The trace description
    required string message = 2;
}

/** @struct DecisionalState
    @brief Describes a decisional state
*/
message DecisionalState {
    //! The state source
    required Tasker source = 1;
    //! The state key
    required string key    = 2;
    //! The state value
    required string value  = 3;
}

/** @struct DebugPoints
    @brief Defines debug points
*/
message DebugPoints {
    //! The source
    required Tasker           source      = 1;
    //! The coordinates
    required CoordLatLongList coordinates = 2;
}

/** @struct SeqOfHeading
    @brief Defines a list of headings
*/
message SeqOfHeading {
    //! The headings
    repeated Heading elem = 1;
}

/** @struct VisionCone
    @brief Defines a vision cone
*/
message VisionCone {
    //! The origin
    required CoordLatLong origin     = 1;
    //! The height
    required int32        height     = 2;
    //! The sensor
    required string       sensor     = 3;
    //! The directions
    required SeqOfHeading directions = 4;
}

/** @struct SeqOfVisionCone
    @brief Defines a list of vision cones
*/
message SeqOfVisionCone {
    //! The cones
    repeated VisionCone elem = 1;
}

/** @struct UnitVisionCones
    @brief Updates the vision cones of a unit
*/
message UnitVisionCones {
    //! The unit identifier
    required Id              unit       = 1;
    //! The vision cones
    required SeqOfVisionCone cones      = 2;
    //! DEPRECATED in 5.3
    //! There is no replacement, the concept was experimental and never
    //! fully supported.
    required float           elongation = 3;
}

/** @struct UnitVisibility
    @brief Defines the visibility levels for a unit
*/
message UnitVisibility {
    /** @enum Level
        @brief The visibility levels for a unit
    */
    enum Level {
        //! Invisible
        invisible  = 0;
        //! Detected
        detected   = 1;
        //! Recognized
        recognized = 2;
        //! Identified
        identified = 3;
        //! Recorded
        recorded   = 4;
    }
}

/** @struct UnitDetection
    @brief Notifies of the detection of a unit
*/
message UnitDetection {
    //! The observer unit identifier
    required Id                   observer           = 1;
    //! The detected unit identifier @todo rename to unit
    required Id                   detected_unit      = 2;
    //! The current visibility level @todo rename to visibility
    required UnitVisibility.Level current_visibility = 3;
    //! The maximum visibility level
    required UnitVisibility.Level max_visibility     = 4;
}

/** @struct ObjectDetection
    @brief Notifies of the detection of an object
*/
message ObjectDetection {
    //! The observer unit identifier
    required Id                   observer        = 1;
    //! The detected object identifier @todo rename to object
    required Id                   detected_object = 2;
    //! The current visibility level
    required UnitVisibility.Level visibility      = 3;
}

/** @struct CrowdConcentrationDetection
    @brief Notifies of the detection of a crowd concentration
*/
message CrowdConcentrationDetection {
    //! The observer unit identifier
    required Id                   observer               = 1;
    //! The detected crowd identifier @todo rename to crowd
    required Id                   detected_crowd         = 2;
    //! The detected concentration @todo rename to concentration
    required Id                   detected_concentration = 3;
    //! The current visibility level
    required UnitVisibility.Level visibility             = 4;
}

/** @struct CrowdFlowDetection
    @brief Notifies of the detection of a crowd flow
*/
message CrowdFlowDetection {
    //! The observer unit identifier
    required Id          observer       = 1;
    //! The detected crowd identifier @todo rename to crowd
    required Id          detected_crowd = 2;
    //! The detected flow identifier @todo rename to flow
    required Id          detected_flow  = 3;
    //! The flow path @todo rename to path
    required Path        visible_flow   = 4;
}

/** @struct ObjectCreation
    @brief Notifies of the creation of an object
*/
message ObjectCreation {
    //! The object identifier
    required Id               object              = 1;
    //! The object type
    required ObjectType       type                = 2;
    //! The object name
    required string           name                = 3;
    //! The object party
    required Id               party               = 4;
    //! The object location
    required Location         location            = 5;
    //! The object attributes
    required ObjectAttributes attributes          = 6;
    //! The external identifier
    optional int32            external_identifier = 7;
    //! The extension fields
    optional Extension        extension           = 8;
    //! The object color @see RgbColor
    optional RgbColor      color                  = 9;
}

/** @struct ObjectDestruction
    @brief Notifies of the destruction of an object
*/
message ObjectDestruction {
    //! The object identifier
    required Id       object = 1;
}

/** @struct ObjectUpdate
    @brief Notifies of the update of an object
*/
message ObjectUpdate {
    //! The object identifier
    required Id               object     = 1;
    //! The object location
    optional Location         location   = 2;
    //! The object attributes
    required ObjectAttributes attributes = 3;
    //! The object name
    optional string           name       = 4;
}

/** @struct ObjectUpdate
    @brief Notifies of the creation of an object knowledge
*/
message ObjectKnowledgeCreation {
    //! The knowledge identifier
    required Id                knowledge       = 1;
    //! The party identifier
    required Id                party           = 2;
    //! The object identifier
    required Id                object          = 3;
    //! The object type
    required ObjectType        type            = 4;
    //! The object attributes
    required ObjectAttributes  attributes      = 5;
    //! The knowledge group identifier
    optional Id                knowledge_group = 6;
    //! The object party
    optional Id                object_party    = 7;
    //! The object name
    optional string            object_name     = 8;
    //! The display symbol from location type geometry
    optional Location          symbol          = 9;
}

/** @struct ObjectKnowledgeUpdate
    @brief Notifies of the update of an object knowledge
*/
message ObjectKnowledgeUpdate {
    //! The knowledge identifier
    required Id                knowledge           = 1;
    //! The party identifier
    required Id                party               = 2;
    //! The object identifier
    optional Id                object              = 3;
    //! The percentage of relevance
    optional int32             relevance           = 4;
    //! The object location
    optional Location          location            = 5;
    //! The object attributes
    optional ObjectAttributes  attributes          = 6;
    //! Whether the object is currently perceived or not
    optional bool              perceived           = 7;
    //! The list of automats perceiving the object
    optional IdList            perceiving_automats = 8;
    //! The knowledge group identifier
    optional Id                knowledge_group     = 9;
}

/** @struct ObjectKnowledgeDestruction
    @brief Notifies of the destruction of an object knowledge
*/
message ObjectKnowledgeDestruction {
    //! The knowledge identifier
    required Id                knowledge = 1;
    //! The knowledge party identifier @deprecated to be maintained by
    //! the client if needed
    required Id                party     = 2;
}

/** @struct UrbanKnowledgeCreation
    @brief Notifies of the creation of a urban knowledge
*/
message UrbanKnowledgeCreation {
    //! The knowledge identifier
    required Id                     knowledge = 1;
    //! The party identifier
    required Id                     party     = 2;
    //! The object identifier
    required Id                     object    = 3;
}

/** @struct UrbanKnowledgeUpdate
    @brief Notifies of the update of a urban knowledge
*/
message UrbanKnowledgeUpdate {
    //! The knowledge identifier
    required Id                     knowledge           = 1;
    //! The party identifier
    required Id                     party               = 2;
    //! The object identifier
    required Id                     object              = 3;
    //! The percentage of knowledge
    optional int32                  progress            = 4;
    //! The maximum percentage of knowledge ever reached
    optional int32                  max_progress        = 5;
    //! Whether the object is currently perceived or not
    optional bool                   perceived           = 6;
    //! The list of automats perceiving the object @todo rename along
    //! ObjectKnowledgeUpdate::perceiving_automats
    optional IdList                 automat_perceptions = 7;
}

/** @struct UrbanKnowledgeDestruction
    @brief Notifies of the destruction of a urban knowledge
*/
message UrbanKnowledgeDestruction {
    //! The knowledge identifier
    required Id                     knowledge = 1;
    //! The party identifier
    required Id                     party     = 2;
}

/** @struct LogMedicalEquipmentAvailability
    @brief Regroups the information about the availability of a medical
           equipment

    @todo explain a bit what are the different amounts
*/
message LogMedicalEquipmentAvailability {
    //! The equipment type
    required Id            equipment = 1;
    //! The total
    required int32         total     = 2;
    //! The number of equipments available
    required int32         available = 3;
    //! The number of equipments working
    required int32         working   = 4;
    //! The number of equipments lent
    optional int32         lent      = 5;
    //! The number of equipments resting
    optional int32         resting   = 6;
}

/** @struct SeqOfLogMedicalEquipmentAvailability
    @brief Lists several medical equipment availabilities
*/
message SeqOfLogMedicalEquipmentAvailability {
    //! The equipment availabilities
    repeated LogMedicalEquipmentAvailability elem = 1;
}

/** @struct LogMedicalState
    @brief Updates the medical state of a unit
*/
message LogMedicalState {
    //! The unit identifier
    required Id                                   unit                  = 1;
    //! Whether the supply chain is in place or not
    optional bool                                 chain                 = 2;
    //! The medical priorities
    optional LogMedicalPriorities                 priorities            = 3;
    //! The tactical priorities @todo What's this ?
    optional IdList                               tactical_priorities   = 4;
    //! The status of evacuation ambulances @todo explain the
    //! difference between evacuation and collection somewhere
    optional SeqOfLogMedicalEquipmentAvailability evacuation_ambulances = 5;
    //! The status of collection ambulances @todo explain the
    //! difference between evacuation and collection somewhere
    optional SeqOfLogMedicalEquipmentAvailability collection_ambulances = 6;
    //! The status of doctors
    optional SeqOfLogMedicalEquipmentAvailability doctors               = 7;
}

/** @struct LogMaintenanceEquipmentAvailability
    @brief Regroups the information about the availability of a
           maintenance equipment

    @todo explain a bit what are the different amounts
    @todo seems a copy-paste of LogMedicalEquipmentAvailability
*/
message LogMaintenanceEquipmentAvailability {
    //! The equipment type
    required Id            equipment = 1;
    //! The total
    required int32         total     = 2;
    //! The number of equipments available
    required int32         available = 3;
    //! The number of equipments working
    required int32         working   = 4;
    //! The number of equipments lent
    optional int32         lent      = 5;
    //! The number of equipments resting
    optional int32         resting   = 6;
}

/** @struct SeqOfLogMaintenanceEquipmentAvailability
    @brief Lists several maintenance equipment availabilities
*/
message SeqOfLogMaintenanceEquipmentAvailability {
    //! The equipment availabilities
    repeated LogMaintenanceEquipmentAvailability elem = 1;
}

/** @enum EnumLogMaintenanceWorkRate
    @brief Defines the different work rates
*/
enum EnumLogMaintenanceWorkRate {
    //! Rate 1
    rate_1 = 0;
    //! Rate 2
    rate_2 = 1;
    //! Rate 3
    rate_3 = 2;
    //! Rate 4
    rate_4 = 3;
}

/** @struct LogMaintenanceState
    @brief Notifies of the state of a maintenance
*/
message LogMaintenanceState {
    //! The unit identifier
    required Id                                       unit                = 1;
    //! Whether the supply chain is in place or not
    optional bool                                     chain               = 2;
    //! The work rate
    optional EnumLogMaintenanceWorkRate               work_rate           = 3;
    //! The maintenance priorities
    optional IdList                                   priorities          = 4;
    //! The tactical priorities @todo What's this ?
    optional IdList                                   tactical_priorities = 5;
    //! The haulers availabilities
    optional SeqOfLogMaintenanceEquipmentAvailability haulers             = 6;
    //! The repairers availabilities
    optional SeqOfLogMaintenanceEquipmentAvailability repairers           = 7;
}

/** @struct LogSupplyEquimentAvailability
    @brief Provides the availability of supply equipments
*/
message LogSupplyEquimentAvailability {
    //! The equipment type @bug not sure this is really meant to be optional
    optional Id            equipment = 1;
    //! The total number of equipment
    optional int32         total     = 2;
    //! The number of equipment available
    optional int32         available = 3;
    //! The number of working equipment
    optional int32         working   = 4;
    //! The number of lent equipment
    optional int32         lent      = 5;
    //! The number of resting equipment @todo What's this ?
    optional int32         resting   = 6;
}

/** @struct SeqOfLogSupplyEquimentAvailability
    @brief Lists the availabilities of supply equipments
*/
message SeqOfLogSupplyEquimentAvailability {
    //! The availabilities of supply equipments
    repeated LogSupplyEquimentAvailability elem = 1;
}

/** @struct DotationStock
    @brief Provides the stock of a dotation
*/
message DotationStock {
    //! The resource type
    required Id           resource = 1;
    //! The quantity
    required int32        quantity = 2;
}

/** @struct SeqOfDotationStock
    @brief Lists the stocks of dotations
*/
message SeqOfDotationStock {
    //! The stocks of dotations
    repeated DotationStock elem = 1;
}

/** @struct LogSupplyState
    @brief Notifies of the update of the supply state for a unit
*/
message LogSupplyState {
    //! The unit identifier
    optional Id                                 unit          = 1;
    //! Whether the supply chain is in place or not
    optional bool                               chain         = 2;
    //! The dotation stocks
    optional SeqOfDotationStock                 stocks        = 3;
    //! The transporter availabilities
    optional SeqOfLogSupplyEquimentAvailability transporters  = 4;
    //! The resource contained in a connected resource network if any.
    optional DotationStock                      network_stock = 5;
}

/** @struct DotationQuota
    @brief Provides the quota of a dotation
*/
message DotationQuota {
    //! The resource type
    required Id           resource = 1;
    //! The quantity
    required int32        quantity = 2;
}

/** @struct SeqOfDotationQuota
    @brief Lists the quotas of dotations
*/
message SeqOfDotationQuota {
    //! The quotas of dotations
    repeated DotationQuota elem = 1;
}

/** @struct LogSupplyQuotas
    @brief Notifies of the update of the supply quotas for a unit
*/
message LogSupplyQuotas {
    //! The parent entity
    required ParentEntity       supplied = 1;
    //! The supplier entity
    required ParentEntity       supplier = 2;
    //! The quotas
    required SeqOfDotationQuota quotas   = 3;
}

/** @struct CrowdCreation
    @brief Notifies of the creation of a crowd
*/
message CrowdCreation {
    //! The crowd identifier
    required Id               crowd       = 1;
    //! The crowd type
    required Id               type        = 2;
    //! The crowd name
    optional string           name        = 3;
    //! The crowd party
    required Id               party       = 4;
    //! The crowd repartition @see HumanRepartition
    required HumanRepartition repartition = 5;
    //! The unit color @see RgbColor
    optional RgbColor         color       = 6;
}

/** @struct CrowdUpdate
    @brief Notifies of the update of a crowd
*/
message CrowdUpdate {
    //! The crowd identifier
    required Id             crowd                 = 1;
    //! The crowd domination
    optional int32          domination            = 2;
    //! The party adhesions
    optional PartyAdhesions adhesions             = 3;
    //! The crowd critical intelligence
    optional string         critical_intelligence = 4;
    //! The armed individuals proportion between 0 and 1
    optional float          armed_individuals     = 5;
    //! The number of healthy persons
    optional int32          healthy               = 6;
    //! The number of wounded persons
    optional int32          wounded               = 7;
    //! The number of contaminated persons
    optional int32          contaminated          = 8;
    //! The number of dead persons
    optional int32          dead                  = 9;
    //! The extension fields
    optional Extension      extension             = 10;
    //! The decisional model
    optional string         decisional_model      = 11;
    //! The brain debug activation
    optional bool           brain_debug           = 12;
    //! The crowd name
    optional string         name                  = 13;
}

/** @struct CrowdDestruction
    @brief Notifies of the destruction of a crowd
*/
message CrowdDestruction {
    //! The crowd identifier
    required Id      crowd = 1;
}

/** @struct CrowdConcentrationCreation
    @brief Notifies of the creation of a crowd concentration
*/
message CrowdConcentrationCreation {
    //! The crowd concentration identifier
    required Id                   concentration = 1;
    //! The crowd identifier
    required Id                   crowd         = 2;
    //! The crowd position
    required CoordLatLong         position      = 3;
}

/** @struct CrowdConcentrationDestruction
    @brief Notifies of the destruction of a crowd concentration
*/
message CrowdConcentrationDestruction {
    //! The crowd concentration identifier
    required Id                   concentration = 1;
    //! The crowd identifier
    required Id                   crowd         = 2;
}

/** @enum EnumCrowdAttitude
    @brief Defines the different states of a crowd
*/
enum EnumCrowdAttitude {
    //! Peaceful
    peaceful  = 0;
    //! Agitated
    agitated  = 1;
    //! Excited
    excited   = 2;
    //! Agressive
    agressive = 3;
}

/** @struct CrowdConcentrationUpdate
    @brief Notifies of the update of a crowd concentration
*/
message CrowdConcentrationUpdate {
    //! The crowd concentration identifier
    required Id                   concentration = 1;
    //! The crowd identifier
    required Id                   crowd         = 2;
    //! The number of healthy persons
    optional int32                healthy       = 3;
    //! The number of wounded persons
    optional int32                wounded       = 4;
    //! The number of contaminated persons
    optional int32                contaminated  = 5;
    //! The number of dead persons
    optional int32                dead          = 6;
    //! The crowd attitude
    optional EnumCrowdAttitude    attitude      = 7;
}

/** @struct CrowdFlowCreation
    @brief Notifies of the creation of a crowd flow
*/
message CrowdFlowCreation {
    //! The crowd flow identifier
    required Id          flow  = 1;
    //! The crowd identifier
    required Id          crowd = 2;
}

/** @struct CrowdFlowDestruction
    @brief Notifies of the destruction of a crowd flow
*/
message CrowdFlowDestruction {
    //! The crowd flow identifier
    required Id          flow  = 1;
    //! The crowd identifier
    required Id          crowd = 2;
}

/** @struct CrowdFlowUpdate
    @brief Notifies of the update of a crowd flow
*/
message CrowdFlowUpdate {
    //! The crowd flow identifier
    required Id                flow         = 1;
    //! The crowd identifier
    required Id                crowd        = 2;
    //! The crowd shape
    optional Path              parts        = 3;
    //! The crowd path
    optional Path              path         = 4;
    //! @todo What's this ?
    optional Heading           direction    = 5;
    //! The flow speed
    optional int32             speed        = 6;
    //! The number of healthy persons
    optional int32             healthy      = 7;
    //! The number of wounded persons
    optional int32             wounded      = 8;
    //! The number of contaminated persons
    optional int32             contaminated = 9;
    //! The number of dead persons
    optional int32             dead         = 10;
    //! The crowd attitude
    optional EnumCrowdAttitude attitude     = 11;
}

/** @struct CrowdKnowledgeCreation
    @brief Notifies of the creation of a crowd knowledge
*/
message CrowdKnowledgeCreation {
    //! The crowd knowledge identifier
    required Id               knowledge       = 1;
    //! The knowledge group identifier
    required Id               knowledge_group = 2;
    //! The crowd identifier
    optional Id               crowd           = 3;
    //! The party identifier
    optional Id               party           = 4;
}

/** @struct CrowdKnowledgeUpdate
    @brief Notifies of the update of a crowd knowledge
*/
message CrowdKnowledgeUpdate {
    //! The crowd knowledge identifier
    required Id               knowledge             = 1;
    //! The knowledge group identifier
    required Id               knowledge_group       = 2;
    //! The crowd domination
    optional int32            domination            = 3;
    //! The crowd critical intelligence
    optional string           critical_intelligence = 4;
}

/** @struct CrowdKnowledgeDestruction
    @brief Notifies of the destruction of a crowd knowledge
*/
message CrowdKnowledgeDestruction {
    //! The crowd knowledge identifier
    required Id               knowledge       = 1;
    //! The knowledge group identifier
    required Id               knowledge_group = 2;
}

/** @struct CrowdConcentrationKnowledgeCreation
    @brief Notifies of the creation of a crowd concentration knowledge
*/
message CrowdConcentrationKnowledgeCreation {
    //! The crowd concentration knowledge identifier
    required Id                            knowledge       = 1;
    //! The crowd knowledge identifier
    required Id                            crowd           = 2;
    //! The knowledge group identifier
    required Id                            knowledge_group = 3;
    //! The crowd concentration identifier
    required Id                            concentration   = 4;
    //! The crowd position
    optional CoordLatLong                  position        = 5;
}

/** @struct CrowdConcentrationKnowledgeUpdate
    @brief Notifies of the update of a crowd concentration knowledge
*/
message CrowdConcentrationKnowledgeUpdate {
    //! The crowd concentration knowledge identifier
    required Id                            knowledge       = 1;
    //! The crowd knowledge identifier
    required Id                            crowd           = 2;
    //! The knowledge group identifier
    required Id                            knowledge_group = 3;
    //! The crowd concentration identifier
    optional Id                            concentration   = 4;
    //! The number of persons alive
    optional int32                         alive           = 5;
    //! The number of dead persons
    optional int32                         dead            = 6;
    //! The crowd attitude
    optional EnumCrowdAttitude             attitude        = 7;
    //! The knowledge pertinence
    optional int32                         pertinence      = 8;
    //! Whether the crowd concentration is currently perceived or not
    optional bool                          perceived       = 9;
}

/** @struct CrowdConcentrationKnowledgeDestruction
    @brief Notifies of the destruction of a crowd concentration knowledge
*/
message CrowdConcentrationKnowledgeDestruction {
    //! The crowd concentration knowledge identifier
    required Id                            knowledge       = 1;
    //! The crowd knowledge identifier
    required Id                            crowd           = 2;
    //! The knowledge group identifier
    required Id                            knowledge_group = 3;
}

/** @struct CrowdFlowKnowledgeCreation
    @brief Notifies of the creation of a crowd flow knowledge
*/
message CrowdFlowKnowledgeCreation {
    //! The crowd flow knowledge identifier
    required Id                   knowledge       = 1;
    //! The crowd knowledge identifier
    required Id                   crowd           = 2;
    //! The knowledge group identifier
    required Id                   knowledge_group = 3;
    //! The crowd flow identifier
    required Id                   flow            = 4;
}

/** @struct FlowPart
    @brief Defines the part of a flow
*/
message FlowPart {
    //! The flow shape
    required Path  shape      = 1;
    //! The pertinence
    required int32 pertinence = 2;
}

/** @struct SeqOfFlowPart
    @brief Lists the parts of a flow
*/
message SeqOfFlowPart {
    //! The flow parts
    repeated FlowPart elem = 1;
}

/** @struct CrowdFlowKnowledgeUpdate
    @brief Notifies of the update of a crowd flow knowledge
*/
message CrowdFlowKnowledgeUpdate {
    //! The crowd flow knowledge identifier
    required Id                knowledge       = 1;
    //! The crowd knowledge identifier
    required Id                crowd           = 2;
    //! The crowd knowledge group identifier
    required Id                knowledge_group = 3;
    //! The flow identifier
    optional Id                flow            = 4;
    //! The flow parts
    optional SeqOfFlowPart     parts           = 5;
    //! The flow direction
    optional Heading           direction       = 6;
    //! The flow speed
    optional int32             speed           = 7;
    //! The number of persons alive
    optional int32             alive           = 8;
    //! The number of dead persons
    optional int32             dead            = 9;
    //! The crowd attitude
    optional EnumCrowdAttitude attitude        = 10;
    //! Whether the flow is currently perceived or not
    optional bool              perceived       = 11;
}

/** @struct CrowdFlowKnowledgeDestruction
    @brief Notifies of the destruction of a crowd flow knowledge
*/
message CrowdFlowKnowledgeDestruction {
    //! The crowd flow knowledge identifier
    required Id                   knowledge       = 1;
    //! The crowd knowledge identifier
    required Id                   crowd           = 2;
    //! The knowledge group identifier
    required Id                   knowledge_group = 3;
}

/** @struct FolkCreation
    @brief Notifies of the creation of a folk
*/
message FolkCreation {
    /** @struct Profiles
        @brief Defines the profiles
    */
    message Profiles {
        //! The profiles
        repeated string elem = 1;
    }
    /** @struct Activities
        @brief Defines the activities
    */
    message Activities {
        //! The activities
        repeated string elem = 1;
    }
    //! @copybrief Profiles
    required Profiles   profiles       = 1;
    //! @copybrief Activities
    required Activities activities     = 2;
    //! The container size
    optional int32      container_size = 3;
    //! The number of edges
    optional int32      edge_number    = 4;
}

/** @struct FolkGraphEdgeUpdate
    @brief Defines a folk graph edge
*/
message FolkGraphEdgeUpdate {
    //! What's this ?
    required int32 folk             = 1;
    //! What's this ?
    required int32 shape_id         = 2;
    //! What's this ?
    repeated int32 crowd_occupation = 3;
}

/** @struct FolkGraphUpdate
    @brief Notifies of the update of a folk graph
*/
message FolkGraphUpdate {
    //! The graph edges
    repeated FolkGraphEdgeUpdate elem = 1;
}

//! Returned by ControlCheckPointSetFrequency
//!
//! Errors are reported in parent SimToClient.error_msg.
message ControlCheckPointSetFrequencyAck {
}

//! Sent in response to ControlCheckPointSaveNow, after the checkpoint
//! operation terminated.
message ControlCheckPointSaveNowAck {
    //! Error detail if any, empty upon success.
    optional string error_msg = 1;
    //! Generated checkpoint name.
    optional string name      = 2;
}

//! Emitted when a checkpoint creation starts.
message ControlCheckPointSaveBegin {
    optional string name = 1;
}

//! Emitted when a checkpoint creation ends.
message ControlCheckPointSaveEnd {
    optional string name = 1;
}

/** @struct ControlCheckPointSaveDelete
    @brief Notify that a checkpoint directory has been deleted on the
           simulation (due to max number of checkpoints attained)
*/
message ControlCheckPointSaveDelete {
    //! The checkpoint directory name
    required string name = 1;
}

message ControlCheckPointListAck {
}

message ControlCheckPointList {
    repeated string checkpoint = 1;
}

message ControlCheckPointDeleteAck {
}

/** @struct ControlSendCurrentStateBegin
    @brief Notify of the start of the sending of the simulation state

    @see ControlSendCurrentStateEnd
*/
message ControlSendCurrentStateBegin {
}

/** @struct ControlSendCurrentStateEnd
    @brief Notify of the end of the sending of the simulation state

    @see ControlSendCurrentStateBegin
*/
message ControlSendCurrentStateEnd {
}

/** @struct RgbaColor
    @brief Defines a color with alpha channel
*/
message RgbaColor {
    //! The red component between 0 and 255
    required int32 red   = 1;
    //! The green component between 0 and 255
    required int32 green = 2;
    //! The blue component between 0 and 255
    required int32 blue  = 3;
    //! The alpha channel between 0 and 1
    required float alpha = 4;
}

/** @struct UrbanAttributes
    @brief Regroups the attributes of a urban object
    @see UrbanCreation UrbanUpdate
*/
message UrbanAttributes {
    /** @struct Architecture
        @brief Defines the architecture of a urban object
    */
    message Architecture {
        //! The height in meters
        required float  height            = 1;
        //! The floor number starting at 0 for the ground floor
        required int32  floor_number      = 2;
        //! The roof shape
        required string roof_shape        = 3;
        //! The material
        required string material          = 4;
        //! The occupation in percent
        required float  occupation        = 5;
        //! The trafficability in tons used in path-finding
        required float  trafficability    = 6;
        //! The number of parking floors
        required int32  parking_floors    = 7;
    }
    /** @struct Structure
        @brief Defines the structure of a urban object
    */
    message Structure {
        //! The structural state in percent
        required uint32 state = 1;
    }
    /** @struct Infrastructures
        @brief Defines the infrastructures of a urban object
    */
    message Infrastructures {
        /** @struct Infrastructure
            @brief Defines the infrastructure of a urban object
        */
        message Infrastructure {
            //! The infrastructure type
            required string type      = 1;
            //! Whether the infrastructure is active or not
            required bool   active    = 2;
            //! The threshold in percent below which the infrastructure
            //! stops working
            required float  threshold = 3;
        }
        //! The resource networks
        repeated ResourceNetwork resource_network = 1;
        //! The infrastructure
        optional Infrastructure infrastructure    = 2;
    }
    //! The architecture
    optional Architecture    architecture    = 1;
    //! The structure
    optional Structure       structure       = 2;
    //! The color
    optional RgbaColor       color           = 3;
    //! The infrastructures
    optional Infrastructures infrastructures = 4;
    //! The usages
    repeated UrbanUsage      usages          = 5;
}

/** @struct UrbanCreation
    @brief Notifies of the creation of a urban object
*/
message UrbanCreation {
    //! The object identifier
    required Id              object       = 1;
    //! The object name
    required string          name         = 2;
    //! The object location
    required Location        location     = 3;
    //! The object attributes
    optional UrbanAttributes attributes   = 4;
    //! The parent object
    optional Id              parent       = 5;
}

/** @struct UrbanDetection
    @brief Notifies of the detection of a urban object
*/
message UrbanDetection {
    //! The unit identifier
    required Id                   observer     = 1;
    //! The object identifier
    required Id                   object       = 2;
    //! The visibility level
    required UnitVisibility.Level visibility   = 3;
}

/** @struct UrbanUpdate
    @brief Notifies of the update of a urban object
*/
message UrbanUpdate {
    //! The object identifier
    required Id              object     = 1;
    //! The object location
    optional Location        location   = 2;
    //! The object attributes
    optional UrbanAttributes attributes = 3;
}

/** @struct KnowledgeGroupCreation
    @brief Notifies of the creation of a knowledge group
*/
message KnowledgeGroupCreation {
    //! The knowledge group identifier
    required Id               knowledge_group = 1;
    //! The party identifier
    required Id               party           = 2;
    //! The parent group
    optional Id               parent          = 3;
    //! The group type
    required string           type            = 4;
    //! Whether the communication of the group is jammed or not
    optional bool             jam             = 5;
    //! This particular knowledge group's name
    required string           name            = 6 [default = ""];
    //! Whether the group is specific for the army crowds or not
    optional bool             crowd           = 7;
}

/** @struct KnowledgeGroupUpdate
    @brief Notifies of the update of a knowledge group
*/
message KnowledgeGroupUpdate {
    //! The knowledge group identifier
    required Id               knowledge_group = 1;
    //! The party identifier
    optional Id               party           = 2;
    //! The parent group
    optional Id               parent          = 3;
    //! Whether the group is enabled or not
    optional bool             enabled         = 4;
    //! The group type
    optional string           type            = 5;
    //! The group name
    optional string           name            = 6;
}

/** @struct KnowledgeGroupDestruction
    @brief Notifies of the destruction of a knowledge group
*/
message KnowledgeGroupDestruction {
    //! The knowledge group identifier
    required Id               knowledge_group = 1;
    //! The party identifier
    required Id               party           = 2;
}

/** @struct KnowledgeGroupAck
    @brief Factorizes knowledge group related magic action error codes
    @todo This is pointless to factorize this...
*/
message KnowledgeGroupAck {
    /** @enum ErrorCode
        @brief Defines the error codes
    */
    enum ErrorCode {
        //! No error
        no_error                     = 0;
        //! The unit identifier provided is invalid
        error_invalid_unit           = 1;
        //! The superior identifier provided is invalid
        error_invalid_superior       = 2;
        //! The party identifier provided is invalid
        error_invalid_party          = 3;
        //! The knowledge group identifier provided is invalid @todo
        //! rename to error_invalid_knowledge_group
        error_invalid_knowledgegroup = 4;
        //! The type provided is invalid
        error_invalid_type           = 5;
        //! The perception provided is invalid
        error_invalid_perception     = 6;
        //! Operation failed because the provided action parameters
        //! were invalid
        error_invalid_parameter      = 7;
    }
}

/** @struct KnowledgeGroupMagicActionAck
    @brief Acknowledges a knowledge group magic action
    @see KnowledgeMagicAction
*/
message KnowledgeGroupMagicActionAck {
    //! The knowledge group identifier
    required Id                          knowledge_group = 1;
    //! The error code
    required KnowledgeGroupAck.ErrorCode error_code      = 2;
    //! More detailed account of the returned error
    optional string                      error_msg       = 3;
    //! Action results, depends on the action type and outcome.
    optional MissionParameters           result          = 4;
    //! Unique order identifier
    optional uint32                      id              = 5;
}

//! DEPRECATED in 5.3
//!
//! This message is replaced by MagicActionAck.
message KnowledgeGroupCreationAck {
    //! The knowledge group identifier
    required Id                          knowledge_group = 1;
    //! The error code
    required KnowledgeGroupAck.ErrorCode error_code      = 2;
}

//! DEPRECATED in 5.3
//!
//! This message is replaced by KnowledgeGroupMagicActionAck.
message KnowledgeGroupUpdateAck {
    //! The knowledge group identifier
    required Id                          knowledge_group = 1;
    //! The error code
    required KnowledgeGroupAck.ErrorCode error_code      = 2;
}

//! DEPRECATED in 5.3
//!
//! This message was sent when updating the global weather.
message ControlGlobalWeatherAck {
}

//! DEPRECATED in 5.3
//!
//! This message was sent when creating or updating a local weather.
message ControlLocalWeatherAck {
}

//! Global or local weather attributes.
message WeatherAttributes {

    enum EnumPrecipitationType {
        dry        = 0;
        sand_storm = 1;
        fog        = 2;
        drizzle    = 3;
        rain       = 4;
        snow       = 5;
        smoke      = 6;
    }

    enum EnumLightingType {
        clear_day               = 0;
        slightly_cloudy_day     = 1;
        mildly_cloudy_day       = 2;
        fairly_cloudy_day       = 3;
        very_cloudy_day         = 4;
        full_moon_night         = 5;
        three_quater_moon_night = 6;
        half_quater_moon_night  = 7;
        quater_moon_night       = 8;
        new_moon_night          = 9;
        artificial_light        = 10;
        global_weather          = 11;
    }
    //! Temperature in degrees Celsius
    required int32                 temperature    = 1;
    //! Wind speed in kilometers per hour.
    required int32                 wind_speed     = 2;
    //! Direction where the wind flows in degrees.
    required Heading               wind_direction = 3;
    //! Cloud layer bottom altitude in meters
    required int32                 cloud_floor    = 4;
    //! Cloud layer top altitude in meters
    required int32                 cloud_ceiling  = 5;
    //! Cloud density in percent
    required int32                 cloud_density  = 6;
    //! Precipitation type
    required EnumPrecipitationType precipitation  = 7;
    //! Lighting type, this parameter is currently ignored.
    required EnumLightingType      lighting       = 8;
}

//! Global weather update notification.
message ControlGlobalWeather {
    required Id                weather    = 1;
    required WeatherAttributes attributes = 2;
}

//! Local weather creation or update notification.
message ControlLocalWeatherCreation {
    required Id                weather      = 1;
    //! The top-left corner of the area
    optional CoordLatLong      top_left     = 2;
    //! The bottom-left corner of the area
    optional CoordLatLong      bottom_right = 3;
    optional WeatherAttributes attributes   = 4;
    optional DateTime          start_date   = 5;
    optional DateTime          end_date     = 6;
}

//! Local weather removal notification.
message ControlLocalWeatherDestruction {
    required Id weather = 1;
}

/** @struct PopulationCreation
    @brief Notifies of the creation of a population
*/
message PopulationCreation {
    //! The population identifier
    required Id             id        = 1;
    //! The party identifier
    required Id             party     = 2;
    //! The population type
    required Id             type      = 3;
    //! The population name
    required string         name      = 4;
    //! @deprecated should be an extension entry
    required string         text      = 5;
    //! The object identifiers of urban blocks where the population live
    repeated Id             objects   = 6;
}

/** @struct PopulationUpdate
    @brief Notifies of the update of a population
*/
message PopulationUpdate {
    /** @struct MotivationSatisfaction
        @brief Defines a motivation satisfaction
    */
    message MotivationSatisfaction {
        //! The motivation type ("home", "office", ...) as listed in
        //! urban.xml
        required string motivation = 1;
        //! The level of satisfaction for this motivation between 0 and 1
        required float  percentage = 2;
    }
    /** @struct ResourceSatisfaction
        @brief Defines a resource satisfaction
    */
    message ResourceSatisfaction {
        //! The resource type
        required Id           resource = 1;
        //! The level of satisfaction for this motivation between 0 and 1
        required float        value    = 2;
    }
    /** @struct Satisfaction
        @brief Defines the population satisfaction
    */
    message Satisfaction {
        //! The resource satisfactions
        repeated ResourceSatisfaction   resources   = 1;
        //! The motivation satisfactions
        repeated MotivationSatisfaction motivations = 2;
        //! The level of satisfaction for vital space between 0 and 1
        optional float                  lodging     = 3;
        //! The level of satisfaction for health matters between 0 and 1
        optional float                  health      = 4;
        //! The level of satisfaction for safety matters between 0 and 1
        optional float                  safety      = 5;
    }
    /** @struct BlockOccupation
        @brief Defines a block occupation
    */
    message BlockOccupation {
        /** @struct UsageOccupation
          @brief Defines the number of persons by usage
         */
        message UsageOccupation {
            //! The usage type ("home, "office", ...)
            required string usage  = 1;
            //! The number of persons for this usage
            required int32  number = 2;
        }
        //! The block object identifier
        required Id              object    = 1;
        //! The number of persons by usage
        repeated UsageOccupation persons   = 2;
        //! Whether the population has been alerted or not
        required bool            alerted   = 3;
        //! Whether the population is confined into this block or not
        required bool            confined  = 4;
        //! Whether the population is evacuated into this block or not
        required bool            evacuated = 5;
        //! Angriness of persons in this block because of lack of resources.
        required float           angriness = 6;
    }
    //! The population identifier
    required Id              id           = 1;
    //! The number of healthy persons
    optional int32           healthy      = 2;
    //! The number of wounded persons
    optional int32           wounded      = 3;
    //! The number of dead persons
    optional int32           dead         = 4;
    //! The party adhesions
    optional PartyAdhesions  adhesions    = 5;
    //! The current satisfaction
    optional Satisfaction    satisfaction = 6;
    //! The current motivation @see MotivationSatisfaction
    optional string          motivation   = 7;
    //! The current block occupations
    repeated BlockOccupation occupations  = 8;
    //! The extension fields
    optional Extension       extension    = 9;
    //! The population name
    optional string          name         = 10;
}

message Action {
    required uint32               id                     = 1;
    optional MagicAction          magic_action           = 2;
    optional UnitMagicAction      unit_magic_action      = 3;
    optional ObjectMagicAction    object_magic_action    = 4;
    optional KnowledgeMagicAction knowledge_magic_action = 5;
    optional SetAutomatMode       set_automat_mode       = 6;
    optional int32                error_code             = 7;
    optional string               error_msg              = 8;
    optional string               start_time             = 9;
    optional UnitOrder            unit_order             = 10;
    optional AutomatOrder         automat_order          = 11;
    optional CrowdOrder           crowd_order            = 12;
    optional FragOrder            frag_order             = 13;
    //! Hide this action on clients
    optional bool                 hidden                 = 14;
}

message ActionDestruction {
    required uint32 id = 1;
}

message Segment {
    required CoordLatLong from = 1;
    required CoordLatLong to   = 2;
}

message SegmentRequestAck {
    enum ErrorCode {
        //! Operation succeeded
        no_error                = 0;
        //! Operation failed
        error_invalid_parameter = 1;
    }
    //! Returns computed segments
    repeated Segment   segments       = 1;
    //! Reason for the failure of the request
    required ErrorCode error_code     = 2;
    //! More detailed account of the returned error
    optional string    error_msg      = 3;
}

message SimToClient {
    message Content {
        //! @copybrief TaskCreationRequestAck
        optional TaskCreationRequestAck order_ack = 1;
        //! @copybrief FragOrderAck
        optional FragOrderAck frag_order_ack = 4;
        //! @copybrief SetAutomatModeAck
        optional SetAutomatModeAck set_automat_mode_ack = 5;
        //! @copybrief UnitCreationRequestAck
        optional UnitCreationRequestAck unit_creation_request_ack = 6;
        //! @copybrief MagicActionAck
        optional MagicActionAck magic_action_ack = 7;
        //! @copybrief UnitMagicActionAck
        optional UnitMagicActionAck unit_magic_action_ack = 8;
        //! @copybrief ObjectMagicActionAck
        optional ObjectMagicActionAck object_magic_action_ack = 9;
        //! @copybrief CrowdMagicActionAck
        optional CrowdMagicActionAck crowd_magic_action_ack = 10;
        //! @copybrief ChangeDiplomacyAck
        optional ChangeDiplomacyAck change_diplomacy_ack = 11;
        //! @copybrief AutomatChangeKnowledgeGroupAck
        optional AutomatChangeKnowledgeGroupAck
            automat_change_knowledge_group_ack = 12;
        //! @copybrief ChangeLogisticLinksAck
        optional ChangeLogisticLinksAck automat_change_logistic_links_ack = 13;
        //! @copybrief AutomatChangeSuperiorAck
        optional AutomatChangeSuperiorAck automat_change_superior_ack = 14;
        //! @copybrief UnitChangeSuperiorAck
        optional UnitChangeSuperiorAck unit_change_superior_ack = 15;
        //! @copybrief LogSupplyPushFlowAck
        optional LogSupplyPushFlowAck log_supply_push_flow_ack = 16;
        //! @copybrief LogSupplyChangeQuotasAck
        optional LogSupplyChangeQuotasAck log_supply_change_quotas_ack = 17;
        //! @copybrief ControlInformation
        optional ControlInformation control_information = 18;
        //! @copybrief ControlProfilingInformation
        optional ControlProfilingInformation control_profiling_information = 19;
        //! @copybrief ControlBeginTick
        optional ControlBeginTick control_begin_tick = 20;
        //! @copybrief ControlEndTick
        optional ControlEndTick control_end_tick = 21;
        //! @copybrief ControlStopAck
        optional ControlStopAck control_stop_ack = 22;
        //! @copybrief ControlPauseAck
        optional ControlPauseAck control_pause_ack = 23;
        //! @copybrief ControlResumeAck
        optional ControlResumeAck control_resume_ack = 24;
        //! @copybrief ControlChangeTimeFactorAck
        optional ControlChangeTimeFactorAck control_change_time_factor_ack = 25;
        //! @copybrief ControlDateTimeChangeAck
        optional ControlDateTimeChangeAck control_date_time_change_ack = 26;
        //! @copybrief ControlCheckPointSaveEnd
        optional ControlCheckPointSaveEnd control_checkpoint_save_end = 27;
        //! @copybrief FormationCreation
        optional FormationCreation formation_creation = 28;
        //! @copybrief PartyCreation
        optional PartyCreation party_creation = 29;
        //! @copybrief AutomatCreation
        optional AutomatCreation automat_creation = 30;
        //! @copybrief AutomatAttributes
        optional AutomatAttributes automat_attributes = 31;
        //! @copybrief UnitCreation
        optional UnitCreation unit_creation = 32;
        //! @copybrief UnitAttributes
        optional UnitAttributes unit_attributes = 33;
        //! @copybrief UnitPathFind
        optional UnitPathFind unit_pathfind = 34;
        //! @copybrief UnitDestruction
        optional UnitDestruction unit_destruction = 35;
        //! @copybrief UnitEnvironmentType
        optional UnitEnvironmentType unit_environment_type = 36;
        //! @copybrief ChangeDiplomacy
        optional ChangeDiplomacy change_diplomacy = 37;
        //! @copybrief UnitChangeSuperior
        optional UnitChangeSuperior unit_change_superior = 38;
        //! @copybrief ChangeLogisticLinks
        optional ChangeLogisticLinks automat_change_logistic_links = 39;
        //! @copybrief AutomatChangeKnowledgeGroup
        optional AutomatChangeKnowledgeGroup
            automat_change_knowledge_group = 40;
        //! @copybrief AutomatChangeSuperior
        optional AutomatChangeSuperior automat_change_superior = 41;
        //! @copybrief UnitKnowledgeCreation
        optional UnitKnowledgeCreation unit_knowledge_creation = 42;
        //! @copybrief UnitKnowledgeUpdate
        optional UnitKnowledgeUpdate unit_knowledge_update = 43;
        //! @copybrief UnitKnowledgeDestruction
        optional UnitKnowledgeDestruction unit_knowledge_destruction = 44;
        //! @copybrief StartUnitFire
        optional StartUnitFire start_unit_fire = 45;
        //! @copybrief StopUnitFire
        optional StopUnitFire stop_unit_fire = 46;
        //! @copybrief StartCrowdFire
        optional StartCrowdFire start_crowd_fire = 47;
        //! @copybrief StopCrowdFire
        optional StopCrowdFire stop_crowd_fire = 48;
        //! @copybrief Explosion
        optional Explosion explosion = 49;
        //! @copybrief UnitDamagedByUnitFire
        optional UnitDamagedByUnitFire unit_damaged_by_unit_fire = 50;
        //! @copybrief CrowdDamagedByUnitFire
        optional CrowdDamagedByUnitFire crowd_damaged_by_unit_fire = 51;
        //! @copybrief UnitDamagedByCrowdFire
        optional UnitDamagedByCrowdFire unit_damaged_by_crowd_fire = 52;
        //! @copybrief StartFireEffect
        optional StartFireEffect start_fire_effect = 53;
        //! @copybrief StopFireEffect
        optional StopFireEffect stop_fire_effect = 54;
        //! @copybrief Report
        optional Report report = 55;
        //! @copybrief InvalidateReport
        optional InvalidateReport invalidate_report = 56;
        //! @copybrief Trace
        optional Trace trace = 57;
        //! @copybrief DecisionalState
        optional DecisionalState decisional_state = 58;
        //! @copybrief DebugPoints
        optional DebugPoints debug_points = 59;
        //! @copybrief UnitVisionCones
        optional UnitVisionCones unit_vision_cones = 60;
        //! @copybrief UnitDetection
        optional UnitDetection unit_detection = 61;
        //! @copybrief ObjectDetection
        optional ObjectDetection object_detection = 62;
        //! @copybrief CrowdConcentrationDetection
        optional CrowdConcentrationDetection crowd_concentration_detection = 63;
        //! @copybrief CrowdFlowDetection
        optional CrowdFlowDetection crowd_flow_detection = 64;
        //! @copybrief UnitOrder
        optional UnitOrder unit_order = 65;
        //! @copybrief AutomatOrder
        optional AutomatOrder automat_order = 66;
        //! @copybrief CrowdOrder
        optional CrowdOrder crowd_order = 67;
        //! @copybrief ObjectCreation
        optional ObjectCreation object_creation = 68;
        //! @copybrief ObjectDestruction
        optional ObjectDestruction object_destruction = 69;
        //! @copybrief ObjectUpdate
        optional ObjectUpdate object_update = 70;
        //! @copybrief ObjectKnowledgeCreation
        optional ObjectKnowledgeCreation object_knowledge_creation = 71;
        //! @copybrief ObjectKnowledgeUpdate
        optional ObjectKnowledgeUpdate object_knowledge_update = 72;
        //! @copybrief ObjectKnowledgeDestruction
        optional ObjectKnowledgeDestruction object_knowledge_destruction = 73;
        //! @copybrief LogMedicalHandlingCreation
        optional LogMedicalHandlingCreation log_medical_handling_creation = 74;
        //! @copybrief LogMedicalHandlingUpdate
        optional LogMedicalHandlingUpdate log_medical_handling_update = 75;
        //! @copybrief LogMedicalHandlingDestruction
        optional LogMedicalHandlingDestruction
            log_medical_handling_destruction = 76;
        //! @copybrief LogMedicalState
        optional LogMedicalState log_medical_state = 77;
        //! @copybrief LogMaintenanceHandlingCreation
        optional LogMaintenanceHandlingCreation
            log_maintenance_handling_creation = 78;
        //! @copybrief LogMaintenanceHandlingUpdate
        optional LogMaintenanceHandlingUpdate
            log_maintenance_handling_update = 79;
        //! @copybrief LogMaintenanceHandlingDestruction
        optional LogMaintenanceHandlingDestruction
            log_maintenance_handling_destruction = 80;
        //! @copybrief LogMaintenanceState
        optional LogMaintenanceState log_maintenance_state = 81;
        //! @copybrief LogSupplyHandlingCreation
        optional LogSupplyHandlingCreation log_supply_handling_creation = 82;
        //! @copybrief LogSupplyHandlingUpdate
        optional LogSupplyHandlingUpdate log_supply_handling_update = 83;
        //! @copybrief LogSupplyHandlingDestruction
        optional LogSupplyHandlingDestruction
            log_supply_handling_destruction = 84;
        //! @copybrief LogSupplyState
        optional LogSupplyState log_supply_state = 85;
        //! @copybrief LogSupplyQuotas
        optional LogSupplyQuotas log_supply_quotas = 86;
        //! @copybrief CrowdCreation
        optional CrowdCreation crowd_creation = 87;
        //! @copybrief CrowdUpdate
        optional CrowdUpdate crowd_update = 88;
        //! @copybrief CrowdConcentrationCreation
        optional CrowdConcentrationCreation crowd_concentration_creation = 89;
        //! @copybrief CrowdConcentrationDestruction
        optional CrowdConcentrationDestruction
            crowd_concentration_destruction = 90;
        //! @copybrief CrowdConcentrationUpdate
        optional CrowdConcentrationUpdate crowd_concentration_update = 91;
        //! @copybrief CrowdFlowCreation
        optional CrowdFlowCreation crowd_flow_creation = 92;
        //! @copybrief CrowdFlowDestruction
        optional CrowdFlowDestruction crowd_flow_destruction = 93;
        //! @copybrief CrowdFlowUpdate
        optional CrowdFlowUpdate crowd_flow_update = 94;
        //! @copybrief CrowdKnowledgeCreation
        optional CrowdKnowledgeCreation crowd_knowledge_creation = 95;
        //! @copybrief CrowdKnowledgeUpdate
        optional CrowdKnowledgeUpdate crowd_knowledge_update = 96;
        //! @copybrief CrowdKnowledgeDestruction
        optional CrowdKnowledgeDestruction crowd_knowledge_destruction = 97;
        //! @copybrief CrowdConcentrationKnowledgeCreation
        optional CrowdConcentrationKnowledgeCreation
            crowd_concentration_knowledge_creation = 98;
        //! @copybrief CrowdConcentrationKnowledgeDestruction
        optional CrowdConcentrationKnowledgeDestruction
            crowd_concentration_knowledge_destruction = 99;
        //! @copybrief CrowdConcentrationKnowledgeUpdate
        optional CrowdConcentrationKnowledgeUpdate
            crowd_concentration_knowledge_update = 100;
        //! @copybrief CrowdFlowKnowledgeCreation
        optional CrowdFlowKnowledgeCreation crowd_flow_knowledge_creation = 101;
        //! @copybrief CrowdFlowKnowledgeDestruction
        optional CrowdFlowKnowledgeDestruction
            crowd_flow_knowledge_destruction = 102;
        //! @copybrief CrowdFlowKnowledgeUpdate
        optional CrowdFlowKnowledgeUpdate crowd_flow_knowledge_update = 103;
        //! @copybrief FolkCreation
        optional FolkCreation folk_creation = 104;
        //! @copybrief FolkGraphUpdate
        optional FolkGraphUpdate folk_graph_update = 105;
        //! @copybrief ControlGlobalWeatherAck
        optional ControlGlobalWeatherAck control_global_weather_ack = 106;
        //! @copybrief ControlLocalWeatherAck
        optional ControlLocalWeatherAck control_local_weather_ack = 107;
        //! @copybrief ControlCheckPointSaveBegin
        optional ControlCheckPointSaveBegin control_checkpoint_save_begin = 108;
        //! @copybrief ControlCheckPointSetFrequencyAck
        optional ControlCheckPointSetFrequencyAck
            control_checkpoint_set_frequency_ack = 109;
        //! @copybrief ControlCheckPointSaveNowAck
        optional ControlCheckPointSaveNowAck
            control_checkpoint_save_now_ack = 110;
        //! @copybrief ControlSendCurrentStateBegin
        optional ControlSendCurrentStateBegin
            control_send_current_state_begin = 111;
        //! @copybrief ControlSendCurrentStateEnd
        optional ControlSendCurrentStateEnd
            control_send_current_state_end = 112;
        //! @copybrief UrbanCreation
        optional UrbanCreation urban_creation = 113;
        //! @copybrief UrbanUpdate
        optional UrbanUpdate urban_update = 114;
        //! @copybrief UrbanKnowledgeCreation
        optional UrbanKnowledgeCreation urban_knowledge_creation = 115;
        //! @copybrief UrbanKnowledgeUpdate
        optional UrbanKnowledgeUpdate urban_knowledge_update = 116;
        //! @copybrief UrbanKnowledgeDestruction
        optional UrbanKnowledgeDestruction urban_knowledge_destruction = 117;
        //! @copybrief StockResource
        optional StockResource stock_resource = 118;
        //! @copybrief UrbanDetection
        optional UrbanDetection urban_detection = 119;
        //! @copybrief KnowledgeGroupMagicActionAck
        optional KnowledgeGroupMagicActionAck
            knowledge_group_magic_action_ack = 120;
        //! @copybrief KnowledgeGroupCreation
        optional KnowledgeGroupCreation knowledge_group_creation = 121;
        //! @copybrief KnowledgeGroupUpdate
        optional KnowledgeGroupUpdate knowledge_group_update = 122;
        //! @copybrief KnowledgeGroupCreationAck
        optional KnowledgeGroupCreationAck knowledge_group_creation_ack = 123;
        //! @copybrief KnowledgeGroupUpdateAck
        optional KnowledgeGroupUpdateAck knowledge_group_update_ack = 124;
        //! @copybrief KnowledgeGroupDestruction
        optional KnowledgeGroupDestruction knowledge_group_destruction = 125;
        //! @copybrief ActionCreateFireOrderAck
        optional ActionCreateFireOrderAck action_create_fire_order_ack = 126;
        //! @copybrief ControlGlobalWeather
        optional ControlGlobalWeather control_global_weather = 127;
        //! @copybrief ControlLocalWeatherCreation
        optional ControlLocalWeatherCreation
            control_local_weather_creation = 128;
        //! @copybrief ControlLocalWeatherDestruction
        optional ControlLocalWeatherDestruction
            control_local_weather_destruction = 129;
        //! @copybrief ControlCheckPointListAck
        optional ControlCheckPointListAck control_checkpoint_list_ack = 130;
        //! @copybrief ControlCheckPointList
        optional ControlCheckPointList control_checkpoint_list = 131;
        //! @copybrief ControlCheckPointDeleteAck
        optional ControlCheckPointDeleteAck control_checkpoint_delete_ack = 132;
        //! @copybrief LogSupplyPullFlowAck
        optional LogSupplyPullFlowAck log_supply_pull_flow_ack = 133;
        //! @copybrief FormationDestruction
        optional FormationDestruction formation_destruction = 134;
        //! @copybrief AutomatDestruction
        optional AutomatDestruction automat_destruction = 135;
        //! @copybrief CrowdDestruction
        optional CrowdDestruction crowd_destruction = 136;
        //! @copybrief PopulationCreation
        optional PopulationCreation population_creation = 137;
        //! @copybrief PopulationUpdate
        optional PopulationUpdate population_update = 138;
        //! @copybrief FragOrder
        optional FragOrder frag_order = 139;
        //! @copybrief BurningCellRequestAck
        optional BurningCellRequestAck burning_cell_request_ack = 140;
        //! @copybrief FormationUpdate
        optional FormationUpdate formation_update = 141;
        //! @copybrief ControlCheckPointSaveDelete
        optional ControlCheckPointSaveDelete
            control_checkpoint_save_delete = 142;
        //! @copybrief LogFuneralHandlingCreation
        optional LogFuneralHandlingCreation log_funeral_handling_creation = 143;
        //! @copybrief LogLogFuneralHandlingUpdateMedicalHandlingUpdate
        optional LogFuneralHandlingUpdate log_funeral_handling_update = 144;
        //! @copybrief LogFuneralHandlingDestruction
        optional LogFuneralHandlingDestruction
            log_funeral_handling_destruction = 145;
        //! @copybrief AutomatChangeSuperior
        optional FormationChangeSuperior formation_change_superior = 146;
        //! @copybrief IndirectFirePerception
        optional IndirectFirePerception indirect_fire_perception = 147;
        //! @copybrief ControlEnableVisionConesAck
        optional ControlEnableVisionConesAck
            control_enable_vision_cones_ack = 148;
        //! @copybrief ListEnabledVisionConesAck
        optional ListEnabledVisionConesAck list_enabled_vision_cones_ack = 149;
        optional LogisticHistoryAck logistic_history_ack = 150;
        optional ListLogisticRequestsAck list_logistic_requests_ack = 151;
        optional Action            action = 152;
        optional ActionDestruction action_destruction = 153;
        optional StartUnitFireDetection start_unit_fire_detection = 154;
        optional StopUnitFireDetection stop_unit_fire_detection = 155;
        optional ComputePathfindAck compute_pathfind_ack = 156;
        optional SegmentRequestAck segment_request_ack = 157;
        optional LogSupplyRequestCreation log_supply_request_creation = 158;
        optional LogSupplyRequestUpdate log_supply_request_update = 159;
        optional LogSupplyRequestDestruction
            log_supply_request_destruction = 160;
        optional Pathfind pathfind_creation = 161;
        optional PathfindDestruction pathfind_destruction = 162;
        optional Pathfind pathfind_update = 163;
        //! @copybrief PartyUpdate
        optional PartyUpdate party_update = 164;
        optional ListReportsAck list_reports_ack = 165;
    }
    /** @property context
        @brief Identifies the request matching the response.

        This field is filled using the "context" fields provided in the
        request message.

        This context allows the client application to differentiate
        acknowledgements to similar messages.

        @see ClientToAuthentication
    */
    optional int32   context = 1;
    //! A field containing one of the messages to be sent
    required Content message = 2;
    /** @property client_id

        This field is filled using the "client_id" field set by the
        requester in case of acknowledgement messages,
        in order to identify which request was done by which client.

        @see AuthenticationToClient
    */
    optional int32   client_id = 3;
    //! This fields will eventually supersede message specific error
    //! handling. For now, ignore it unless a client message explicitely
    //! states it is using it, in which case a non-empty message signals
    //! an error.
    optional string  error_msg = 4;
}

/** @}*/
