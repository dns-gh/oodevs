// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2010 MASA Group
//
// *****************************************************************************

import "common.proto";

package sword;

/** @struct OrderAck
    @brief A container for order acknowledgement error message
    @see UnitOrder AutomatOrder CrowdOrder FragOrder
*/
message OrderAck {
    /** @enum ErrorCode
        @brief Reason for the failure of order/mission assignment
        @todo Move long descriptions to the corresponding field in BlablaOrder and use @@see tags here
    */
    enum ErrorCode {
        no_error                                = 0;  //!< Operation succeeded @todo As error codes are optional, no_error should not exist
        error_invalid_unit                      = 1;  //!< Operation failed because of an invalid tasker identifier e.g. an existing agent/automat/crowd identifier @todo rename to error_invalid_tasker
        error_invalid_limit                     = 2;  //!< Operation failed because of an invalid limit : limit parameters are required for automat missions @deprecated should be handled using invalid_mission_parameters
        error_invalid_lima                      = 3;  //!< Operation failed because of an invalid phase line : phase line parameters are required for some missions @deprecated should be handled using invalid_mission_parameters
        error_invalid_mission                   = 4;  //!< Operation failed because of an invalid mission identifier : the mission must exist and be available for the specified tasker unit
        error_invalid_mission_parameters        = 5;  //!< Operation failed because of an invalid mission parameter : parameters are defined in the file "Missions.xml" @todo rename to error_invalid_parameter
        error_unit_cannot_receive_order         = 6;  //!< Operation failed because the unit is not in a state where it can execute the order : it must be alive and disengaged (for an agent) @todo rename to error_tasker_unable_cannot_receive_order
        error_invalid_order_conduite            = 7;  //!< Operation failed because of an invalid fragmentary order identifier : valid identifiers can be found in the file "Missions.xml" @todo rename to error_invalid_fragorder
        error_invalid_order_mission             = 8;  //!< Operation failed because of an invalid mission identifier : valid identifiers can be found in the file "Missions.xml"
        error_unit_surrendered                  = 11; //!< Operation failed because the unit is not in a state where it can execute the order : it must not have surrendered and be able to receive orders @todo rename to error_tasker_surrendered
        error_invalid_lima_function             = 12; //!< Operation failed because of an invalid phase line function : phase line parameters are required for some missions, each phase line is assigned one or more functions in the context of the mission @deprecated should be handled using invalid_mission_parameters
    }
}

/** @struct TaskCreationRequestAck
    @brief An agent order execution request acknowledgement message

    @see UnitOrder
    @todo gather UnitOrder, AutomatOrder and CrowdOrder into one message
*/
message TaskCreationRequestAck {
    required Tasker             tasker     = 1; //!< Identifier of the agent, automat, crowd on which the order was issued @see Tasker
    required OrderAck.ErrorCode error_code = 2; //!< Reason for the failure of an agent order execution operation @see OrderAck.ErrorCode
}

/** @struct FragOrderAck
    @brief A fragmentary order execution request acknowledgement message

    @see FragOrder
    @todo gather with UnitOrder, AutomatOrder and CrowdOrder into one message ?
*/
message FragOrderAck {
    required Tasker             tasker     = 1; //!< Identifier of the agent, automat or crowd on which the fragmentary order was issued @see Tasker
    required OrderAck.ErrorCode error_code = 2; //!< Reason for the failure of a fragmentary order execution operation @see OrderAck.ErrorCode
}

/** @struct SetAutomatModeAck
    @brief An automat mode change request acknowledgement message

    @see SetAutomatMode
*/
message SetAutomatModeAck {
    /** @enum ErrorCode
        @brief Reason for the failure of automat mode change
    */
    enum ErrorCode {
        no_error           = 0; //!< Operation succeeded @todo make error_code field optional instead
        error_invalid_unit = 1; //!< Operation failed because of an invalid automat identifier @todo rename to error_invalid_automat
        error_not_allowed  = 2; //!< Operation failed because the parent automat is engaged @todo rename to error_parent_automat_engaged
    }
    required AutomatId automate   = 1; //!< Identifier of the automat for which to change mode @see AutomatId
    required ErrorCode error_code = 2; //!< Reason for the failure of the automat mode changing operation @see ErrorCode
}

/** @struct UnitActionAck
    @brief A container for agent action acknowledgement error message
    @todo rename to AgentActionAck
*/
message UnitActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of agent action operation
    */
    enum ErrorCode {
        no_error                = 0; //!< Operation succeeded
        error_invalid_unit      = 1; //!< Operation failed because of an invalid agent identifier @todo rename to error_invalid_agent
        error_automate_embraye  = 2; //!< Operation failed because the target agent is currently controlled by its parent automat @todo rename to error_automate_engaged
        error_invalid_attribute = 3; //!< Operation failed because the provided action parameters were invalid @todo rename to error_invalid_parameter
        error_unit_surrendered  = 4; //!< Operation failed because the agent is not in a state where it can execute the order : it must not have surrendered to be able to receive orders @todo rename to error_agent_surrendered
    }
}

/** @struct UnitCreationRequestAck
    @brief An agent creation request acknowledgement message

    This message is sent in response to an agent creation request.

    @see UnitCreationRequest
    @todo rename to AgentCreationRequestAck
*/
message UnitCreationRequestAck {
    required UnitActionAck.ErrorCode error = 1; //!< Reason for the failure of the agent creation operation @see UnitActionAck.ErrorCode
}

/** @struct UnitMagicActionAck
    @brief An agent magic action execution request acknowledgement message.

    This message is sent in response to an agent magic action request
    @see UnitMagicAction
    @todo rename to AgentMagicActionRequestAck
*/
message UnitMagicActionAck {
    required UnitId                  unit       = 1; //!< Identifier of the agent on which the magic action was requested to be executed @todo rename to agent
    required UnitActionAck.ErrorCode error_code = 2; //!< Reason for the failure of the agent magic action execution operation. @see UnitActionAck.ErrorCode
}

/** @struct MagicActionAck
    @brief A magic action execution request acknowledgement message

    This message is sent when a magic action is issued in response to a client request.

    @see MagicAction
    @todo rename to MagicActionRequestAck
*/
message MagicActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the magic action operation
    */
    enum ErrorCode {
        no_error                = 0; //!< Operation succeeded
        error_invalid_attribute = 1; //!< Operation failed because the provided action parameters were invalid @todo rename to error_invalid_parameter
    }
    required ErrorCode error_code = 1; //!< Reason for the failure of the magic action execution operation @see ErrorCode
}

/** @struct ObjectMagicActionAck
    @brief An object magic action execution request acknowledgement message

    This message is sent when an object magic action is issued in response to a client request

    @see ObjectMagicAction
    @todo rename to ObjectMagicActionRequestAck
*/
message ObjectMagicActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the object magic action operation
    */
    enum ErrorCode {
        no_error                          = 0; //!< Operation succeeded
        error_invalid_object              = 1; //!< Operation failed because the provided object identifier was invalid
        error_invalid_party               = 3; //!< Operation failed because the provided party identifier was invalid
        error_missing_specific_attributes = 5; //!< Operation failed because object specific attributes are missing : they must meet the requirements associated with the object type
        error_invalid_specific_attributes = 6; //!< Operation failed because object specific attributes are invalid : they must meet the requirements associated with the object type
    }
    required ErrorCode error_code = 1; //!< Reason for the failure of the object magic action execution operation @see ErrorCode
}

/** @struct CrowdMagicActionAck
    @brief A crowd magic action execution request acknowledgement message

    This message is sent when a crowd magic action is issued in response to a client request.

    @see CrowdMagicAction
    @todo rename to CrowdMagicActionRequestAck
*/
message CrowdMagicActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the crowd magic action operation
    */
    enum ErrorCode {
        no_error                = 0; //!< Operation succeeded
        error_invalid_unit      = 1; //!< Operation failed because the provided crowd identifier was invalid @todo rename to error_invalid_crowd
        error_invalid_attribute = 2; //!< Operation failed because the provided action parameters were invalid @todo rename to error_invalid_parameter
    }
    required CrowdId   crowd      = 1; //!< Identifier of the crowd on which the magic action was requested to be executed
    required ErrorCode error_code = 2; //!< Reason for the failure of the crowd magic action execution operation @see ErrorCode
}

/** @struct ChangeDiplomacyAck
    @brief A diplomacy change request acknowledgement message

    This message is sent when a diplomacy change is realized in response to a client request.

    @see ChangeDiplomacy
    @todo rename to DiplomacyChangeRequestAck
*/
message ChangeDiplomacyAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the diplomacy change operation
    */
    enum ErrorCode {
        no_error_diplomacy            = 0; //!< Operation succeeded @todo rename to no_error
        error_invalid_party_diplomacy = 1; //!< Operation failed because the provided diplomacy is invalid
    }
    required PartyId       party1     = 1; //!< Identifier of the party from which the diplomacy is defined @see PartyId
    required PartyId       party2     = 2; //!< Identifier of the party to which the diplomacy is defined @see PartyId
    required EnumDiplomacy diplomacy  = 3; //!< Definition of the diplomacy between specified parties @see EnumDiplomacy
    required ErrorCode     error_code = 4; //!< Reason for the failure of the diplomacy change operation @see ErrorCode
}

/** @struct HierarchyModificationAck
    @brief A container for hierarchy modification action acknowledgement error message
    @todo split into different types
*/
message HierarchyModificationAck {
    /** @enum ErrorCode
        @brief Reason for the failure of a hierarchy modification operation
    */
    enum ErrorCode {
        no_error_hierarchy               = 0;  //!< Operation succeeded @todo rename to no_error
        error_invalid_agent              = 1;  //!< Operation failed because no existing agent with the provided identifier could be found
        error_invalid_automate           = 2;  //!< Operation failed because no existing automat with the provided identifier could be found @todo rename to error_invalid_automat
        error_invalid_formation          = 3;  //!< Operation failed because no existing formation with the provided identifier could be found
        error_invalid_automate_tc2       = 4;  //!< Operation failed because no existing logistics automat with the provided identifier could be found @todo rename to error_invalid_supply_automat
        error_unit_surrendered_hierarchy = 8;  //!< Operation failed because the unit is not in a state where it can execute the order : it must not have surrendered to be able to receive orders @todo rename to error_agent_surrendered
        error_invalid_party_hierarchy    = 9;  //!< Operation failed because no existing party with the provided identifier could be found @todo rename to error_invalid_party
        error_invalid_knowledge_group    = 10; //!< Operation failed because no existing knowledge group with the provided identifier could be found @todo rename to error_invalid_knowledge_group
        error_parties_mismatched         = 11; //!< Operation failed because an agent cannot be moved from a party to another
    }
}

/** @struct AutomatChangeKnowledgeGroupAck
    @brief An acknowledgement message to an automat's knowledge group change request

    This message is sent when an automat's knowledge group change is realized in response to a client request.

    @see UnitMagicAction of type "change_knowledge_group"
    @todo gather magic action acks
*/
message AutomatChangeKnowledgeGroupAck {
    required HierarchyModificationAck.ErrorCode error_code = 1; //!< Reason for the failure of the automat knowledge group change operation @see HierarchyModificationAck.ErrorCode
}

/** @struct ChangeLogisticLinksAck
    @brief An acknowledgement message to an automat's logistic links change request

    This message is sent when an automat's logistic links change is realized in response to a client request.

    @see UnitMagicAction of type UnitMagiAction.Type.change_logistic_links
    @todo gather magic action acks
*/
message ChangeLogisticLinksAck {
    required HierarchyModificationAck.ErrorCode error_code = 1; //!< Reason for the failure of the automat logistic links change operation @see HierarchyModificationAck.ErrorCode
}

/** @struct AutomatChangeSuperiorAck
    @brief An acknowledgement message to an automat's superior change request

    This message is sent when an automat's superior change is realized in response to a client request.

    @see UnitMagicAction of UnitMagiAction.Type.change_automat_superior
    @todo gather magic action acks
*/
message AutomatChangeSuperiorAck {
    required HierarchyModificationAck.ErrorCode error_code = 1; //!< Reason for the failure of the automat superior change operation @see HierarchyModificationAck.ErrorCode
}

/** @struct UnitChangeSuperiorAck
    @brief An acknowledgement message to an agent's superior change request

    This message is sent when an agent's superior change is realized in response to a client request.

    @see UnitMagicAction of UnitMagiAction.Type.unit_change_superior
    @todo gather magic action acks
*/
message UnitChangeSuperiorAck {
    required HierarchyModificationAck.ErrorCode error_code = 1; //!< Reason for the failure of the agent superior change operation @see HierarchyModificationAck.ErrorCode
}

/** @struct LogSupplyPushFlowAck
    @brief An acknowledgement message to a logistic pushed flow request

    This message is sent when a logistic pushed flow is realized in response to a client request.

    @see UnitMagicAction of UnitMagiAction.Type.log_supply_push_flow
    @todo gather magic action acks
*/
message LogSupplyPushFlowAck {
    /** @enum EnumLogSupplyPushFlow
        @brief Reason for the failure of the pushed flow creation
        @todo rename to ErrorCode
    */
    enum EnumLogSupplyPushFlow {
        no_error_pushflow      = 0; //!< Operation succeeded @todo As error codes are optional, no_error should not exist
        error_invalid_supplier = 1; //!< Operation failed because no existing supplying automat with the provided identifier could be found
        error_invalid_receiver = 2; //!< Operation failed because no existing receiving automat with the provided identifier could be found
    }
    optional EnumLogSupplyPushFlow ack = 1; //!< Reason for the failure of the request @see EnumLogSupplyPushFlow @todo rename to error_code
}

/** @struct LogSupplyPullFlowAck
    @brief An acknowledgement message to a logistic pulled flow request

    This message is sent when a logistic pulled flow is realized in response to a client request.

    @see UnitMagicAction of UnitMagiAction.Type.log_supply_pull_flow
    @todo gather magic action acks
*/
message LogSupplyPullFlowAck {
    /** @enum EnumLogSupplyPullFlow
        @brief Reason for the failure of the pulled flow creation @todo rename to ErrorCode
    */
    enum EnumLogSupplyPullFlow {
        no_error_pullflow               = 0; //!< Operation succeeded @todo As error codes are optional, no_error should not exist
        error_invalid_provider_pullflow = 1; //!< Operation failed because no existing supplying automat with the provided identifier could be found @todo rename to error_invalid_supplier
        error_invalid_receiver_pullflow = 2; //!< Operation failed because no existing receiving automat with the provided identifier could be found @todo rename to error_invalid_receiver
    }
    optional EnumLogSupplyPullFlow ack = 1; //!< Reason for the failure of the request @see EnumLogSupplyPushFlow @todo rename to error_code
}

/** @struct LogSupplyChangeQuotasAck
    @brief An acknowledgement message to a quota allocation change request

    This message is sent when a quota allocation is changed in response to a client request.

    @see UnitMagicAction of UnitMagiAction.Type.log_supply_change_quotas
    @todo gather magic action acks
*/
message LogSupplyChangeQuotasAck {
    /** @enum LogSupplyChangeQuotas
        @brief Reason for the failure of the quota allocation.
        @todo rename to ErrorCode
    */
    enum LogSupplyChangeQuotas {
        no_error_quotas        = 0; //!< Operation succeeded @todo rename to no_error @todo As error codes are optional, no_error should not exist
        error_invalid_supplier = 1; //!< Operation failed because no existing supplying automat with the provided identifier could be found
        error_invalid_receiver = 2; //!< Operation failed because no existing receiving automat with the provided identifier could be found
    }
    optional LogSupplyChangeQuotas ack = 1; //!< Reason for the failure of the request @see LogSupplyChangeQuotas @todo rename to error_code
}

/** @struct ActionCreateFireOrderAck
    @brief An acknowledgement message to a creation fire order request
    @see ActionCreateFireOrder
*/
message ActionCreateFireOrderAck {
    /** @enum EnumActionCreateFireOrderErrorCode
        @brief Reason for the failure of the create fire order.
        @todo rename to ErrorCode
    */
    enum EnumActionCreateFireOrderErrorCode {
        no_error                     = 0; //!< Operation succeeded @todo make error_code optional and remove no_error
        error_invalid_reporter       = 1; //!< Operation failed because no existing reporter with the provided identifier could be found
        error_invalid_target         = 2; //!< Operation failed because no existing target with the provided identifier could be found
        error_invalid_ammunition     = 3; //!< Operation failed because no existing ammunition with the provided identifier could be found
        error_target_not_illuminated = 4; //!< Operation failed because of the target not being illuminated
    }
    required EnumActionCreateFireOrderErrorCode error_code = 2; //!< Reason for the failure of the request @see EnumActionCreateFireOrderErrorCode @todo change field index to 1
}

/** @struct ChangePopulationMagicActionAck
    @brief An acknowledgement message to a population change magic action request
    @see ChangePopulationMagicAction
*/
message ChangePopulationMagicActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the population change magic action
    */
    enum ErrorCode {
        no_error                 = 0; //!< Operation succeeded @todo make error_code optional and remove no_error
        error_invalid_population = 1; //!< Operation failed because no existing population with the provided identifier could be found.
        error_invalid_adhesion   = 2; //!< Operation failed because no existing party with the provided identifier could be found
        error_invalid_number     = 3; //!< Operation failed because of an invalid number (for instance a negative number of dead was provided) @todo change numbers to unsigned integers ?
    }
    required ErrorCode error_code = 1; //!< Reason for the failure of the request @see ErrorCode
}

/** @struct UrbanMagicActionAck
    @brief An acknowledgement message to a urban magic action request
    @see UrbanMagicAction
*/
message UrbanMagicActionAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the urban magic action
    */
    enum ErrorCode {
       no_error                 = 0; //!< Operation succeeded @todo make error_code optional and remove no_error
       error_invalid_urbanblock = 1; //!< Operation failed because no existing urban block with the provided identifier could be found @todo rename to error_invalid_urban_block or error_invalid_block
       error_invalid_role       = 2; //!< Operation failed because no existing motivation type with the provided identifier could be found
       error_invalid_threshold  = 3; //!< Operation failed because of an invalid threshold @todo Find how a threshold can be invalid
    }
    required ErrorCode error_code = 1; //!< Reason for the failure of the request
}

/** @struct ControlInformation
    @brief A control information message containing various global informations
    @todo Find when and why this is sent (probably when a client connects ?)
*/
message ControlInformation {
   required int32               current_tick         = 1; //!< The current tick number
   required DateTime            initial_date_time    = 2; //!< The initial date and time @see DateTime
   required DateTime            date_time            = 3; //!< The current date and time @see DateTime @see ControlDateTimeChange
   required int32               tick_duration        = 4; //!< The duration of a simulation tick in seconds
   required int32               time_factor          = 5; //!< The simulation time multiplier @see ControlChangeTimeFactor
   required int32               checkpoint_frequency = 6; //!< The number of seconds between automatic checkpoints saves @see ControlCheckPointSetFrequency @see ControlCheckPointSaveNow
   required EnumSimulationState status               = 7; //!< The current status of the simulation @see EnumSimulationState @see ControlStop ControlPause ControlResume
   required bool                send_vision_cones    = 8; //!< Whether the vision cones for units is currently being sent or not @see SimToClient::Content::unit_vision_cones
   required bool                profiling_enabled    = 9; //!< Whether the profiling information is currently being sent or not @see SimToClient::Content::control_profiling_information
}

/** @struct ControlProfilingInformation
    @brief A control profiling information message
    @deprecated The message seems to never be actually sent by the simulation
*/
message ControlProfilingInformation {
   required float perception = 1; //!< The amount of time spent for computing perceptions @todo unit ?
   required float decision   = 2; //!< The amount of time spent for computing decisions @todo unit ?
   required float action     = 3; //!< The amount of time spent for performing actions @todo unit ?
   required float main_loop  = 4; //!< The amount of time spent for the whole tick @todo unit ?
}

/** @struct ControlBeginTick
    @brief A control begin tick message
    @see ControlEndTick
*/
message ControlBeginTick {
   required int32    current_tick = 1; //<! The current tick number
   required DateTime date_time    = 2; //<! The current date and time @see DateTime
}

/** @struct ControlEndTick
    @brief A control end tick message
    @see ControlBeginTick
*/
message ControlEndTick {
   required int32 current_tick    = 1; //<! The current tick number
   required int32 tick_duration   = 2; //<! The current tick duration in seconds
   required int32 long_pathfinds  = 3; //<! The number of pending long path finding requests @todo explain how and why is a path considered long
   required int32 short_pathfinds = 4; //<! The number of pending short path finding requests @todo explain how and why is a path considered short
   required int32 memory          = 5; //<! The memory size in use in bytes
   required int32 virtual_memory  = 6; //<! The virtual memory size in use in bytes
}

/** @struct ControlAck
    @brief A control acknowledgement message
    @see ControlStop ControlPause ControlResume
    @see ControlChangeTimeFactor
    @see ControlDateTimeChange
    @todo split into different acks
*/
message ControlAck {
    /** @enum ErrorCode
        @brief Reason for the failure of the control request
    */
    enum ErrorCode {
       no_error                  = 0; //<! Operation succeeded
       error_already_started     = 1; //<! @deprecated never used
       error_not_started         = 2; //<! Stop request failed because the simulation is already stopped
       error_not_paused          = 3; //<! Resume request failed because the simulation is running
       error_already_paused      = 4; //<! Pause request failed because the simulation is already paused
       error_invalid_time_factor = 5; //<! The time factor must be strictly positive
       error_invalid_date_time   = 6; //<! The new date/time must be after the current date/time
    }
}

/** @struct ControlDateTimeChangeAck
    @brief A data time change acknowledgement message
    @see ControlDateTimeChange
*/
message ControlDateTimeChangeAck {
    required ControlAck.ErrorCode error_code = 1; //!< Reason for the failure of the request
}

/** @struct ControlChangeTimeFactorAck
    @brief A time factor change acknowledgement message
    @see ControlChangeTimeFactor
*/
message ControlChangeTimeFactorAck {
   required int32                time_factor = 1; //!< The simulation time multiplier
   required ControlAck.ErrorCode error_code  = 2; //!< Reason for the failure of the request
}

/** @struct ControlStopAck
    @brief A stop acknowledgement message
    @see ControlStop
*/
message ControlStopAck {
   required ControlAck.ErrorCode error_code = 1; //!< Reason for the failure of the request
}

/** @struct ControlPauseAck
    @brief A pause acknowledgement message
    @see ControlPause
*/
message ControlPauseAck {
   required ControlAck.ErrorCode error_code = 1; //!< Reason for the failure of the request
}

/** @struct ControlResumeAck
    @brief A resume acknowledgement message
    @see ControlResume
*/
message ControlResumeAck {
   required ControlAck.ErrorCode error_code = 1; //!< Reason for the failure of the request
}

/** @struct PartyCreation
    @brief A party creation message
*/
message PartyCreation {
   required PartyId       party     = 1; //!< The party identifier @see PartyId
   required string        name      = 2; //!< The party name
   required EnumDiplomacy type      = 3; //!< @todo Relation to what ?
   optional Extension     extension = 4; //!< @todo What is that ?
   optional RgbColor      color     = 5; //!< The party color @see RgbColor
}

/** @struct FormationCreation
    @brief A formation creation message
*/
message FormationCreation {
    required FormationId       formation             = 1;  //!< The formation identifier @see FormationId
    required PartyId           party                 = 2;  //!< The party identifier @see PartyId
    optional FormationId       parent                = 3;  //!< The parent formation identifier @see FormationId
    required EnumNatureLevel   level                 = 4;  //!< @todo What's this ?
    required string            name                  = 5;  //!< The formation name
    optional Extension         extension             = 6;  //!< @todo What's this ?
    required string            app6symbol            = 7;  //!< The formation APP-6 symbol
    required EnumLogisticLevel logistic_level        = 8;  //!< @todo What's this ?
    optional RgbColor          color                 = 9;  //!< The formation color @see RgbColor
    optional ParentEntity      logistic_base_organic = 10; //!< @todo What's this ?
}

/** @struct FormationDestruction
    @brief A formation destruction message
*/
message FormationDestruction {
   required FormationId formation = 1;
}

/** @struct AutomatCreation
    @brief An automat creation message
*/
message AutomatCreation {
    required AutomatId         automat         = 1;  //!< The automat identifier @see AutomatId
    required AutomatType       type            = 2;  //!< The automat type @see AutomatType
    required string            name            = 3;  //!< The automat name
    required ParentEntity      parent          = 4;  //!< The automat parent @see ParentEntity
    required PartyId           party           = 5;  //!< The automat party @see PartyId
    optional KnowledgeGroupId  knowledge_group = 6;  //!< The automat knowledge group @see KnowledgeGroupId
    optional Extension         extension       = 7;  //!< @todo What's this ?
    required string            app6symbol      = 8;  //!< The automat APP-6 symbol
    required EnumLogisticLevel logistic_level  = 9;  //!< The automat logistic level @see EnumLogisticLevel
    optional RgbColor          color           = 10; //!< The automat color @see RgbColor
}

/** @struct RulesOfEngagement
    @brief A rules of engagement message
*/
message RulesOfEngagement {
    /** @enum Value
        @brief Value of the rules of engagement
        @todo make RulesOfEngagement the enum or move the value field in this message
    */
    enum Value {
       none             = 0; //!< No rule of engagement
       free_fire        = 1; //!< Fire permitted
       retaliation_only = 2; //!< Fire back permitted
       fire_upon_order  = 3; //!< Fire forbidden
    }
}

/** @struct ForceRatio
    @brief A force ratio message
*/
message ForceRatio {
    /** @enum Value
        @brief Value of the force ratio
        @todo make ForceRatio the enum
    */
    enum Value {
        none        = 0; //!< No force ratio
        neutral     = 1; //!< Neutral
        favorable   = 2; //!< Favorable
        unfavorable = 3; //!< Unfavorable
    }
}

/** @struct AutomatAttributes
    @brief An automat attributes update message
*/
message AutomatAttributes {
   required AutomatId                   automat               = 1; //!< The automat identifier @see AutomatId
   optional EnumAutomatMode             etat_automate         = 2; //!< The automat mode @see EnumAutomatMode @todo translate
   optional ForceRatio.Value            force_ratio           = 3; //!< The automat force ratio @see ForceRatio
   optional EnumMeetingEngagementStatus meeting_engagement   = 4; //!< @todo What's this ?
   optional EnumOperationalStatus       operational_state     = 5; //!< The automat operational status @todo translate
   optional RulesOfEngagement.Value     roe                   = 6; //!< The automat rules of engagement @see RulesOfEngagement
   optional AutomatId                   tc2_organic           = 7; //!< @todo What's this ?
   optional ParentEntity                logistic_base_organic = 8; //!< @todo What's this ?
}

/** @struct AutomatDestruction
    @brief An automat destruction message
*/
message AutomatDestruction {
   required AutomatId automat = 1; //!< The automat identifier @see AutomatId
}

/** @struct UnitCreation
    @brief A unit creation message
*/
message UnitCreation {
   required UnitId    unit    = 1; //!< The unit identifier @see UnitId
   required UnitType  type    = 2; //!< The unit type @see UnitType
   required string    name    = 3; //!< The unit name
   required AutomatId automat = 4; //!< @todo What's this ?
   required bool      pc      = 5; //!< @todo What's this ?
   optional RgbColor  color   = 6; //!< The unit color @see RgbColor
}

/** @struct BorrowedEquipments
    @brief A borrowed equipments message
*/
message BorrowedEquipments {
    /** @struct BorrowedEquipment
        @brief A borrowed equipment message
    */
    message BorrowedEquipment {
        required UnitId        owner    = 1; //!< The owner identifier @see UnitId
        required EquipmentType type     = 2; //!< The equipment type @see EquipmentType
        required int32         quantity = 3; //!< The quantity of equipment
    }
    repeated BorrowedEquipment elem = 1; //!< The equipments @see BorrowedEquipment
}

/** @struct LentEquipments
    @brief A lent equipments message
*/
message LentEquipments {
    /** @struct LentEquipment
        @brief A lent equipment message
    */
    message LentEquipment {
        required UnitId        borrower = 1; //!< The borrower identifier @see UnitId
        required EquipmentType type     = 2; //!< The equipment type @see EquipmentType
        required int32         quantity = 3; //!< The quantity of equipment
    }
    repeated LentEquipment elem = 1; //!< The equipments @see LentEquipment
}

/** @struct ResourceDotations
    @brief A resource dotations message
*/
message ResourceDotations {
    /** @struct ResourceDotation
        @brief A resource dotation message
    */
    message ResourceDotation {
        required ResourceType type     = 1; //!< The resource type @see ResourceType
        required int32        quantity = 2; //!< The quantity available
    }
    repeated ResourceDotation elem = 1; //!< The resource dotations @see ResourceDotation
}

/** @struct EquipmentDotations
    @brief An equipment dotations message
*/
message EquipmentDotations {
    /** @struct EquipmentDotation
        @brief An equipment dotation message
    */
    message EquipmentDotation {
        required EquipmentType type        = 1; //!< The equipment type @see EquipmentType
        required int32         available   = 2; //!< The amount of equipment available
        required int32         unavailable = 3; //!< The amount of equipment unavailable
        required int32         repairable  = 4; //!< The amount of equipment fixable
        required int32         repairing   = 5; //!< The amount of equipment under maintenance
        required int32         captured    = 6; //!< The amount of equipment captured
    }
    repeated EquipmentDotation elem = 1; //!< The equipment dotations @see EquipmentDotation
}

/** @struct HumanDotations
    @brief A human dotations message
*/
message HumanDotations {
    /** @struct HumanDotation
        @brief A human dotation message
    */
    message HumanDotation {
        required EnumHumanRank rang                = 1;  //!< The rank @see EnumHumanRank
        required int32         total               = 2;  //!< The total number of persons
        required int32         operational         = 3;  //!< The number of persons operational
        required int32         dead                = 4;  //!< The number of deads
        required int32         wounded             = 5;  //!< The number of wounded persons
        required int32         mentally_wounded    = 6;  //!< The number of mentally wounded persons
        required int32         contaminated        = 7;  //!< The number of NBC contaminated persons
        required int32         healing             = 8;  //!< The number of persons being treated by medical services
        required int32         maintenance         = 9;  //!< The number of persons performing maintenance
        required int32         unevacuated_wounded = 10; //!< The number of non-evacuated wounded persons
    }
    repeated HumanDotation elem = 1; //!< The human dotations @see HumanDotation
}

/** @struct ContaminationState
    @brief A contamination state message
    @todo move into UnitAttributes
*/
message ContaminationState {
   optional int32 percentage = 1; //!< @todo What's this ?
   optional float quantity   = 2; //!< @todo What's this ?
}

/** @struct NBCAgents
    @brief A NBC agents message
    @todo rename to NbcAgents
    @todo move into UnitAttributes
*/
message NBCAgents {
    repeated NBCAgentType elem = 1; //!< The list of NBC agents @see NBCAgentType
}

/** @struct Communication
    @brief A communication message
    @todo move into UnitAttributes
    @todo rename to Communications with an s
*/
message Communication {
    optional bool              jammed          = 1; //!< Whether the communications are jammed or not
    optional KnowledgeGroupId  knowledge_group = 2; //!< The knowledge group identifier @see KnowledgeGroupId
}

/** @struct Extension
    @brief An extension message
    @todo What's this ?
*/
message Extension {
    /** @struct Entry
        @brief An extension entry message
    */
    message Entry {
        required string name  = 1; //!< The entry name
        required string value = 2; //!< The entry value
    }
    repeated Entry entries = 1; //!< The extension entries @see Entry
}

/** @struct UnitAttributes
    @brief A unit attributes message
*/
message UnitAttributes {
    /** @struct Posture
        @brief Posture states
    */
    enum Posture {
        mouvement           = 0; //!< Moving @todo moving
        mouvement_discret   = 1; //!< Moving discreetly @todo infiltrating
        arret               = 2; //!< Stopped @todo stopping
        poste_reflexe       = 3; //!< ? @todo short stopping
        poste               = 4; //!< ? @todo parked
        poste_amenage       = 5; //!< ? @todo parked on self-prepared area
        poste_prepare_genie = 6; //!< ? @todo parked on engineer-prepared area
    }
    /** @struct FireAvailability
        @brief Fire availability states
    */
    enum FireAvailability {
        no_fire          = 0; //!< No fire
        fire_ready       = 1; //!< Fire ready
        fire_unavailable = 2; //!< Fire unavailable
    }
    /** @struct CrowdRoe
        @brief Rules of engagement against crowds
        @todo rename to RulesOfEngagementAgainstCrowds or something along
    */
    enum CrowdRoe {
        none                                      = 0; //!< No rule @todo rename to no_rule
        emploi_force_interdit                     = 1; //!< Coercion forbidden @todo passive
        maintien_a_distance_par_moyens_non_letaux = 2; //!< Hold back civilians by usage of non lethal means @todo translate @todo non_lethal_force ? hold_back ?
        dispersion_par_moyens_de_defense_actifs   = 3; //!< Disperse civilians by active defense means @todo translate @todo active_defense ? disperse ?
        armes_letales_autorisees                  = 4; //!< Lethal weapons authorized for use @todo lethal_force
    }
    required UnitId                      unit                       = 1;  //!< The unit identifier @see UnitId
    optional HumanDotations              human_dotations            = 2;  //!< The human dotations @see HumanDotations
    optional EquipmentDotations          equipment_dotations        = 3;  //!< The equipment dotations @see EquipmentDotations
    optional ResourceDotations           resource_dotations         = 4;  //!< The resource dotations @see ResourceDotations
    optional LentEquipments              lent_equipments            = 5;  //!< The lent equipments @see LentEquipments
    optional BorrowedEquipments          borrowed_equipments        = 6;  //!< The borrowed equipments @see BorrowedEquipments
    optional CoordLatLong                position                   = 7;  //!< The current position @see CoordLatLong
    optional Heading                     direction                  = 8;  //!< The current heading @see Heading @todo rename to heading
    optional int32                       height                     = 9;  //!< The current height from the ground in meters
    optional int32                       altitude                   = 10; //!< The current altitude on the geoid model of the earth in meters
    optional int32                       speed                      = 11; //!< The current speed in kilometers per hour
    optional int32                       raw_operational_state      = 12; //!< The operational state as a percentage
    optional UnitIdList                  reinforcements             = 13; //!< The reinforcements @see UnitIdList
    optional UnitId                      reinforced_unit            = 14; //!< The reinforced unit @see UnitId
    optional bool                        dead                       = 15; //!< Whether the unit is dead or not
    optional bool                        neutralized                = 16; //!< Whether the unit has been neutralized or not
    optional bool                        stealth                    = 17; //!< Whether the unit is in stealth mode
    optional bool                        embarked                   = 18; //!< Whether the unit has been embarked or not
    optional bool                        transporters_available     = 19; //!< Whether the unit has human transporters available or not
    optional Posture                     old_posture                = 20; //!< The posture which the unit is transitioning from @see Posture @todo rename to old_posture
    optional Posture                     new_posture                = 21; //!< The posture which the unit is transitioning to @see Posture @todo rename to new_posture
    optional int32                       posture_transition         = 22; //!< The completion of the posture transition in percent
    optional int32                       installation               = 23; //!< The completion of the installation in percent
    optional bool                        protective_suits           = 24; //!< Whether the unit is wearing NBC protective suits or not
    optional NBCAgents                   contamination_agents       = 25; //!< The NBC contamination agents @see NBCAgents
    optional ContaminationState          contamination_state        = 26; //!< The NBC contamination state @see ContaminationState
    optional Communication               communications             = 27; //!< The communication state @see Communication
    optional bool                        radio_emitter_disabled     = 28; //!< Whether the radio emitter is disabled or not
    optional bool                        radio_receiver_disabled    = 29; //!< Whether the radio receiver is disabled or not
    optional bool                        radar_active               = 30; //!< Whether the radar is active or not
    optional UnitIdList                  transported_units          = 31; //!< The transported units @see UnitIdList
    optional UnitId                      transporting_unit          = 32; //!< The transporting unit @see UnitId
    optional ForceRatio.Value            force_ratio                = 33; //!< The force ratio @see ForceRatio
    optional EnumMeetingEngagementStatus meeting_engagement         = 34; //!< The meeting engagement status @see EnumMeetingEngagementStatus
    optional EnumOperationalStatus       operational_state          = 35; //!< The operational state @see EnumOperationalStatus
    optional FireAvailability            indirect_fire_availability = 36; //!< The indirect fire availability @see FireAvailability
    optional RulesOfEngagement.Value     roe                        = 37; //!< The rules of engagement @see RulesOfEngagement @todo rename to rules_of_engagement
    optional CrowdRoe                    roe_crowd                  = 38; //!< The rules of engagement against crowds @see CrowdRoe @todo rename to ?
    optional EnumUnitTiredness           tiredness                  = 39; //!< The tiredness @see EnumUnitTiredness
    optional EnumUnitMorale              morale                     = 40; //!< The morale @see EnumUnitMorale
    optional EnumUnitExperience          experience                 = 41; //!< The experience @see EnumUnitExperience
    optional UnitId                      surrendered_unit           = 42; //!< The unit to which this unit has surrendered @see UnitId
    optional bool                        prisoner                   = 43; //!< Whether the unit has been made prisoner or not
    optional bool                        refugees_managed           = 44; //!< Whether refugees are being handled by the unit or not
    optional Extension                   extension                  = 45; //!< @todo What's this ?
}

/** @struct UnitPathFind
    @brief Notifies of a path change for a unit
*/
message UnitPathFind {
   required UnitId unit = 1; //!< The unit identifier @see UnitId
   required Path   path = 2; //!< The unit path @see Path
}

/** @struct UnitDestruction
    @brief Notifies of the destruction a unit
*/
message UnitDestruction {
    required UnitId unit = 1; //!< The unit identifier @see UnitId
}

/** @struct UnitEnvironmentType
    @brief Notifies of a change in the environment for a given unit
*/
message UnitEnvironmentType {
    required UnitId unit   = 1; //!< The unit identifier @see UnitId
    required int32  area   = 2; //!< @todo What's this ?
    required int32  left   = 3; //!< @todo What's this ?
    required int32  right  = 4; //!< @todo What's this ?
    required int32  linear = 5; //!< @todo What's this ?
}

/** @struct UnitEnvironmentType
    @brief Notifies of the creation of a unit knowledge
*/
message UnitKnowledgeCreation {
    required UnitKnowledgeId  knowledge       = 1; //!< The unit knowledge identifier @see UnitKnowledgeId
    required KnowledgeGroupId knowledge_group = 2; //!< The knowledge group identifier @see KnowledgeGroupId
    required UnitId           unit            = 3; //!< The unit identifier @see UnitId
    required UnitType         type            = 4; //!< The unit type @see UnitType
}

enum EnumUnitIdentificationLevel {
    identifiee = 0;
    reconnue   = 1;
    detectee   = 2;
    signale    = 3;
}

message AutomatPerception {
    required AutomatId                   automat              = 1;
    required EnumUnitIdentificationLevel identification_level = 2;
}

message SeqOfAutomatPerception {
    repeated AutomatPerception elem = 1;
}

message UnitKnowledgeUpdate {
    required UnitKnowledgeId             knowledge                = 1;
    required KnowledgeGroupId            knowledge_group          = 2;
    optional int32                       pertinence               = 3;
    optional EnumUnitIdentificationLevel identification_level     = 4;
    optional EnumUnitIdentificationLevel max_identification_level = 5;
    optional int32                       etat_op                  = 6;
    optional bool                        dead                     = 7;
    optional CoordLatLong                position                 = 8;
    optional Heading                     direction                = 9;
    optional int32                       speed                    = 10;
    optional PartyId                     party                    = 11;
    optional bool                        nature_pc                = 12;
    optional SeqOfAutomatPerception      perception_par_compagnie = 13;
    optional UnitId                      surrendered_unit         = 14;
    optional bool                        prisoner                 = 15;
    optional bool                        refugees_managed         = 16;
}

message UnitKnowledgeDestruction {
   required UnitKnowledgeId  knowledge       = 1;
   required KnowledgeGroupId knowledge_group = 2;
}

message UnitFireTarget {
    optional UnitId          unit     = 1;
    optional CrowdId         crowd    = 2;
    optional CoordLatLong position = 3;
}
message StartUnitFire {
    required FireId         fire        = 1;
    required UnitId         firing_unit = 2;
    required UnitFireTarget target      = 3;
    required UnitFireType   type        = 4;
    optional ResourceType   ammunition  = 5;
}

message UnitHumanFireDamage {
   required EnumHumanRank rank           = 1;
   required int32         alive_nbr      = 2;
   required int32         dead_nbr       = 3;
   required int32         wounded_u1_nbr = 4;
   required int32         wounded_u2_nbr = 5;
   required int32         wounded_u3_nbr = 6;
   required int32         wounded_ue_nbr = 7;
}

message SeqOfUnitHumanFireDamage {
   repeated UnitHumanFireDamage elem = 1;
}

message UnitEquipmentFireDamage {
   required EquipmentType equipement_type = 1;
   required uint32        available_nbr   = 2;
   required uint32        unavailable_nbr = 3;
   required uint32        repairable_nbr  = 4;
}

message SeqOfUnitEquipmentFireDamage {
   repeated UnitEquipmentFireDamage elem = 1;
}

message UnitFireDamages {
    required UnitId                       target     = 1;
    required SeqOfUnitHumanFireDamage     humans     = 2;
    required SeqOfUnitEquipmentFireDamage equipments = 3;
}

message UnitsFireDamages {
    repeated UnitFireDamages elem = 1;
}

message CrowdFireDamages {
    required CrowdId target   = 1;
    required int32   dead_nbr = 2;
}

message CrowdsFireDamages {
    repeated CrowdFireDamages elem = 1;
}

message StopUnitFire {
    required FireId            fire           = 1;
    optional UnitsFireDamages  units_damages  = 2;
    optional CrowdsFireDamages crowds_damages = 3;
}

message StartCrowdFire {
   required FireId  fire         = 1;
   required CrowdId firing_crowd = 2;
}

message StopCrowdFire {
    required FireId           fire          = 1;
    required UnitsFireDamages units_damages = 2;
}

message Explosion {
    required ObjectId          object         = 1;
    optional UnitsFireDamages  units_damages  = 2;
    optional CrowdsFireDamages crowds_damages = 3;
}

message StartFireEffect {
    required FireEffectId       fire_effect = 1;
    required Location           location    = 2;
    required EnumFireEffectType type        = 3;
}

message StopFireEffect {
    required FireEffectId fire_effect = 1;
}

enum EnumReportType {
    information       = 0;
    operational       = 1;
    exceptional_event = 2;
    warning           = 3;
}

message Report {
    required ReportId          report     = 1;
    required Tasker            source     = 2;
    required ReportType        type       = 3;
    required ReportCategory    category   = 4;
    required DateTime          time       = 5;
    optional MissionParameters parameters = 6;
}

message InvalidateReport {
    required ReportId report = 1;
    required Tasker   source = 2;
}

message Trace {
    required Tasker source  = 1;
    required string message = 2;
}

message DecisionalState {
    required Tasker source = 1;
    required string key    = 2;
    required string value  = 3;
}

message DebugPoints {
    required Tasker           source      = 1;
    required CoordLatLongList coordinates = 2;
}

message SeqOfHeading {
    repeated Heading elem = 1;
}

message VisionCone {
    required CoordLatLong origin     = 1;
    required int32        height     = 2;
    required string       sensor     = 3;
    required SeqOfHeading directions = 4;
}

message SeqOfVisionCone {
    repeated VisionCone elem = 1;
}

message UnitVisionCones {
    required UnitId          unit       = 1;
    required SeqOfVisionCone cones      = 2;
    required float           elongation = 3;
}

message UnitDetection {
    required UnitId             observer           = 1;
    required UnitId             detected_unit      = 2;
    required EnumUnitVisibility current_visibility = 3;
    required EnumUnitVisibility max_visibility     = 4;
}

message ObjectDetection {
    required UnitId             observer        = 1;
    required ObjectId           detected_object = 2;
    required EnumUnitVisibility visibility      = 3;
}

message CrowdConcentrationDetection {
    required UnitId               observer               = 1;
    required CrowdId              detected_crowd         = 2;
    required CrowdConcentrationId detected_concentration = 3;
    required EnumUnitVisibility   visibility             = 4;
}

message CrowdFlowDetection {
    required UnitId      observer       = 1;
    required CrowdId     detected_crowd = 2;
    required CrowdFlowId detected_flow  = 3;
    required Path        visible_flow   = 4;
}

message ObjectCreation {
    required ObjectId         object     = 1;
    required ObjectType       type       = 2;
    required string           name       = 3;
    required PartyId          party      = 4;
    required Location         location   = 5;
    required ObjectAttributes attributes = 6;
}

message ObjectDestruction {
    required ObjectId object = 1;
}

message ObjectUpdate {
    required ObjectId         object     = 1;
    optional Location         location   = 2;
    required ObjectAttributes attributes = 3;
}

message ObjectKnowledgeCreation {
    required ObjectKnowledgeId knowledge       = 1;
    required PartyId           party           = 2;
    required ObjectId          object          = 3;
    required ObjectType        type            = 4;
    required ObjectAttributes  attributes      = 5;
    optional KnowledgeGroupId  knowledge_group = 6;
}

message ObjectKnowledgeUpdate {
    required ObjectKnowledgeId knowledge           = 1;
    required PartyId           party               = 2;
    optional ObjectId          object              = 3;
    optional int32             relevance           = 4;
    optional Location          location            = 5;
    optional ObjectAttributes  attributes          = 6;
    optional bool              perceived           = 7;
    optional AutomatIdList     perceiving_automats = 8;
    optional KnowledgeGroupId  knowledge_group     = 9;
}

message ObjectKnowledgeDestruction {
    required ObjectKnowledgeId knowledge = 1;
    required PartyId           party     = 2;
}

message UrbanKnowledgeCreation {
    required UrbanObjectKnowledgeId knowledge    = 1;
    required PartyId                party        = 2;
    required UrbanObjectId          urban_block  = 3;
}

message UrbanKnowledgeUpdate {
    required UrbanObjectKnowledgeId knowledge            = 1;
    required PartyId                party                = 2;
    required UrbanObjectId          urban_block          = 3;
    optional int32                  progress             = 4;
    optional int32                  maxProgress          = 5;
    optional bool                   perceived            = 6;
    optional AutomatIdList          automat_perceptions  = 7;
}

message UrbanKnowledgeDestruction {
    required UrbanObjectKnowledgeId knowledge = 1;
    required PartyId                party     = 2;
}

message LogMedicalHandlingCreation {
    required MedicalRequestId request       = 1;
    required UnitId           unit          = 2;
    required int32            tick_creation = 3;
    required EnumHumanRank    rang          = 4;
    required EnumHumanWound   blessure      = 5;
    optional bool             blesse_mental = 6;
    optional bool             contamine_nbc = 7;
}

message LogMedicalHandlingUpdate {
    required MedicalRequestId             request                = 1;
    required UnitId                       unit                   = 2;
    optional UnitId                       provider               = 3;
    optional EnumHumanWound               blessure               = 4;
    optional bool                         blesse_mental          = 5;
    optional bool                         contamine_nbc          = 6;
    optional EnumLogMedicalHandlingStatus etat                   = 7;
    optional bool                         diagnostique_effectue  = 8;
}

message LogMedicalHandlingDestruction {
    required MedicalRequestId request = 1;
    required UnitId           unit    = 2;
}

message LogMedicalEquipmentAvailability{
    required EquipmentType equipment_type = 1;
    required int32         nbr_total       = 2;
    required int32         nbr_disponibles = 3;
    required int32         nbr_au_travail  = 4;
    optional int32         nbr_pretes      = 5;
    optional int32         nbr_au_repos    = 6;
}

message SeqOfLogMedicalEquipmentAvailability {
    repeated LogMedicalEquipmentAvailability elem = 1;
}

message LogMedicalState {
    required UnitId                               unit                                = 1;
    optional bool                                 chaine_activee                      = 2;
    optional LogMedicalPriorities                 priorites                           = 3;
    optional AutomatIdList                        tactical_priorities                 = 4;
    optional SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_releve    = 5;
    optional SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_ramassage = 6;
    optional SeqOfLogMedicalEquipmentAvailability disponibilites_medecins             = 7;
}

message LogMaintenanceHandlingCreation {
    required MaintenanceRequestId request       = 1;
    required UnitId               unit          = 2;
    required int32                tick_creation = 3;
    required EquipmentType        equipement    = 4;
    required BreakdownType        breakdown     = 5;
}

message LogMaintenanceHandlingUpdate {
    required MaintenanceRequestId             request               = 1;
    required UnitId                           unit                  = 2;
    required UnitId                           provider              = 3;
    optional EnumLogMaintenanceHandlingStatus etat                  = 4;
    optional bool                             diagnostique_effectue = 5;
}

message LogMaintenanceHandlingDestruction {
    required MaintenanceRequestId request = 1;
    required UnitId               unit    = 2;
}

message LogMaintenanceEquipmentAvailability {
    required EquipmentType equipment_type  = 1;
    required int32 nbr_total               = 2;
    required int32 nbr_disponibles         = 3;
    required int32 nbr_au_travail          = 4;
    optional int32 nbr_pretes              = 5;
    optional int32 nbr_au_repos            = 6;
}

message SeqOfLogMaintenanceEquipmentAvailability {
    repeated LogMaintenanceEquipmentAvailability elem = 1;
}

message LogMaintenanceState {
    required UnitId                                   unit                       = 1;
    optional bool                                     chaine_activee             = 2;
    optional EnumLogMaintenanceRegimeTravail          regime_travail             = 3;
    optional LogMaintenancePriorities                 priorites                  = 4;
    optional AutomatIdList                            priorites_tactiques        = 5;
    optional SeqOfLogMaintenanceEquipmentAvailability disponibilites_remorqueurs = 6;
    optional SeqOfLogMaintenanceEquipmentAvailability disponibilites_reparateurs = 7;
}

message LogSupplyHandlingCreation {
    optional SupplyRequestId    request       = 1;
    optional AutomatId          consumer      = 2;
    optional int32              tick_creation = 3;
    optional SeqOfDotationQuery dotations     = 4;
}

message DotationQuery {
    optional ResourceType resource            = 1;
    optional int32        quantite_demandee   = 2;
    optional int32        quantite_accordee   = 3;
    optional int32        quantite_en_transit = 4;
}

message SeqOfDotationQuery {
    repeated DotationQuery elem = 1;
}

message LogSupplyHandlingUpdate {
    /** @enum EnumConvoyState
        @brief List of states a supply request can go through
    */
    enum EnumConvoyState {
        convoy_waiting_for_transporters     = 0; //!< Convoy is waiting for transporters
        convoy_forming                      = 1; //!< Convoy is forming
        convoy_moving_to_loading_point      = 2; //!< Convoy is moving to loading point
        convoy_loading                      = 3; //!< Convoy is loading
        convoy_moving_to_unloading_point    = 4; //!< Convoy is moving to unloading point
        convoy_unloading                    = 5; //!< Convoy is unloading
        convoy_moving_back_to_loading_point = 6; //!< Convoy is returning to forming point
        convoy_finished                     = 7; //!< Convoying operation is finished
    }
    optional SupplyRequestId    request         = 1;
    optional AutomatId          consumer        = 2;
    optional ParentEntity       supplier        = 3;
    optional ParentEntity       convoy_provider = 4;
    optional UnitId             convoying_unit  = 5;
    optional EnumConvoyState    etat            = 6;
    optional SeqOfDotationQuery dotations       = 7;
}

message LogSupplyHandlingDestruction {
    required SupplyRequestId request  = 1;
    required AutomatId       consumer = 2;
}

message LogSupplyEquimentAvailability {
    optional EquipmentType equipment       = 1;
    optional int32         nbr_total       = 2;
    optional int32         nbr_disponibles = 3;
    optional int32         nbr_au_travail  = 4;
    optional int32         nbr_pretes      = 5;
    optional int32         nbr_au_repos    = 6;
}

message SeqOfLogSupplyEquimentAvailability {
    repeated LogSupplyEquimentAvailability elem = 1;
}

message LogSupplyState {
    optional UnitId                              unit                                 = 1;
    optional bool                                chaine_activee                       = 2;
    optional SeqOfDotationStock                  stocks                               = 3;
    optional SeqOfLogSupplyEquimentAvailability  disponibilites_transporteurs_convois = 4;
}

message LogSupplyQuotas {
    required ParentEntity       supplied = 1;
    required SeqOfDotationQuota quotas   = 2;
}

message CrowdCreation {
   required CrowdId   crowd     = 1;
   required CrowdType type      = 2;
   optional string    name      = 3;
   required PartyId   party     = 4;
   optional Extension extension = 5;
}

message CrowdUpdate {
   required CrowdId crowd           = 1;
   optional int32   etat_domination = 2;
}

message CrowdDestruction {
   required CrowdId crowd = 1;
}

message CrowdConcentrationCreation {
   required CrowdConcentrationId concentration = 1;
   required CrowdId              crowd         = 2;
   required CoordLatLong         position      = 3;
}

message CrowdConcentrationDestruction {
   required CrowdConcentrationId concentration = 1;
   required CrowdId              crowd         = 2;
}

message CrowdConcentrationUpdate {
   required CrowdConcentrationId concentration      = 1;
   required CrowdId              crowd              = 2;
   optional int32                nb_humains_vivants = 3;
   optional int32                nb_humains_morts   = 4;
   optional EnumCrowdAttitude    attitude           = 5;
}

message CrowdFlowCreation {
   required CrowdFlowId flow  = 1;
   required CrowdId     crowd = 2;
}

message CrowdFlowDestruction {
   required CrowdFlowId flow  = 1;
   required CrowdId     crowd = 2;
}

message CrowdFlowUpdate {
   required CrowdFlowId       flow               = 1;
   required CrowdId           crowd              = 2;
   optional Path              path               = 3;
   optional Path              parts              = 4;
   optional Heading           direction          = 5;
   optional int32             speed              = 6;
   optional int32             nb_humains_vivants = 7;
   optional int32             nb_humains_morts   = 8;
   optional EnumCrowdAttitude attitude           = 9;
}

message CrowdKnowledgeCreation {
   required CrowdKnowledgeId knowledge       = 1;
   required KnowledgeGroupId knowledge_group = 2;
   optional CrowdId          crowd           = 3;
   optional PartyId          party           = 4;
}

message CrowdKnowledgeUpdate {
   required CrowdKnowledgeId knowledge       = 1;
   required KnowledgeGroupId knowledge_group = 2;
   optional int32            etat_domination = 3;
}

message CrowdKnowledgeDestruction {
   required CrowdKnowledgeId knowledge       = 1;
   required KnowledgeGroupId knowledge_group = 2;
}

message CrowdConcentrationKnowledgeCreation {
    required CrowdConcentrationKnowledgeId knowledge       = 1;
    required CrowdKnowledgeId              crowd           = 2;
    required KnowledgeGroupId              knowledge_group = 3;
    required CrowdConcentrationId          concentration   = 4;
    optional CoordLatLong                  position        = 5;
}

message CrowdConcentrationKnowledgeUpdate {
    required CrowdConcentrationKnowledgeId knowledge          = 1;
    required CrowdKnowledgeId              crowd              = 2;
    required KnowledgeGroupId              knowledge_group    = 3;
    optional CrowdConcentrationId          concentration      = 4;
    optional int32                         nb_humains_vivants = 5;
    optional int32                         nb_humains_morts   = 6;
    optional EnumCrowdAttitude             attitude           = 7;
    optional int32                         pertinence         = 8;
    optional bool                          est_percu          = 9;
}

message CrowdConcentrationKnowledgeDestruction {
    required CrowdConcentrationKnowledgeId knowledge       = 1;
    required CrowdKnowledgeId              crowd           = 2;
    required KnowledgeGroupId              knowledge_group = 3;
}

message CrowdFlowKnowledgeCreation {
    required CrowdFlowKnowledgeId knowledge       = 1;
    required CrowdKnowledgeId     crowd           = 2;
    required KnowledgeGroupId     knowledge_group = 3;
    required CrowdFlowId          flow            = 4;
}

message FlowPart {
   required Path forme      = 1;
   required int32   pertinence = 2;
}

message SeqOfFlowPart {
   repeated FlowPart elem = 1;
}

message CrowdFlowKnowledgeUpdate {
    required CrowdFlowKnowledgeId knowledge          = 1;
    required CrowdKnowledgeId     crowd              = 2;
    required KnowledgeGroupId     knowledge_group    = 3;
    optional CrowdFlowId          flow               = 4;
    optional SeqOfFlowPart        portions_flux      = 5;
    optional Heading              direction          = 6;
    optional int32                speed              = 7;
    optional int32                nb_humains_vivants = 8;
    optional int32                nb_humains_morts   = 9;
    optional EnumCrowdAttitude    attitude           = 10;
    optional bool                 est_percu          = 11;
}

message CrowdFlowKnowledgeDestruction {
    required CrowdFlowKnowledgeId knowledge       = 1;
    required CrowdKnowledgeId     crowd           = 2;
    required KnowledgeGroupId     knowledge_group = 3;
}

// Folk
message FolkCreation_profiles {
   repeated string elem = 1;
}

message FolkCreation_activities {
   repeated string elem = 1;
}

message FolkCreation {
   required FolkCreation_profiles   profiles       = 1;
   required FolkCreation_activities activities     = 2;
   optional int32                   container_size = 3;
   optional int32                   edge_number    = 4;
}

message FolkGraphEdgeUpdate {
   required int32 folk             = 1;
   required int32 shape_id         = 2;
   repeated int32 crowd_occupation = 3;
}

message FolkGraphUpdate {
   repeated FolkGraphEdgeUpdate elem = 1;
}

// Checkpoints
message ControlCheckPointSetFrequencyAck {
}

message ControlCheckPointSaveNowAck {
}

message ControlCheckPointSaveBegin {
}

message ControlCheckPointSaveBeginAck {
}

message ControlCheckPointSaveEnd {
    optional string name = 1;
}

message ControlCheckPointListAck {
}

message ControlCheckPointList {
    repeated string checkpoint = 1;
}

message ControlCheckPointDeleteAck {
}

// Current State / Initialization
message ControlSendCurrentStateBegin{
}

message ControlSendCurrentStateEnd {
}

message UrbanAttributes {
    message Architecture {
        required float  height            = 1;
        required int32  floor_number      = 2;
        required string roof_shape        = 3;
        required string material          = 4;
        required float  occupation        = 5;
        required float  trafficability    = 6;
        required bool   parking_available = 7 [default = false];
    }
    message Structure {
        required uint32 state = 1;
    }
    message Infrastructures {
        message Infrastructure {
          required string type      = 1;
          required bool   active    = 2;
          required float  threshold = 3;
        }
        repeated ResourceNetwork resource_network = 1;
        optional Infrastructure infrastructure = 2;
    }
    optional Architecture    architecture    = 1;
    optional Structure       structure       = 2;
    optional RgbaColor       color           = 3;
    optional Infrastructures infrastructures = 4;
    repeated UrbanUsage      usages          = 5;
}

message UrbanCreation {
   required UrbanObjectId   urban_object = 1;
   required UrbanObjectId   urban_block  = 2;
   required string          name         = 3;
   required Location        location     = 4;
   optional UrbanAttributes attributes   = 5;
   optional UrbanObjectId   parent       = 6;
}

message UrbanDetection {
    required UnitId             observer     = 1;
    required UrbanObjectId      urban_object = 2;
    required EnumUnitVisibility visibility   = 3;
}

message UrbanUpdate {
   required UrbanObjectId   urban_object = 1;
   optional Location     location     = 2;
   optional UrbanAttributes attributes   = 3;
}

// Knowledge groups
message KnowledgeGroupCreation {
   required KnowledgeGroupId knowledge_group = 1;
   required PartyId          party           = 2;
   optional KnowledgeGroupId parent          = 3;
   required string           type            = 4;
   optional bool             jam             = 5;
}

message KnowledgeGroupUpdate {
   required KnowledgeGroupId knowledge_group = 1;
   optional PartyId          party           = 2;
   optional KnowledgeGroupId parent          = 3;
   optional bool             enabled         = 4;
   optional string           type            = 5;
}

message KnowledgeGroupAck {
    enum ErrorCode {
       no_error                     = 0;
       error_invalid_unit           = 1;
       error_invalid_superior       = 2;
       error_invalid_party          = 3;
       error_invalid_knowledgegroup = 4;
       error_invalid_type           = 5;
    }
}

message KnowledgeGroupMagicActionAck {
    required KnowledgeGroupId            knowledge_group = 1;
    required KnowledgeGroupAck.ErrorCode error_code      = 2;
}

message KnowledgeGroupCreationAck {
    required KnowledgeGroupId            knowledge_group = 1;
    required KnowledgeGroupAck.ErrorCode error_code      = 2;
}

message KnowledgeGroupUpdateAck {
    required KnowledgeGroupId            knowledge_group = 1;
    required KnowledgeGroupAck.ErrorCode error_code      = 2;
}

message KnowledgeGroupDestruction {
    required KnowledgeGroupId knowledge_group = 1;
    required PartyId          party           = 2;
}

// Weather
message ControlGlobalWeatherAck {
}

message ControlLocalWeatherAck {
}

message ControlGlobalWeather {
    required WeatherId            weather    = 1;
    required WeatherAttributes attributes = 2;
}

message ControlLocalWeatherCreation {
   required WeatherId            weather                 = 1;
   optional CoordLatLong      top_left_coordinate     = 2;
   optional CoordLatLong      bottom_right_coordinate = 3;
   optional WeatherAttributes attributes              = 4;

}

message ControlLocalWeatherDestruction {
   required WeatherId weather = 1;
}

// Populations
message PopulationCreation {
    required PopulationId   id        = 1;
    required PartyId        party     = 2;
    required PopulationType type      = 3;
    required string         name      = 4;
    required string         text      = 5;
    optional Extension      extension = 6;
    repeated UrbanObjectId  blocks    = 7;
}

message PopulationUpdate {
    message MotivationSatisfaction {
        required MotivationType motivation = 1; // motivationType = "home", "office", ...
        required float          value      = 2;
    }
    message ResourceSatisfaction {
        required ResourceType resource = 1;
        required float        value    = 2;
    }
    message Satisfaction {
        repeated ResourceSatisfaction   resources   = 1;
        repeated MotivationSatisfaction motivations = 2;
        optional float                  lodging     = 3;
        optional float                  health      = 4;
        optional float                  safety      = 5;
    }
    message BlockOccupation {
         required UrbanObjectId block = 1;
         required int32         number = 2;
     }
    required PopulationId    id           = 1;
    optional int32           healthy      = 2;
    optional int32           wounded      = 3;
    optional int32           dead         = 4;
    repeated PartyAdhesion   adhesions    = 5;
    optional Satisfaction    satisfaction = 6;
    optional MotivationType  motivation   = 7;
    repeated BlockOccupation occupations  = 8;
}

// Message container
message SimToClient {
    message Content {
        optional TaskCreationRequestAck               order_ack                                   = 1;
        optional FragOrderAck                         frag_order_ack                              = 4;
        optional SetAutomatModeAck                    set_automat_mode_ack                        = 5;
        optional UnitCreationRequestAck               unit_creation_request_ack                   = 6;
        optional MagicActionAck                       magic_action_ack                            = 7;
        optional UnitMagicActionAck                   unit_magic_action_ack                       = 8;
        optional ObjectMagicActionAck                 object_magic_action_ack                     = 9;
        optional CrowdMagicActionAck                  crowd_magic_action_ack                      = 10;
        optional ChangeDiplomacyAck                   change_diplomacy_ack                        = 11;
        optional AutomatChangeKnowledgeGroupAck       automat_change_knowledge_group_ack          = 12;
        optional ChangeLogisticLinksAck               automat_change_logistic_links_ack           = 13;
        optional AutomatChangeSuperiorAck             automat_change_superior_ack                 = 14;
        optional UnitChangeSuperiorAck                unit_change_superior_ack                    = 15;
        optional LogSupplyPushFlowAck                 log_supply_push_flow_ack                    = 16;
        optional LogSupplyChangeQuotasAck             log_supply_change_quotas_ack                = 17;
        optional ControlInformation                   control_information                         = 18;
        optional ControlProfilingInformation          control_profiling_information               = 19;
        optional ControlBeginTick                     control_begin_tick                          = 20;
        optional ControlEndTick                       control_end_tick                            = 21;
        optional ControlStopAck                       control_stop_ack                            = 22;
        optional ControlPauseAck                      control_pause_ack                           = 23;
        optional ControlResumeAck                     control_resume_ack                          = 24;
        optional ControlChangeTimeFactorAck           control_change_time_factor_ack              = 25;
        optional ControlDateTimeChangeAck             control_date_time_change_ack                = 26;
        optional ControlCheckPointSaveEnd             control_checkpoint_save_end                 = 27;
        optional FormationCreation                    formation_creation                          = 28;
        optional PartyCreation                        party_creation                              = 29;
        optional AutomatCreation                      automat_creation                            = 30;
        optional AutomatAttributes                    automat_attributes                          = 31;
        optional UnitCreation                         unit_creation                               = 32;
        optional UnitAttributes                       unit_attributes                             = 33;
        optional UnitPathFind                         unit_pathfind                               = 34;
        optional UnitDestruction                      unit_destruction                            = 35;
        optional UnitEnvironmentType                  unit_environment_type                       = 36;
        optional ChangeDiplomacy                      change_diplomacy                            = 37;
        optional UnitChangeSuperior                   unit_change_superior                        = 38;
        optional ChangeLogisticLinks                  automat_change_logistic_links               = 39;
        optional AutomatChangeKnowledgeGroup          automat_change_knowledge_group              = 40;
        optional AutomatChangeSuperior                automat_change_superior                     = 41;
        optional UnitKnowledgeCreation                unit_knowledge_creation                     = 42;
        optional UnitKnowledgeUpdate                  unit_knowledge_update                       = 43;
        optional UnitKnowledgeDestruction             unit_knowledge_destruction                  = 44;
        optional StartUnitFire                        start_unit_fire                             = 45;
        optional StopUnitFire                         stop_unit_fire                              = 46;
        optional StartCrowdFire                       start_crowd_fire                            = 47;
        optional StopCrowdFire                        stop_crowd_fire                             = 48;
        optional Explosion                            explosion                                   = 49;
        optional StartFireEffect                      start_fire_effect                           = 50;
        optional StopFireEffect                       stop_fire_effect                            = 51;
        optional Report                               report                                      = 52;
        optional InvalidateReport                     invalidate_report                           = 53;
        optional Trace                                trace                                       = 54;
        optional DecisionalState                      decisional_state                            = 55;
        optional DebugPoints                          debug_points                                = 56;
        optional UnitVisionCones                      unit_vision_cones                           = 57;
        optional UnitDetection                        unit_detection                              = 58;
        optional ObjectDetection                      object_detection                            = 59;
        optional CrowdConcentrationDetection          crowd_concentration_detection               = 60;
        optional CrowdFlowDetection                   crowd_flow_detection                        = 61;
        optional UnitOrder                              unit_order                                = 62;
        optional AutomatOrder                           automat_order                             = 63;
        optional CrowdOrder                             crowd_order                               = 64;
        optional ObjectCreation                         object_creation                           = 65;
        optional ObjectDestruction                      object_destruction                        = 66;
        optional ObjectUpdate                           object_update                             = 67;
        optional ObjectKnowledgeCreation                object_knowledge_creation                 = 68;
        optional ObjectKnowledgeUpdate                  object_knowledge_update                   = 69;
        optional ObjectKnowledgeDestruction             object_knowledge_destruction              = 70;
        optional LogMedicalHandlingCreation             log_medical_handling_creation             = 71;
        optional LogMedicalHandlingUpdate               log_medical_handling_update               = 72;
        optional LogMedicalHandlingDestruction          log_medical_handling_destruction          = 73;
        optional LogMedicalState                        log_medical_state                         = 74;
        optional LogMaintenanceHandlingCreation         log_maintenance_handling_creation         = 75;
        optional LogMaintenanceHandlingUpdate           log_maintenance_handling_update           = 76;
        optional LogMaintenanceHandlingDestruction      log_maintenance_handling_destruction      = 77;
        optional LogMaintenanceState                    log_maintenance_state                     = 78;
        optional LogSupplyHandlingCreation              log_supply_handling_creation              = 79;
        optional LogSupplyHandlingUpdate                log_supply_handling_update                = 80;
        optional LogSupplyHandlingDestruction           log_supply_handling_destruction           = 81;
        optional LogSupplyState                         log_supply_state                          = 82;
        optional LogSupplyQuotas                        log_supply_quotas                         = 83;
        optional CrowdCreation                          crowd_creation                            = 84;
        optional CrowdUpdate                            crowd_update                              = 85;
        optional CrowdConcentrationCreation             crowd_concentration_creation              = 86;
        optional CrowdConcentrationDestruction          crowd_concentration_destruction           = 87;
        optional CrowdConcentrationUpdate               crowd_concentration_update                = 88;
        optional CrowdFlowCreation                      crowd_flow_creation                       = 89;
        optional CrowdFlowDestruction                   crowd_flow_destruction                    = 90;
        optional CrowdFlowUpdate                        crowd_flow_update                         = 91;
        optional CrowdKnowledgeCreation                 crowd_knowledge_creation                  = 92;
        optional CrowdKnowledgeUpdate                   crowd_knowledge_update                    = 93;
        optional CrowdKnowledgeDestruction              crowd_knowledge_destruction               = 94;
        optional CrowdConcentrationKnowledgeCreation    crowd_concentration_knowledge_creation    = 95;
        optional CrowdConcentrationKnowledgeDestruction crowd_concentration_knowledge_destruction = 96;
        optional CrowdConcentrationKnowledgeUpdate      crowd_concentration_knowledge_update      = 97;
        optional CrowdFlowKnowledgeCreation             crowd_flow_knowledge_creation             = 98;
        optional CrowdFlowKnowledgeDestruction          crowd_flow_knowledge_destruction          = 99;
        optional CrowdFlowKnowledgeUpdate               crowd_flow_knowledge_update               = 100;
        optional FolkCreation                           folk_creation                             = 101;
        optional FolkGraphUpdate                        folk_graph_update                         = 102;
        optional ControlGlobalWeatherAck                control_global_weather_ack                = 103;
        optional ControlLocalWeatherAck                 control_local_weather_ack                 = 104;
        optional ControlCheckPointSaveBegin             control_checkpoint_save_begin             = 105;
        optional ControlCheckPointSetFrequencyAck       control_checkpoint_set_frequency_ack      = 106;
        optional ControlCheckPointSaveNowAck            control_checkpoint_save_now_ack           = 107;
        optional ControlSendCurrentStateBegin           control_send_current_state_begin          = 108;
        optional ControlSendCurrentStateEnd             control_send_current_state_end            = 109;
        optional UrbanCreation                          urban_creation                            = 110;
        optional UrbanUpdate                            urban_update                              = 111;
        optional UrbanKnowledgeCreation                 urban_knowledge_creation                  = 112;
        optional UrbanKnowledgeUpdate                   urban_knowledge_update                    = 113;
        optional UrbanKnowledgeDestruction              urban_knowledge_destruction               = 114;
        optional StockResource                          stock_resource                            = 115;
        optional UrbanDetection                         urban_detection                           = 116;
        optional KnowledgeGroupMagicActionAck           knowledge_group_magic_action_ack          = 117;
        optional KnowledgeGroupCreation                 knowledge_group_creation                  = 118;
        optional KnowledgeGroupUpdate                   knowledge_group_update                    = 119;
        optional KnowledgeGroupCreationAck              knowledge_group_creation_ack              = 120;
        optional KnowledgeGroupUpdateAck                knowledge_group_update_ack                = 121;
        optional KnowledgeGroupDestruction              knowledge_group_destruction               = 122;
        optional ActionCreateFireOrderAck               action_create_fire_order_ack              = 123;
        optional ControlGlobalWeather                   control_global_weather                    = 124;
        optional ControlLocalWeatherCreation            control_local_weather_creation            = 125;
        optional ControlLocalWeatherDestruction         control_local_weather_destruction         = 126;
        optional ControlCheckPointListAck               control_checkpoint_list_ack               = 127;
        optional ControlCheckPointList                  control_checkpoint_list                   = 128;
        optional ControlCheckPointDeleteAck             control_checkpoint_delete_ack             = 129;
        optional LogSupplyPullFlowAck                   log_supply_pull_flow_ack                  = 130;
        optional FormationDestruction                   formation_destruction                     = 131;
        optional AutomatDestruction                     automat_destruction                       = 132;
        optional CrowdDestruction                       crowd_destruction                         = 133;
        optional PopulationCreation                     population_creation                       = 134;
        optional PopulationUpdate                       population_update                         = 135;
        optional ChangePopulationMagicActionAck         change_population_magic_action_ack        = 136;
        optional UrbanMagicActionAck                    urban_magic_action_ack                    = 137;
        optional FragOrder                              frag_order                                = 138;
    }
    optional int32   context = 1;
    required Content message = 2;
}
