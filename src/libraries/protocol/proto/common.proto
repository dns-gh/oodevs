// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2010 MASA Group
//
// *****************************************************************************

package sword;

/** @file
 *  @brief Messages common to various modules
 */

/** @struct Id
    @brief Defines an identifier
*/
message Id {
    //! The identifier
    required uint32 id = 1;
}

/** @struct IdList
    @brief Defines a list of identifiers
*/
message IdList {
    //! The identifiers
    repeated Id elem = 1;
}

/** @struct Tasker
    @brief Encapsulates all possible actors
*/
message Tasker {
    //! An automat
    optional Id automat    = 1;
    //! A formation
    optional Id formation  = 2;
    //! A crowd
    optional Id crowd      = 3;
    //! A unit
    optional Id unit       = 4;
    //! A party
    optional Id party      = 5;
    //! A population
    optional Id population = 6;
}

/** @struct ParentEntity
    @brief Defines a parent entity which can be either an automat or a
           formation
*/
message ParentEntity {
    //! An automat
    optional Id automat   = 1;
    //! A formation
    optional Id formation = 2;
}

/** @struct ObjectType
    @brief Defines an object type

    The Id refers to the type implemented in the physical database. See
    the @ref objects_xsd.
*/
message ObjectType {
    //! The identifier @todo should be an integer
    required string id = 1;
}

/** @struct ResourceNetworkType
    @brief Defines a resource network type

    The Id refers to the type implemented in the physical database. See
    the @ref resource_networks_xsd.
*/
message ResourceNetworkType {
    //! The identifier
    required string name = 1;
}

/** @struct Heading
    @brief Defines a heading
*/
message Heading {
    //! The direction in degrees
    required int32 heading = 1;
}

/** @struct DateTime
    @brief Defines a date/time
*/
message DateTime {
    //! The date-time formatted according to ISO 8601
    required string data = 1;
}

/** @struct AutomatChangeSuperior
    @brief Notifies of an automat changing superior
*/
message AutomatChangeSuperior {
    /** @struct Superior
        @brief Defines a superior
        @todo why not use a ParentEntity ?
    */
    message Superior {
        //! A formation
        optional Id formation = 1;
        //! An automat
        optional Id automat   = 2;
    }
    //! The automat identifier
    required Id       automat  = 1;
    //! The superior
    required Superior superior = 2;
}

/** @struct FormationChangeSuperior
    @brief Notifies of a formation changing superior
*/
message FormationChangeSuperior {
    /** @struct Superior
        @brief Defines a superior
        @todo why not use a ParentEntity ?
    */
    message Superior {
        //! A formation
        optional Id formation = 1;
        //! A party
        optional Id party     = 2;
    }
    //! The formation identifier
    required Id       formation = 1;
    //! The superior
    required Superior superior  = 2;
}

/** @struct UnitChangeSuperior
    @brief Notifies of a unit changing superior
*/
message UnitChangeSuperior {
    //! The unit identifier
    required Id unit   = 1;
    //! The parent identifier
    required Id parent = 2;
}

/** @enum EnumSimulationState
    @brief Defines the different states of the simulation
*/
enum EnumSimulationState {
    //! Running
    running = 0;
    //! Paused
    paused  = 1;
    //! Stopped
    stopped = 2;
    //! Loading
    loading = 3;
}

/** @enum EnumAutomatMode
    @brief Defines the different states of an automat
*/
enum EnumAutomatMode {
    //! Engaged
    engaged    = 0;
    //! Disengaged
    disengaged = 1;
}

/** @enum EnumDiplomacy
    @brief Defines the different states of a diplomacy
*/
enum EnumDiplomacy {
    //! Unknown
    unknown  = 0;
    //! Friendly
    friendly = 1;
    //! Enemy
    enemy    = 2;
    //! Neutral
    neutral  = 3;
}

/** @enum EnumHumanWound
    @brief Defines the different types of wounds
*/
enum EnumHumanWound {
    //! Unwounded
    unwounded               = 0;
    //! Dead
    dead                    = 1;
    //! Wounded urgency level 1
    wounded_urgency_1       = 2;
    //! Wounded urgency level 2
    wounded_urgency_2       = 3;
    //! Wounded urgency level 3
    wounded_urgency_3       = 4;
    //! Wounded extreme urgency
    wounded_extreme_urgency = 5;
}

/** @enum DotationType
    @brief Defines possible dotation categories
*/
enum DotationType {
    dotation_type_ammunition         = 0;
    dotation_type_fuel               = 1;
    dotation_type_explosive          = 2;
    dotation_type_mine               = 3;
    dotation_type_barbed_wire        = 4;
    dotation_type_parts              = 5;
    dotation_type_food_and_water     = 6;
    dotation_type_extinguisher_agent = 7;
    dotation_type_energy             = 8;
    dotation_type_funeral            = 9;
}

//! Defines the different nature levels using APP-6A symbols
//! See: http://en.wikipedia.org/wiki/Military_organization
enum EnumNatureLevel {
    none_naturelevel = 0;
    //! Fire and maneuver team
    b                = 1;
    //! Fireteam
    o                = 2;
    //! Squad or crew
    c                = 3;
    //! Section or patrol
    oo               = 4;
    //! Platoon or Commonwealth troop
    ooo              = 5;
    //! Infantry company, artillery battery, U.S. Cavalry troop, or
    //! Commonwealth armour or combat engineering squadron
    i                = 6;
    //! Infantry battalion, U.S. Cavalry squadron, or Commonwealth
    //! armoured regiment
    ii               = 7;
    //! Regiment or group
    iii              = 8;
    //! Brigade
    x                = 9;
    //! Division
    xx               = 10;
    //! Corps
    xxx              = 11;
    //! Army
    xxxx             = 12;
    //! Army group, front
    xxxxx            = 13;
}

/** @struct ControlStop
    @brief Stops the simulation
    @see ControlStopAck
*/
message ControlStop {
}

//! Pauses the simulation. Pausing a paused simulation does nothing.
//! Returns ControlPauseAck.
message ControlPause {
}

//! Resumes a paused simulation. If tick greater is than zero, the
//! simulation runs until after the end message of
//! (ControlResumeAck.current_tick + ControlResumeAck.tick - 1) tick
//! before being suspended again. Resuming a running simulation does
//! nothing if tick is set to 0, and will pause it after tick ticks
//! otherwise.
message ControlResume {
    optional uint32 tick = 1;
}

/** @struct ControlChangeTimeFactor
    @brief Changes the simulation time factor
*/
message ControlChangeTimeFactor {
    //! The new time multiplier
    required int32 time_factor = 1;
}

// Color
/** @struct RgbColor
    @brief Defines a color
*/
message RgbColor {
    //! The red component between 0 and 255
    required int32 red   = 1;
    //! The green component between 0 and 255
    required int32 green = 2;
    //! The blue component between 0 and 255
    required int32 blue  = 3;
}

/** @struct CoordLatLong
    @brief Defines coordinates
*/
message CoordLatLong {
    //! The latitude
    required double latitude  = 1;
    //! The longitude
    required double longitude = 2;
}

/** @struct CoordLatLongList
    @brief Defines a list of coordinates
*/
message CoordLatLongList {
    //! The coordinates
    repeated CoordLatLong elem = 2;
}

/** @struct Location
    @brief Defines a location as an area at given coordinates
*/
message Location {
    /** @enum Geometry
        @brief Defines the different geometries available
    */
    enum Geometry {
        //! Circle
        circle    = 0;
        //! Ellipse
        ellipse   = 1;
        //! Line
        line      = 2;
        //! Rectangle
        rectangle = 3;
        //! Polygon
        polygon   = 4;
        //! Point
        point     = 5;
        //! Sector
        sector    = 6;
        //! None
        none      = 7;
    }
    //! The type of geometry
    required Geometry         type        = 1;
    //! The coordinates associated to the geometry
    optional CoordLatLongList coordinates = 2;
}

/** @struct LocationList
    @brief Defines a list of locations
*/
message LocationList {
    //! The locations
    repeated Location elem = 1;
}

/** @struct Line
    @brief Defines a line location
    @todo Why is there a type in location ?
*/
message Line {
    //! The location
    required Location location = 1;
}

/** @struct Path
    @brief Defines a path
    @todo Why is there a type in location ?
*/
message Path {
    //! The location
    required Location location = 1;
}

/** @struct PathPoint
*/
message PathPoint {
    // The coordinate point
    required CoordLatLong coordinate = 1;
    // The index of the associated waypoint
    optional int32        waypoint   = 2;
    // if the associated waypoint is reached
    optional bool         reached    = 3;
}

/** @struct PathResult
    @brief Defines a path
        with the debug information
*/
message PathResult {
    //! The calculated path
    repeated PathPoint points = 1;
}

/** @struct PathList
    @brief Defines a list of paths
*/
message PathList {
    //! The paths
    repeated Path elem = 1;
}

/** @struct Point
    @brief Defines a point location
    @todo Why is there a type in location ?
*/
message Point {
    //! The location
    required Location location = 1;
}

/** @struct PointList
    @brief Defines a list of points
*/
message PointList {
    //! The points
    repeated Point elem = 1;
}

/** @struct Polygon
    @brief Defines a polygon location
    @todo Why is there a type in location ?
*/
message Polygon {
    //! The location
    required Location location = 1;
}

/** @struct PointList
    @brief Defines a list of polygons
*/
message PolygonList {
    //! The polygons
    repeated Polygon  elem = 1;
}

/** @struct LogMedicalPriorities
    @brief Defines a list human wounds
*/
message LogMedicalPriorities {
    //! The wounds
    repeated EnumHumanWound elem = 1;
}

/** @struct ObstacleType
    @brief Encapsulates an obstacle type
*/
message ObstacleType {
    /** @enum DemolitionTargetType
        @brief Defines an obstacle type
    */
    enum DemolitionTargetType {
        //! The obstacle is already built and will always be active
        preliminary = 0;
        //! The obstacle can be activated or deactivated during the exercise
        reserved    = 1;
    }
}

/** @struct PlannedWork
    @brief Defines a planned work
*/
message PlannedWork {
    //! The work type
    required string                            type              = 1;
    //! The location of the work
    required Location                          position          = 2;
    //! The type of obstacle @todo rename to obstacle
    optional ObstacleType.DemolitionTargetType type_obstacle     = 3;
    //! The obstacle density (for instance density of mines) @todo unit ?
    optional float                             density           = 4;
    //! The combat train
    optional Id                                combat_train      = 5;
    //! The obstacle life time in seconds
    optional int32                             activity_time     = 6;
    //! The time at which the obstacle is to be activated
    optional int32                             activation_time   = 7;
    //! The name to be given to the constructed object
    optional string                            name              = 8;
    //! The altitude modifier
    optional int32                             altitude_modifier = 9;
    //! The time limited object time
    optional int32                             time_limit        = 10;
    //! The mine improvement
    optional bool                              mining            = 11;
    //! The lodging capacity
    optional int32                             lodging           = 12;
    //! The fire class
    optional string                            fire_class        = 13;
    //! The max combustion energy(fire class)
    optional int32                             max_combustion    = 14;
}

/** @struct PlannedWorkList
  @brief Lists several planned works
 */
message PlannedWorkList {
    //! The planned works
    repeated PlannedWork elem = 1;
}

/** @struct MissionObjective
    @brief Defines a mission objective
*/
message MissionObjective {
    //! The objective location
    required Location location = 1;
    //! The objective date and time
    required DateTime time     = 2;
}

/** @struct MissionObjectiveList
    @brief Lists several mission objectives
*/
message MissionObjectiveList {
    //! The mission objectives
    repeated MissionObjective elem = 1;
}

/** @struct PhaseLineOrder
    @brief Defines a phase line order
*/
message PhaseLineOrder {
    /** @enum Function
        @brief Defines a phase line function
    */
    enum Function {
        //! Line of departure
        line_of_departure              = 0;
        //! Attitude change line
        attitude_change_line           = 1;
        //! Coordination line
        coordination_line              = 2;
        //! Denial line
        denial_line                    = 3;
        //! Objective line
        objective_line                 = 4;
        //! Blocking line
        blocking_line                  = 5;
        //! Handover line
        handover_line                  = 6;
        //! Start of mission line
        start_of_mission_line          = 7;
        //! End of mission line
        end_of_mission_line            = 8;
        //! Recognition and reception line
        recognition_and_reception_line = 9;
    }
    //! The phase line
    required Line     line      = 1;
    //! The date and time
    required DateTime time      = 2;
    //! The functions
    repeated Function fonctions = 3;
}

/** @struct PhaseLinesOrder
    @brief Lists several phase line orders
*/
message PhaseLinesOrder {
    //! The phase line orders
    repeated PhaseLineOrder elem = 1;
}

/** @struct Nature
    @brief Encapsulates the nature flags
*/
message Nature {
    /** @enum Flags
        @brief Defines the nature flags
    */
    enum Flags {
        //! Tank
        tank             = 1;
        //! Missile Launcher
        missile_launcher = 2;
        //! Command Post
        command_post     = 4;
        //! Logistics
        logistics        = 8;
        //! Mortar
        mortar           = 16;
        //! Rocket Launcher
        rocket_launcher  = 32;
        //! Vehicle
        vehicle          = 64;
        //! Infantry
        infantry         = 128;
        //! Helicopter
        helicopter       = 256;
        //! Anti Aircraft
        anti_aircraft    = 1024;
    }
    //! The combination of flags
    required int32 flags = 1;
}

/** @struct Extension
    @brief An extension message
    @todo What's this ?
*/
message Extension {
    /** @struct Entry
        @brief An extension entry message
    */
    message Entry {
        //! The entry name
        required string name  = 1;
        //! The entry value
        required string value = 2;
    }
    //! The extension entries @see Entry
    repeated Entry entries = 1;
}

/** @struct ResourceNetworkElement
    @brief A resource network element message
*/
message ResourceNetworkElement {
    //! An object identifier
    required Id                  object   = 1;
    //! The resource network type
    required ResourceNetworkType resource = 2;
}

/** @struct SupplyFlowResource
    @brief The resource part of supply flow (push/pull) messages
    @todo What's this ?
*/
message SupplyFlowResource {
    //! The resource type that will be conveyed
    required Id     resourceType = 1;
    //! The quantity that will be conveyed
    required uint32 quantity     = 2;
}

/** @struct SupplyFlowTransporter
    @brief The transporters (conveyors) part of supply flow (push/pull)
    messages
*/
message SupplyFlowTransporter {
    //! The equipment (trucks ...) that will be used to convey the resources
    required Id     equipmentType = 1;
    //! The previous equipment type quantity
    required uint32 quantity      = 2;
}

/** @struct SupplyFlowRecipient
    @brief The recipient(receiver) of a supply flow
    @todo What's this ?
*/
message SupplyFlowRecipient {
    //! The receiver of the supply flow
    required Id                 receiver  = 1;
    //! The resources conveyed  - must contain at least one element
    repeated SupplyFlowResource resources = 2;
    //! The optional way points the convey has to take to go to the receiver
    optional PointList          path      = 3;
}

/** @struct PushFlowParameters
    @brief The parameters of a supply push flow operation
    @todo What's this ?
*/
message PushFlowParameters {
    //! The recipients (and the associated path/resources) of the
    //! supply - must contain at least one element
    repeated SupplyFlowRecipient   recipients   = 1;
    //! The optional explicit transporter to use for the supply
    //! operation - If no transporters are specified, they are chosen
    //! automatically
    repeated SupplyFlowTransporter transporters = 2;
    //! The optional way points the convey has to take when going back
    //! to its logistic base
    optional PointList             wayBackPath  = 3;
    //! Message is used to supply if set to true, push flow otherwise
    optional bool                  supply       = 4;
}

/** @struct PullFlowParameters
    @brief The parameters of a supply pull flow operation
    @todo What's this ?
*/
message PullFlowParameters {
    //! The logistic base which will provide the resources
    required ParentEntity          supplier     = 1;
    //! The resources to supply - must contain at least one element
    repeated SupplyFlowResource    resources    = 2;
    //! The optional explicit transporter to use for the supply
    //! operation - If no transporters are specified, they are chosen
    //! automatically
    repeated SupplyFlowTransporter transporters = 3;
    //! The optional way points the convey has to take to go to the
    //! logistic base
    optional PointList             wayOutPath   = 4;
    //! The optional way points the convey has to take to go back to
    //! the 'requester'
    optional PointList             wayBackPath  = 5;
}

/** @struct MissionParameter
    @brief Defines a mission parameter
*/
message MissionParameter {
    /** @struct Value
        @brief Wraps the different possible values of a mission parameter
    */
    message Value {
        //! A boolean
        optional bool                     booleanValue             = 1;
        //! An integer
        optional int32                    intValue                 = 2;
        //! A heading
        optional Heading                  heading                  = 3;
        //! @todo What's this ?
        optional int32                    enumeration              = 4;
        //! A date time
        optional DateTime                 dateTime                 = 5;
        //! A point
        optional Point                    point                    = 6;
        //! A polygon
        optional Polygon                  area                     = 7;
        //! A path
        optional Path                     path                     = 8;
        //! A limit
        optional Line                     limit                    = 9;
        //! A phase line list
        optional PhaseLinesOrder          phaseLine                = 10;
        //! An automat identifier
        optional Id                       automat                  = 11;
        //! An agent identifier
        optional Id                       agent                    = 12;
        //! An agent knowledge identifier
        optional Id                       agentKnowledge           = 13;
        //! A crowd knowledge identifier
        optional Id                       crowdKnowledge           = 14;
        //! An object knowledge identifier
        optional Id                       objectKnowledge          = 15;
        //! A urban object knowledge identifier
        optional Id                       urbanKnowledge           = 16;
        //! A planned work
        optional PlannedWork              plannedWork              = 17;
        //! A nature
        optional Nature                   nature                   = 18;
        //! A resource type
        optional Id                       resourceType             = 19;
        //! A maintenance priority list
        optional IdList                   logMaintenancePriorities = 20;
        //! A medical priority list
        optional LogMedicalPriorities     logMedicalPriorities     = 21;
        //! A resource network node element
        optional ResourceNetworkElement   resourceNetworkNode      = 22;
        //! A resource network type
        optional ResourceNetworkType      resourceNetworkType      = 23;

        //! A float
        optional float                    aReal                    = 24;
        //! A path list
        optional PathList                 pathList                 = 25;
        //! A point list
        optional PointList                pointList                = 26;
        //! A polygon list
        optional PolygonList              polygonList              = 27;
        //! A location
        optional Location                 location                 = 28;
        //! A location list
        optional LocationList             locationList             = 29;
        //! An agent identifier list
        optional IdList                   unitList                 = 30;
        //! An automat identifier list
        optional IdList                   automatList              = 31;
        //! A unit knowledge list
        optional IdList                   unitKnowledgeList        = 32;
        //! An object knowledge list
        optional IdList                   objectKnowledgeList      = 33;
        //! A planned work list
        optional PlannedWorkList          plannedWorkList          = 34;
        //! An equipment type
        optional Id                       equipmentType            = 35;
        //! An indirect fire identifier
        optional Id                       indirectFire             = 36;
        //! A string
        optional string                   aCharStr                 = 37;
        //! A mission objective
        optional MissionObjective         missionObjective         = 38;
        //! A mission objective list
        optional MissionObjectiveList     missionObjectiveList     = 39;
        //! An object identifier
        optional Id                       object                   = 40;
        //! A party identifier
        optional Id                       party                    = 41;
        //! A formation identifier
        optional Id                       formation                = 42;
        //! @todo What's this ?
        optional uint32                   identifier               = 43;
        //! A quantity
        optional int32                    quantity                 = 44;
        //! A knowledge group identifier
        optional Id                       knowledgeGroup           = 45;
        //! An extension list
        optional Extension                extensionList            = 46;
        //! A list of values
        repeated Value                    list                     = 47;
        //! An external identifier
        optional int32                    external_identifier      = 48;
        // Magic action only
        //! Parameter specific to push flow operation
        optional PushFlowParameters       push_flow_parameters     = 49;
        //! Parameter specific to pull flow operation
        optional PullFlowParameters       pull_flow_parameters     = 50;
        //! A stage
        optional string                   stage                    = 51;
        //! A crowd identifier
        optional Id                       crowd                    = 52;
        //! A phase line function type
        optional PhaseLineOrder.Function  phase_line_function      = 53;
        //! A pathfind request
        optional Pathfind                 pathfind                 = 54;
    }
    //! Whether the parameter is a null value or not
    optional bool  null_value = 1;
    //! The parameter
    repeated Value value      = 2;
}

/** @struct MissionParameters
    @brief Defines a list of mission parameters
*/
message MissionParameters {
    //! A list of mission parameters
    repeated MissionParameter elem = 1;
}

/** @struct UnitOrder
    @brief Defines a unit order
*/
message UnitOrder {
    //! The tasker
    required Id                tasker         = 1;
    //! The mission type
    required Id                type           = 2;
    //! The mission parameters
    optional MissionParameters parameters     = 3;
    //! The label
    optional string            label          = 4;
    //! The symbol location
    optional Location          symbolLocation = 5;
    //! The start date and time
    optional DateTime          start_time     = 6;
    //! optional name
    optional string            name           = 7;
    //! unique order id
    optional uint32            id             = 8;
    //! The parent automat order id
    optional uint32            parent         = 9;
}

/** @struct AutomatOrder
    @brief Defines an automat order
*/
message AutomatOrder {
    //! The tasker
    required Id                tasker         = 1;
    //! The mission type
    required Id                type           = 2;
    //! The mission parameters
    optional MissionParameters parameters     = 3;
    //! The label
    optional string            label          = 4;
    //! The symbol location
    optional Location          symbolLocation = 5;
    //! The start date and time
    optional DateTime          start_time     = 6;
    //! optional name
    optional string            name           = 7;
    //! unique order id
    optional uint32            id             = 8;
}

/** @struct CrowdOrder
    @brief Defines a crowd order
*/
message CrowdOrder {
    //! The tasker
    required Id                tasker         = 1;
    //! The mission type
    required Id                type           = 2;
    //! The mission parameters
    optional MissionParameters parameters     = 3;
    //! The label
    optional string            label          = 4;
    //! The symbol location
    optional Location          symbolLocation = 5;
    //! The start date and time
    optional DateTime          start_time     = 6;
    //! optional name
    optional string            name           = 7;
    //! unique order id
    optional uint32            id             = 8;
}

/** @struct FragOrder
    @brief Defines a frag order
*/
message FragOrder {
    //! The tasker
    required Tasker            tasker         = 1;
    //! The mission type
    required Id                type           = 2;
    //! The mission parameters
    optional MissionParameters parameters     = 3;
    //! The label
    optional string            label          = 4;
    //! The symbol location
    optional Location          symbolLocation = 5;
    //! The start date and time
    optional DateTime          start_time     = 6;
    //! optional name
    optional string            name           = 7;
    //! unique order id
    optional uint32            id             = 8;
}

/** @struct ClientObjectProperty
    @brief Defines a client object property
*/
message ClientObjectProperty {
    /** @struct Value
        @brief Defines a client object property value
    */
    message Value {
        //! A string
        optional string string_value           = 1;
        //! An integer
        optional int32  integer_value          = 2;
        //! An unsigned integer
        optional uint32 unsigned_integer_value = 3;
        //! A float
        optional float  float_value            = 4;
        //! A boolean
        optional bool   bool_value             = 5;
    }
    //! The property name
    required string name  = 1;
    //! The property value
    required Value  value = 2;
}

/** @struct Diffusion
    @brief Defines the diffusion of a tactical line or a shape
*/
message Diffusion {
    //! The automat identifier
    optional Id automat         = 1;
    //! The formation identifier
    optional Id formation       = 2;
    //! The party identifier
    repeated Id party           = 3;
    //! The knowledge group identifier
    optional Id knowledge_group = 4;
    //! The unit identifier
    optional Id unit            = 5;
}

/** @struct TacticalLine
    @brief Defines a tactical line
*/
message TacticalLine {
    //! The name
    required string    name      = 1;
    //! The geometry
    required Location  geometry  = 2;
    //! The diffusion
    required Diffusion diffusion = 3;
}

/** @enum EnumPenStyle
    @brief Defines the pen style of a shape
*/
enum EnumPenStyle {
    //! Solid
    solid    = 0;
    //! Dashed
    dashed   = 1;
    //! Dash dot
    dash_dot = 2;
}

/** @struct Shape
    @brief Defines a shape
*/
message Shape {
    required string           category  = 1;
    required RgbColor         color     = 2;
    required string           pattern   = 3;
    required CoordLatLongList points    = 4;
    optional Diffusion        diffusion = 5;
    optional EnumPenStyle     pen_style = 6;
    optional string           name      = 7;
    optional string           text      = 8;
    optional string           font      = 9;
}

/** @struct ChatTarget
    @brief Defines a chat target
*/
message ChatTarget {
    //! The profile
    required string profile = 1;
}

/** @struct TextMessage
    @brief Defines a text message
*/
message TextMessage {
    //! The source
    required ChatTarget source  = 1;
    //! The target
    required ChatTarget target  = 2;
    //! The message content
    required string     message = 3;
}

/** @struct UrbanUsage
    @brief Defines a urban usage
*/
message UrbanUsage {
    //! The role
    required string role       = 1;
    //! The percentage
    required uint32 percentage = 2;
}

/** @struct ResourceNetwork
    @brief Defines a resource network
*/
message ResourceNetwork {
    /** @struct Link
        @brief Defines a resource link
    */
    message Link {
        //! The target identifier
        required Id     object   = 1;
        //! The capacity
        required int32  capacity = 2;
        //! The flow identifier
        required uint32 flow     = 3;
    }
    //! The resource network type
    required ResourceNetworkType resource            = 1;
    //! The link
    repeated Link                link                = 2;
    //! Whether the network is enabled or not
    required bool                enabled             = 3;
    //! The maximum stock
    optional uint32              max_stock           = 4;
    //! The current stock
    optional uint32              stock               = 5;
    //! The current production
    optional uint32              production          = 6;
    //! The current consumption
    optional uint32              consumption         = 7;
    //! Whether the resource is critic for the block. If defined as
    //! critical and no resource available, the block is disabled.
    optional bool                critical            = 8;
    //! The initial stock
    optional uint32              initial_stock       = 9;
    //! The maximum production
    optional uint32              max_production      = 10;
    //! The maximum consumption
    optional uint32              max_consumption     = 11;
    //! The current consumption
    optional uint32              current_consumption = 12;
    //! The functional state
    optional float               functional_state    = 13;
}

/** @struct ObjectAttributeResourceNetwork
    @brief Defines an object attribute resource network
*/
message ObjectAttributeResourceNetwork {
    //! The resource network
    repeated ResourceNetwork network = 1;
}

/** @struct ObjectAttributeConstruction
    @brief Defines an object attribute construction
*/
message ObjectAttributeConstruction {
    //! The resource type
    optional Id    resource   = 1;
    //! The dotation
    optional int32 dotation   = 2;
    //! The density
    optional float density    = 3;
    //! The percentage of completion
    optional int32 percentage = 4;
}

/** @struct ObjectAttributeMine
    @brief Defines an object attribute mine
*/
message ObjectAttributeMine {
    //! The resource type
    optional Id    resource   = 1;
    //! The dotation
    optional int32 dotation   = 2;
    //! The density
    optional float density    = 3;
    //! The percentage of completion
    optional int32 percentage = 4;
}

/** @struct ObjectAttributeLodging
    @brief Defines an object attribute lodging
*/
message ObjectAttributeLodging {
    //! The resource type
    optional int32 capacity   = 1;
}

/** @struct ObjectAttributeLogistic
    @brief Defines an object attribute logistic
*/
message ObjectAttributeLogistic {
    //! The logistic superior identifier
    required ParentEntity logistic_superior = 1;
}

/** @struct ObjectAttributeInteractionHeight
    @brief Defines an object attribute interaction height
*/
message ObjectAttributeInteractionHeight {
    //! The height @todo unit ?
    required float height = 1;
}

/** @struct ObjectAttributeObstacle
    @brief Defines an object attribute obstacle
*/
message ObjectAttributeObstacle {
    //! The obstacle type
    required ObstacleType.DemolitionTargetType type            = 1;
    //! Whether the obstacle is activated or not
    optional bool                              activated       = 2;
    //! The activation time @todo unit ?
    optional int32                             activation_time = 3;
    //! The activity time @todo unit ?
    optional int32                             activity_time   = 4;
    //! The creation time
    optional uint32                            creation_time   = 5;
}

/** @struct ObjectAttributeLifeTime
    @brief Defines an object attribute life time
*/
message ObjectAttributeLifeTime {
    //! The life time @todo unit ?
    required int32 value = 1;
}

/** @struct ObjectAttributeBypass
    @brief Defines an object attribute bypass
*/
message ObjectAttributeBypass {
    //! The percentage of bypass
    required int32 percentage = 1;
}

/** @struct ObjectAttributeEffectDelay
    @brief Defines an object attribute effect delay
*/
message ObjectAttributeEffectDelay {
    //! The delay @todo unit ?
    required int32 value = 1;
}

/** @struct ObjectAttributeNBC
    @brief Defines an object attribute NBC
*/
message ObjectAttributeNBC {
    //! The danger level @todo unit ?
    required int32 danger_level = 1;
    //! The NBC agents
    repeated Id    nbc_agents   = 2;
}

/** @struct StockResource
    @brief Defines a stock resource
*/
message StockResource {
    //! The resource type
    required Id    resource = 1;
    //! The current amount
    required int32 current  = 2;
    //! The maximum amount
    optional int32 maximum  = 3;
}

/** @struct ObjectAttributeStock
    @brief Defines an object attribute stock
*/
message ObjectAttributeStock {
    //! The resources
    repeated StockResource resources = 1;
}

/** @struct ObjectAttributeCrossingSite
    @brief Defines an object attribute crossing site
*/
message ObjectAttributeCrossingSite {
    //! The width @todo unit ?
    required int32 width                 = 1;
    //! The depth @todo unit ?
    required int32 depth                 = 2;
    //! The flow rate @todo unit ?
    required int32 flow_rate             = 3;
    //! Whether the banks require fitting or not
    required bool  banks_require_fitting = 4;
}

/** @struct ObjectAttributeSupplyRoute
    @brief Defines an object attribute supply route
*/
message ObjectAttributeSupplyRoute {
    //! @todo What's this ?
    required bool  equipped   = 1;
    //! The maximum weight the route can handle @todo unit ?
    required int32 max_weight = 2;
    //! The width of the route @todo unit ?
    required int32 width      = 3;
    //! The length of the route @todo unit ?
    required int32 length     = 4;
    //! The flow rate for the route @todo unit ?
    required int32 flow_rate  = 5;
}

/** @struct ObjectAttributeFlood
    @brief Defines an object attribute flood
*/
message ObjectAttributeFlood {
    //! The depth in meters
    required int32 depth              = 1;
    //! The flood maximum radius in meters
    required int32 reference_distance = 2;
}

/** @struct LocatedQuantity
    @brief Defines a located quantity
*/
message LocatedQuantity {
    //! The coordinates
    required CoordLatLong coordinate = 1;
    //! The quantity
    required float        quantity   = 2;
}

/** @struct LocatedQuantityList
    @brief Lists several object attribute located quantities
    @todo inline in ObjectAttributeToxicCloud
*/
message LocatedQuantityList {
    //! The quantities
    repeated LocatedQuantity elem = 1;
}

/** @struct ObjectAttributeToxicCloud
    @brief Defines an object attribute toxic cloud
*/
message ObjectAttributeToxicCloud {
    //! The located quantities
    required LocatedQuantityList quantities = 1;
}

/** @struct ObjectAttributePropagation
    @brief Defines an object attribute propagation
*/
message ObjectAttributePropagation {
    //! The located quantities
    required string model = 1;
    optional string date = 2;
}

/** @struct ObjectAttributeFire
    @brief Defines an object attribute fire
*/
message ObjectAttributeFire {
    //! @todo What's this ?
    required string class_name            = 1;
    //! The maximum energy required for combustion @todo unit ?
    required int32  max_combustion_energy = 2;
}

/** @struct ObjectAttributeBurn
    @brief Defines an object attribute burn
*/
message ObjectAttributeBurn {
    //! The current heat @todo unit ?
    required int32 current_heat      = 1;
    //! The current energy required for combustion @todo unit ?
    required int32 combustion_energy = 2;
}

/** @enum EnumBurningCellPhase
    @brief Defines the phases of a burning cell
*/
enum EnumBurningCellPhase {
    //! Pre-ignition
    pre_ignition = 0;
    //! Combustion
    combustion   = 1;
    //! Decline
    decline      = 2;
    //! Extinguished
    extinguished = 3;
}

/** @struct ObjectAttributeBurnSurface
    @brief Defines an object attribute burn surface
*/
message ObjectAttributeBurnSurface {
    /** @struct BurningCell
        @brief Defines a burning cell
    */
    message BurningCell {
        /** @struct PreIgnition
            @brief Defines a pre-ignition
        */
        message PreIgnition {
            //! The ignition energy @todo unit ?
            required int32 ignition_energy    = 1;
            //! The ignition threshold above which the ignition is
            //! complete @todo unit ?
            required int32 ignition_threshold = 2;
        }
        /** @struct Combustion
            @brief Defines an object combustion
        */
        message Combustion {
            //! The current heat @todo unit ?
            required int32 current_heat          = 1;
            //! The combustion energy @todo unit ?
            required int32 combustion_energy     = 2;
            //! The maximum combustion energy @todo unit ?
            required int32 max_combustion_energy = 3;
        }
        /** @struct ObjectAttributeBurn
            @brief Defines an object attribute burn
        */
        message Decline {
            //! The current heat @todo unit ?
            required int32 current_heat = 1;
        }
        //! @todo What's this ? Why is it not using CoordLatLong ?
        required int32                origin_x     = 1;
        //! @todo What's this ? Why is it not using CoordLatLong ?
        required int32                origin_y     = 2;
        //! The current phase
        required EnumBurningCellPhase phase        = 3;
        //! The pre-ignition data
        optional PreIgnition          pre_ignition = 4;
        //! The combustion data
        optional Combustion           combustion   = 5;
        //! The decline data
        optional Decline              decline      = 6;
    }
    //! The size of a cell @todo unit ?
    required int32       cell_size     = 1;
    //! The burning cells
    repeated BurningCell burning_cells = 2;
}

//! DEPRECATED in 5.3
//!
message MedicalTreatmentBedCapacity {
    //! The type identifier, see Data/MedicalTreatment.xml
    required int32 type_id          = 1;
    //! The baseline number of beds available
    optional uint32 baseline_count  = 2;
    //! The number of beds available
    optional uint32 available_count = 3;
    //! The number of beds available in case of emergency
    optional uint32 emergency_count = 4;
}

//! DEPRECATED in 5.3
//!
message ObjectAttributeMedicalTreatment {
    /** @enum EnumMedicalTreatmentStatus
        @brief Defines the different states of a medical treatment
    */
    enum EnumMedicalTreatmentStatus {
        //! Normal
        normal    = 0;
        //! @todo What's this ?
        on_divert = 1;
        //! Closed
        closed    = 2;
    }
    //! @todo What's this ?
    optional string                      external_reference_id = 1;
    //! The bed capacities
    repeated MedicalTreatmentBedCapacity bed_capacities        = 2;
    //! The facility current status
    optional EnumMedicalTreatmentStatus  facility_status       = 3;
    //! The total number of doctors
    optional uint32                      doctors               = 4;
    //! The number of available doctors
    optional uint32                      available_doctors     = 5;
}

/** @struct ObjectAttributeNBCType
    @brief Defines an object attribute NBC type
*/
message ObjectAttributeNBCType {
    //! The agent type
    required Id    agent                = 1;
    //! The concentration of the agent @todo unit ?
    required int32 concentration        = 2;
    //! The life duration of the source @todo unit ? @todo rename to duration
    required int32 source_life_duration = 3;
}

/** @struct ObjectAttributeAltitudeModifier
    @brief Defines an object attribute altitude modifier
*/
message ObjectAttributeAltitudeModifier {
    //! The height in meters
    required int32 height           = 1;
}

/** @struct ObjectAttributeUnderground
    @brief Defines an object attribute underground
*/
message ObjectAttributeUnderground {
    //! The underground network name
    required string network_name = 1;
    //! The activation state
    required bool   available    = 2;
}


/** @struct ObjectAttributeTrafficability
    @brief Defines an object attribute trafficability
*/
message ObjectAttributeTrafficability {
    required float value = 1;
}

/** @struct ObjectAttributes
    @brief Encapsulates an object attribute
*/
message ObjectAttributes {
    //! @copybrief ObjectAttributeConstruction
    optional ObjectAttributeConstruction      construction       = 1;
    //! @copybrief ObjectAttributeObstacle
    optional ObjectAttributeObstacle          obstacle           = 2;
    //! @copybrief ObjectAttributeMine
    optional ObjectAttributeMine              mine               = 3;
    //! @copybrief ObjectAttributeLifeTime
    optional ObjectAttributeLifeTime          life_time          = 4;
    //! @copybrief ObjectAttributeBypass
    optional ObjectAttributeBypass            bypass             = 5;
    //! @copybrief ObjectAttributeLogistic
    optional ObjectAttributeLogistic          logistic           = 6;
    //! @copybrief ObjectAttributeNBC
    optional ObjectAttributeNBC               nbc                = 7;
    //! @copybrief ObjectAttributeCrossingSite
    optional ObjectAttributeCrossingSite      crossing_site      = 8;
    //! @copybrief ObjectAttributeSupplyRoute
    optional ObjectAttributeSupplyRoute       supply_route       = 9;
    //! @copybrief ObjectAttributeToxicCloud
    optional ObjectAttributeToxicCloud        toxic_cloud        = 10;
    //! @copybrief ObjectAttributeFire
    optional ObjectAttributeFire              fire               = 11;
    //! @copybrief ObjectAttributeMedicalTreatment
    optional ObjectAttributeMedicalTreatment  medical_treatment  = 12;
    //! @copybrief ObjectAttributeInteractionHeight
    optional ObjectAttributeInteractionHeight interaction_height = 13;
    //! @copybrief ObjectAttributeStock
    optional ObjectAttributeStock             stock              = 14;
    //! @copybrief ObjectAttributeNBCType
    optional ObjectAttributeNBCType           nbc_agent          = 15;
    //! @copybrief ObjectAttributeEffectDelay
    optional ObjectAttributeEffectDelay       effect_delay       = 16;
    //! @copybrief ObjectAttributeResourceNetwork
    optional ObjectAttributeResourceNetwork   resource_networks  = 17;
    //! @copybrief ObjectAttributeBurn
    optional ObjectAttributeBurn              burn               = 18;
    //! @copybrief ObjectAttributeFlood
    optional ObjectAttributeFlood             flood              = 19;
    //! @copybrief ObjectAttributeBurnSurface
    optional ObjectAttributeBurnSurface       burn_surface       = 20;
    //! @copybrief ObjectAttributeLodging
    optional ObjectAttributeLodging           lodging            = 21;
    //! @copybrief ObjectAttributeAltitudeModifier
    optional ObjectAttributeAltitudeModifier  altitude_modifier  = 22;
    //! @copybrief ObjectAttributeUnderground
    optional ObjectAttributeUnderground       underground        = 23;
    //! @copybrief ObjectAttributeTrafficability
    optional ObjectAttributeTrafficability    trafficability     = 24;
    //! @copybrief ObjectAttributePropagation
    optional ObjectAttributePropagation       propagation        = 25;
}

/** @struct Marker
    @brief Defines a marker
*/
message Marker {
    //! The marker name
    required string name        = 1;
    //! The marker description
    required string description = 2;
    //! The marker parent
    optional Id     parent      = 4;
    //! The marker number
    optional string number      = 5;
}

/** @struct PartyAdhesion
    @brief Defines a party adhesion
*/
message PartyAdhesion {
    //! The party identifier
    required Id    party = 1;
    //! @todo What's this ?
    required float value = 2;
}

/** @struct PartyAdhesion
    @brief Defines an adhesion list
*/
message PartyAdhesions {
    //! The adhesions
    repeated PartyAdhesion adhesion = 1;
}

/** @struct HumanRepartition
    @brief Defines a human repartition
*/
message HumanRepartition {
    //! Male proportion between 0 and 1
    required float     male      = 1;
    //! Female proportion between 0 and 1
    required float     female    = 2;
    //! Children proportion between 0 and 1
    required float     children  = 3;
}

//! Error code returned by the magic actions:
//!  select_diagnosis_team
//!  select_maintenance_transporter
//!  select_new_logistic_state
//!  select_repair_team
enum ManualMaintenanceError {
    consign_already_resolved   = 0;
    diagnosis_team_unavailable = 1;
    repair_team_unavailable    = 2;
    transporter_unavailable    = 3;
}

message MagicAction {
    enum Type {
        //! Update global weather parameters. A ControlGlobalWeather
        //! will be emitted to notify the weather changes.
        //! parameters[0], AReal: temperature.
        //! parameters[1], AReal: wind speed in km/h.
        //! parameters[2], Heading: the direction where the wind flows
        //!   in degrees.
        //! parameters[3], AReal: cloud layer bottom altitude in meters.
        //! parameters[4], AReal: cloud layer top altitude in meters.
        //! parameters[5], AReal: cloud density.
        //! parameters[6], Enumeration: a value within PrecipitationType.
        global_weather                     = 0;
        //! Create or update a local weather. In both cases, a
        //! ControlLocalWeatherCreation message is sent will local weather
        //! attributes.
        //! parameters[0], AReal: temperature.
        //! parameters[1], AReal: wind speed in km/h.
        //! parameters[2], Heading: the direction where the wind flows
        //!   in degrees.
        //! parameters[3], AReal: cloud layer bottom altitude in meters.
        //! parameters[4], AReal: cloud layer top altitude in meters.
        //! parameters[5], AReal: cloud density.
        //! parameters[6], Enumeration: a value within PrecipitationType.
        //! parameters[7], Datetime: start time.
        //! parameters[8], Datetime: end time.
        //! parameters[9], Location: a location with two points defining
        //!   the area top-left and bottom right corners.
        //! parameters[10], Identifier, optional: the identifier of a
        //!   local weather to update. If not passed, a local weather is
        //!   created instead.
        //! result[0], Identifier: on success, created local weather identifier.
        local_weather                      = 1;
        //! Remove a local weather. A ControlLocalWeatherDestruction
        //! message is emitted on success.
        //! parameters[0], Identifier: identifier of the local weather
        //!   to remove.
        local_weather_destruction          = 2;
        //! Change diplomacy between two parties.
        //! Trigger a ChangeDiplomacy on success
        //! parameters[0], Identifier: first party identifier
        //! parameters[1], Identifier: second party identifier
        //! parameters[2], Enumeration: new diplomacy as EnumDiplomacy
        change_diplomacy                   = 3;
        //! Create a knowledge group.
        //! parameters[0], Identifier: parent party or knowledge
        //!   group identifier.
        //! parameters[1], ACharStr: group type identifier as defined in
        //!   the physical database.
        //! result[0], Identifier: created group identifier.
        create_knowledge_group             = 4;
        //! A change resource network properties magic action
        //! parameters[0], Identifier : urban object id
        //! parameters[1], value parameters of lists of resource data(list)
        //!   resource data list : resource (string), consumption(quantity),
        //!     critical(bool), enabled(bool), production(quantity),
        //!     maxstock(quantity), links
        //!   links: list of list with a "identifier,quantity" format
        change_resource_network_properties = 5;
        //! Initiate a fire order on a specific location.
        //! parameters[0], Location or Point: fire location.
        //! parameters[1], ResourceType: resource type.
        //! parameters[2], AReal: real multiplied by an intervention type
        //!  of a resource type to calculate the iterations number.
        create_fire_order_on_location      = 6;
        debug_internal                     = 7;
        //! When a log consign is in state waiting for manual intervention,
        //! update the request to a new state automatically.
        //! parameters[0], Identifier: log request identifier.
        //! On failure, result[0], Identifier : among ManualMaintenanceError
        //!   values.
        select_new_logistic_state          = 8;
        //! When a maintenance log consign is in "select transporter" state,
        //!  "select diagnosis team" state or "select repair team" state in
        //!  manual intervention, update the request to delegate to the
        //!  superior logistic base.
        //! parameters[0], Identifier: log request identifier.
        transfer_to_logistic_superior      = 9;
        //! When a maintenance log consign is in state "waiting for transporter
        //!  selection", update the request to a new state with a manually
        //!  selected transporter.
        //! parameters[0], Identifier: log request identifier.
        //! parameters[1], Identifier: selected transporter type identifier.
        //! parameters[2], AgentId, optional: : diagnosis unit identifier.
        //! On failure, result[0], Identifier : among ManualMaintenanceError
        //!   values.
        select_maintenance_transporter     = 10;
        //! When a maintenance log consign is in state "waiting for diagnosis
        //!  team selection", update the request to a new state with a manually
        //!  selected diagnoser.
        //! parameters[0], Identifier: log request identifier.
        //! parameters[1], Identifier: selected diagnoser type identifier.
        //! On failure, result[0], Identifier : among ManualMaintenanceError
        //!   values.
        select_diagnosis_team              = 11;
        //! When a maintenance log consign is in state "waiting for repair team
        //!  selection", update the request to a new state with a manually
        //!  selected repair team.
        //! parameters[0], Identifier: identifier of log request.
        //! parameters[1], Identifier: selected repair team type identifier.
        //! On failure, result[0], Identifier : among ManualMaintenanceError
        //!   values.
        select_repair_team                 = 12;
        //! Create a pathfind
        //! parameters[0], PathfindRequest: the unit and waypoints.
        //! result[0], Identifier: created pathfind identifier.
        //! The pathfind identifier will be sent along in a ComputePathfindAck.
        pathfind_creation                  = 13;
        //! Destroy a pathfind
        //! parameters[0], Identifier: the pathfind identifier.
        pathfind_destruction               = 14;
    }
    required Type              type       = 1;
    required MissionParameters parameters = 2;
    //! The action name is mostly used as a label by third-party systems
    //! listening and displaying simulation events.
    optional string            name       = 3;
    //! The start date and time
    optional DateTime          start_time = 4;
}

//! Perform magic actions on units, automats or crowds.
message UnitMagicAction {
    enum Type {
        //! Teleport a unit
        //! The tasker must reference the unit to teleport.
        //! parameters[0], Point: destination coordinates.
        move_to                           = 0;
        //! Surrender to an army
        //! The tasker can be an automat or an unit.
        //!    In case of an unit, its whole automat surrenders.
        //! parameters[0], Party: the party to which the tasker will surrender.
        //!    Must not be the owner party.
        surrender_to                      = 1;
        //! Cancel the surrender to an army
        //! The tasker can be an automat or an unit.
        //!    In case of an unit, its whole automat cancels its surrender.
        //! No parameters
        cancel_surrender                  = 2;
        //! A recover transporters magic action
        recover_transporters              = 3;
        //! Destroy a random equipment
        //! The tasker must be a unit identifier.
        destroy_component                 = 4;
        //! Restore target unit equipments, troops and resource to their
        //! capacity
        //! The tasker must be a unit identifier.
        recover_all                       = 5;
        //! Restore target unit troops to their capacity
        //! The tasker must be a unit identifier.
        recover_troops                    = 6;
        //! Restore target unit equipments to their capacity
        //! The tasker must be a unit identifier.
        recover_equipments                = 7;
        //! Recover target unit resources to their capacity
        //! The tasker must be a unit identifier.
        recover_resources                 = 8;
        //! Destroy the target unit
        //! The tasker must be a unit identifier.
        destroy_all                       = 9;
        //! Change the human factors
        //! The tasker must be a unit identifier.
        //! parameters[0], EnumUnitTiredness: rested,
        //!     tired, exhausted
        //! parameters[1], EnumUnitMorale: fanatical,
        //!     high, standard, low
        //! parameters[2], EnumUnitExperience: veteran,
        //!     expert, novice
        //! parameters[3], EnumUnitStress: calm,
        //!     worried, stressed
        change_human_factors              = 10;
        //! A partial recovery magic action
        //! The tasker must be a valid unit identifier.
        //! parameters[0], Resupply equipments
        //!     List of Identifier: equipment, Quantity: quantity
        //! parameters[1], Resupply humands
        //!     List of Identifier: human, Quantity: availability
        //! parameters[2], Resupply resources
        //!     List of Identifier: DotationType, Quantity: % of capacity
        //! parameters[3], Resupply ammunitions
        //!     List of Identifier: Ammunition, Quantity: % of capacity
        //! parameters[4], Resupply supplies
        //!     List of Identifier: DotationType, Quantity: quantity
        //! Each parameter must be either a null_value to be omitted or
        //! a parameter value list.
        //! value { list { identifier: 1 }
        //!         list { quantity: 10  } }
        partial_recovery                  = 11;
        //! A unit creation magic action
        //! The tasker must be set to the parent automat.
        //! parameters[0], Identifier: the unit type.
        //! parameters[1], Point: the unit location in WGS84.
        //! parameters[2], ACharStr, optional: the unit name.
        //! parameters[3], BooleanValue, optional: if true, force the unit to
        //!    become the new PC for this automat.
        unit_creation                     = 12;
        //! Launch a strike on a unit knowledge
        //! The tasker (reporter) must be a valid unit identifier.
        //! parameters[0], Identifier: the target's knowledge identifier in
        //!  reporters's knowledges.
        //! parameters[1], ResourceType: the ammunition type identifier
        //!  to launch, must be compatible with indirect fire.
        //!  If the ammunition is guided, the target must be illuminated.
        //! parameters[2], AReal: real multiplied with the resource
        //!  intervention type to get the number of iterations.
        create_fire_order                 = 13;
        //! A crowd total destruction magic action
        //! Kill all humans in a crowd
        //! The tasker must be a crowd identifier
        //! No parameters
        crowd_total_destruction           = 14;
        //! Change crowd composition(healthy/wounded/contaminated/dead)
        //! The tasker must be a crowd identifier
        //! parameters[0], Quantity: healthy number.
        //! parameters[1], Quantity: wounded number.
        //! parameters[2], Quantity: contaminated number.
        //! parameters[3], Quantity: dead number.
        //! all parameters must be positive integers
        //!     and non-zero.
        crowd_change_health_state         = 15;
        //! Change crowd attitude.
        //! The tasker must be a crowd identifier.
        //! parameters[0], EnumCrowdAttitude: peaceful,
        //!     agitated, excited, agressive.
        crowd_change_attitude             = 16;
        //! Change crowd affinities.
        //! The tasker must be a crowd identifier.
        //! parameters[0], List: a parameter value list:
        //! value { list { identifier: 1 }
        //!         list { aReal: -0.55  } }
        //! Identifier, a party identifier
        //! AReal, a real between -1 and 1.
        //!    -1 is enemy affinity and.
        //!     1 is friend affinity.
        crowd_change_affinities           = 17;
        //! Change percentage of armed individuals.
        //! parameters[0], Quantity: a number between
        //!    0 and 100.
        crowd_change_armed_individuals    = 18;
        //! Change an automat knowledge group
        //! The tasker must be an automat identifier.
        //! parameters[0], KnowledgeGroup: the new parent knowledge group.
        //! The automat must belong to the same party than its knowledge
        //! group.
        //! An AutomatChangeKnowledgeGroup message is triggered on
        //! successful update.
        change_knowledge_group            = 19;
        //! A change logistic links magic action
        //! parameters with each parameter has value(0) for
        //! 'superior' that is an identifier, an automat or a formation
        change_logistic_links             = 20;
        //! A unit change superior magic action
        //! The tasker must be an unit identifier.
        //! parameters[0], Automat: the new automat
        unit_change_superior              = 21;
        //! Change superior of an automat
        //! The tasker must be an automat identifier
        //! parameters[0], Formation: the new formation
        //! This message triggers a AutomatChangeSuperior on success.
        change_automat_superior           = 22;
        //! Change superior of a formation
        //! The tasker must be a formation identifier
        //! parameters[0], Formation or Party: the new formation or party
        //! This message triggers a FormationChangeSuperior on success.
        change_formation_superior         = 23;
        //! DEPRECATED
        //!
        //! This message is ignored by the simulation.
        knowledge_group_update            = 24;
        //! A log supply push flow magic action
        //! tasker must match a logistics automat/formation/unit
        //! parameters[0]: value matches 'push_flow_parameters' param
        //! (see PushFlowParameters message definition)
        log_supply_push_flow              = 25;
        //! A log supply change quotas magic action
        //! parameters[0], value(0) : supplier id/automat/formation
        //! The tasker must be an automat or a formation identifier
        //! for the supplied unit
        //! parameters[1] : values of list
        //! for each list :
        //!     list(0) is the dotation id
        //!     list(1) is the dotation quantity
        log_supply_change_quotas          = 26;
        //! An automate creation magic action
        //! The tasker must be set to the parent formation or automat.
        //! parameters[0], Identifier: the automat type.
        //! parameters[1], Identifier: the automat knowledge group.
        //! result[0], AutomatId: created automat identifier.
        automat_creation                  = 27;
        //! Create a formation
        //! The tasker must be the parent party or parent formation.
        //! parameters[0], AReal: formation level, among EnumNatureLevel
        //!   values.
        //! parameters[1], String: name.
        //! parameters[2], String: logistic level, an empty string or
        //!   "logistic-base".
        //! result[0], FormationId: created formation identifier.
        formation_creation                = 28;
        //! A crowd creation magic action
        //! The tasker must be set to the parent party or formation.
        //! parameters[0], ACharStr: crowd type name.
        //! parameters[1], Point: crowd location.
        //! parameters[2], Quantity: healty persons count.
        //! parameters[3], Quantity: wounded persons count.
        //! parameters[4], Quantity: dead persons count.
        //! parameters[5], ACharStr: crowd name.
        //! result[0], CrowdId: created crowd identifier.
        crowd_creation                    = 29;
        //! A log supply pull flow magic action
        //! The tasker must be an automat
        //! parameters[0]: value matches 'pull_flow_parameters' param
        //! (see PullFlowParameters message definition)
        log_supply_pull_flow              = 30;
        //! A create wound magic action
        //! @deprecated
        create_wound                      = 31;
        //! A change of health state on inhabitant magic action
        //! The tasker must be a population identifier.
        //! parameters[0], Quantity: healty persons count.
        //! parameters[1], Quantity: wounded persons count.
        //! parameters[2], Quantity: dead persons count.
        inhabitant_change_health_state    = 32;
        //! Change population affinities.
        //! The tasker must be a population identifier.
        //! parameters[0], List: a parameter value list:
        //! value { list { identifier: 1 }
        //!         list { aReal: -0.55  } }
        //! Identifier, a party identifier
        //! AReal, a real between -1 and 1.
        //!    -1 is enemy affinity and.
        //!     1 is friend affinity.
        inhabitant_change_affinities      = 33;
        //! @deprecated
        inhabitant_change_alerted_state   = 34;
        //! @deprecated
        inhabitant_change_confined_state  = 35;
        //! A change of affinities on unit magic action
        unit_change_affinities            = 36;
        //! An extension change magic action
        change_extension                  = 37;
        //! Change critical intelligence magic action
        //! The tasker must be an unit identifier.
        //! parameters[0], ACharStr: critical intelligence text.
        change_critical_intelligence      = 38;
        //! Exchange equipments between units.
        //! The tasker is set to the lending unit.
        //! parameters[0], Identifier: borrowing unit identifier.
        //! parameters[1], multiple List: the list of equipments to
        //!   transfer. Each record is a two elements List made of the
        //!   equipment Identifier and the number of items to transfer as
        //!   a Quantity.
        //! This action will trigger a UnitAttributes update on success.
        //! The lender and borrower respective lent_equipments and
        //! borrowed_equipments will be adjusted.
        //! Trying to transfer an equipment not available in the source
        //! unit is an error. But transfering more equipments than
        //! available will succeed, the number of transfered equipments
        //! will capped on the number of available ones.
        //! Deleting a unit cancels its lendings and borrowings.
        transfer_equipment                = 39;
        //! @deprecated
        change_equipment_human_size       = 40;
        //! Breaks down unit equipments
        //! The tasker is set to target unit.
        //! parameters[0], multiple List: a sequence of breakdown records as
        //!   List elements. Each of them contains:
        //!     parameters[0]: Identifier: the equipment type identifier
        //!     parameters[1]: Quantity: number of breakdowns, each
        //!       breakdown is mapped to a single equipment, extra
        //!       breakdowns are ignored.
        //!     parameters[2]: Optional, Identifier: the breakdown type
        //!       if not set, a random breakdown is applied.
        //! The breakdowns are described in a following UnitAttributes
        //! equipment_dotations fields.
        create_breakdowns                 = 41;
        //! @deprecated
        //!
        //! You can achieve the same effect with change_human_state
        //! magic action, except for the random part.
        //!
        //! Applies wounds on unit crew members.
        //! The tasker is set to target unit.
        //! parameters[0], multiple List: a sequence of wound records as
        //!   List elements, Each of them contains:
        //!     parameters[0]: Quantity: the number of affected humans.
        //!     parameters[1]: Optional, Enumeration: the human wound type
        //!       if not set, apply a random wound type.
        //! The wounds are described in a following UnitAttributes
        //! human_dotations field. The wounds are applied from lowest to
        //! highest ranked crew members.
        create_wounds                     = 42;
        //! Reloads the brain of target entity
        //! The tasker is set to a unit, automat or crowd
        //! parameters[0], Optional, String: Name of the brain model to reload
        //!     if not set, reload the current brain model
        reload_brain                      = 43;
        //! No parameters, magically finish the current logistic actions
        //! The tasker is set to a unit or automat.
        //!     valid taskers are units or automats currently handling logistic
        //!     requests.
        //!     @see LogMaintenanceHandlingUpdate::provider
        //!     @see LogMedicalHandlingUpdate::provider
        //!     @see LogSupplyHandlingCreation::supplier
        //!     @see LogFuneralHandlingUpdate::handling_unit
        log_finish_handlings              = 44;
        //! Changes the state of unit equipments.
        //! The tasker is set to target units.
        //! parameters[0], multiple List: contains equipments records as
        //!   List. Each element contains:
        //!     parameters[0], Identifier: the equipment type
        //!     parameters[1], Quantity: the number of available equipments
        //!     parameters[2], Quantity: the number of unavailable equipments
        //!     parameters[3], Quantity: the number of equipments which
        //!       can be repaired if evacuated.
        //!     parameters[4], Quantity: the number of equipments which
        //!       can be fixed on site.
        //!     parameters[5], Quantity: the number of equipments in
        //!       maintainance.
        //!     parameters[6], Quantity: the number of captured
        //!       equipments.
        //!     parameters[7], List: list of breakdowns identifiers.
        //!       There must be as many entries as there are equipments fixable
        //!       if evacuated.
        //! The new equipments are described in a following
        //! UnitAttributes message equipment_dotation field.
        change_equipment_state            = 45;
        //! Changes the state of unit humans.
        //! The tasker is set to target unit.
        //! parameters[0], multiple List: contains humans records as
        //!   List. Each element contains:
        //!     parameters[0], Quantity: the number of affected humans.
        //!     parameters[1], Enumeration: humans rank, among EnumHumanRank
        //!     parameters[2], Enumeration: humans state, among EnumHumanState
        //!     parameters[3], List: a list containing a single
        //!       Enumeration from EnumInjuriesSeriousness, defining the
        //!       injury if any. Only used if the state is set to "injured".
        //!     parameters[4], BooleanValue: true if humans are mentally
        //!       wounded.
        //!     parameters[5], BooleanValue: true if humans are
        //!       contaminated.
        //! The new human states are described in a following
        //! UnitAttributes message human_dotation field.
        //!
        //! Note the simulation assumes the first parameter describes
        //! the state of all humans matched by ranks in target unit.
        //! For historical reasons, the action accepts partial states
        //! and resolves them by:
        //! 1. Removing from the request all human states already
        //!    in target unit.
        //! 2. Applying the remaining changes, ignoring extra values.
        //!
        //! Assuming a unit with 2 healthy troopers, the following calls
        //! to change_human_state:
        //!   1. Mark 1 trooper injured
        //!   2. Mark 1 trooper healthy
        //! result in a unit with 1 healthy and 1 injured trooper. The
        //! second request will be matched by the existing healthy
        //! trooper and be turned into a no-operation.
        //!
        //! Future versions are likely to fail upon partial state
        //! changes.
        change_human_state                = 46;
        //! Changes unit resources.
        //! The tasker is set to target unit.
        //! parameters[0], multiple List: a sequence of resource records
        //!   as List, each of them containing:
        //!     parameters[0], Identifier: the resource category type,
        //!       defined in the physical database.
        //!     parameters[1], Quantity: resources count
        //!     parameters[2], AReal: the logictic threshold (between 0 and 100)
        //! The new resources are described in a following
        //! UnitAttributes message resource_dotations field.
        change_dotation                   = 47;
        //! Create a direct fire order
        //! The tasker is set to the firing unit.
        //! parameters[0], AgentId: target unit identifier
        create_direct_fire_order          = 48;
        //! Loads a unit into another unit
        //! The tasker is set to the transporter unit
        //! parameters[0], AgentId: Transported unit id
        load_unit                         = 49;
        //! Unloads a unit from another unit
        //! The tasker is set to the transporter unit
        //! parameters[0], AgentId: Transported unit id
        unload_unit                       = 50;
        //! Remove a unit from game
        //! The tasker must be set to selected unit.
        //! result[0], UnitId: deleted unit identifier.
        delete_unit                       = 51;
        //! Restore target unit equipments, troops and resources to their
        //! capacity, without those currently handled by logistics
        //! The tasker must be a unit identifier.
        recover_all_except_log            = 52;
        //! Restore target unit troops to their capacity, without those
        //! currently handled by logistics
        //! The tasker must be a unit identifier.
        recover_troops_except_log         = 53;
        //! Restore target unit equipments to their capacity, without those
        //! currently handled by logistics
        //! The tasker must be a unit identifier.
        recover_equipments_except_log     = 54;
        //! Restore target unit resources to their capacity, without those
        //! currently handled by logistics
        //! The tasker must be a unit identifier.
        recover_resources_except_log      = 55;
        //! Make a unit, automat or crowd emit decisional debug traces. The
        //! traces currently contain activation graphs in Graphviz format, and
        //! are sent in Trace messages.
        //! The tasker is selected unit, automat or crowd identifier.
        //! parameters[0], BooleanValue: if true, enable brain debug,
        //!   otherwise disable it
        change_brain_debug                = 56;
        //! Change the posture of a unit.
        //! The tasker is set to the target unit.
        //! parameters[0], Enumeration: the new posture, among
        //!   UnitAttributes::Posture
        change_posture                    = 57;
        //! Load a script in specified brain then invoke a function
        //! without argument, returning a string. This action is used
        //! for debugging/testing purpose. The caller sets up a testing
        //! environment with a script, including a root test function,
        //! which is called afterwards. Test results are returned by the
        //! test function.
        //! The tasker is set to target unit.
        //! parameters[0], ACharStr: name of the function to execute,
        //!   which must return a string.
        //! parameters[1], ACharStr: source code defining at least the
        //!   function to execute, referenced above.
        //! result[0], ACharStr: function result.
        exec_script                       = 58;
        //! Switch the manual/automatic mode for maintenance.
        //! The tasker is set to target logistic base:
        //!    an automat or a formation identifier.
        //! parameters[0], BooleanValue: if true, maintenance is in manual mode,
        //!   otherwise maintenance is in automated mode.
        log_maintenance_set_manual        = 59;
        //! Create an automat and its units (defined in the physical base)
        //! The tasker must be set to the parent formation or automat.
        //! parameters[0], Identifier: the automat type.
        //! parameters[1], Point: the automat location in WGS84.
        //! parameters[2], Identifier: the automat knowledge group.
        //! result[0], AutomatId: created automat identifier.
        //! result[1+], AgentId: created units identifier
        automat_and_units_creation        = 60;
        //! Switch the manual/automatic mode for supply.
        //! The tasker is set to target logistic base:
        //!    an automat or a formation identifier.
        //! parameters[0], BooleanValue: if true, supply is in manual mode,
        //!   otherwise supply is in automated mode.
        log_supply_set_manual             = 61;
        //! Create a basic load supply request
        //! The tasker is set to target logistic base or automat.
        //! parameters[0], Identifier: the supplier identifier.
        //!   The supplier should be a logistic base.
        //! parameters[1], Identifier: the recipient identifier.
        //!   The recipient should be an automat.
        //! parameters[2], Type of supplies
        //!   List of Identifier: DotationType, Quantity: quantity
        //! Each parameter must be either a null_value to be omitted or
        //!   a parameter value list.
        //! value { list { identifier: 1 }
        //!         list { quantity: 10  } }
        //! result[0+], Identifier: created requests identifier
        create_basic_load_supply_request  = 62;
        //! Create stock supply request
        //! The tasker is set to target logistic base or automat.
        //! parameters[0], Identifier: the supplier identifier.
        //! The supplier should be a logistic base.
        //! parameters[1], Identifier: the recipient identifier.
        //! The recipient should be a logistic base.
        //! parameters[2], Type of supplies
        //! List of Identifier: DotationType, Quantity: quantity
        //! Each parameter must be either a null_value to be omitted or
        //!   a parameter value list.
        //! value { list { identifier: 1 }
        //!         list { quantity: 10  } }
        //! result[0+], Identifier: created requests identifier
        create_stock_supply_request       = 63;
    }
    //! The tasker @todo Explain what is a "tasker"
    required Tasker            tasker     = 1;
    //! The magic action typ
    required Type              type       = 2;
    //! The magic action parameters depending on the magic action type
    required MissionParameters parameters = 3;
    //! optional name
    optional string            name       = 4;
    //! The start date and time
    optional DateTime          start_time = 5;
}

/** @struct ObjectMagicAction
    @brief An object magic action request
    @see ObjectMagicActionAck
*/
message ObjectMagicAction {
    /** @enum Type
        @brief The type of magic action.

        Specific parameters are expected for each type.

        @todo Explain what parameters are expected for each type
    */
    enum Type {
        /** @brief A create object magic action.
        */
        create  = 0;
        /** @brief An update object magic action.
        */
        update  = 1;
        /** @brief A destroy object magic action.
        */
        destroy = 2;
    }
    /** @enum Attribute
        @brief The type of object.

        The first parameter among the parameters actually is of type
        MissionParameter::Value::identifier and must be reinterpreted as
        a value of this enumeration.

        @todo to be refactored
    */
    enum Attribute {
        construction       = 0;
        obstacle           = 1;
        mine               = 2;
        time_limit         = 3;
        bypass             = 4;
        logistic           = 5;
        nbc                = 6;
        crossing_site      = 7;
        supply_route       = 8;
        toxic_cloud        = 9;
        fire               = 10;
        medical_treatment  = 11;
        interaction_height = 12;
        stock              = 13;
        nbc_agent          = 14;
        effect_delay       = 15;
        flood              = 16;
        structural_state   = 18;
        infrastructure     = 19;
        usages             = 20;
        lodging            = 21;
        trafficability     = 22;
        underground        = 23;
        confined           = 24;
        alerted            = 25;
        evacuated          = 26;
        resource_network   = 27;
        altitude_modifier  = 28;
        disaster           = 29;
        density            = 30;
    }
    //! The object identifier
    required Id                object     = 1;
    //! The type of magic action
    required Type              type       = 2;
    //! The parameters of the magic action : the first parameter must
    //! be the object type name and the second parameter must be the
    //! object location
    required MissionParameters parameters = 3;
    //! optional name
    optional string            name       = 4;
    //! The start date and time
    optional DateTime          start_time = 5;
}

message KnowledgeMagicAction {
    //! A KnowledgeGroupMagicActionAck message is returned in response.
    enum Type {
        //! Enables or disables the knowledge group
        //! parameters[0], BooleanValue: whether to enable or disable the group.
        enable              = 0;
        //! Changes the knowledge group parent to a party
        //! parameters[0], PartyId: new parent identifier.
        //!   Must be the same as the knowledge group top party.
        //!   Used when the group was under another group, to put it at top
        //!   level.
        update_party        = 1;
        //! Changes the knowledge group parent to another knowledge group.
        //! parameters[0], PartyId: the parent party.
        //!   Must be the same as the knowledge group top party.
        //! parameters[1], KnowledgeGroupId: the new parent knowledge group.
        //!   Must be from the same party.
        //!   Used when the group was at top level, to put it under another
        //!   group.
        update_party_parent = 2;
        //! Changes the knowledge group type
        //! parameters[0], ACharStr: The new knowledge group type according to
        //!   those defined in the physical database.
        update_type         = 3;
        //! Adds a new unit/object/population knowledge in the knowledge group.
        //! parameters[0], Identifier: The id of the real entity from which a
        //!   knowledge should be created.
        //! Can be the id of an agent, an object, a population or a urban block.
        //! parameters[1], Enumeration: The perception level according enum
        //!   UnitIdentification::Level as defined in simulation_client.proto
        //!   This parameter can also be an Quantity (deprecated)
        add_knowledge       = 4;
    }
    required Id                knowledge_group = 1;
    required Type              type            = 2;
    required MissionParameters parameters      = 3;
    optional string            name            = 4;
    //! The start date and time
    optional DateTime          start_time      = 5;
}

//! Engage or disengage an automat.
//! When engaged, missions cannot be sent directly to its units, they
//! have to be given to the automat which dispatches them afterwards.
//! The operation is acknowledged with a SetAutomatModeAck.
message SetAutomatMode {
    required Id              automate = 1;
    required EnumAutomatMode mode     = 2;
    optional string          name     = 3;
    //! The start date and time
    optional DateTime        start_time = 4;
}

enum EnumHumanRank {
    //! Commissioned Officer
    officer     = 0;
    //! Non-commissioned Officer
    sub_officer = 1;
    //! Other Enlisted Rank
    trooper     = 2;
}

/** @struct LogFuneralHandlingCreation
    @brief Notifies of the creation of a funeral handling
*/
message LogFuneralHandlingCreation {
    //! The funeral request identifier
    required Id               request          = 1;
    //! The requesting unit identifier
    required Id               unit             = 2;
    //! The creation tick number
    required int32            tick             = 3;
    //! The rank of the human associated to the request
    required EnumHumanRank    rank             = 4;
}

/** @struct LogFuneralHandlingUpdate
    @brief Notifies of the update of a funeral handling
*/
message LogFuneralHandlingUpdate {
    /** @enum EnumLogFuneralHandlingStatus
        @brief Defines the funeral handling states
    */
    enum EnumLogFuneralHandlingStatus {
        //! Waiting to be handled by logistic superior
        waiting_for_handling     = 0;
        //! Transporting the unpackaged body from the requesting unit
        //! to the first logistic base
        transporting_unpackaged  = 1;
        //! Waiting for packaging resource to be available
        waiting_for_packaging    = 2;
        //! Packaging the body
        packaging                = 3;
        //! Waiting for a transporter (supply logistic) to arrive to
        //! the current logistic base
        waiting_for_transporter  = 4;
        //! Transporting the packaged body between logistic bases
        transporting_packaged    = 5;
        //! Finished
        finished                 = 6;
    }
    //! The request identifier
    required Id                            request                = 1;
    //! The current logistic base handling the request
    optional ParentEntity                  handling_unit          = 2;
    //! The current unit transporting the body
    optional Id                            convoying_unit         = 3;
    //! The current status
    optional EnumLogFuneralHandlingStatus  state                  = 4;
    //! When set, the tick when the current state will be finished
    //! If unset, the end state time is unknown
    optional int32                         current_state_end_tick = 5;
    //! The packaging type
    optional Id                            packaging_resource     = 6;
}

/** @struct LogFuneralHandlingDestruction
    @brief Notifies of the destruction of a funeral handling
*/
message LogFuneralHandlingDestruction {
    //! The request identifier
    required Id               request = 1;
}

/** @struct LogMaintenanceHandlingCreation
    @brief Notifies of the creation of a maintenance handling
*/
message LogMaintenanceHandlingCreation {
    //! The request identifier
    required Id                   request    = 1;
    //! The unit identifier
    required Id                   unit       = 2;
    //! The creation tick number
    required int32                tick       = 3;
    //! The equipment type under maintenance
    required Id                   equipement = 4;
    //! The breakdown type
    required Id                   breakdown  = 5;
}

/** @struct LogMaintenanceHandlingUpdate
    @brief Notifies of the update of a maintenance handling
*/
message LogMaintenanceHandlingUpdate {
    /** @enum EnumLogMaintenanceHandlingStatus
        @brief Defines the maintenance handling states
    */
    enum EnumLogMaintenanceHandlingStatus {
        //! Moving to supply
        moving_to_supply                     = 0;
        //! Waiting for transporter
        waiting_for_transporter              = 1;
        //! Transporter moving to supply
        transporter_moving_to_supply         = 2;
        //! Transporter loading
        transporter_loading                  = 3;
        //! Transporter moving back
        transporter_moving_back              = 4;
        //! Transporter unloading
        transporter_unloading                = 5;
        //! Being diagnosed
        diagnosing                           = 6;
        //! Searching maintenance upper levels
        searching_upper_levels               = 7;
        //! Waiting for parts
        waiting_for_parts                    = 8;
        //! Waiting for a repairer
        waiting_for_repairer                 = 9;
        //! Being repaired
        repairing                            = 10;
        //! Moving back
        moving_back                          = 11;
        //! Finished
        finished                             = 12;
        //! Waiting for transporter selection
        waiting_for_transporter_selection    = 13;
        // Waiting for diagnosis team selection
        waiting_for_diagnosis_team_selection = 14;
        //! Waiting for repair team selection
        waiting_for_repair_team_selection    = 15;
    }
    //! The request identifier
    required Id                               request                = 1;
    //! The unit identifier
    required Id                               unit                   = 2;
    //! The maintenance provider identifier
    required Id                               provider               = 3;
    //! The maintenance state
    optional EnumLogMaintenanceHandlingStatus state                  = 4;
    //! When set, the tick when the current state will be finished
    //! If unset, the end state time is unknown
    optional int32                            current_state_end_tick = 5;
    //! Whether a diagnostic has been established or not
    optional bool                             diagnosed              = 6;
}

/** @struct LogMaintenanceHandlingDestruction
    @brief Notifies of the destruction of a maintenance handling
*/
message LogMaintenanceHandlingDestruction {
    //! The request identifier
    required Id                   request = 1;
    //! The unit identifier
    required Id                   unit    = 2;
}

/** @struct LogMedicalHandlingCreation
    @brief Notifies of the creation of a medical handling
*/
message LogMedicalHandlingCreation {
    //! The medical request identifier
    required Id               request          = 1;
    //! The unit identifier
    required Id               unit             = 2;
    //! The creation tick number
    required int32            tick             = 3;
    //! The rank
    required EnumHumanRank    rank             = 4;
    //! The type wound
    required EnumHumanWound   wound            = 5;
    //! Whether the unit is mentally wounded or not
    optional bool             mental_wound     = 6;
    //! Whether the unit is NBC contaminated or not
    optional bool             nbc_contaminated = 7;
}

/** @struct LogMedicalHandlingUpdate
    @brief Notifies of the update of a medical handling
*/
message LogMedicalHandlingUpdate {
    /** @enum EnumLogMedicalHandlingStatus
        @brief Defines the medical handling states
    */
    enum EnumLogMedicalHandlingStatus {
        //! Waiting for evacuation
        waiting_for_evacuation                    = 0;
        //! Evacuation ambulance moving in
        evacuation_ambulance_moving_in            = 1;
        //! Evacuation ambulance loading
        evacuation_ambulance_loading              = 2;
        //! Waiting for evacuation loading completion
        waiting_for_evacuation_loading_completion = 3;
        //! Evacuation ambulance moving out
        evacuation_ambulance_moving_out           = 4;
        //! Evacuation ambulance unloading
        evacuation_ambulance_unloading            = 5;
        //! Waiting for diagnostic
        waiting_for_diagnostic                    = 6;
        //! Being diagnosed
        diagnosing                                = 7;
        //! Looking for triage
        looking_for_triage                        = 8;
        //! Waiting for triage
        waiting_for_triage                        = 9;
        //! Being triaged
        triaging                                  = 10;
        //! Looking for medical attention
        looking_for_medical_attention             = 11;
        //! Waiting for medical attention
        waiting_for_medical_attention             = 12;
        //! Receiving medical attention
        receiving_medical_attention               = 13;
        //! Resting
        resting                                   = 14;
        //! Waiting for collection
        waiting_for_collection                    = 15;
        //! Collection ambulance loading
        collection_ambulance_loading              = 16;
        //! Waiting for collection loading completion
        waiting_for_collection_loading_completion = 17;
        //! Collection ambulance moving in
        collection_ambulance_moving_in            = 18;
        //! Collection ambulance unloading
        collection_ambulance_unloading            = 19;
        //! Finished
        finished                                  = 20;
    }
    //! The request identifier
    required Id                           request          = 1;
    //! The unit identifier
    required Id                           unit             = 2;
    //! The provider identifier
    optional Id                           provider         = 3;
    //! The type of wound
    optional EnumHumanWound               wound            = 4;
    //! Whether the unit is mentally wounded or not
    optional bool                         mental_wound     = 5;
    //! Whether the unit is NBC contaminated or not
    optional bool                         nbc_contaminated = 6;
    //! The current state
    optional EnumLogMedicalHandlingStatus state            = 7;
    //! When set, the tick when the current state will be finished
    //! If unset, the end state time is unknown
    optional int32                        current_state_end_tick = 8;
    //! Whether a diagnostic has been established or not
    optional bool                         diagnosed        = 9;
}

/** @struct LogMedicalHandlingDestruction
    @brief Notifies of the destruction of a medical handling
*/
message LogMedicalHandlingDestruction {
    //! The request identifier
    required Id               request = 1;
    //! The unit identifier
    required Id               unit    = 2;
}

//! DEPRECATED in 5.4, replaced by LogSupplyRequest
message SupplyResourceRequest {
    //! The type of the resource
    required Id           resource  = 1;
    //! The amount requested
    required int32        requested = 2;
    //! The amount granted
    required int32        granted   = 3;
    //! The amount being convoyed
    required int32        convoyed  = 4;
}

//! DEPRECATED in 5.4, replaced by LogSupplyRequest
message SupplyRecipientResourcesRequest {
    //! The recipient of the supply flow
    required Id                    recipient = 1;
    //! The resources requested/granted/convoyed
    repeated SupplyResourceRequest resources = 2;
}

message SupplyRecipientResourceRequests {
    repeated SupplyRecipientResourcesRequest requests = 1;
}

/** @struct LogSupplyHandlingCreation
    @brief Notifies of the creation of a supply handling
*/
message LogSupplyHandlingCreation {
    //! The request identifier
    required Id              request               = 1;
    //! The creation tick number
    required int32           tick                  = 2;
    //! The supplier
    required ParentEntity    supplier              = 3;
    //! The logistic base which provides the transporters for the convoy
    required ParentEntity    transporters_provider = 4;
}

/** @struct LogSupplyHandlingUpdate
    @brief Notifies of the update of a log supply handling
*/
message LogSupplyHandlingUpdate {
    /** @enum EnumLogSupplyHandlingStatus
        @brief List of states a supply request can go through
    */
    enum EnumLogSupplyHandlingStatus {
        //! Convoy is waiting for transporters
        convoy_waiting_for_transporters     = 0;
        //! Convoy setup
        convoy_setup                        = 1;
        //! Convoy is moving to loading point
        convoy_moving_to_loading_point      = 2;
        //! Convoy is loading
        convoy_loading                      = 3;
        //! Convoy is moving to unloading point
        convoy_moving_to_unloading_point    = 4;
        //! Convoy is unloading
        convoy_unloading                    = 5;
        //! Convoy is returning to forming point
        convoy_moving_back_to_loading_point = 6;
        //! Convoying operation is finished
        convoy_finished                     = 7;
    }
    //! The request identifier
    optional Id                              request                = 1;
    //! The convoyer
    optional Id                              convoyer               = 2;
    //! The current state of the handling
    optional EnumLogSupplyHandlingStatus     state                  = 3;
    //! When set, the tick when the current state will be finished
    //! If unset, the end state time is unknown
    optional int32                           current_state_end_tick = 4;
    //! DEPRECATED in 5.4 and replaced by "supply_requests", still filled.
    //! Requests now have exactly one resource.
    optional SupplyRecipientResourceRequests requests               = 5;
    //! The list of LogSupplyRequest identifiers
    repeated Id                              supply_requests        = 6;
}

/** @struct LogSupplyHandlingDestruction
    @brief Notifies of the destruction of a log supply handling
*/
message LogSupplyHandlingDestruction {
    //! The request identifier
    required Id              request  = 1;
}

//! Request sent by a unit to have its basic load or its stocks resupplied,
//! for instance when a type of supplies is below the low logistic threshold.
message LogSupplyRequestCreation {
    required Id request   = 1;
    required Id requester = 2;
    required Id resource  = 3;
}

//! A request is updated when the state of the request changes.
message LogSupplyRequestUpdate {
    enum EnumLogSupplyRequestStatus {
        request_outstanding = 0;
        request_granted     = 1;
        request_conveyed    = 2;
        request_delivered   = 3;
        request_rejected    = 4;
    }
    required Id                         request   = 1;
    required Id                         requester = 2;
    required Id                         resource  = 3;
    required EnumLogSupplyRequestStatus state     = 4;
    required Id                         recipient = 5;
    required Id                         supplier  = 6;
    required int32                      requested = 7;
    required int32                      granted   = 8;
    required int32                      convoyed  = 9;
    required int32                      delivered = 10;
}

//! A request is destroyed when the resource is delivered.
message LogSupplyRequestDestruction {
    required Id request = 1;
}

//! LogHistoryEntry is a snapshot of a logistic request.
//!
//! Exactly one of its funeral/maintenance/medical/supply field is set
//! with one of the possible combination of messages:
//! - creation: for just created requests
//! - creation + update: an ongoing request
//! - creation + update + destruction: request before destruction
message LogHistoryEntry {
    message Funeral {
        optional LogFuneralHandlingCreation        creation = 1;
        optional LogFuneralHandlingUpdate          update = 2;
        optional LogFuneralHandlingDestruction     destruction = 3;
    }

    message Maintenance {
        optional LogMaintenanceHandlingCreation    creation = 1;
        optional LogMaintenanceHandlingUpdate      update = 2;
        optional LogMaintenanceHandlingDestruction destruction = 3;
    }

    message Medical {
        optional LogMedicalHandlingCreation        creation = 1;
        optional LogMedicalHandlingUpdate          update = 2;
        optional LogMedicalHandlingDestruction     destruction = 3;
    }

    message Supply {
        optional LogSupplyHandlingCreation         creation = 1;
        optional LogSupplyHandlingUpdate           update = 2;
        optional LogSupplyHandlingDestruction      destruction = 3;
    }

    required int32       tick        = 1;
    optional Funeral     funeral     = 2;
    optional Maintenance maintenance = 3;
    optional Medical     medical     = 4;
    optional Supply      supply      = 5;
}

//! Asks the history of selected logistic requests.
//!
//! Errors are reported in SimToClient.error_msg fields.
message LogisticHistoryRequest {
    repeated Id requests = 1;
}

//! Returns a list of logistic requests entries matching those specified
//! in the LogisticHistoryRequest. Entries are sorted per request, from
//! oldest to newest.
message LogisticHistoryAck {
    repeated LogHistoryEntry entries = 1;
}

//! Returns the most recent state of any logistic request referencing
//! of supplied entities (unit, automat, formation...) at some point
//! in its history.
//!
//! If current_tick is supplied, returns them as if it were the current
//! tick. current_tick must be between 1 and the current simulated tick
//! for usual runs, or in the session tick range for replay runs.
//!
//! Errors are reported in SimToClient.error_msg fields.
message ListLogisticRequests {
    repeated Id     entities     = 1;
    optional uint32 max_count    = 2;
    optional int32  current_tick = 3;
}

//! Returns the most recent LogHistoryEntry of each request touching the
//! entities listed in ListLogisticRequests, from newest to oldest.
message ListLogisticRequestsAck {
    repeated LogHistoryEntry entries = 1;
}

//! Defines a pathfind request.
message PathfindRequest {
    //! The unit identifier.
    required Id           unit                   = 1;
    //! The waypoints.
    repeated CoordLatLong positions              = 2;
    //! The equipment types composing the unit.
    repeated Id           equipment_types        = 3;
    //! Indicate whether or not the request
    //! should ignore the dynamic objects.
    optional bool         ignore_dynamic_objects = 4;
}

/** @struct Pathfind
    @brief Notifies of the creation of a pathfind
*/
message Pathfind {
    //! The pathfind identifier
    required uint32          id          = 1;
    //! The pathfind request
    required PathfindRequest request     = 2;
    //! Computed path
    optional PathResult      result      = 3;
}

//! Creates a new path.
//! (see PathfindRequest)
message ComputePathfind {
    required PathfindRequest request = 1;
}

//! Returns a calculated path, if operation succeeded.
message ComputePathfindAck {
    enum ErrorCode {
        //! Operation succeeded
        no_error                = 0;
        //! Operation failed because the provided action parameters
        //! were invalid
        error_invalid_parameter = 1;
        //! Operation failed because the path could not be calculated
        error_path_invalid      = 2;
    }
    //! Reason for the failure of the magic action execution operation
    //! @see ErrorCode
    required ErrorCode  error_code  = 1;
    //! More detailed account of the returned error
    optional string     error_msg   = 2;
    //! The associated unit
    optional Id         unit        = 3;
    //! Returns computed path
    optional PathResult path        = 4;
}

/** @struct PathfindDestruction
    @brief Notifies of the destruction of a pathfind
*/
message PathfindDestruction {
    //! The pathfind identifier
    required uint32     id          = 1;
}

/** @struct Timeskip
    @brief Notifies of the creation of a timeskip
*/
message Timeskip {
    optional uint32 tick = 1;
    optional string time = 2;
}
