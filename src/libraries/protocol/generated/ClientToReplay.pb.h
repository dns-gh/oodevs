// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_ClientToReplay_2eproto__INCLUDED
#define PROTOBUF_ClientToReplay_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Common.pb.h"

namespace MsgsClientToReplay {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ClientToReplay_2eproto();
void protobuf_AssignDesc_ClientToReplay_2eproto();
void protobuf_ShutdownFile_ClientToReplay_2eproto();

class MsgControlSkipToTick;
class MsgClientToReplay;
class MsgClientToReplay_Content;

// ===================================================================

class MsgControlSkipToTick : public ::google::protobuf::Message {
 public:
  MsgControlSkipToTick();
  virtual ~MsgControlSkipToTick();
  
  MsgControlSkipToTick(const MsgControlSkipToTick& from);
  
  inline MsgControlSkipToTick& operator=(const MsgControlSkipToTick& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlSkipToTick& default_instance();
  void Swap(MsgControlSkipToTick* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlSkipToTick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlSkipToTick& from);
  void MergeFrom(const MsgControlSkipToTick& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 tick = 1;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 1;
  inline ::google::protobuf::int32 tick() const;
  inline void set_tick(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 tick_;
  friend void  protobuf_AddDesc_ClientToReplay_2eproto();
  friend void protobuf_AssignDesc_ClientToReplay_2eproto();
  friend void protobuf_ShutdownFile_ClientToReplay_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlSkipToTick* default_instance_;
};
// -------------------------------------------------------------------

class MsgClientToReplay_Content : public ::google::protobuf::Message {
 public:
  MsgClientToReplay_Content();
  virtual ~MsgClientToReplay_Content();
  
  MsgClientToReplay_Content(const MsgClientToReplay_Content& from);
  
  inline MsgClientToReplay_Content& operator=(const MsgClientToReplay_Content& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgClientToReplay_Content& default_instance();
  void Swap(MsgClientToReplay_Content* other);
  
  // implements Message ----------------------------------------------
  
  MsgClientToReplay_Content* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgClientToReplay_Content& from);
  void MergeFrom(const MsgClientToReplay_Content& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsClientToReplay.MsgControlSkipToTick control_skip_to_tick = 1;
  inline bool has_control_skip_to_tick() const;
  inline void clear_control_skip_to_tick();
  static const int kControlSkipToTickFieldNumber = 1;
  inline const ::MsgsClientToReplay::MsgControlSkipToTick& control_skip_to_tick() const;
  inline ::MsgsClientToReplay::MsgControlSkipToTick* mutable_control_skip_to_tick();
  
  // optional .Common.MsgControlChangeTimeFactor control_change_time_factor = 2;
  inline bool has_control_change_time_factor() const;
  inline void clear_control_change_time_factor();
  static const int kControlChangeTimeFactorFieldNumber = 2;
  inline const ::Common::MsgControlChangeTimeFactor& control_change_time_factor() const;
  inline ::Common::MsgControlChangeTimeFactor* mutable_control_change_time_factor();
  
  // optional .Common.MsgControlStop control_stop = 3;
  inline bool has_control_stop() const;
  inline void clear_control_stop();
  static const int kControlStopFieldNumber = 3;
  inline const ::Common::MsgControlStop& control_stop() const;
  inline ::Common::MsgControlStop* mutable_control_stop();
  
  // optional .Common.MsgControlPause control_pause = 4;
  inline bool has_control_pause() const;
  inline void clear_control_pause();
  static const int kControlPauseFieldNumber = 4;
  inline const ::Common::MsgControlPause& control_pause() const;
  inline ::Common::MsgControlPause* mutable_control_pause();
  
  // optional .Common.MsgControlResume control_resume = 5;
  inline bool has_control_resume() const;
  inline void clear_control_resume();
  static const int kControlResumeFieldNumber = 5;
  inline const ::Common::MsgControlResume& control_resume() const;
  inline ::Common::MsgControlResume* mutable_control_resume();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsClientToReplay::MsgControlSkipToTick* control_skip_to_tick_;
  ::Common::MsgControlChangeTimeFactor* control_change_time_factor_;
  ::Common::MsgControlStop* control_stop_;
  ::Common::MsgControlPause* control_pause_;
  ::Common::MsgControlResume* control_resume_;
  friend void  protobuf_AddDesc_ClientToReplay_2eproto();
  friend void protobuf_AssignDesc_ClientToReplay_2eproto();
  friend void protobuf_ShutdownFile_ClientToReplay_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgClientToReplay_Content* default_instance_;
};
// -------------------------------------------------------------------

class MsgClientToReplay : public ::google::protobuf::Message {
 public:
  MsgClientToReplay();
  virtual ~MsgClientToReplay();
  
  MsgClientToReplay(const MsgClientToReplay& from);
  
  inline MsgClientToReplay& operator=(const MsgClientToReplay& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgClientToReplay& default_instance();
  void Swap(MsgClientToReplay* other);
  
  // implements Message ----------------------------------------------
  
  MsgClientToReplay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgClientToReplay& from);
  void MergeFrom(const MsgClientToReplay& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgClientToReplay_Content Content;
  
  // accessors -------------------------------------------------------
  
  // optional int32 context = 1 [default = 0];
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 1;
  inline ::google::protobuf::int32 context() const;
  inline void set_context(::google::protobuf::int32 value);
  
  // required .MsgsClientToReplay.MsgClientToReplay.Content message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::MsgsClientToReplay::MsgClientToReplay_Content& message() const;
  inline ::MsgsClientToReplay::MsgClientToReplay_Content* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 context_;
  ::MsgsClientToReplay::MsgClientToReplay_Content* message_;
  friend void  protobuf_AddDesc_ClientToReplay_2eproto();
  friend void protobuf_AssignDesc_ClientToReplay_2eproto();
  friend void protobuf_ShutdownFile_ClientToReplay_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgClientToReplay* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// MsgControlSkipToTick

// required int32 tick = 1;
inline bool MsgControlSkipToTick::has_tick() const {
  return _has_bit(0);
}
inline void MsgControlSkipToTick::clear_tick() {
  tick_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlSkipToTick::tick() const {
  return tick_;
}
inline void MsgControlSkipToTick::set_tick(::google::protobuf::int32 value) {
  _set_bit(0);
  tick_ = value;
}

// -------------------------------------------------------------------

// MsgClientToReplay_Content

// optional .MsgsClientToReplay.MsgControlSkipToTick control_skip_to_tick = 1;
inline bool MsgClientToReplay_Content::has_control_skip_to_tick() const {
  return _has_bit(0);
}
inline void MsgClientToReplay_Content::clear_control_skip_to_tick() {
  if (control_skip_to_tick_ != NULL) control_skip_to_tick_->::MsgsClientToReplay::MsgControlSkipToTick::Clear();
  _clear_bit(0);
}
inline const ::MsgsClientToReplay::MsgControlSkipToTick& MsgClientToReplay_Content::control_skip_to_tick() const {
  return control_skip_to_tick_ != NULL ? *control_skip_to_tick_ : *default_instance_->control_skip_to_tick_;
}
inline ::MsgsClientToReplay::MsgControlSkipToTick* MsgClientToReplay_Content::mutable_control_skip_to_tick() {
  _set_bit(0);
  if (control_skip_to_tick_ == NULL) control_skip_to_tick_ = new ::MsgsClientToReplay::MsgControlSkipToTick;
  return control_skip_to_tick_;
}

// optional .Common.MsgControlChangeTimeFactor control_change_time_factor = 2;
inline bool MsgClientToReplay_Content::has_control_change_time_factor() const {
  return _has_bit(1);
}
inline void MsgClientToReplay_Content::clear_control_change_time_factor() {
  if (control_change_time_factor_ != NULL) control_change_time_factor_->::Common::MsgControlChangeTimeFactor::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgControlChangeTimeFactor& MsgClientToReplay_Content::control_change_time_factor() const {
  return control_change_time_factor_ != NULL ? *control_change_time_factor_ : *default_instance_->control_change_time_factor_;
}
inline ::Common::MsgControlChangeTimeFactor* MsgClientToReplay_Content::mutable_control_change_time_factor() {
  _set_bit(1);
  if (control_change_time_factor_ == NULL) control_change_time_factor_ = new ::Common::MsgControlChangeTimeFactor;
  return control_change_time_factor_;
}

// optional .Common.MsgControlStop control_stop = 3;
inline bool MsgClientToReplay_Content::has_control_stop() const {
  return _has_bit(2);
}
inline void MsgClientToReplay_Content::clear_control_stop() {
  if (control_stop_ != NULL) control_stop_->::Common::MsgControlStop::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgControlStop& MsgClientToReplay_Content::control_stop() const {
  return control_stop_ != NULL ? *control_stop_ : *default_instance_->control_stop_;
}
inline ::Common::MsgControlStop* MsgClientToReplay_Content::mutable_control_stop() {
  _set_bit(2);
  if (control_stop_ == NULL) control_stop_ = new ::Common::MsgControlStop;
  return control_stop_;
}

// optional .Common.MsgControlPause control_pause = 4;
inline bool MsgClientToReplay_Content::has_control_pause() const {
  return _has_bit(3);
}
inline void MsgClientToReplay_Content::clear_control_pause() {
  if (control_pause_ != NULL) control_pause_->::Common::MsgControlPause::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgControlPause& MsgClientToReplay_Content::control_pause() const {
  return control_pause_ != NULL ? *control_pause_ : *default_instance_->control_pause_;
}
inline ::Common::MsgControlPause* MsgClientToReplay_Content::mutable_control_pause() {
  _set_bit(3);
  if (control_pause_ == NULL) control_pause_ = new ::Common::MsgControlPause;
  return control_pause_;
}

// optional .Common.MsgControlResume control_resume = 5;
inline bool MsgClientToReplay_Content::has_control_resume() const {
  return _has_bit(4);
}
inline void MsgClientToReplay_Content::clear_control_resume() {
  if (control_resume_ != NULL) control_resume_->::Common::MsgControlResume::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgControlResume& MsgClientToReplay_Content::control_resume() const {
  return control_resume_ != NULL ? *control_resume_ : *default_instance_->control_resume_;
}
inline ::Common::MsgControlResume* MsgClientToReplay_Content::mutable_control_resume() {
  _set_bit(4);
  if (control_resume_ == NULL) control_resume_ = new ::Common::MsgControlResume;
  return control_resume_;
}

// -------------------------------------------------------------------

// MsgClientToReplay

// optional int32 context = 1 [default = 0];
inline bool MsgClientToReplay::has_context() const {
  return _has_bit(0);
}
inline void MsgClientToReplay::clear_context() {
  context_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgClientToReplay::context() const {
  return context_;
}
inline void MsgClientToReplay::set_context(::google::protobuf::int32 value) {
  _set_bit(0);
  context_ = value;
}

// required .MsgsClientToReplay.MsgClientToReplay.Content message = 2;
inline bool MsgClientToReplay::has_message() const {
  return _has_bit(1);
}
inline void MsgClientToReplay::clear_message() {
  if (message_ != NULL) message_->::MsgsClientToReplay::MsgClientToReplay_Content::Clear();
  _clear_bit(1);
}
inline const ::MsgsClientToReplay::MsgClientToReplay_Content& MsgClientToReplay::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::MsgsClientToReplay::MsgClientToReplay_Content* MsgClientToReplay::mutable_message() {
  _set_bit(1);
  if (message_ == NULL) message_ = new ::MsgsClientToReplay::MsgClientToReplay_Content;
  return message_;
}


}  // namespace MsgsClientToReplay

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_ClientToReplay_2eproto__INCLUDED
