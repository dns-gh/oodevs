// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_PluginToClient_2eproto__INCLUDED
#define PROTOBUF_PluginToClient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "MessengerToClient.pb.h"

namespace MsgsPluginToClient {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PluginToClient_2eproto();
void protobuf_AssignDesc_PluginToClient_2eproto();
void protobuf_ShutdownFile_PluginToClient_2eproto();

class MsgPluginTextMessage;
class MsgPluginToClient;
class MsgPluginToClient_Content;

// ===================================================================

class MsgPluginTextMessage : public ::google::protobuf::Message {
 public:
  MsgPluginTextMessage();
  virtual ~MsgPluginTextMessage();
  
  MsgPluginTextMessage(const MsgPluginTextMessage& from);
  
  inline MsgPluginTextMessage& operator=(const MsgPluginTextMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPluginTextMessage& default_instance();
  void Swap(MsgPluginTextMessage* other);
  
  // implements Message ----------------------------------------------
  
  MsgPluginTextMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPluginTextMessage& from);
  void MergeFrom(const MsgPluginTextMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string destinataire = 1;
  inline bool has_destinataire() const;
  inline void clear_destinataire();
  static const int kDestinataireFieldNumber = 1;
  inline const ::std::string& destinataire() const;
  inline void set_destinataire(const ::std::string& value);
  inline void set_destinataire(const char* value);
  inline void set_destinataire(const char* value, size_t size);
  inline ::std::string* mutable_destinataire();
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* destinataire_;
  static const ::std::string _default_destinataire_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_PluginToClient_2eproto();
  friend void protobuf_AssignDesc_PluginToClient_2eproto();
  friend void protobuf_ShutdownFile_PluginToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPluginTextMessage* default_instance_;
};
// -------------------------------------------------------------------

class MsgPluginToClient_Content : public ::google::protobuf::Message {
 public:
  MsgPluginToClient_Content();
  virtual ~MsgPluginToClient_Content();
  
  MsgPluginToClient_Content(const MsgPluginToClient_Content& from);
  
  inline MsgPluginToClient_Content& operator=(const MsgPluginToClient_Content& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPluginToClient_Content& default_instance();
  void Swap(MsgPluginToClient_Content* other);
  
  // implements Message ----------------------------------------------
  
  MsgPluginToClient_Content* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPluginToClient_Content& from);
  void MergeFrom(const MsgPluginToClient_Content& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsPluginToClient.MsgPluginTextMessage plugin_text_message = 1;
  inline bool has_plugin_text_message() const;
  inline void clear_plugin_text_message();
  static const int kPluginTextMessageFieldNumber = 1;
  inline const ::MsgsPluginToClient::MsgPluginTextMessage& plugin_text_message() const;
  inline ::MsgsPluginToClient::MsgPluginTextMessage* mutable_plugin_text_message();
  
  // optional .MsgsMessengerToClient.MsgIntelligenceCreation plugin_intelligence_creation = 2;
  inline bool has_plugin_intelligence_creation() const;
  inline void clear_plugin_intelligence_creation();
  static const int kPluginIntelligenceCreationFieldNumber = 2;
  inline const ::MsgsMessengerToClient::MsgIntelligenceCreation& plugin_intelligence_creation() const;
  inline ::MsgsMessengerToClient::MsgIntelligenceCreation* mutable_plugin_intelligence_creation();
  
  // optional .MsgsMessengerToClient.MsgIntelligenceUpdate plugin_intelligence_update = 3;
  inline bool has_plugin_intelligence_update() const;
  inline void clear_plugin_intelligence_update();
  static const int kPluginIntelligenceUpdateFieldNumber = 3;
  inline const ::MsgsMessengerToClient::MsgIntelligenceUpdate& plugin_intelligence_update() const;
  inline ::MsgsMessengerToClient::MsgIntelligenceUpdate* mutable_plugin_intelligence_update();
  
  // optional .MsgsMessengerToClient.MsgIntelligenceDestruction plugin_intelligence_destruction = 4;
  inline bool has_plugin_intelligence_destruction() const;
  inline void clear_plugin_intelligence_destruction();
  static const int kPluginIntelligenceDestructionFieldNumber = 4;
  inline const ::MsgsMessengerToClient::MsgIntelligenceDestruction& plugin_intelligence_destruction() const;
  inline ::MsgsMessengerToClient::MsgIntelligenceDestruction* mutable_plugin_intelligence_destruction();
  
  // optional .MsgsMessengerToClient.MsgLimitCreation plugin_limit_creation = 5;
  inline bool has_plugin_limit_creation() const;
  inline void clear_plugin_limit_creation();
  static const int kPluginLimitCreationFieldNumber = 5;
  inline const ::MsgsMessengerToClient::MsgLimitCreation& plugin_limit_creation() const;
  inline ::MsgsMessengerToClient::MsgLimitCreation* mutable_plugin_limit_creation();
  
  // optional .MsgsMessengerToClient.MsgLimitUpdate plugin_limit_update = 6;
  inline bool has_plugin_limit_update() const;
  inline void clear_plugin_limit_update();
  static const int kPluginLimitUpdateFieldNumber = 6;
  inline const ::MsgsMessengerToClient::MsgLimitUpdate& plugin_limit_update() const;
  inline ::MsgsMessengerToClient::MsgLimitUpdate* mutable_plugin_limit_update();
  
  // optional .MsgsMessengerToClient.MsgLimitDestruction plugin_limit_destruction = 7;
  inline bool has_plugin_limit_destruction() const;
  inline void clear_plugin_limit_destruction();
  static const int kPluginLimitDestructionFieldNumber = 7;
  inline const ::MsgsMessengerToClient::MsgLimitDestruction& plugin_limit_destruction() const;
  inline ::MsgsMessengerToClient::MsgLimitDestruction* mutable_plugin_limit_destruction();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsPluginToClient::MsgPluginTextMessage* plugin_text_message_;
  ::MsgsMessengerToClient::MsgIntelligenceCreation* plugin_intelligence_creation_;
  ::MsgsMessengerToClient::MsgIntelligenceUpdate* plugin_intelligence_update_;
  ::MsgsMessengerToClient::MsgIntelligenceDestruction* plugin_intelligence_destruction_;
  ::MsgsMessengerToClient::MsgLimitCreation* plugin_limit_creation_;
  ::MsgsMessengerToClient::MsgLimitUpdate* plugin_limit_update_;
  ::MsgsMessengerToClient::MsgLimitDestruction* plugin_limit_destruction_;
  friend void  protobuf_AddDesc_PluginToClient_2eproto();
  friend void protobuf_AssignDesc_PluginToClient_2eproto();
  friend void protobuf_ShutdownFile_PluginToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPluginToClient_Content* default_instance_;
};
// -------------------------------------------------------------------

class MsgPluginToClient : public ::google::protobuf::Message {
 public:
  MsgPluginToClient();
  virtual ~MsgPluginToClient();
  
  MsgPluginToClient(const MsgPluginToClient& from);
  
  inline MsgPluginToClient& operator=(const MsgPluginToClient& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPluginToClient& default_instance();
  void Swap(MsgPluginToClient* other);
  
  // implements Message ----------------------------------------------
  
  MsgPluginToClient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPluginToClient& from);
  void MergeFrom(const MsgPluginToClient& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgPluginToClient_Content Content;
  
  // accessors -------------------------------------------------------
  
  // optional int32 context = 1 [default = 0];
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 1;
  inline ::google::protobuf::int32 context() const;
  inline void set_context(::google::protobuf::int32 value);
  
  // required .MsgsPluginToClient.MsgPluginToClient.Content message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::MsgsPluginToClient::MsgPluginToClient_Content& message() const;
  inline ::MsgsPluginToClient::MsgPluginToClient_Content* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 context_;
  ::MsgsPluginToClient::MsgPluginToClient_Content* message_;
  friend void  protobuf_AddDesc_PluginToClient_2eproto();
  friend void protobuf_AssignDesc_PluginToClient_2eproto();
  friend void protobuf_ShutdownFile_PluginToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPluginToClient* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// MsgPluginTextMessage

// required string destinataire = 1;
inline bool MsgPluginTextMessage::has_destinataire() const {
  return _has_bit(0);
}
inline void MsgPluginTextMessage::clear_destinataire() {
  if (destinataire_ != &_default_destinataire_) {
    destinataire_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MsgPluginTextMessage::destinataire() const {
  return *destinataire_;
}
inline void MsgPluginTextMessage::set_destinataire(const ::std::string& value) {
  _set_bit(0);
  if (destinataire_ == &_default_destinataire_) {
    destinataire_ = new ::std::string;
  }
  destinataire_->assign(value);
}
inline void MsgPluginTextMessage::set_destinataire(const char* value) {
  _set_bit(0);
  if (destinataire_ == &_default_destinataire_) {
    destinataire_ = new ::std::string;
  }
  destinataire_->assign(value);
}
inline void MsgPluginTextMessage::set_destinataire(const char* value, size_t size) {
  _set_bit(0);
  if (destinataire_ == &_default_destinataire_) {
    destinataire_ = new ::std::string;
  }
  destinataire_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPluginTextMessage::mutable_destinataire() {
  _set_bit(0);
  if (destinataire_ == &_default_destinataire_) {
    destinataire_ = new ::std::string;
  }
  return destinataire_;
}

// required string message = 2;
inline bool MsgPluginTextMessage::has_message() const {
  return _has_bit(1);
}
inline void MsgPluginTextMessage::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgPluginTextMessage::message() const {
  return *message_;
}
inline void MsgPluginTextMessage::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void MsgPluginTextMessage::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void MsgPluginTextMessage::set_message(const char* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPluginTextMessage::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// MsgPluginToClient_Content

// optional .MsgsPluginToClient.MsgPluginTextMessage plugin_text_message = 1;
inline bool MsgPluginToClient_Content::has_plugin_text_message() const {
  return _has_bit(0);
}
inline void MsgPluginToClient_Content::clear_plugin_text_message() {
  if (plugin_text_message_ != NULL) plugin_text_message_->::MsgsPluginToClient::MsgPluginTextMessage::Clear();
  _clear_bit(0);
}
inline const ::MsgsPluginToClient::MsgPluginTextMessage& MsgPluginToClient_Content::plugin_text_message() const {
  return plugin_text_message_ != NULL ? *plugin_text_message_ : *default_instance_->plugin_text_message_;
}
inline ::MsgsPluginToClient::MsgPluginTextMessage* MsgPluginToClient_Content::mutable_plugin_text_message() {
  _set_bit(0);
  if (plugin_text_message_ == NULL) plugin_text_message_ = new ::MsgsPluginToClient::MsgPluginTextMessage;
  return plugin_text_message_;
}

// optional .MsgsMessengerToClient.MsgIntelligenceCreation plugin_intelligence_creation = 2;
inline bool MsgPluginToClient_Content::has_plugin_intelligence_creation() const {
  return _has_bit(1);
}
inline void MsgPluginToClient_Content::clear_plugin_intelligence_creation() {
  if (plugin_intelligence_creation_ != NULL) plugin_intelligence_creation_->::MsgsMessengerToClient::MsgIntelligenceCreation::Clear();
  _clear_bit(1);
}
inline const ::MsgsMessengerToClient::MsgIntelligenceCreation& MsgPluginToClient_Content::plugin_intelligence_creation() const {
  return plugin_intelligence_creation_ != NULL ? *plugin_intelligence_creation_ : *default_instance_->plugin_intelligence_creation_;
}
inline ::MsgsMessengerToClient::MsgIntelligenceCreation* MsgPluginToClient_Content::mutable_plugin_intelligence_creation() {
  _set_bit(1);
  if (plugin_intelligence_creation_ == NULL) plugin_intelligence_creation_ = new ::MsgsMessengerToClient::MsgIntelligenceCreation;
  return plugin_intelligence_creation_;
}

// optional .MsgsMessengerToClient.MsgIntelligenceUpdate plugin_intelligence_update = 3;
inline bool MsgPluginToClient_Content::has_plugin_intelligence_update() const {
  return _has_bit(2);
}
inline void MsgPluginToClient_Content::clear_plugin_intelligence_update() {
  if (plugin_intelligence_update_ != NULL) plugin_intelligence_update_->::MsgsMessengerToClient::MsgIntelligenceUpdate::Clear();
  _clear_bit(2);
}
inline const ::MsgsMessengerToClient::MsgIntelligenceUpdate& MsgPluginToClient_Content::plugin_intelligence_update() const {
  return plugin_intelligence_update_ != NULL ? *plugin_intelligence_update_ : *default_instance_->plugin_intelligence_update_;
}
inline ::MsgsMessengerToClient::MsgIntelligenceUpdate* MsgPluginToClient_Content::mutable_plugin_intelligence_update() {
  _set_bit(2);
  if (plugin_intelligence_update_ == NULL) plugin_intelligence_update_ = new ::MsgsMessengerToClient::MsgIntelligenceUpdate;
  return plugin_intelligence_update_;
}

// optional .MsgsMessengerToClient.MsgIntelligenceDestruction plugin_intelligence_destruction = 4;
inline bool MsgPluginToClient_Content::has_plugin_intelligence_destruction() const {
  return _has_bit(3);
}
inline void MsgPluginToClient_Content::clear_plugin_intelligence_destruction() {
  if (plugin_intelligence_destruction_ != NULL) plugin_intelligence_destruction_->::MsgsMessengerToClient::MsgIntelligenceDestruction::Clear();
  _clear_bit(3);
}
inline const ::MsgsMessengerToClient::MsgIntelligenceDestruction& MsgPluginToClient_Content::plugin_intelligence_destruction() const {
  return plugin_intelligence_destruction_ != NULL ? *plugin_intelligence_destruction_ : *default_instance_->plugin_intelligence_destruction_;
}
inline ::MsgsMessengerToClient::MsgIntelligenceDestruction* MsgPluginToClient_Content::mutable_plugin_intelligence_destruction() {
  _set_bit(3);
  if (plugin_intelligence_destruction_ == NULL) plugin_intelligence_destruction_ = new ::MsgsMessengerToClient::MsgIntelligenceDestruction;
  return plugin_intelligence_destruction_;
}

// optional .MsgsMessengerToClient.MsgLimitCreation plugin_limit_creation = 5;
inline bool MsgPluginToClient_Content::has_plugin_limit_creation() const {
  return _has_bit(4);
}
inline void MsgPluginToClient_Content::clear_plugin_limit_creation() {
  if (plugin_limit_creation_ != NULL) plugin_limit_creation_->::MsgsMessengerToClient::MsgLimitCreation::Clear();
  _clear_bit(4);
}
inline const ::MsgsMessengerToClient::MsgLimitCreation& MsgPluginToClient_Content::plugin_limit_creation() const {
  return plugin_limit_creation_ != NULL ? *plugin_limit_creation_ : *default_instance_->plugin_limit_creation_;
}
inline ::MsgsMessengerToClient::MsgLimitCreation* MsgPluginToClient_Content::mutable_plugin_limit_creation() {
  _set_bit(4);
  if (plugin_limit_creation_ == NULL) plugin_limit_creation_ = new ::MsgsMessengerToClient::MsgLimitCreation;
  return plugin_limit_creation_;
}

// optional .MsgsMessengerToClient.MsgLimitUpdate plugin_limit_update = 6;
inline bool MsgPluginToClient_Content::has_plugin_limit_update() const {
  return _has_bit(5);
}
inline void MsgPluginToClient_Content::clear_plugin_limit_update() {
  if (plugin_limit_update_ != NULL) plugin_limit_update_->::MsgsMessengerToClient::MsgLimitUpdate::Clear();
  _clear_bit(5);
}
inline const ::MsgsMessengerToClient::MsgLimitUpdate& MsgPluginToClient_Content::plugin_limit_update() const {
  return plugin_limit_update_ != NULL ? *plugin_limit_update_ : *default_instance_->plugin_limit_update_;
}
inline ::MsgsMessengerToClient::MsgLimitUpdate* MsgPluginToClient_Content::mutable_plugin_limit_update() {
  _set_bit(5);
  if (plugin_limit_update_ == NULL) plugin_limit_update_ = new ::MsgsMessengerToClient::MsgLimitUpdate;
  return plugin_limit_update_;
}

// optional .MsgsMessengerToClient.MsgLimitDestruction plugin_limit_destruction = 7;
inline bool MsgPluginToClient_Content::has_plugin_limit_destruction() const {
  return _has_bit(6);
}
inline void MsgPluginToClient_Content::clear_plugin_limit_destruction() {
  if (plugin_limit_destruction_ != NULL) plugin_limit_destruction_->::MsgsMessengerToClient::MsgLimitDestruction::Clear();
  _clear_bit(6);
}
inline const ::MsgsMessengerToClient::MsgLimitDestruction& MsgPluginToClient_Content::plugin_limit_destruction() const {
  return plugin_limit_destruction_ != NULL ? *plugin_limit_destruction_ : *default_instance_->plugin_limit_destruction_;
}
inline ::MsgsMessengerToClient::MsgLimitDestruction* MsgPluginToClient_Content::mutable_plugin_limit_destruction() {
  _set_bit(6);
  if (plugin_limit_destruction_ == NULL) plugin_limit_destruction_ = new ::MsgsMessengerToClient::MsgLimitDestruction;
  return plugin_limit_destruction_;
}

// -------------------------------------------------------------------

// MsgPluginToClient

// optional int32 context = 1 [default = 0];
inline bool MsgPluginToClient::has_context() const {
  return _has_bit(0);
}
inline void MsgPluginToClient::clear_context() {
  context_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgPluginToClient::context() const {
  return context_;
}
inline void MsgPluginToClient::set_context(::google::protobuf::int32 value) {
  _set_bit(0);
  context_ = value;
}

// required .MsgsPluginToClient.MsgPluginToClient.Content message = 2;
inline bool MsgPluginToClient::has_message() const {
  return _has_bit(1);
}
inline void MsgPluginToClient::clear_message() {
  if (message_ != NULL) message_->::MsgsPluginToClient::MsgPluginToClient_Content::Clear();
  _clear_bit(1);
}
inline const ::MsgsPluginToClient::MsgPluginToClient_Content& MsgPluginToClient::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::MsgsPluginToClient::MsgPluginToClient_Content* MsgPluginToClient::mutable_message() {
  _set_bit(1);
  if (message_ == NULL) message_ = new ::MsgsPluginToClient::MsgPluginToClient_Content;
  return message_;
}


}  // namespace MsgsPluginToClient

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_PluginToClient_2eproto__INCLUDED
