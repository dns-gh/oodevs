// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_SimToClient_2eproto__INCLUDED
#define PROTOBUF_SimToClient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Common.pb.h"

namespace MsgsSimToClient {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SimToClient_2eproto();
void protobuf_AssignDesc_SimToClient_2eproto();
void protobuf_ShutdownFile_SimToClient_2eproto();

class OrderAck;
class MsgUnitOrderAck;
class MsgAutomatOrderAck;
class MsgCrowdOrderAck;
class MsgFragOrderAck;
class MsgSetAutomatModeAck;
class UnitActionAck;
class MsgUnitCreationRequestAck;
class MsgMagicActionAck;
class MsgUnitMagicActionAck;
class MsgObjectMagicActionAck;
class MsgCrowdMagicActionAck;
class MsgChangeDiplomacyAck;
class HierarchyModificationAck;
class MsgAutomatChangeKnowledgeGroupAck;
class MsgAutomatChangeLogisticLinksAck;
class MsgAutomatChangeSuperiorAck;
class MsgUnitChangeSuperiorAck;
class MsgLogSupplyPushFlowAck;
class MsgLogSupplyChangeQuotasAck;
class MsgActionCreateFireOrderAck;
class MsgControlInformation;
class MsgControlProfilingInformation;
class MsgControlBeginTick;
class MsgControlEndTick;
class ControlAck;
class MsgControlDatetimeChangeAck;
class MsgControlChangeTimeFactorAck;
class MsgControlStopAck;
class MsgControlPauseAck;
class MsgControlResumeAck;
class MsgPartyCreation;
class MsgFormationCreation;
class MsgAutomatCreation;
class RulesOfEngagement;
class ForceRatio;
class MsgAutomatAttributes;
class MsgUnitCreation;
class BorrowedEquipments;
class BorrowedEquipments_BorrowedEquipment;
class LentEquipments;
class LentEquipments_LentEquipment;
class ResourceDotations;
class ResourceDotations_ResourceDotation;
class EquipmentDotations;
class EquipmentDotations_EquipmentDotation;
class HumanDotations;
class HumanDotations_HumanDotation;
class ContaminationState;
class NBCAgents;
class Communication;
class MsgUnitAttributes;
class MsgUnitPathFind;
class MsgUnitDestruction;
class MsgUnitEnvironmentType;
class MsgUnitKnowledgeCreation;
class AutomatPerception;
class SeqOfAutomatPerception;
class MsgUnitKnowledgeUpdate;
class MsgUnitKnowledgeDestruction;
class UnitFireTarget;
class MsgStartUnitFire;
class UnitHumanFireDamage;
class SeqOfUnitHumanFireDamage;
class MsgUnitEquipmentFireDamage;
class SeqOfUnitEquipmentFireDamage;
class MsgUnitFireDamages;
class MsgUnitsFireDamages;
class MsgCrowdFireDamages;
class MsgCrowdsFireDamages;
class MsgStopUnitFire;
class MsgStartCrowdFire;
class MsgStopCrowdFire;
class MsgExplosion;
class MsgStartFireEffect;
class MsgStopFireEffect;
class MsgReport;
class MsgInvalidateReport;
class MsgTrace;
class MsgDecisionalState;
class MsgDebugPoints;
class SeqOfHeading;
class MsgVisionCone;
class SeqOfVisionCone;
class MsgUnitVisionCones;
class MsgUnitDetection;
class MsgObjectDetection;
class MsgCrowdConcentrationDetection;
class MsgCrowdFlowDetection;
class MsgObjectCreation;
class MsgObjectDestruction;
class MsgObjectUpdate;
class MsgObjectKnowledgeCreation;
class MsgObjectKnowledgeUpdate;
class MsgObjectKnowledgeDestruction;
class MsgUrbanKnowledgeCreation;
class MsgUrbanKnowledgeUpdate;
class MsgUrbanKnowledgeDestruction;
class MsgLogMedicalHandlingCreation;
class MsgLogMedicalHandlingUpdate;
class MsgLogMedicalHandlingDestruction;
class MsgLogMedicalEquipmentAvailability;
class SeqOfLogMedicalEquipmentAvailability;
class MsgLogMedicalState;
class MsgLogMaintenanceHandlingCreation;
class MsgLogMaintenanceHandlingUpdate;
class MsgLogMaintenanceHandlingDestruction;
class MsgLogMaintenanceEquipmentAvailability;
class SeqOfLogMaintenanceEquipmentAvailability;
class MsgLogMaintenanceState;
class MsgLogSupplyHandlingCreation;
class MsgDotationQuery;
class SeqOfDotationQuery;
class MsgLogSupplyHandlingUpdate;
class MsgLogSupplyHandlingDestruction;
class MsgLogSupplyEquimentAvailability;
class SeqOfLogSupplyEquimentAvailability;
class MsgLogSupplyState;
class MsgLogSupplyQuotas;
class MsgCrowdCreation;
class MsgCrowdUpdate;
class MsgCrowdConcentrationCreation;
class MsgCrowdConcentrationDestruction;
class MsgCrowdConcentrationUpdate;
class MsgCrowdFlowCreation;
class MsgCrowdFlowDestruction;
class MsgCrowdFlowUpdate;
class MsgCrowdKnowledgeCreation;
class MsgCrowdKnowledgeUpdate;
class MsgCrowdKnowledgeDestruction;
class MsgCrowdConcentrationKnowledgeCreation;
class MsgCrowdConcentrationKnowledgeUpdate;
class MsgCrowdConcentrationKnowledgeDestruction;
class MsgCrowdFlowKnowledgeCreation;
class MsgFlowPart;
class SeqOfFlowPart;
class MsgCrowdFlowKnowledgeUpdate;
class MsgCrowdFlowKnowledgeDestruction;
class MsgFolkCreation_profiles;
class MsgFolkCreation_activities;
class MsgFolkCreation;
class MsgFolkGraphEdgeUpdate;
class MsgFolkGraphUpdate;
class MsgControlCheckPointSetFrequencyAck;
class MsgControlCheckPointSaveNowAck;
class MsgControlCheckPointSaveBegin;
class MsgControlCheckPointSaveBeginAck;
class MsgControlCheckPointSaveEnd;
class MsgControlCheckPointListAck;
class MsgControlCheckPointList;
class MsgControlCheckPointDeleteAck;
class MsgControlSendCurrentStateBegin;
class MsgControlSendCurrentStateEnd;
class MagicActionCreateUrban;
class MagicActionUpdateUrban;
class MagicActionDestroyUrban;
class MsgUrbanMagicAction;
class MsgUrbanMagicActionAck;
class UrbanAttributes;
class UrbanAttributes_Architecture;
class UrbanAttributes_Structure;
class UrbanAttributes_Infrastructures;
class MsgUrbanCreation;
class MsgUrbanDetection;
class MsgUrbanUpdate;
class MsgKnowledgeGroupCreation;
class MsgKnowledgeGroupUpdate;
class KnowledgeGroupAck;
class MsgKnowledgeGroupMagicActionAck;
class MsgKnowledgeGroupCreationAck;
class MsgKnowledgeGroupUpdateAck;
class MsgKnowledgeGroupDestruction;
class MsgControlGlobalWeatherAck;
class MsgControlLocalWeatherAck;
class MsgControlGlobalWeather;
class MsgControlLocalWeatherCreation;
class MsgControlLocalWeatherDestruction;
class MsgSimToClient;
class MsgSimToClient_Content;

enum OrderAck_ErrorCode {
  OrderAck_ErrorCode_no_error = 0,
  OrderAck_ErrorCode_error_invalid_unit = 1,
  OrderAck_ErrorCode_error_invalid_limit = 2,
  OrderAck_ErrorCode_error_invalid_lima = 3,
  OrderAck_ErrorCode_error_invalid_mission = 4,
  OrderAck_ErrorCode_error_invalid_mission_parameters = 5,
  OrderAck_ErrorCode_error_unit_cannot_receive_order = 6,
  OrderAck_ErrorCode_error_invalid_order_conduite = 7,
  OrderAck_ErrorCode_error_invalid_order_mission = 8,
  OrderAck_ErrorCode_error_invalid_order_initial = 9,
  OrderAck_ErrorCode_error_invalid_order_conduite_parameters = 10,
  OrderAck_ErrorCode_error_unit_surrendered = 11,
  OrderAck_ErrorCode_error_invalid_lima_function = 12
};
bool OrderAck_ErrorCode_IsValid(int value);
const OrderAck_ErrorCode OrderAck_ErrorCode_ErrorCode_MIN = OrderAck_ErrorCode_no_error;
const OrderAck_ErrorCode OrderAck_ErrorCode_ErrorCode_MAX = OrderAck_ErrorCode_error_invalid_lima_function;

const ::google::protobuf::EnumDescriptor* OrderAck_ErrorCode_descriptor();
inline const ::std::string& OrderAck_ErrorCode_Name(OrderAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderAck_ErrorCode_descriptor(), value);
}
inline bool OrderAck_ErrorCode_Parse(
    const ::std::string& name, OrderAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderAck_ErrorCode>(
    OrderAck_ErrorCode_descriptor(), name, value);
}
enum MsgSetAutomatModeAck_ErrorCode {
  MsgSetAutomatModeAck_ErrorCode_no_error = 0,
  MsgSetAutomatModeAck_ErrorCode_error_invalid_unit = 1,
  MsgSetAutomatModeAck_ErrorCode_error_not_allowed = 2
};
bool MsgSetAutomatModeAck_ErrorCode_IsValid(int value);
const MsgSetAutomatModeAck_ErrorCode MsgSetAutomatModeAck_ErrorCode_ErrorCode_MIN = MsgSetAutomatModeAck_ErrorCode_no_error;
const MsgSetAutomatModeAck_ErrorCode MsgSetAutomatModeAck_ErrorCode_ErrorCode_MAX = MsgSetAutomatModeAck_ErrorCode_error_not_allowed;

const ::google::protobuf::EnumDescriptor* MsgSetAutomatModeAck_ErrorCode_descriptor();
inline const ::std::string& MsgSetAutomatModeAck_ErrorCode_Name(MsgSetAutomatModeAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgSetAutomatModeAck_ErrorCode_descriptor(), value);
}
inline bool MsgSetAutomatModeAck_ErrorCode_Parse(
    const ::std::string& name, MsgSetAutomatModeAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgSetAutomatModeAck_ErrorCode>(
    MsgSetAutomatModeAck_ErrorCode_descriptor(), name, value);
}
enum UnitActionAck_ErrorCode {
  UnitActionAck_ErrorCode_no_error = 0,
  UnitActionAck_ErrorCode_error_invalid_unit = 1,
  UnitActionAck_ErrorCode_error_automate_embraye = 2,
  UnitActionAck_ErrorCode_error_invalid_attribute = 3,
  UnitActionAck_ErrorCode_error_unit_surrendered = 4
};
bool UnitActionAck_ErrorCode_IsValid(int value);
const UnitActionAck_ErrorCode UnitActionAck_ErrorCode_ErrorCode_MIN = UnitActionAck_ErrorCode_no_error;
const UnitActionAck_ErrorCode UnitActionAck_ErrorCode_ErrorCode_MAX = UnitActionAck_ErrorCode_error_unit_surrendered;

const ::google::protobuf::EnumDescriptor* UnitActionAck_ErrorCode_descriptor();
inline const ::std::string& UnitActionAck_ErrorCode_Name(UnitActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitActionAck_ErrorCode_descriptor(), value);
}
inline bool UnitActionAck_ErrorCode_Parse(
    const ::std::string& name, UnitActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitActionAck_ErrorCode>(
    UnitActionAck_ErrorCode_descriptor(), name, value);
}
enum MsgMagicActionAck_ErrorCode {
  MsgMagicActionAck_ErrorCode_no_error = 0,
  MsgMagicActionAck_ErrorCode_error_invalid_attribute = 1
};
bool MsgMagicActionAck_ErrorCode_IsValid(int value);
const MsgMagicActionAck_ErrorCode MsgMagicActionAck_ErrorCode_ErrorCode_MIN = MsgMagicActionAck_ErrorCode_no_error;
const MsgMagicActionAck_ErrorCode MsgMagicActionAck_ErrorCode_ErrorCode_MAX = MsgMagicActionAck_ErrorCode_error_invalid_attribute;

const ::google::protobuf::EnumDescriptor* MsgMagicActionAck_ErrorCode_descriptor();
inline const ::std::string& MsgMagicActionAck_ErrorCode_Name(MsgMagicActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgMagicActionAck_ErrorCode_descriptor(), value);
}
inline bool MsgMagicActionAck_ErrorCode_Parse(
    const ::std::string& name, MsgMagicActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgMagicActionAck_ErrorCode>(
    MsgMagicActionAck_ErrorCode_descriptor(), name, value);
}
enum MsgObjectMagicActionAck_ErrorCode {
  MsgObjectMagicActionAck_ErrorCode_no_error = 0,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_object = 1,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_id = 2,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_camp = 3,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_localisation = 4,
  MsgObjectMagicActionAck_ErrorCode_error_missing_specific_attributes = 5,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_specific_attributes = 6
};
bool MsgObjectMagicActionAck_ErrorCode_IsValid(int value);
const MsgObjectMagicActionAck_ErrorCode MsgObjectMagicActionAck_ErrorCode_ErrorCode_MIN = MsgObjectMagicActionAck_ErrorCode_no_error;
const MsgObjectMagicActionAck_ErrorCode MsgObjectMagicActionAck_ErrorCode_ErrorCode_MAX = MsgObjectMagicActionAck_ErrorCode_error_invalid_specific_attributes;

const ::google::protobuf::EnumDescriptor* MsgObjectMagicActionAck_ErrorCode_descriptor();
inline const ::std::string& MsgObjectMagicActionAck_ErrorCode_Name(MsgObjectMagicActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgObjectMagicActionAck_ErrorCode_descriptor(), value);
}
inline bool MsgObjectMagicActionAck_ErrorCode_Parse(
    const ::std::string& name, MsgObjectMagicActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgObjectMagicActionAck_ErrorCode>(
    MsgObjectMagicActionAck_ErrorCode_descriptor(), name, value);
}
enum MsgCrowdMagicActionAck_ErrorCode {
  MsgCrowdMagicActionAck_ErrorCode_no_error = 0,
  MsgCrowdMagicActionAck_ErrorCode_error_invalid_unit = 1,
  MsgCrowdMagicActionAck_ErrorCode_error_invalid_attribute = 2
};
bool MsgCrowdMagicActionAck_ErrorCode_IsValid(int value);
const MsgCrowdMagicActionAck_ErrorCode MsgCrowdMagicActionAck_ErrorCode_ErrorCode_MIN = MsgCrowdMagicActionAck_ErrorCode_no_error;
const MsgCrowdMagicActionAck_ErrorCode MsgCrowdMagicActionAck_ErrorCode_ErrorCode_MAX = MsgCrowdMagicActionAck_ErrorCode_error_invalid_attribute;

const ::google::protobuf::EnumDescriptor* MsgCrowdMagicActionAck_ErrorCode_descriptor();
inline const ::std::string& MsgCrowdMagicActionAck_ErrorCode_Name(MsgCrowdMagicActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgCrowdMagicActionAck_ErrorCode_descriptor(), value);
}
inline bool MsgCrowdMagicActionAck_ErrorCode_Parse(
    const ::std::string& name, MsgCrowdMagicActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgCrowdMagicActionAck_ErrorCode>(
    MsgCrowdMagicActionAck_ErrorCode_descriptor(), name, value);
}
enum MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode {
  MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_no_error_diplomacy = 0,
  MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_error_invalid_camp_diplomacy = 1
};
bool MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_IsValid(int value);
const MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_EnumChangeDiplomacyErrorCode_MIN = MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_no_error_diplomacy;
const MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_EnumChangeDiplomacyErrorCode_MAX = MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_error_invalid_camp_diplomacy;

const ::google::protobuf::EnumDescriptor* MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor();
inline const ::std::string& MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_Name(MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor(), value);
}
inline bool MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_Parse(
    const ::std::string& name, MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode>(
    MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor(), name, value);
}
enum HierarchyModificationAck_ErrorCode {
  HierarchyModificationAck_ErrorCode_no_error_hierarchy = 0,
  HierarchyModificationAck_ErrorCode_error_invalid_pion = 1,
  HierarchyModificationAck_ErrorCode_error_invalid_automate = 2,
  HierarchyModificationAck_ErrorCode_error_invalid_formation = 3,
  HierarchyModificationAck_ErrorCode_error_invalid_automate_tc2 = 4,
  HierarchyModificationAck_ErrorCode_error_invalid_automate_maintenance = 5,
  HierarchyModificationAck_ErrorCode_error_invalid_automate_sante = 6,
  HierarchyModificationAck_ErrorCode_error_invalid_automate_supply = 7,
  HierarchyModificationAck_ErrorCode_error_unit_surrendered_hierarchy = 8,
  HierarchyModificationAck_ErrorCode_error_invalid_party_hierarchy = 9,
  HierarchyModificationAck_ErrorCode_error_invalid_knowledge_group = 10,
  HierarchyModificationAck_ErrorCode_error_parties_mismatched = 11
};
bool HierarchyModificationAck_ErrorCode_IsValid(int value);
const HierarchyModificationAck_ErrorCode HierarchyModificationAck_ErrorCode_ErrorCode_MIN = HierarchyModificationAck_ErrorCode_no_error_hierarchy;
const HierarchyModificationAck_ErrorCode HierarchyModificationAck_ErrorCode_ErrorCode_MAX = HierarchyModificationAck_ErrorCode_error_parties_mismatched;

const ::google::protobuf::EnumDescriptor* HierarchyModificationAck_ErrorCode_descriptor();
inline const ::std::string& HierarchyModificationAck_ErrorCode_Name(HierarchyModificationAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    HierarchyModificationAck_ErrorCode_descriptor(), value);
}
inline bool HierarchyModificationAck_ErrorCode_Parse(
    const ::std::string& name, HierarchyModificationAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HierarchyModificationAck_ErrorCode>(
    HierarchyModificationAck_ErrorCode_descriptor(), name, value);
}
enum MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow {
  MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_no_error_pushflow = 0,
  MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_donneur_pushflow = 1,
  MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_receveur_pushflow = 2
};
bool MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_IsValid(int value);
const MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_EnumLogSupplyPushFlow_MIN = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_no_error_pushflow;
const MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_EnumLogSupplyPushFlow_MAX = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_receveur_pushflow;

const ::google::protobuf::EnumDescriptor* MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor();
inline const ::std::string& MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_Name(MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor(), value);
}
inline bool MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_Parse(
    const ::std::string& name, MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow>(
    MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor(), name, value);
}
enum MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas {
  MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_no_error_quotas = 0,
  MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_donneur_quotas = 1,
  MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_receveur_quotas = 2
};
bool MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_IsValid(int value);
const MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_LogSupplyChangeQuotas_MIN = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_no_error_quotas;
const MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_LogSupplyChangeQuotas_MAX = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_receveur_quotas;

const ::google::protobuf::EnumDescriptor* MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor();
inline const ::std::string& MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_Name(MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor(), value);
}
inline bool MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_Parse(
    const ::std::string& name, MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas>(
    MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor(), name, value);
}
enum MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode {
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_no_error = 0,
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_reporter = 1,
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_target = 2,
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_munition = 3,
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_target_no_illuminated = 4
};
bool MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_IsValid(int value);
const MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_EnumActionCreateFireOrderErrorCode_MIN = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_no_error;
const MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_EnumActionCreateFireOrderErrorCode_MAX = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_target_no_illuminated;

const ::google::protobuf::EnumDescriptor* MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor();
inline const ::std::string& MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_Name(MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor(), value);
}
inline bool MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_Parse(
    const ::std::string& name, MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode>(
    MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor(), name, value);
}
enum ControlAck_ErrorCode {
  ControlAck_ErrorCode_no_error = 0,
  ControlAck_ErrorCode_error_already_started = 1,
  ControlAck_ErrorCode_error_not_started = 2,
  ControlAck_ErrorCode_error_not_paused = 3,
  ControlAck_ErrorCode_error_already_paused = 4,
  ControlAck_ErrorCode_error_invalid_time_factor = 5,
  ControlAck_ErrorCode_error_invalid_date_time = 6
};
bool ControlAck_ErrorCode_IsValid(int value);
const ControlAck_ErrorCode ControlAck_ErrorCode_ErrorCode_MIN = ControlAck_ErrorCode_no_error;
const ControlAck_ErrorCode ControlAck_ErrorCode_ErrorCode_MAX = ControlAck_ErrorCode_error_invalid_date_time;

const ::google::protobuf::EnumDescriptor* ControlAck_ErrorCode_descriptor();
inline const ::std::string& ControlAck_ErrorCode_Name(ControlAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlAck_ErrorCode_descriptor(), value);
}
inline bool ControlAck_ErrorCode_Parse(
    const ::std::string& name, ControlAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlAck_ErrorCode>(
    ControlAck_ErrorCode_descriptor(), name, value);
}
enum RulesOfEngagement_Value {
  RulesOfEngagement_Value_none_roe = 0,
  RulesOfEngagement_Value_tir_libre = 1,
  RulesOfEngagement_Value_tir_sur_riposte = 2,
  RulesOfEngagement_Value_tir_interdit = 3
};
bool RulesOfEngagement_Value_IsValid(int value);
const RulesOfEngagement_Value RulesOfEngagement_Value_Value_MIN = RulesOfEngagement_Value_none_roe;
const RulesOfEngagement_Value RulesOfEngagement_Value_Value_MAX = RulesOfEngagement_Value_tir_interdit;

const ::google::protobuf::EnumDescriptor* RulesOfEngagement_Value_descriptor();
inline const ::std::string& RulesOfEngagement_Value_Name(RulesOfEngagement_Value value) {
  return ::google::protobuf::internal::NameOfEnum(
    RulesOfEngagement_Value_descriptor(), value);
}
inline bool RulesOfEngagement_Value_Parse(
    const ::std::string& name, RulesOfEngagement_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RulesOfEngagement_Value>(
    RulesOfEngagement_Value_descriptor(), name, value);
}
enum ForceRatio_Value {
  ForceRatio_Value_none_force_ratio = 0,
  ForceRatio_Value_neutre = 1,
  ForceRatio_Value_favorable = 2,
  ForceRatio_Value_defavorable = 3
};
bool ForceRatio_Value_IsValid(int value);
const ForceRatio_Value ForceRatio_Value_Value_MIN = ForceRatio_Value_none_force_ratio;
const ForceRatio_Value ForceRatio_Value_Value_MAX = ForceRatio_Value_defavorable;

const ::google::protobuf::EnumDescriptor* ForceRatio_Value_descriptor();
inline const ::std::string& ForceRatio_Value_Name(ForceRatio_Value value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForceRatio_Value_descriptor(), value);
}
inline bool ForceRatio_Value_Parse(
    const ::std::string& name, ForceRatio_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForceRatio_Value>(
    ForceRatio_Value_descriptor(), name, value);
}
enum MsgUnitAttributes_Posture {
  MsgUnitAttributes_Posture_mouvement = 0,
  MsgUnitAttributes_Posture_mouvement_discret = 1,
  MsgUnitAttributes_Posture_arret = 2,
  MsgUnitAttributes_Posture_poste_reflexe = 3,
  MsgUnitAttributes_Posture_poste = 4,
  MsgUnitAttributes_Posture_poste_amenage = 5,
  MsgUnitAttributes_Posture_poste_prepare_genie = 6
};
bool MsgUnitAttributes_Posture_IsValid(int value);
const MsgUnitAttributes_Posture MsgUnitAttributes_Posture_Posture_MIN = MsgUnitAttributes_Posture_mouvement;
const MsgUnitAttributes_Posture MsgUnitAttributes_Posture_Posture_MAX = MsgUnitAttributes_Posture_poste_prepare_genie;

const ::google::protobuf::EnumDescriptor* MsgUnitAttributes_Posture_descriptor();
inline const ::std::string& MsgUnitAttributes_Posture_Name(MsgUnitAttributes_Posture value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgUnitAttributes_Posture_descriptor(), value);
}
inline bool MsgUnitAttributes_Posture_Parse(
    const ::std::string& name, MsgUnitAttributes_Posture* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgUnitAttributes_Posture>(
    MsgUnitAttributes_Posture_descriptor(), name, value);
}
enum MsgUnitAttributes_FireAvailability {
  MsgUnitAttributes_FireAvailability_none_fire_available = 0,
  MsgUnitAttributes_FireAvailability_pret_au_tir = 1,
  MsgUnitAttributes_FireAvailability_indisponible = 2
};
bool MsgUnitAttributes_FireAvailability_IsValid(int value);
const MsgUnitAttributes_FireAvailability MsgUnitAttributes_FireAvailability_FireAvailability_MIN = MsgUnitAttributes_FireAvailability_none_fire_available;
const MsgUnitAttributes_FireAvailability MsgUnitAttributes_FireAvailability_FireAvailability_MAX = MsgUnitAttributes_FireAvailability_indisponible;

const ::google::protobuf::EnumDescriptor* MsgUnitAttributes_FireAvailability_descriptor();
inline const ::std::string& MsgUnitAttributes_FireAvailability_Name(MsgUnitAttributes_FireAvailability value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgUnitAttributes_FireAvailability_descriptor(), value);
}
inline bool MsgUnitAttributes_FireAvailability_Parse(
    const ::std::string& name, MsgUnitAttributes_FireAvailability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgUnitAttributes_FireAvailability>(
    MsgUnitAttributes_FireAvailability_descriptor(), name, value);
}
enum MsgUnitAttributes_CrowdRoe {
  MsgUnitAttributes_CrowdRoe_none = 0,
  MsgUnitAttributes_CrowdRoe_emploi_force_interdit = 1,
  MsgUnitAttributes_CrowdRoe_maintien_a_distance_par_moyens_non_letaux = 2,
  MsgUnitAttributes_CrowdRoe_dispersion_par_moyens_de_defense_actifs = 3,
  MsgUnitAttributes_CrowdRoe_armes_letales_autorisees = 4
};
bool MsgUnitAttributes_CrowdRoe_IsValid(int value);
const MsgUnitAttributes_CrowdRoe MsgUnitAttributes_CrowdRoe_CrowdRoe_MIN = MsgUnitAttributes_CrowdRoe_none;
const MsgUnitAttributes_CrowdRoe MsgUnitAttributes_CrowdRoe_CrowdRoe_MAX = MsgUnitAttributes_CrowdRoe_armes_letales_autorisees;

const ::google::protobuf::EnumDescriptor* MsgUnitAttributes_CrowdRoe_descriptor();
inline const ::std::string& MsgUnitAttributes_CrowdRoe_Name(MsgUnitAttributes_CrowdRoe value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgUnitAttributes_CrowdRoe_descriptor(), value);
}
inline bool MsgUnitAttributes_CrowdRoe_Parse(
    const ::std::string& name, MsgUnitAttributes_CrowdRoe* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgUnitAttributes_CrowdRoe>(
    MsgUnitAttributes_CrowdRoe_descriptor(), name, value);
}
enum MsgUrbanMagicActionAck_ErrorCode {
  MsgUrbanMagicActionAck_ErrorCode_no_error = 0,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_urban = 1,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_id = 2,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_camp = 3,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_localisation = 4,
  MsgUrbanMagicActionAck_ErrorCode_error_missing_specific_attributes = 5,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_specific_attributes = 6
};
bool MsgUrbanMagicActionAck_ErrorCode_IsValid(int value);
const MsgUrbanMagicActionAck_ErrorCode MsgUrbanMagicActionAck_ErrorCode_ErrorCode_MIN = MsgUrbanMagicActionAck_ErrorCode_no_error;
const MsgUrbanMagicActionAck_ErrorCode MsgUrbanMagicActionAck_ErrorCode_ErrorCode_MAX = MsgUrbanMagicActionAck_ErrorCode_error_invalid_specific_attributes;

const ::google::protobuf::EnumDescriptor* MsgUrbanMagicActionAck_ErrorCode_descriptor();
inline const ::std::string& MsgUrbanMagicActionAck_ErrorCode_Name(MsgUrbanMagicActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgUrbanMagicActionAck_ErrorCode_descriptor(), value);
}
inline bool MsgUrbanMagicActionAck_ErrorCode_Parse(
    const ::std::string& name, MsgUrbanMagicActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgUrbanMagicActionAck_ErrorCode>(
    MsgUrbanMagicActionAck_ErrorCode_descriptor(), name, value);
}
enum KnowledgeGroupAck_ErrorCode {
  KnowledgeGroupAck_ErrorCode_no_error = 0,
  KnowledgeGroupAck_ErrorCode_error_invalid_unit = 1,
  KnowledgeGroupAck_ErrorCode_error_invalid_superior = 2,
  KnowledgeGroupAck_ErrorCode_error_invalid_camp = 3,
  KnowledgeGroupAck_ErrorCode_error_invalid_knowledgegroup = 4,
  KnowledgeGroupAck_ErrorCode_error_invalid_type = 5
};
bool KnowledgeGroupAck_ErrorCode_IsValid(int value);
const KnowledgeGroupAck_ErrorCode KnowledgeGroupAck_ErrorCode_ErrorCode_MIN = KnowledgeGroupAck_ErrorCode_no_error;
const KnowledgeGroupAck_ErrorCode KnowledgeGroupAck_ErrorCode_ErrorCode_MAX = KnowledgeGroupAck_ErrorCode_error_invalid_type;

const ::google::protobuf::EnumDescriptor* KnowledgeGroupAck_ErrorCode_descriptor();
inline const ::std::string& KnowledgeGroupAck_ErrorCode_Name(KnowledgeGroupAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    KnowledgeGroupAck_ErrorCode_descriptor(), value);
}
inline bool KnowledgeGroupAck_ErrorCode_Parse(
    const ::std::string& name, KnowledgeGroupAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KnowledgeGroupAck_ErrorCode>(
    KnowledgeGroupAck_ErrorCode_descriptor(), name, value);
}
enum EnumLogSupplyHandlingStatus {
  convoi_en_attente_camions = 1,
  convoi_constitution = 2,
  convoi_deplacement_vers_point_chargement = 3,
  convoi_chargement = 4,
  convoi_deplacement_vers_point_dechargement = 5,
  convoi_dechargement = 6,
  convoi_deplacement_retour = 7,
  termine = 8
};
bool EnumLogSupplyHandlingStatus_IsValid(int value);
const EnumLogSupplyHandlingStatus EnumLogSupplyHandlingStatus_MIN = convoi_en_attente_camions;
const EnumLogSupplyHandlingStatus EnumLogSupplyHandlingStatus_MAX = termine;

const ::google::protobuf::EnumDescriptor* EnumLogSupplyHandlingStatus_descriptor();
inline const ::std::string& EnumLogSupplyHandlingStatus_Name(EnumLogSupplyHandlingStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumLogSupplyHandlingStatus_descriptor(), value);
}
inline bool EnumLogSupplyHandlingStatus_Parse(
    const ::std::string& name, EnumLogSupplyHandlingStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumLogSupplyHandlingStatus>(
    EnumLogSupplyHandlingStatus_descriptor(), name, value);
}
enum EnumUnitIdentificationLevel {
  identifiee = 0,
  reconnue = 1,
  detectee = 2,
  signale = 3
};
bool EnumUnitIdentificationLevel_IsValid(int value);
const EnumUnitIdentificationLevel EnumUnitIdentificationLevel_MIN = identifiee;
const EnumUnitIdentificationLevel EnumUnitIdentificationLevel_MAX = signale;

const ::google::protobuf::EnumDescriptor* EnumUnitIdentificationLevel_descriptor();
inline const ::std::string& EnumUnitIdentificationLevel_Name(EnumUnitIdentificationLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumUnitIdentificationLevel_descriptor(), value);
}
inline bool EnumUnitIdentificationLevel_Parse(
    const ::std::string& name, EnumUnitIdentificationLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumUnitIdentificationLevel>(
    EnumUnitIdentificationLevel_descriptor(), name, value);
}
enum EnumReportType {
  information = 0,
  operational = 1,
  exceptional_event = 2,
  warning = 3
};
bool EnumReportType_IsValid(int value);
const EnumReportType EnumReportType_MIN = information;
const EnumReportType EnumReportType_MAX = warning;

const ::google::protobuf::EnumDescriptor* EnumReportType_descriptor();
inline const ::std::string& EnumReportType_Name(EnumReportType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumReportType_descriptor(), value);
}
inline bool EnumReportType_Parse(
    const ::std::string& name, EnumReportType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumReportType>(
    EnumReportType_descriptor(), name, value);
}
// ===================================================================

class OrderAck : public ::google::protobuf::Message {
 public:
  OrderAck();
  virtual ~OrderAck();
  
  OrderAck(const OrderAck& from);
  
  inline OrderAck& operator=(const OrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderAck& default_instance();
  void Swap(OrderAck* other);
  
  // implements Message ----------------------------------------------
  
  OrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderAck& from);
  void MergeFrom(const OrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OrderAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = OrderAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = OrderAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_invalid_limit = OrderAck_ErrorCode_error_invalid_limit;
  static const ErrorCode error_invalid_lima = OrderAck_ErrorCode_error_invalid_lima;
  static const ErrorCode error_invalid_mission = OrderAck_ErrorCode_error_invalid_mission;
  static const ErrorCode error_invalid_mission_parameters = OrderAck_ErrorCode_error_invalid_mission_parameters;
  static const ErrorCode error_unit_cannot_receive_order = OrderAck_ErrorCode_error_unit_cannot_receive_order;
  static const ErrorCode error_invalid_order_conduite = OrderAck_ErrorCode_error_invalid_order_conduite;
  static const ErrorCode error_invalid_order_mission = OrderAck_ErrorCode_error_invalid_order_mission;
  static const ErrorCode error_invalid_order_initial = OrderAck_ErrorCode_error_invalid_order_initial;
  static const ErrorCode error_invalid_order_conduite_parameters = OrderAck_ErrorCode_error_invalid_order_conduite_parameters;
  static const ErrorCode error_unit_surrendered = OrderAck_ErrorCode_error_unit_surrendered;
  static const ErrorCode error_invalid_lima_function = OrderAck_ErrorCode_error_invalid_lima_function;
  static inline bool ErrorCode_IsValid(int value) {
    return OrderAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    OrderAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    OrderAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return OrderAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return OrderAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return OrderAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitOrderAck : public ::google::protobuf::Message {
 public:
  MsgUnitOrderAck();
  virtual ~MsgUnitOrderAck();
  
  MsgUnitOrderAck(const MsgUnitOrderAck& from);
  
  inline MsgUnitOrderAck& operator=(const MsgUnitOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitOrderAck& default_instance();
  void Swap(MsgUnitOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitOrderAck& from);
  void MergeFrom(const MsgUnitOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId tasker = 1;
  inline bool has_tasker() const;
  inline void clear_tasker();
  static const int kTaskerFieldNumber = 1;
  inline const ::Common::UnitId& tasker() const;
  inline ::Common::UnitId* mutable_tasker();
  
  // required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::OrderAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* tasker_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatOrderAck : public ::google::protobuf::Message {
 public:
  MsgAutomatOrderAck();
  virtual ~MsgAutomatOrderAck();
  
  MsgAutomatOrderAck(const MsgAutomatOrderAck& from);
  
  inline MsgAutomatOrderAck& operator=(const MsgAutomatOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatOrderAck& default_instance();
  void Swap(MsgAutomatOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatOrderAck& from);
  void MergeFrom(const MsgAutomatOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId tasker = 1;
  inline bool has_tasker() const;
  inline void clear_tasker();
  static const int kTaskerFieldNumber = 1;
  inline const ::Common::AutomatId& tasker() const;
  inline ::Common::AutomatId* mutable_tasker();
  
  // required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::OrderAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* tasker_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdOrderAck : public ::google::protobuf::Message {
 public:
  MsgCrowdOrderAck();
  virtual ~MsgCrowdOrderAck();
  
  MsgCrowdOrderAck(const MsgCrowdOrderAck& from);
  
  inline MsgCrowdOrderAck& operator=(const MsgCrowdOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdOrderAck& default_instance();
  void Swap(MsgCrowdOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdOrderAck& from);
  void MergeFrom(const MsgCrowdOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdId tasker = 1;
  inline bool has_tasker() const;
  inline void clear_tasker();
  static const int kTaskerFieldNumber = 1;
  inline const ::Common::CrowdId& tasker() const;
  inline ::Common::CrowdId* mutable_tasker();
  
  // required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::OrderAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdId* tasker_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgFragOrderAck : public ::google::protobuf::Message {
 public:
  MsgFragOrderAck();
  virtual ~MsgFragOrderAck();
  
  MsgFragOrderAck(const MsgFragOrderAck& from);
  
  inline MsgFragOrderAck& operator=(const MsgFragOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFragOrderAck& default_instance();
  void Swap(MsgFragOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgFragOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFragOrderAck& from);
  void MergeFrom(const MsgFragOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.Tasker tasker = 1;
  inline bool has_tasker() const;
  inline void clear_tasker();
  static const int kTaskerFieldNumber = 1;
  inline const ::Common::Tasker& tasker() const;
  inline ::Common::Tasker* mutable_tasker();
  
  // required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::OrderAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::Tasker* tasker_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFragOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgSetAutomatModeAck : public ::google::protobuf::Message {
 public:
  MsgSetAutomatModeAck();
  virtual ~MsgSetAutomatModeAck();
  
  MsgSetAutomatModeAck(const MsgSetAutomatModeAck& from);
  
  inline MsgSetAutomatModeAck& operator=(const MsgSetAutomatModeAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgSetAutomatModeAck& default_instance();
  void Swap(MsgSetAutomatModeAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgSetAutomatModeAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgSetAutomatModeAck& from);
  void MergeFrom(const MsgSetAutomatModeAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgSetAutomatModeAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgSetAutomatModeAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = MsgSetAutomatModeAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_not_allowed = MsgSetAutomatModeAck_ErrorCode_error_not_allowed;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgSetAutomatModeAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgSetAutomatModeAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgSetAutomatModeAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgSetAutomatModeAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgSetAutomatModeAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgSetAutomatModeAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId automat = 1;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 1;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
  // required .MsgsSimToClient.MsgSetAutomatModeAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* automat_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgSetAutomatModeAck* default_instance_;
};
// -------------------------------------------------------------------

class UnitActionAck : public ::google::protobuf::Message {
 public:
  UnitActionAck();
  virtual ~UnitActionAck();
  
  UnitActionAck(const UnitActionAck& from);
  
  inline UnitActionAck& operator=(const UnitActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitActionAck& default_instance();
  void Swap(UnitActionAck* other);
  
  // implements Message ----------------------------------------------
  
  UnitActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitActionAck& from);
  void MergeFrom(const UnitActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef UnitActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = UnitActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = UnitActionAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_automate_embraye = UnitActionAck_ErrorCode_error_automate_embraye;
  static const ErrorCode error_invalid_attribute = UnitActionAck_ErrorCode_error_invalid_attribute;
  static const ErrorCode error_unit_surrendered = UnitActionAck_ErrorCode_error_unit_surrendered;
  static inline bool ErrorCode_IsValid(int value) {
    return UnitActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    UnitActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    UnitActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return UnitActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return UnitActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return UnitActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UnitActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitCreationRequestAck : public ::google::protobuf::Message {
 public:
  MsgUnitCreationRequestAck();
  virtual ~MsgUnitCreationRequestAck();
  
  MsgUnitCreationRequestAck(const MsgUnitCreationRequestAck& from);
  
  inline MsgUnitCreationRequestAck& operator=(const MsgUnitCreationRequestAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitCreationRequestAck& default_instance();
  void Swap(MsgUnitCreationRequestAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitCreationRequestAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitCreationRequestAck& from);
  void MergeFrom(const MsgUnitCreationRequestAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.UnitActionAck.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::MsgsSimToClient::UnitActionAck_ErrorCode error() const;
  inline void set_error(::MsgsSimToClient::UnitActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitCreationRequestAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgMagicActionAck();
  virtual ~MsgMagicActionAck();
  
  MsgMagicActionAck(const MsgMagicActionAck& from);
  
  inline MsgMagicActionAck& operator=(const MsgMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgMagicActionAck& default_instance();
  void Swap(MsgMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgMagicActionAck& from);
  void MergeFrom(const MsgMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgMagicActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgMagicActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_attribute = MsgMagicActionAck_ErrorCode_error_invalid_attribute;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgMagicActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgMagicActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgMagicActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgMagicActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgMagicActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgMagicActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgMagicActionAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::MsgMagicActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgMagicActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgUnitMagicActionAck();
  virtual ~MsgUnitMagicActionAck();
  
  MsgUnitMagicActionAck(const MsgUnitMagicActionAck& from);
  
  inline MsgUnitMagicActionAck& operator=(const MsgUnitMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitMagicActionAck& default_instance();
  void Swap(MsgUnitMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitMagicActionAck& from);
  void MergeFrom(const MsgUnitMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required .MsgsSimToClient.UnitActionAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::UnitActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::UnitActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgObjectMagicActionAck();
  virtual ~MsgObjectMagicActionAck();
  
  MsgObjectMagicActionAck(const MsgObjectMagicActionAck& from);
  
  inline MsgObjectMagicActionAck& operator=(const MsgObjectMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectMagicActionAck& default_instance();
  void Swap(MsgObjectMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectMagicActionAck& from);
  void MergeFrom(const MsgObjectMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgObjectMagicActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgObjectMagicActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_object = MsgObjectMagicActionAck_ErrorCode_error_invalid_object;
  static const ErrorCode error_invalid_id = MsgObjectMagicActionAck_ErrorCode_error_invalid_id;
  static const ErrorCode error_invalid_camp = MsgObjectMagicActionAck_ErrorCode_error_invalid_camp;
  static const ErrorCode error_invalid_localisation = MsgObjectMagicActionAck_ErrorCode_error_invalid_localisation;
  static const ErrorCode error_missing_specific_attributes = MsgObjectMagicActionAck_ErrorCode_error_missing_specific_attributes;
  static const ErrorCode error_invalid_specific_attributes = MsgObjectMagicActionAck_ErrorCode_error_invalid_specific_attributes;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgObjectMagicActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgObjectMagicActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgObjectMagicActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgObjectMagicActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgObjectMagicActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgObjectMagicActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgObjectMagicActionAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgCrowdMagicActionAck();
  virtual ~MsgCrowdMagicActionAck();
  
  MsgCrowdMagicActionAck(const MsgCrowdMagicActionAck& from);
  
  inline MsgCrowdMagicActionAck& operator=(const MsgCrowdMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdMagicActionAck& default_instance();
  void Swap(MsgCrowdMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdMagicActionAck& from);
  void MergeFrom(const MsgCrowdMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgCrowdMagicActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgCrowdMagicActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = MsgCrowdMagicActionAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_invalid_attribute = MsgCrowdMagicActionAck_ErrorCode_error_invalid_attribute;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgCrowdMagicActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgCrowdMagicActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgCrowdMagicActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgCrowdMagicActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgCrowdMagicActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgCrowdMagicActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdId crowd = 1;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 1;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
  // required .MsgsSimToClient.MsgCrowdMagicActionAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::MsgCrowdMagicActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgCrowdMagicActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdId* crowd_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgChangeDiplomacyAck : public ::google::protobuf::Message {
 public:
  MsgChangeDiplomacyAck();
  virtual ~MsgChangeDiplomacyAck();
  
  MsgChangeDiplomacyAck(const MsgChangeDiplomacyAck& from);
  
  inline MsgChangeDiplomacyAck& operator=(const MsgChangeDiplomacyAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChangeDiplomacyAck& default_instance();
  void Swap(MsgChangeDiplomacyAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgChangeDiplomacyAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChangeDiplomacyAck& from);
  void MergeFrom(const MsgChangeDiplomacyAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode EnumChangeDiplomacyErrorCode;
  static const EnumChangeDiplomacyErrorCode no_error_diplomacy = MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_no_error_diplomacy;
  static const EnumChangeDiplomacyErrorCode error_invalid_camp_diplomacy = MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_error_invalid_camp_diplomacy;
  static inline bool EnumChangeDiplomacyErrorCode_IsValid(int value) {
    return MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_IsValid(value);
  }
  static const EnumChangeDiplomacyErrorCode EnumChangeDiplomacyErrorCode_MIN =
    MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_EnumChangeDiplomacyErrorCode_MIN;
  static const EnumChangeDiplomacyErrorCode EnumChangeDiplomacyErrorCode_MAX =
    MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_EnumChangeDiplomacyErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  EnumChangeDiplomacyErrorCode_descriptor() {
    return MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor();
  }
  static inline const ::std::string& EnumChangeDiplomacyErrorCode_Name(EnumChangeDiplomacyErrorCode value) {
    return MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_Name(value);
  }
  static inline bool EnumChangeDiplomacyErrorCode_Parse(const ::std::string& name,
      EnumChangeDiplomacyErrorCode* value) {
    return MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Common.PartyId party1 = 1;
  inline bool has_party1() const;
  inline void clear_party1();
  static const int kParty1FieldNumber = 1;
  inline const ::Common::PartyId& party1() const;
  inline ::Common::PartyId* mutable_party1();
  
  // required .Common.PartyId party2 = 2;
  inline bool has_party2() const;
  inline void clear_party2();
  static const int kParty2FieldNumber = 2;
  inline const ::Common::PartyId& party2() const;
  inline ::Common::PartyId* mutable_party2();
  
  // required .Common.EnumDiplomacy diplomatie = 3;
  inline bool has_diplomatie() const;
  inline void clear_diplomatie();
  static const int kDiplomatieFieldNumber = 3;
  inline Common::EnumDiplomacy diplomatie() const;
  inline void set_diplomatie(Common::EnumDiplomacy value);
  
  // required .MsgsSimToClient.MsgChangeDiplomacyAck.EnumChangeDiplomacyErrorCode error_code = 4;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 4;
  inline ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PartyId* party1_;
  ::Common::PartyId* party2_;
  int diplomatie_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgChangeDiplomacyAck* default_instance_;
};
// -------------------------------------------------------------------

class HierarchyModificationAck : public ::google::protobuf::Message {
 public:
  HierarchyModificationAck();
  virtual ~HierarchyModificationAck();
  
  HierarchyModificationAck(const HierarchyModificationAck& from);
  
  inline HierarchyModificationAck& operator=(const HierarchyModificationAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HierarchyModificationAck& default_instance();
  void Swap(HierarchyModificationAck* other);
  
  // implements Message ----------------------------------------------
  
  HierarchyModificationAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HierarchyModificationAck& from);
  void MergeFrom(const HierarchyModificationAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef HierarchyModificationAck_ErrorCode ErrorCode;
  static const ErrorCode no_error_hierarchy = HierarchyModificationAck_ErrorCode_no_error_hierarchy;
  static const ErrorCode error_invalid_pion = HierarchyModificationAck_ErrorCode_error_invalid_pion;
  static const ErrorCode error_invalid_automate = HierarchyModificationAck_ErrorCode_error_invalid_automate;
  static const ErrorCode error_invalid_formation = HierarchyModificationAck_ErrorCode_error_invalid_formation;
  static const ErrorCode error_invalid_automate_tc2 = HierarchyModificationAck_ErrorCode_error_invalid_automate_tc2;
  static const ErrorCode error_invalid_automate_maintenance = HierarchyModificationAck_ErrorCode_error_invalid_automate_maintenance;
  static const ErrorCode error_invalid_automate_sante = HierarchyModificationAck_ErrorCode_error_invalid_automate_sante;
  static const ErrorCode error_invalid_automate_supply = HierarchyModificationAck_ErrorCode_error_invalid_automate_supply;
  static const ErrorCode error_unit_surrendered_hierarchy = HierarchyModificationAck_ErrorCode_error_unit_surrendered_hierarchy;
  static const ErrorCode error_invalid_party_hierarchy = HierarchyModificationAck_ErrorCode_error_invalid_party_hierarchy;
  static const ErrorCode error_invalid_knowledge_group = HierarchyModificationAck_ErrorCode_error_invalid_knowledge_group;
  static const ErrorCode error_parties_mismatched = HierarchyModificationAck_ErrorCode_error_parties_mismatched;
  static inline bool ErrorCode_IsValid(int value) {
    return HierarchyModificationAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    HierarchyModificationAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    HierarchyModificationAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return HierarchyModificationAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return HierarchyModificationAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return HierarchyModificationAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HierarchyModificationAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatChangeKnowledgeGroupAck : public ::google::protobuf::Message {
 public:
  MsgAutomatChangeKnowledgeGroupAck();
  virtual ~MsgAutomatChangeKnowledgeGroupAck();
  
  MsgAutomatChangeKnowledgeGroupAck(const MsgAutomatChangeKnowledgeGroupAck& from);
  
  inline MsgAutomatChangeKnowledgeGroupAck& operator=(const MsgAutomatChangeKnowledgeGroupAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatChangeKnowledgeGroupAck& default_instance();
  void Swap(MsgAutomatChangeKnowledgeGroupAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatChangeKnowledgeGroupAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatChangeKnowledgeGroupAck& from);
  void MergeFrom(const MsgAutomatChangeKnowledgeGroupAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatChangeKnowledgeGroupAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatChangeLogisticLinksAck : public ::google::protobuf::Message {
 public:
  MsgAutomatChangeLogisticLinksAck();
  virtual ~MsgAutomatChangeLogisticLinksAck();
  
  MsgAutomatChangeLogisticLinksAck(const MsgAutomatChangeLogisticLinksAck& from);
  
  inline MsgAutomatChangeLogisticLinksAck& operator=(const MsgAutomatChangeLogisticLinksAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatChangeLogisticLinksAck& default_instance();
  void Swap(MsgAutomatChangeLogisticLinksAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatChangeLogisticLinksAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatChangeLogisticLinksAck& from);
  void MergeFrom(const MsgAutomatChangeLogisticLinksAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatChangeLogisticLinksAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatChangeSuperiorAck : public ::google::protobuf::Message {
 public:
  MsgAutomatChangeSuperiorAck();
  virtual ~MsgAutomatChangeSuperiorAck();
  
  MsgAutomatChangeSuperiorAck(const MsgAutomatChangeSuperiorAck& from);
  
  inline MsgAutomatChangeSuperiorAck& operator=(const MsgAutomatChangeSuperiorAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatChangeSuperiorAck& default_instance();
  void Swap(MsgAutomatChangeSuperiorAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatChangeSuperiorAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatChangeSuperiorAck& from);
  void MergeFrom(const MsgAutomatChangeSuperiorAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatChangeSuperiorAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitChangeSuperiorAck : public ::google::protobuf::Message {
 public:
  MsgUnitChangeSuperiorAck();
  virtual ~MsgUnitChangeSuperiorAck();
  
  MsgUnitChangeSuperiorAck(const MsgUnitChangeSuperiorAck& from);
  
  inline MsgUnitChangeSuperiorAck& operator=(const MsgUnitChangeSuperiorAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitChangeSuperiorAck& default_instance();
  void Swap(MsgUnitChangeSuperiorAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitChangeSuperiorAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitChangeSuperiorAck& from);
  void MergeFrom(const MsgUnitChangeSuperiorAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitChangeSuperiorAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyPushFlowAck : public ::google::protobuf::Message {
 public:
  MsgLogSupplyPushFlowAck();
  virtual ~MsgLogSupplyPushFlowAck();
  
  MsgLogSupplyPushFlowAck(const MsgLogSupplyPushFlowAck& from);
  
  inline MsgLogSupplyPushFlowAck& operator=(const MsgLogSupplyPushFlowAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyPushFlowAck& default_instance();
  void Swap(MsgLogSupplyPushFlowAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyPushFlowAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyPushFlowAck& from);
  void MergeFrom(const MsgLogSupplyPushFlowAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow EnumLogSupplyPushFlow;
  static const EnumLogSupplyPushFlow no_error_pushflow = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_no_error_pushflow;
  static const EnumLogSupplyPushFlow error_invalid_donneur_pushflow = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_donneur_pushflow;
  static const EnumLogSupplyPushFlow error_invalid_receveur_pushflow = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_receveur_pushflow;
  static inline bool EnumLogSupplyPushFlow_IsValid(int value) {
    return MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_IsValid(value);
  }
  static const EnumLogSupplyPushFlow EnumLogSupplyPushFlow_MIN =
    MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_EnumLogSupplyPushFlow_MIN;
  static const EnumLogSupplyPushFlow EnumLogSupplyPushFlow_MAX =
    MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_EnumLogSupplyPushFlow_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  EnumLogSupplyPushFlow_descriptor() {
    return MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor();
  }
  static inline const ::std::string& EnumLogSupplyPushFlow_Name(EnumLogSupplyPushFlow value) {
    return MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_Name(value);
  }
  static inline bool EnumLogSupplyPushFlow_Parse(const ::std::string& name,
      EnumLogSupplyPushFlow* value) {
    return MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MsgLogSupplyPushFlowAck.EnumLogSupplyPushFlow ack = 1;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 1;
  inline ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow ack() const;
  inline void set_ack(::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int ack_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyPushFlowAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyChangeQuotasAck : public ::google::protobuf::Message {
 public:
  MsgLogSupplyChangeQuotasAck();
  virtual ~MsgLogSupplyChangeQuotasAck();
  
  MsgLogSupplyChangeQuotasAck(const MsgLogSupplyChangeQuotasAck& from);
  
  inline MsgLogSupplyChangeQuotasAck& operator=(const MsgLogSupplyChangeQuotasAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyChangeQuotasAck& default_instance();
  void Swap(MsgLogSupplyChangeQuotasAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyChangeQuotasAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyChangeQuotasAck& from);
  void MergeFrom(const MsgLogSupplyChangeQuotasAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas LogSupplyChangeQuotas;
  static const LogSupplyChangeQuotas no_error_quotas = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_no_error_quotas;
  static const LogSupplyChangeQuotas error_invalid_donneur_quotas = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_donneur_quotas;
  static const LogSupplyChangeQuotas error_invalid_receveur_quotas = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_receveur_quotas;
  static inline bool LogSupplyChangeQuotas_IsValid(int value) {
    return MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_IsValid(value);
  }
  static const LogSupplyChangeQuotas LogSupplyChangeQuotas_MIN =
    MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_LogSupplyChangeQuotas_MIN;
  static const LogSupplyChangeQuotas LogSupplyChangeQuotas_MAX =
    MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_LogSupplyChangeQuotas_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  LogSupplyChangeQuotas_descriptor() {
    return MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor();
  }
  static inline const ::std::string& LogSupplyChangeQuotas_Name(LogSupplyChangeQuotas value) {
    return MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_Name(value);
  }
  static inline bool LogSupplyChangeQuotas_Parse(const ::std::string& name,
      LogSupplyChangeQuotas* value) {
    return MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MsgLogSupplyChangeQuotasAck.LogSupplyChangeQuotas ack = 1;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 1;
  inline ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas ack() const;
  inline void set_ack(::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int ack_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyChangeQuotasAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgActionCreateFireOrderAck : public ::google::protobuf::Message {
 public:
  MsgActionCreateFireOrderAck();
  virtual ~MsgActionCreateFireOrderAck();
  
  MsgActionCreateFireOrderAck(const MsgActionCreateFireOrderAck& from);
  
  inline MsgActionCreateFireOrderAck& operator=(const MsgActionCreateFireOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgActionCreateFireOrderAck& default_instance();
  void Swap(MsgActionCreateFireOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgActionCreateFireOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgActionCreateFireOrderAck& from);
  void MergeFrom(const MsgActionCreateFireOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode EnumActionCreateFireOrderErrorCode;
  static const EnumActionCreateFireOrderErrorCode no_error = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_no_error;
  static const EnumActionCreateFireOrderErrorCode error_invalid_reporter = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_reporter;
  static const EnumActionCreateFireOrderErrorCode error_invalid_target = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_target;
  static const EnumActionCreateFireOrderErrorCode error_invalid_munition = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_munition;
  static const EnumActionCreateFireOrderErrorCode error_target_no_illuminated = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_target_no_illuminated;
  static inline bool EnumActionCreateFireOrderErrorCode_IsValid(int value) {
    return MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_IsValid(value);
  }
  static const EnumActionCreateFireOrderErrorCode EnumActionCreateFireOrderErrorCode_MIN =
    MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_EnumActionCreateFireOrderErrorCode_MIN;
  static const EnumActionCreateFireOrderErrorCode EnumActionCreateFireOrderErrorCode_MAX =
    MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_EnumActionCreateFireOrderErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  EnumActionCreateFireOrderErrorCode_descriptor() {
    return MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor();
  }
  static inline const ::std::string& EnumActionCreateFireOrderErrorCode_Name(EnumActionCreateFireOrderErrorCode value) {
    return MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_Name(value);
  }
  static inline bool EnumActionCreateFireOrderErrorCode_Parse(const ::std::string& name,
      EnumActionCreateFireOrderErrorCode* value) {
    return MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgActionCreateFireOrderAck.EnumActionCreateFireOrderErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgActionCreateFireOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlInformation : public ::google::protobuf::Message {
 public:
  MsgControlInformation();
  virtual ~MsgControlInformation();
  
  MsgControlInformation(const MsgControlInformation& from);
  
  inline MsgControlInformation& operator=(const MsgControlInformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlInformation& default_instance();
  void Swap(MsgControlInformation* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlInformation& from);
  void MergeFrom(const MsgControlInformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 current_tick = 1;
  inline bool has_current_tick() const;
  inline void clear_current_tick();
  static const int kCurrentTickFieldNumber = 1;
  inline ::google::protobuf::int32 current_tick() const;
  inline void set_current_tick(::google::protobuf::int32 value);
  
  // required .Common.MsgDateTime initial_date_time = 2;
  inline bool has_initial_date_time() const;
  inline void clear_initial_date_time();
  static const int kInitialDateTimeFieldNumber = 2;
  inline const ::Common::MsgDateTime& initial_date_time() const;
  inline ::Common::MsgDateTime* mutable_initial_date_time();
  
  // required .Common.MsgDateTime date_time = 3;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 3;
  inline const ::Common::MsgDateTime& date_time() const;
  inline ::Common::MsgDateTime* mutable_date_time();
  
  // required int32 tick_duration = 4;
  inline bool has_tick_duration() const;
  inline void clear_tick_duration();
  static const int kTickDurationFieldNumber = 4;
  inline ::google::protobuf::int32 tick_duration() const;
  inline void set_tick_duration(::google::protobuf::int32 value);
  
  // required int32 time_factor = 5;
  inline bool has_time_factor() const;
  inline void clear_time_factor();
  static const int kTimeFactorFieldNumber = 5;
  inline ::google::protobuf::int32 time_factor() const;
  inline void set_time_factor(::google::protobuf::int32 value);
  
  // required int32 checkpoint_frequency = 6;
  inline bool has_checkpoint_frequency() const;
  inline void clear_checkpoint_frequency();
  static const int kCheckpointFrequencyFieldNumber = 6;
  inline ::google::protobuf::int32 checkpoint_frequency() const;
  inline void set_checkpoint_frequency(::google::protobuf::int32 value);
  
  // required .Common.EnumSimulationState status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline Common::EnumSimulationState status() const;
  inline void set_status(Common::EnumSimulationState value);
  
  // required bool send_vision_cones = 8;
  inline bool has_send_vision_cones() const;
  inline void clear_send_vision_cones();
  static const int kSendVisionConesFieldNumber = 8;
  inline bool send_vision_cones() const;
  inline void set_send_vision_cones(bool value);
  
  // required bool profiling_enabled = 9;
  inline bool has_profiling_enabled() const;
  inline void clear_profiling_enabled();
  static const int kProfilingEnabledFieldNumber = 9;
  inline bool profiling_enabled() const;
  inline void set_profiling_enabled(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 current_tick_;
  ::Common::MsgDateTime* initial_date_time_;
  ::Common::MsgDateTime* date_time_;
  ::google::protobuf::int32 tick_duration_;
  ::google::protobuf::int32 time_factor_;
  ::google::protobuf::int32 checkpoint_frequency_;
  int status_;
  bool send_vision_cones_;
  bool profiling_enabled_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlInformation* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlProfilingInformation : public ::google::protobuf::Message {
 public:
  MsgControlProfilingInformation();
  virtual ~MsgControlProfilingInformation();
  
  MsgControlProfilingInformation(const MsgControlProfilingInformation& from);
  
  inline MsgControlProfilingInformation& operator=(const MsgControlProfilingInformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlProfilingInformation& default_instance();
  void Swap(MsgControlProfilingInformation* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlProfilingInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlProfilingInformation& from);
  void MergeFrom(const MsgControlProfilingInformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float perception = 1;
  inline bool has_perception() const;
  inline void clear_perception();
  static const int kPerceptionFieldNumber = 1;
  inline float perception() const;
  inline void set_perception(float value);
  
  // required float decision = 2;
  inline bool has_decision() const;
  inline void clear_decision();
  static const int kDecisionFieldNumber = 2;
  inline float decision() const;
  inline void set_decision(float value);
  
  // required float action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline float action() const;
  inline void set_action(float value);
  
  // required float main_loop = 4;
  inline bool has_main_loop() const;
  inline void clear_main_loop();
  static const int kMainLoopFieldNumber = 4;
  inline float main_loop() const;
  inline void set_main_loop(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float perception_;
  float decision_;
  float action_;
  float main_loop_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlProfilingInformation* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlBeginTick : public ::google::protobuf::Message {
 public:
  MsgControlBeginTick();
  virtual ~MsgControlBeginTick();
  
  MsgControlBeginTick(const MsgControlBeginTick& from);
  
  inline MsgControlBeginTick& operator=(const MsgControlBeginTick& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlBeginTick& default_instance();
  void Swap(MsgControlBeginTick* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlBeginTick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlBeginTick& from);
  void MergeFrom(const MsgControlBeginTick& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 current_tick = 1;
  inline bool has_current_tick() const;
  inline void clear_current_tick();
  static const int kCurrentTickFieldNumber = 1;
  inline ::google::protobuf::int32 current_tick() const;
  inline void set_current_tick(::google::protobuf::int32 value);
  
  // required .Common.MsgDateTime date_time = 2;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 2;
  inline const ::Common::MsgDateTime& date_time() const;
  inline ::Common::MsgDateTime* mutable_date_time();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 current_tick_;
  ::Common::MsgDateTime* date_time_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlBeginTick* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlEndTick : public ::google::protobuf::Message {
 public:
  MsgControlEndTick();
  virtual ~MsgControlEndTick();
  
  MsgControlEndTick(const MsgControlEndTick& from);
  
  inline MsgControlEndTick& operator=(const MsgControlEndTick& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlEndTick& default_instance();
  void Swap(MsgControlEndTick* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlEndTick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlEndTick& from);
  void MergeFrom(const MsgControlEndTick& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 current_tick = 1;
  inline bool has_current_tick() const;
  inline void clear_current_tick();
  static const int kCurrentTickFieldNumber = 1;
  inline ::google::protobuf::int32 current_tick() const;
  inline void set_current_tick(::google::protobuf::int32 value);
  
  // required int32 tick_duration = 2;
  inline bool has_tick_duration() const;
  inline void clear_tick_duration();
  static const int kTickDurationFieldNumber = 2;
  inline ::google::protobuf::int32 tick_duration() const;
  inline void set_tick_duration(::google::protobuf::int32 value);
  
  // required int32 long_pathfinds = 3;
  inline bool has_long_pathfinds() const;
  inline void clear_long_pathfinds();
  static const int kLongPathfindsFieldNumber = 3;
  inline ::google::protobuf::int32 long_pathfinds() const;
  inline void set_long_pathfinds(::google::protobuf::int32 value);
  
  // required int32 short_pathfinds = 4;
  inline bool has_short_pathfinds() const;
  inline void clear_short_pathfinds();
  static const int kShortPathfindsFieldNumber = 4;
  inline ::google::protobuf::int32 short_pathfinds() const;
  inline void set_short_pathfinds(::google::protobuf::int32 value);
  
  // required int32 memory = 5;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 5;
  inline ::google::protobuf::int32 memory() const;
  inline void set_memory(::google::protobuf::int32 value);
  
  // required int32 virtual_memory = 6;
  inline bool has_virtual_memory() const;
  inline void clear_virtual_memory();
  static const int kVirtualMemoryFieldNumber = 6;
  inline ::google::protobuf::int32 virtual_memory() const;
  inline void set_virtual_memory(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 current_tick_;
  ::google::protobuf::int32 tick_duration_;
  ::google::protobuf::int32 long_pathfinds_;
  ::google::protobuf::int32 short_pathfinds_;
  ::google::protobuf::int32 memory_;
  ::google::protobuf::int32 virtual_memory_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlEndTick* default_instance_;
};
// -------------------------------------------------------------------

class ControlAck : public ::google::protobuf::Message {
 public:
  ControlAck();
  virtual ~ControlAck();
  
  ControlAck(const ControlAck& from);
  
  inline ControlAck& operator=(const ControlAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlAck& default_instance();
  void Swap(ControlAck* other);
  
  // implements Message ----------------------------------------------
  
  ControlAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlAck& from);
  void MergeFrom(const ControlAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ControlAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = ControlAck_ErrorCode_no_error;
  static const ErrorCode error_already_started = ControlAck_ErrorCode_error_already_started;
  static const ErrorCode error_not_started = ControlAck_ErrorCode_error_not_started;
  static const ErrorCode error_not_paused = ControlAck_ErrorCode_error_not_paused;
  static const ErrorCode error_already_paused = ControlAck_ErrorCode_error_already_paused;
  static const ErrorCode error_invalid_time_factor = ControlAck_ErrorCode_error_invalid_time_factor;
  static const ErrorCode error_invalid_date_time = ControlAck_ErrorCode_error_invalid_date_time;
  static inline bool ErrorCode_IsValid(int value) {
    return ControlAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    ControlAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    ControlAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return ControlAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return ControlAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return ControlAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ControlAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlDatetimeChangeAck : public ::google::protobuf::Message {
 public:
  MsgControlDatetimeChangeAck();
  virtual ~MsgControlDatetimeChangeAck();
  
  MsgControlDatetimeChangeAck(const MsgControlDatetimeChangeAck& from);
  
  inline MsgControlDatetimeChangeAck& operator=(const MsgControlDatetimeChangeAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlDatetimeChangeAck& default_instance();
  void Swap(MsgControlDatetimeChangeAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlDatetimeChangeAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlDatetimeChangeAck& from);
  void MergeFrom(const MsgControlDatetimeChangeAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlDatetimeChangeAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlChangeTimeFactorAck : public ::google::protobuf::Message {
 public:
  MsgControlChangeTimeFactorAck();
  virtual ~MsgControlChangeTimeFactorAck();
  
  MsgControlChangeTimeFactorAck(const MsgControlChangeTimeFactorAck& from);
  
  inline MsgControlChangeTimeFactorAck& operator=(const MsgControlChangeTimeFactorAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlChangeTimeFactorAck& default_instance();
  void Swap(MsgControlChangeTimeFactorAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlChangeTimeFactorAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlChangeTimeFactorAck& from);
  void MergeFrom(const MsgControlChangeTimeFactorAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 time_factor = 1;
  inline bool has_time_factor() const;
  inline void clear_time_factor();
  static const int kTimeFactorFieldNumber = 1;
  inline ::google::protobuf::int32 time_factor() const;
  inline void set_time_factor(::google::protobuf::int32 value);
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 time_factor_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlChangeTimeFactorAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlStopAck : public ::google::protobuf::Message {
 public:
  MsgControlStopAck();
  virtual ~MsgControlStopAck();
  
  MsgControlStopAck(const MsgControlStopAck& from);
  
  inline MsgControlStopAck& operator=(const MsgControlStopAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlStopAck& default_instance();
  void Swap(MsgControlStopAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlStopAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlStopAck& from);
  void MergeFrom(const MsgControlStopAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlStopAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlPauseAck : public ::google::protobuf::Message {
 public:
  MsgControlPauseAck();
  virtual ~MsgControlPauseAck();
  
  MsgControlPauseAck(const MsgControlPauseAck& from);
  
  inline MsgControlPauseAck& operator=(const MsgControlPauseAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlPauseAck& default_instance();
  void Swap(MsgControlPauseAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlPauseAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlPauseAck& from);
  void MergeFrom(const MsgControlPauseAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlPauseAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlResumeAck : public ::google::protobuf::Message {
 public:
  MsgControlResumeAck();
  virtual ~MsgControlResumeAck();
  
  MsgControlResumeAck(const MsgControlResumeAck& from);
  
  inline MsgControlResumeAck& operator=(const MsgControlResumeAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlResumeAck& default_instance();
  void Swap(MsgControlResumeAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlResumeAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlResumeAck& from);
  void MergeFrom(const MsgControlResumeAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlResumeAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgPartyCreation : public ::google::protobuf::Message {
 public:
  MsgPartyCreation();
  virtual ~MsgPartyCreation();
  
  MsgPartyCreation(const MsgPartyCreation& from);
  
  inline MsgPartyCreation& operator=(const MsgPartyCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPartyCreation& default_instance();
  void Swap(MsgPartyCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgPartyCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPartyCreation& from);
  void MergeFrom(const MsgPartyCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PartyId party = 1;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 1;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .Common.EnumDiplomacy type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline Common::EnumDiplomacy type() const;
  inline void set_type(Common::EnumDiplomacy value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PartyId* party_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  int type_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPartyCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgFormationCreation : public ::google::protobuf::Message {
 public:
  MsgFormationCreation();
  virtual ~MsgFormationCreation();
  
  MsgFormationCreation(const MsgFormationCreation& from);
  
  inline MsgFormationCreation& operator=(const MsgFormationCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFormationCreation& default_instance();
  void Swap(MsgFormationCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgFormationCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFormationCreation& from);
  void MergeFrom(const MsgFormationCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FormationId formation = 1;
  inline bool has_formation() const;
  inline void clear_formation();
  static const int kFormationFieldNumber = 1;
  inline const ::Common::FormationId& formation() const;
  inline ::Common::FormationId* mutable_formation();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.FormationId parent = 3;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 3;
  inline const ::Common::FormationId& parent() const;
  inline ::Common::FormationId* mutable_parent();
  
  // required .Common.EnumNatureLevel level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline Common::EnumNatureLevel level() const;
  inline void set_level(Common::EnumNatureLevel value);
  
  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FormationId* formation_;
  ::Common::PartyId* party_;
  ::Common::FormationId* parent_;
  int level_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFormationCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatCreation : public ::google::protobuf::Message {
 public:
  MsgAutomatCreation();
  virtual ~MsgAutomatCreation();
  
  MsgAutomatCreation(const MsgAutomatCreation& from);
  
  inline MsgAutomatCreation& operator=(const MsgAutomatCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatCreation& default_instance();
  void Swap(MsgAutomatCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatCreation& from);
  void MergeFrom(const MsgAutomatCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId automat = 1;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 1;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
  // required .Common.AutomatType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::AutomatType& type() const;
  inline ::Common::AutomatType* mutable_type();
  
  // required string nom = 3;
  inline bool has_nom() const;
  inline void clear_nom();
  static const int kNomFieldNumber = 3;
  inline const ::std::string& nom() const;
  inline void set_nom(const ::std::string& value);
  inline void set_nom(const char* value);
  inline void set_nom(const char* value, size_t size);
  inline ::std::string* mutable_nom();
  
  // required .Common.ParentEntity parent = 4;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 4;
  inline const ::Common::ParentEntity& parent() const;
  inline ::Common::ParentEntity* mutable_parent();
  
  // required .Common.PartyId party = 5;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 5;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.KnowledgeGroupId knowledge_group = 6;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 6;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* automat_;
  ::Common::AutomatType* type_;
  ::std::string* nom_;
  static const ::std::string _default_nom_;
  ::Common::ParentEntity* parent_;
  ::Common::PartyId* party_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatCreation* default_instance_;
};
// -------------------------------------------------------------------

class RulesOfEngagement : public ::google::protobuf::Message {
 public:
  RulesOfEngagement();
  virtual ~RulesOfEngagement();
  
  RulesOfEngagement(const RulesOfEngagement& from);
  
  inline RulesOfEngagement& operator=(const RulesOfEngagement& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RulesOfEngagement& default_instance();
  void Swap(RulesOfEngagement* other);
  
  // implements Message ----------------------------------------------
  
  RulesOfEngagement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RulesOfEngagement& from);
  void MergeFrom(const RulesOfEngagement& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef RulesOfEngagement_Value Value;
  static const Value none_roe = RulesOfEngagement_Value_none_roe;
  static const Value tir_libre = RulesOfEngagement_Value_tir_libre;
  static const Value tir_sur_riposte = RulesOfEngagement_Value_tir_sur_riposte;
  static const Value tir_interdit = RulesOfEngagement_Value_tir_interdit;
  static inline bool Value_IsValid(int value) {
    return RulesOfEngagement_Value_IsValid(value);
  }
  static const Value Value_MIN =
    RulesOfEngagement_Value_Value_MIN;
  static const Value Value_MAX =
    RulesOfEngagement_Value_Value_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  Value_descriptor() {
    return RulesOfEngagement_Value_descriptor();
  }
  static inline const ::std::string& Value_Name(Value value) {
    return RulesOfEngagement_Value_Name(value);
  }
  static inline bool Value_Parse(const ::std::string& name,
      Value* value) {
    return RulesOfEngagement_Value_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RulesOfEngagement* default_instance_;
};
// -------------------------------------------------------------------

class ForceRatio : public ::google::protobuf::Message {
 public:
  ForceRatio();
  virtual ~ForceRatio();
  
  ForceRatio(const ForceRatio& from);
  
  inline ForceRatio& operator=(const ForceRatio& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForceRatio& default_instance();
  void Swap(ForceRatio* other);
  
  // implements Message ----------------------------------------------
  
  ForceRatio* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForceRatio& from);
  void MergeFrom(const ForceRatio& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ForceRatio_Value Value;
  static const Value none_force_ratio = ForceRatio_Value_none_force_ratio;
  static const Value neutre = ForceRatio_Value_neutre;
  static const Value favorable = ForceRatio_Value_favorable;
  static const Value defavorable = ForceRatio_Value_defavorable;
  static inline bool Value_IsValid(int value) {
    return ForceRatio_Value_IsValid(value);
  }
  static const Value Value_MIN =
    ForceRatio_Value_Value_MIN;
  static const Value Value_MAX =
    ForceRatio_Value_Value_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  Value_descriptor() {
    return ForceRatio_Value_descriptor();
  }
  static inline const ::std::string& Value_Name(Value value) {
    return ForceRatio_Value_Name(value);
  }
  static inline bool Value_Parse(const ::std::string& name,
      Value* value) {
    return ForceRatio_Value_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ForceRatio* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatAttributes : public ::google::protobuf::Message {
 public:
  MsgAutomatAttributes();
  virtual ~MsgAutomatAttributes();
  
  MsgAutomatAttributes(const MsgAutomatAttributes& from);
  
  inline MsgAutomatAttributes& operator=(const MsgAutomatAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatAttributes& default_instance();
  void Swap(MsgAutomatAttributes* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatAttributes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatAttributes& from);
  void MergeFrom(const MsgAutomatAttributes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId automat = 1;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 1;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
  // optional .Common.EnumAutomatMode etat_automate = 2;
  inline bool has_etat_automate() const;
  inline void clear_etat_automate();
  static const int kEtatAutomateFieldNumber = 2;
  inline Common::EnumAutomatMode etat_automate() const;
  inline void set_etat_automate(Common::EnumAutomatMode value);
  
  // optional .MsgsSimToClient.ForceRatio.Value rapport_de_force = 3;
  inline bool has_rapport_de_force() const;
  inline void clear_rapport_de_force();
  static const int kRapportDeForceFieldNumber = 3;
  inline ::MsgsSimToClient::ForceRatio_Value rapport_de_force() const;
  inline void set_rapport_de_force(::MsgsSimToClient::ForceRatio_Value value);
  
  // optional .Common.EnumMeetingEngagementStatus combat_de_rencontre = 4;
  inline bool has_combat_de_rencontre() const;
  inline void clear_combat_de_rencontre();
  static const int kCombatDeRencontreFieldNumber = 4;
  inline Common::EnumMeetingEngagementStatus combat_de_rencontre() const;
  inline void set_combat_de_rencontre(Common::EnumMeetingEngagementStatus value);
  
  // optional .Common.EnumOperationalStatus etat_operationnel = 5;
  inline bool has_etat_operationnel() const;
  inline void clear_etat_operationnel();
  static const int kEtatOperationnelFieldNumber = 5;
  inline Common::EnumOperationalStatus etat_operationnel() const;
  inline void set_etat_operationnel(Common::EnumOperationalStatus value);
  
  // optional .MsgsSimToClient.RulesOfEngagement.Value roe = 6;
  inline bool has_roe() const;
  inline void clear_roe();
  static const int kRoeFieldNumber = 6;
  inline ::MsgsSimToClient::RulesOfEngagement_Value roe() const;
  inline void set_roe(::MsgsSimToClient::RulesOfEngagement_Value value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* automat_;
  int etat_automate_;
  int rapport_de_force_;
  int combat_de_rencontre_;
  int etat_operationnel_;
  int roe_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatAttributes* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitCreation : public ::google::protobuf::Message {
 public:
  MsgUnitCreation();
  virtual ~MsgUnitCreation();
  
  MsgUnitCreation(const MsgUnitCreation& from);
  
  inline MsgUnitCreation& operator=(const MsgUnitCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitCreation& default_instance();
  void Swap(MsgUnitCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitCreation& from);
  void MergeFrom(const MsgUnitCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required .Common.UnitType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::UnitType& type() const;
  inline ::Common::UnitType* mutable_type();
  
  // required string nom = 3;
  inline bool has_nom() const;
  inline void clear_nom();
  static const int kNomFieldNumber = 3;
  inline const ::std::string& nom() const;
  inline void set_nom(const ::std::string& value);
  inline void set_nom(const char* value);
  inline void set_nom(const char* value, size_t size);
  inline ::std::string* mutable_nom();
  
  // required .Common.AutomatId automat = 4;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 4;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
  // required bool pc = 5;
  inline bool has_pc() const;
  inline void clear_pc();
  static const int kPcFieldNumber = 5;
  inline bool pc() const;
  inline void set_pc(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  ::Common::UnitType* type_;
  ::std::string* nom_;
  static const ::std::string _default_nom_;
  ::Common::AutomatId* automat_;
  bool pc_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitCreation* default_instance_;
};
// -------------------------------------------------------------------

class BorrowedEquipments_BorrowedEquipment : public ::google::protobuf::Message {
 public:
  BorrowedEquipments_BorrowedEquipment();
  virtual ~BorrowedEquipments_BorrowedEquipment();
  
  BorrowedEquipments_BorrowedEquipment(const BorrowedEquipments_BorrowedEquipment& from);
  
  inline BorrowedEquipments_BorrowedEquipment& operator=(const BorrowedEquipments_BorrowedEquipment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BorrowedEquipments_BorrowedEquipment& default_instance();
  void Swap(BorrowedEquipments_BorrowedEquipment* other);
  
  // implements Message ----------------------------------------------
  
  BorrowedEquipments_BorrowedEquipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BorrowedEquipments_BorrowedEquipment& from);
  void MergeFrom(const BorrowedEquipments_BorrowedEquipment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 1;
  inline const ::Common::UnitId& owner() const;
  inline ::Common::UnitId* mutable_owner();
  
  // required .Common.EquipmentType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::EquipmentType& type() const;
  inline ::Common::EquipmentType* mutable_type();
  
  // required int32 nombre = 3;
  inline bool has_nombre() const;
  inline void clear_nombre();
  static const int kNombreFieldNumber = 3;
  inline ::google::protobuf::int32 nombre() const;
  inline void set_nombre(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* owner_;
  ::Common::EquipmentType* type_;
  ::google::protobuf::int32 nombre_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BorrowedEquipments_BorrowedEquipment* default_instance_;
};
// -------------------------------------------------------------------

class BorrowedEquipments : public ::google::protobuf::Message {
 public:
  BorrowedEquipments();
  virtual ~BorrowedEquipments();
  
  BorrowedEquipments(const BorrowedEquipments& from);
  
  inline BorrowedEquipments& operator=(const BorrowedEquipments& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BorrowedEquipments& default_instance();
  void Swap(BorrowedEquipments* other);
  
  // implements Message ----------------------------------------------
  
  BorrowedEquipments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BorrowedEquipments& from);
  void MergeFrom(const BorrowedEquipments& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BorrowedEquipments_BorrowedEquipment BorrowedEquipment;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.BorrowedEquipments.BorrowedEquipment elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment >* mutable_elem();
  inline const ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment& elem(int index) const;
  inline ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment* mutable_elem(int index);
  inline ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BorrowedEquipments* default_instance_;
};
// -------------------------------------------------------------------

class LentEquipments_LentEquipment : public ::google::protobuf::Message {
 public:
  LentEquipments_LentEquipment();
  virtual ~LentEquipments_LentEquipment();
  
  LentEquipments_LentEquipment(const LentEquipments_LentEquipment& from);
  
  inline LentEquipments_LentEquipment& operator=(const LentEquipments_LentEquipment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LentEquipments_LentEquipment& default_instance();
  void Swap(LentEquipments_LentEquipment* other);
  
  // implements Message ----------------------------------------------
  
  LentEquipments_LentEquipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LentEquipments_LentEquipment& from);
  void MergeFrom(const LentEquipments_LentEquipment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId borrower = 1;
  inline bool has_borrower() const;
  inline void clear_borrower();
  static const int kBorrowerFieldNumber = 1;
  inline const ::Common::UnitId& borrower() const;
  inline ::Common::UnitId* mutable_borrower();
  
  // required .Common.EquipmentType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::EquipmentType& type() const;
  inline ::Common::EquipmentType* mutable_type();
  
  // required int32 nombre = 3;
  inline bool has_nombre() const;
  inline void clear_nombre();
  static const int kNombreFieldNumber = 3;
  inline ::google::protobuf::int32 nombre() const;
  inline void set_nombre(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* borrower_;
  ::Common::EquipmentType* type_;
  ::google::protobuf::int32 nombre_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LentEquipments_LentEquipment* default_instance_;
};
// -------------------------------------------------------------------

class LentEquipments : public ::google::protobuf::Message {
 public:
  LentEquipments();
  virtual ~LentEquipments();
  
  LentEquipments(const LentEquipments& from);
  
  inline LentEquipments& operator=(const LentEquipments& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LentEquipments& default_instance();
  void Swap(LentEquipments* other);
  
  // implements Message ----------------------------------------------
  
  LentEquipments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LentEquipments& from);
  void MergeFrom(const LentEquipments& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LentEquipments_LentEquipment LentEquipment;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.LentEquipments.LentEquipment elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment >* mutable_elem();
  inline const ::MsgsSimToClient::LentEquipments_LentEquipment& elem(int index) const;
  inline ::MsgsSimToClient::LentEquipments_LentEquipment* mutable_elem(int index);
  inline ::MsgsSimToClient::LentEquipments_LentEquipment* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LentEquipments* default_instance_;
};
// -------------------------------------------------------------------

class ResourceDotations_ResourceDotation : public ::google::protobuf::Message {
 public:
  ResourceDotations_ResourceDotation();
  virtual ~ResourceDotations_ResourceDotation();
  
  ResourceDotations_ResourceDotation(const ResourceDotations_ResourceDotation& from);
  
  inline ResourceDotations_ResourceDotation& operator=(const ResourceDotations_ResourceDotation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceDotations_ResourceDotation& default_instance();
  void Swap(ResourceDotations_ResourceDotation* other);
  
  // implements Message ----------------------------------------------
  
  ResourceDotations_ResourceDotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceDotations_ResourceDotation& from);
  void MergeFrom(const ResourceDotations_ResourceDotation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ResourceType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::Common::ResourceType& type() const;
  inline ::Common::ResourceType* mutable_type();
  
  // required int32 quantite_disponible = 2;
  inline bool has_quantite_disponible() const;
  inline void clear_quantite_disponible();
  static const int kQuantiteDisponibleFieldNumber = 2;
  inline ::google::protobuf::int32 quantite_disponible() const;
  inline void set_quantite_disponible(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ResourceType* type_;
  ::google::protobuf::int32 quantite_disponible_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResourceDotations_ResourceDotation* default_instance_;
};
// -------------------------------------------------------------------

class ResourceDotations : public ::google::protobuf::Message {
 public:
  ResourceDotations();
  virtual ~ResourceDotations();
  
  ResourceDotations(const ResourceDotations& from);
  
  inline ResourceDotations& operator=(const ResourceDotations& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceDotations& default_instance();
  void Swap(ResourceDotations* other);
  
  // implements Message ----------------------------------------------
  
  ResourceDotations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceDotations& from);
  void MergeFrom(const ResourceDotations& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ResourceDotations_ResourceDotation ResourceDotation;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.ResourceDotations.ResourceDotation elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation >* mutable_elem();
  inline const ::MsgsSimToClient::ResourceDotations_ResourceDotation& elem(int index) const;
  inline ::MsgsSimToClient::ResourceDotations_ResourceDotation* mutable_elem(int index);
  inline ::MsgsSimToClient::ResourceDotations_ResourceDotation* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResourceDotations* default_instance_;
};
// -------------------------------------------------------------------

class EquipmentDotations_EquipmentDotation : public ::google::protobuf::Message {
 public:
  EquipmentDotations_EquipmentDotation();
  virtual ~EquipmentDotations_EquipmentDotation();
  
  EquipmentDotations_EquipmentDotation(const EquipmentDotations_EquipmentDotation& from);
  
  inline EquipmentDotations_EquipmentDotation& operator=(const EquipmentDotations_EquipmentDotation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipmentDotations_EquipmentDotation& default_instance();
  void Swap(EquipmentDotations_EquipmentDotation* other);
  
  // implements Message ----------------------------------------------
  
  EquipmentDotations_EquipmentDotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipmentDotations_EquipmentDotation& from);
  void MergeFrom(const EquipmentDotations_EquipmentDotation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EquipmentType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::Common::EquipmentType& type() const;
  inline ::Common::EquipmentType* mutable_type();
  
  // required int32 nb_disponibles = 2;
  inline bool has_nb_disponibles() const;
  inline void clear_nb_disponibles();
  static const int kNbDisponiblesFieldNumber = 2;
  inline ::google::protobuf::int32 nb_disponibles() const;
  inline void set_nb_disponibles(::google::protobuf::int32 value);
  
  // required int32 nb_indisponibles = 3;
  inline bool has_nb_indisponibles() const;
  inline void clear_nb_indisponibles();
  static const int kNbIndisponiblesFieldNumber = 3;
  inline ::google::protobuf::int32 nb_indisponibles() const;
  inline void set_nb_indisponibles(::google::protobuf::int32 value);
  
  // required int32 nb_reparables = 4;
  inline bool has_nb_reparables() const;
  inline void clear_nb_reparables();
  static const int kNbReparablesFieldNumber = 4;
  inline ::google::protobuf::int32 nb_reparables() const;
  inline void set_nb_reparables(::google::protobuf::int32 value);
  
  // required int32 nb_dans_chaine_maintenance = 5;
  inline bool has_nb_dans_chaine_maintenance() const;
  inline void clear_nb_dans_chaine_maintenance();
  static const int kNbDansChaineMaintenanceFieldNumber = 5;
  inline ::google::protobuf::int32 nb_dans_chaine_maintenance() const;
  inline void set_nb_dans_chaine_maintenance(::google::protobuf::int32 value);
  
  // required int32 nb_prisonniers = 6;
  inline bool has_nb_prisonniers() const;
  inline void clear_nb_prisonniers();
  static const int kNbPrisonniersFieldNumber = 6;
  inline ::google::protobuf::int32 nb_prisonniers() const;
  inline void set_nb_prisonniers(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::EquipmentType* type_;
  ::google::protobuf::int32 nb_disponibles_;
  ::google::protobuf::int32 nb_indisponibles_;
  ::google::protobuf::int32 nb_reparables_;
  ::google::protobuf::int32 nb_dans_chaine_maintenance_;
  ::google::protobuf::int32 nb_prisonniers_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static EquipmentDotations_EquipmentDotation* default_instance_;
};
// -------------------------------------------------------------------

class EquipmentDotations : public ::google::protobuf::Message {
 public:
  EquipmentDotations();
  virtual ~EquipmentDotations();
  
  EquipmentDotations(const EquipmentDotations& from);
  
  inline EquipmentDotations& operator=(const EquipmentDotations& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipmentDotations& default_instance();
  void Swap(EquipmentDotations* other);
  
  // implements Message ----------------------------------------------
  
  EquipmentDotations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipmentDotations& from);
  void MergeFrom(const EquipmentDotations& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef EquipmentDotations_EquipmentDotation EquipmentDotation;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.EquipmentDotations.EquipmentDotation elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation >* mutable_elem();
  inline const ::MsgsSimToClient::EquipmentDotations_EquipmentDotation& elem(int index) const;
  inline ::MsgsSimToClient::EquipmentDotations_EquipmentDotation* mutable_elem(int index);
  inline ::MsgsSimToClient::EquipmentDotations_EquipmentDotation* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static EquipmentDotations* default_instance_;
};
// -------------------------------------------------------------------

class HumanDotations_HumanDotation : public ::google::protobuf::Message {
 public:
  HumanDotations_HumanDotation();
  virtual ~HumanDotations_HumanDotation();
  
  HumanDotations_HumanDotation(const HumanDotations_HumanDotation& from);
  
  inline HumanDotations_HumanDotation& operator=(const HumanDotations_HumanDotation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HumanDotations_HumanDotation& default_instance();
  void Swap(HumanDotations_HumanDotation* other);
  
  // implements Message ----------------------------------------------
  
  HumanDotations_HumanDotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HumanDotations_HumanDotation& from);
  void MergeFrom(const HumanDotations_HumanDotation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EnumHumanRank rang = 1;
  inline bool has_rang() const;
  inline void clear_rang();
  static const int kRangFieldNumber = 1;
  inline Common::EnumHumanRank rang() const;
  inline void set_rang(Common::EnumHumanRank value);
  
  // required int32 nb_total = 2;
  inline bool has_nb_total() const;
  inline void clear_nb_total();
  static const int kNbTotalFieldNumber = 2;
  inline ::google::protobuf::int32 nb_total() const;
  inline void set_nb_total(::google::protobuf::int32 value);
  
  // required int32 nb_operationnels = 3;
  inline bool has_nb_operationnels() const;
  inline void clear_nb_operationnels();
  static const int kNbOperationnelsFieldNumber = 3;
  inline ::google::protobuf::int32 nb_operationnels() const;
  inline void set_nb_operationnels(::google::protobuf::int32 value);
  
  // required int32 nb_morts = 4;
  inline bool has_nb_morts() const;
  inline void clear_nb_morts();
  static const int kNbMortsFieldNumber = 4;
  inline ::google::protobuf::int32 nb_morts() const;
  inline void set_nb_morts(::google::protobuf::int32 value);
  
  // required int32 nb_blesses = 5;
  inline bool has_nb_blesses() const;
  inline void clear_nb_blesses();
  static const int kNbBlessesFieldNumber = 5;
  inline ::google::protobuf::int32 nb_blesses() const;
  inline void set_nb_blesses(::google::protobuf::int32 value);
  
  // required int32 nb_blesses_mentaux = 6;
  inline bool has_nb_blesses_mentaux() const;
  inline void clear_nb_blesses_mentaux();
  static const int kNbBlessesMentauxFieldNumber = 6;
  inline ::google::protobuf::int32 nb_blesses_mentaux() const;
  inline void set_nb_blesses_mentaux(::google::protobuf::int32 value);
  
  // required int32 nb_contamines_nbc = 7;
  inline bool has_nb_contamines_nbc() const;
  inline void clear_nb_contamines_nbc();
  static const int kNbContaminesNbcFieldNumber = 7;
  inline ::google::protobuf::int32 nb_contamines_nbc() const;
  inline void set_nb_contamines_nbc(::google::protobuf::int32 value);
  
  // required int32 nb_dans_chaine_sante = 8;
  inline bool has_nb_dans_chaine_sante() const;
  inline void clear_nb_dans_chaine_sante();
  static const int kNbDansChaineSanteFieldNumber = 8;
  inline ::google::protobuf::int32 nb_dans_chaine_sante() const;
  inline void set_nb_dans_chaine_sante(::google::protobuf::int32 value);
  
  // required int32 nb_utilises_pour_maintenance = 9;
  inline bool has_nb_utilises_pour_maintenance() const;
  inline void clear_nb_utilises_pour_maintenance();
  static const int kNbUtilisesPourMaintenanceFieldNumber = 9;
  inline ::google::protobuf::int32 nb_utilises_pour_maintenance() const;
  inline void set_nb_utilises_pour_maintenance(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int rang_;
  ::google::protobuf::int32 nb_total_;
  ::google::protobuf::int32 nb_operationnels_;
  ::google::protobuf::int32 nb_morts_;
  ::google::protobuf::int32 nb_blesses_;
  ::google::protobuf::int32 nb_blesses_mentaux_;
  ::google::protobuf::int32 nb_contamines_nbc_;
  ::google::protobuf::int32 nb_dans_chaine_sante_;
  ::google::protobuf::int32 nb_utilises_pour_maintenance_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HumanDotations_HumanDotation* default_instance_;
};
// -------------------------------------------------------------------

class HumanDotations : public ::google::protobuf::Message {
 public:
  HumanDotations();
  virtual ~HumanDotations();
  
  HumanDotations(const HumanDotations& from);
  
  inline HumanDotations& operator=(const HumanDotations& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HumanDotations& default_instance();
  void Swap(HumanDotations* other);
  
  // implements Message ----------------------------------------------
  
  HumanDotations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HumanDotations& from);
  void MergeFrom(const HumanDotations& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef HumanDotations_HumanDotation HumanDotation;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.HumanDotations.HumanDotation elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation >* mutable_elem();
  inline const ::MsgsSimToClient::HumanDotations_HumanDotation& elem(int index) const;
  inline ::MsgsSimToClient::HumanDotations_HumanDotation* mutable_elem(int index);
  inline ::MsgsSimToClient::HumanDotations_HumanDotation* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HumanDotations* default_instance_;
};
// -------------------------------------------------------------------

class ContaminationState : public ::google::protobuf::Message {
 public:
  ContaminationState();
  virtual ~ContaminationState();
  
  ContaminationState(const ContaminationState& from);
  
  inline ContaminationState& operator=(const ContaminationState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContaminationState& default_instance();
  void Swap(ContaminationState* other);
  
  // implements Message ----------------------------------------------
  
  ContaminationState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContaminationState& from);
  void MergeFrom(const ContaminationState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 percentage = 1;
  inline bool has_percentage() const;
  inline void clear_percentage();
  static const int kPercentageFieldNumber = 1;
  inline ::google::protobuf::int32 percentage() const;
  inline void set_percentage(::google::protobuf::int32 value);
  
  // optional float quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline float quantity() const;
  inline void set_quantity(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 percentage_;
  float quantity_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ContaminationState* default_instance_;
};
// -------------------------------------------------------------------

class NBCAgents : public ::google::protobuf::Message {
 public:
  NBCAgents();
  virtual ~NBCAgents();
  
  NBCAgents(const NBCAgents& from);
  
  inline NBCAgents& operator=(const NBCAgents& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NBCAgents& default_instance();
  void Swap(NBCAgents* other);
  
  // implements Message ----------------------------------------------
  
  NBCAgents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NBCAgents& from);
  void MergeFrom(const NBCAgents& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Common.NBCAgentType elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType >* mutable_elem();
  inline const ::Common::NBCAgentType& elem(int index) const;
  inline ::Common::NBCAgentType* mutable_elem(int index);
  inline ::Common::NBCAgentType* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NBCAgents* default_instance_;
};
// -------------------------------------------------------------------

class Communication : public ::google::protobuf::Message {
 public:
  Communication();
  virtual ~Communication();
  
  Communication(const Communication& from);
  
  inline Communication& operator=(const Communication& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Communication& default_instance();
  void Swap(Communication* other);
  
  // implements Message ----------------------------------------------
  
  Communication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Communication& from);
  void MergeFrom(const Communication& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool jammed = 1;
  inline bool has_jammed() const;
  inline void clear_jammed();
  static const int kJammedFieldNumber = 1;
  inline bool jammed() const;
  inline void set_jammed(bool value);
  
  // optional .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool jammed_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Communication* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitAttributes : public ::google::protobuf::Message {
 public:
  MsgUnitAttributes();
  virtual ~MsgUnitAttributes();
  
  MsgUnitAttributes(const MsgUnitAttributes& from);
  
  inline MsgUnitAttributes& operator=(const MsgUnitAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitAttributes& default_instance();
  void Swap(MsgUnitAttributes* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitAttributes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitAttributes& from);
  void MergeFrom(const MsgUnitAttributes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgUnitAttributes_Posture Posture;
  static const Posture mouvement = MsgUnitAttributes_Posture_mouvement;
  static const Posture mouvement_discret = MsgUnitAttributes_Posture_mouvement_discret;
  static const Posture arret = MsgUnitAttributes_Posture_arret;
  static const Posture poste_reflexe = MsgUnitAttributes_Posture_poste_reflexe;
  static const Posture poste = MsgUnitAttributes_Posture_poste;
  static const Posture poste_amenage = MsgUnitAttributes_Posture_poste_amenage;
  static const Posture poste_prepare_genie = MsgUnitAttributes_Posture_poste_prepare_genie;
  static inline bool Posture_IsValid(int value) {
    return MsgUnitAttributes_Posture_IsValid(value);
  }
  static const Posture Posture_MIN =
    MsgUnitAttributes_Posture_Posture_MIN;
  static const Posture Posture_MAX =
    MsgUnitAttributes_Posture_Posture_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  Posture_descriptor() {
    return MsgUnitAttributes_Posture_descriptor();
  }
  static inline const ::std::string& Posture_Name(Posture value) {
    return MsgUnitAttributes_Posture_Name(value);
  }
  static inline bool Posture_Parse(const ::std::string& name,
      Posture* value) {
    return MsgUnitAttributes_Posture_Parse(name, value);
  }
  
  typedef MsgUnitAttributes_FireAvailability FireAvailability;
  static const FireAvailability none_fire_available = MsgUnitAttributes_FireAvailability_none_fire_available;
  static const FireAvailability pret_au_tir = MsgUnitAttributes_FireAvailability_pret_au_tir;
  static const FireAvailability indisponible = MsgUnitAttributes_FireAvailability_indisponible;
  static inline bool FireAvailability_IsValid(int value) {
    return MsgUnitAttributes_FireAvailability_IsValid(value);
  }
  static const FireAvailability FireAvailability_MIN =
    MsgUnitAttributes_FireAvailability_FireAvailability_MIN;
  static const FireAvailability FireAvailability_MAX =
    MsgUnitAttributes_FireAvailability_FireAvailability_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  FireAvailability_descriptor() {
    return MsgUnitAttributes_FireAvailability_descriptor();
  }
  static inline const ::std::string& FireAvailability_Name(FireAvailability value) {
    return MsgUnitAttributes_FireAvailability_Name(value);
  }
  static inline bool FireAvailability_Parse(const ::std::string& name,
      FireAvailability* value) {
    return MsgUnitAttributes_FireAvailability_Parse(name, value);
  }
  
  typedef MsgUnitAttributes_CrowdRoe CrowdRoe;
  static const CrowdRoe none = MsgUnitAttributes_CrowdRoe_none;
  static const CrowdRoe emploi_force_interdit = MsgUnitAttributes_CrowdRoe_emploi_force_interdit;
  static const CrowdRoe maintien_a_distance_par_moyens_non_letaux = MsgUnitAttributes_CrowdRoe_maintien_a_distance_par_moyens_non_letaux;
  static const CrowdRoe dispersion_par_moyens_de_defense_actifs = MsgUnitAttributes_CrowdRoe_dispersion_par_moyens_de_defense_actifs;
  static const CrowdRoe armes_letales_autorisees = MsgUnitAttributes_CrowdRoe_armes_letales_autorisees;
  static inline bool CrowdRoe_IsValid(int value) {
    return MsgUnitAttributes_CrowdRoe_IsValid(value);
  }
  static const CrowdRoe CrowdRoe_MIN =
    MsgUnitAttributes_CrowdRoe_CrowdRoe_MIN;
  static const CrowdRoe CrowdRoe_MAX =
    MsgUnitAttributes_CrowdRoe_CrowdRoe_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  CrowdRoe_descriptor() {
    return MsgUnitAttributes_CrowdRoe_descriptor();
  }
  static inline const ::std::string& CrowdRoe_Name(CrowdRoe value) {
    return MsgUnitAttributes_CrowdRoe_Name(value);
  }
  static inline bool CrowdRoe_Parse(const ::std::string& name,
      CrowdRoe* value) {
    return MsgUnitAttributes_CrowdRoe_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // optional .MsgsSimToClient.HumanDotations dotation_eff_personnel = 2;
  inline bool has_dotation_eff_personnel() const;
  inline void clear_dotation_eff_personnel();
  static const int kDotationEffPersonnelFieldNumber = 2;
  inline const ::MsgsSimToClient::HumanDotations& dotation_eff_personnel() const;
  inline ::MsgsSimToClient::HumanDotations* mutable_dotation_eff_personnel();
  
  // optional .MsgsSimToClient.EquipmentDotations dotation_eff_materiel = 3;
  inline bool has_dotation_eff_materiel() const;
  inline void clear_dotation_eff_materiel();
  static const int kDotationEffMaterielFieldNumber = 3;
  inline const ::MsgsSimToClient::EquipmentDotations& dotation_eff_materiel() const;
  inline ::MsgsSimToClient::EquipmentDotations* mutable_dotation_eff_materiel();
  
  // optional .MsgsSimToClient.ResourceDotations dotation_eff_ressource = 4;
  inline bool has_dotation_eff_ressource() const;
  inline void clear_dotation_eff_ressource();
  static const int kDotationEffRessourceFieldNumber = 4;
  inline const ::MsgsSimToClient::ResourceDotations& dotation_eff_ressource() const;
  inline ::MsgsSimToClient::ResourceDotations* mutable_dotation_eff_ressource();
  
  // optional .MsgsSimToClient.LentEquipments equipements_pretes = 5;
  inline bool has_equipements_pretes() const;
  inline void clear_equipements_pretes();
  static const int kEquipementsPretesFieldNumber = 5;
  inline const ::MsgsSimToClient::LentEquipments& equipements_pretes() const;
  inline ::MsgsSimToClient::LentEquipments* mutable_equipements_pretes();
  
  // optional .MsgsSimToClient.BorrowedEquipments equipements_empruntes = 6;
  inline bool has_equipements_empruntes() const;
  inline void clear_equipements_empruntes();
  static const int kEquipementsEmpruntesFieldNumber = 6;
  inline const ::MsgsSimToClient::BorrowedEquipments& equipements_empruntes() const;
  inline ::MsgsSimToClient::BorrowedEquipments* mutable_equipements_empruntes();
  
  // optional .Common.MsgCoordLatLong position = 7;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 7;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
  // optional .Common.MsgHeading direction = 8;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 8;
  inline const ::Common::MsgHeading& direction() const;
  inline ::Common::MsgHeading* mutable_direction();
  
  // optional int32 hauteur = 9;
  inline bool has_hauteur() const;
  inline void clear_hauteur();
  static const int kHauteurFieldNumber = 9;
  inline ::google::protobuf::int32 hauteur() const;
  inline void set_hauteur(::google::protobuf::int32 value);
  
  // optional int32 altitude = 10;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 10;
  inline ::google::protobuf::int32 altitude() const;
  inline void set_altitude(::google::protobuf::int32 value);
  
  // optional int32 vitesse = 11;
  inline bool has_vitesse() const;
  inline void clear_vitesse();
  static const int kVitesseFieldNumber = 11;
  inline ::google::protobuf::int32 vitesse() const;
  inline void set_vitesse(::google::protobuf::int32 value);
  
  // optional int32 etat_operationnel_brut = 12;
  inline bool has_etat_operationnel_brut() const;
  inline void clear_etat_operationnel_brut();
  static const int kEtatOperationnelBrutFieldNumber = 12;
  inline ::google::protobuf::int32 etat_operationnel_brut() const;
  inline void set_etat_operationnel_brut(::google::protobuf::int32 value);
  
  // optional .Common.UnitIdList reinforcements = 13;
  inline bool has_reinforcements() const;
  inline void clear_reinforcements();
  static const int kReinforcementsFieldNumber = 13;
  inline const ::Common::UnitIdList& reinforcements() const;
  inline ::Common::UnitIdList* mutable_reinforcements();
  
  // optional .Common.UnitId reinforced_unit = 14;
  inline bool has_reinforced_unit() const;
  inline void clear_reinforced_unit();
  static const int kReinforcedUnitFieldNumber = 14;
  inline const ::Common::UnitId& reinforced_unit() const;
  inline ::Common::UnitId* mutable_reinforced_unit();
  
  // optional bool mort = 15;
  inline bool has_mort() const;
  inline void clear_mort();
  static const int kMortFieldNumber = 15;
  inline bool mort() const;
  inline void set_mort(bool value);
  
  // optional bool neutralise = 16;
  inline bool has_neutralise() const;
  inline void clear_neutralise();
  static const int kNeutraliseFieldNumber = 16;
  inline bool neutralise() const;
  inline void set_neutralise(bool value);
  
  // optional bool mode_furtif_actif = 17;
  inline bool has_mode_furtif_actif() const;
  inline void clear_mode_furtif_actif();
  static const int kModeFurtifActifFieldNumber = 17;
  inline bool mode_furtif_actif() const;
  inline void set_mode_furtif_actif(bool value);
  
  // optional bool embarque = 18;
  inline bool has_embarque() const;
  inline void clear_embarque();
  static const int kEmbarqueFieldNumber = 18;
  inline bool embarque() const;
  inline void set_embarque(bool value);
  
  // optional bool transporteurs_disponibles = 19;
  inline bool has_transporteurs_disponibles() const;
  inline void clear_transporteurs_disponibles();
  static const int kTransporteursDisponiblesFieldNumber = 19;
  inline bool transporteurs_disponibles() const;
  inline void set_transporteurs_disponibles(bool value);
  
  // optional .MsgsSimToClient.MsgUnitAttributes.Posture posture_old = 20;
  inline bool has_posture_old() const;
  inline void clear_posture_old();
  static const int kPostureOldFieldNumber = 20;
  inline ::MsgsSimToClient::MsgUnitAttributes_Posture posture_old() const;
  inline void set_posture_old(::MsgsSimToClient::MsgUnitAttributes_Posture value);
  
  // optional .MsgsSimToClient.MsgUnitAttributes.Posture posture_new = 21;
  inline bool has_posture_new() const;
  inline void clear_posture_new();
  static const int kPostureNewFieldNumber = 21;
  inline ::MsgsSimToClient::MsgUnitAttributes_Posture posture_new() const;
  inline void set_posture_new(::MsgsSimToClient::MsgUnitAttributes_Posture value);
  
  // optional int32 posture_pourcentage = 22;
  inline bool has_posture_pourcentage() const;
  inline void clear_posture_pourcentage();
  static const int kPosturePourcentageFieldNumber = 22;
  inline ::google::protobuf::int32 posture_pourcentage() const;
  inline void set_posture_pourcentage(::google::protobuf::int32 value);
  
  // optional int32 etat_installation = 23;
  inline bool has_etat_installation() const;
  inline void clear_etat_installation();
  static const int kEtatInstallationFieldNumber = 23;
  inline ::google::protobuf::int32 etat_installation() const;
  inline void set_etat_installation(::google::protobuf::int32 value);
  
  // optional bool en_tenue_de_protection_nbc = 24;
  inline bool has_en_tenue_de_protection_nbc() const;
  inline void clear_en_tenue_de_protection_nbc();
  static const int kEnTenueDeProtectionNbcFieldNumber = 24;
  inline bool en_tenue_de_protection_nbc() const;
  inline void set_en_tenue_de_protection_nbc(bool value);
  
  // optional .MsgsSimToClient.NBCAgents contamine_par_agents_nbc = 25;
  inline bool has_contamine_par_agents_nbc() const;
  inline void clear_contamine_par_agents_nbc();
  static const int kContamineParAgentsNbcFieldNumber = 25;
  inline const ::MsgsSimToClient::NBCAgents& contamine_par_agents_nbc() const;
  inline ::MsgsSimToClient::NBCAgents* mutable_contamine_par_agents_nbc();
  
  // optional .MsgsSimToClient.ContaminationState etat_contamination = 26;
  inline bool has_etat_contamination() const;
  inline void clear_etat_contamination();
  static const int kEtatContaminationFieldNumber = 26;
  inline const ::MsgsSimToClient::ContaminationState& etat_contamination() const;
  inline ::MsgsSimToClient::ContaminationState* mutable_etat_contamination();
  
  // optional .MsgsSimToClient.Communication communications = 27;
  inline bool has_communications() const;
  inline void clear_communications();
  static const int kCommunicationsFieldNumber = 27;
  inline const ::MsgsSimToClient::Communication& communications() const;
  inline ::MsgsSimToClient::Communication* mutable_communications();
  
  // optional bool radio_emitter_disabled = 28;
  inline bool has_radio_emitter_disabled() const;
  inline void clear_radio_emitter_disabled();
  static const int kRadioEmitterDisabledFieldNumber = 28;
  inline bool radio_emitter_disabled() const;
  inline void set_radio_emitter_disabled(bool value);
  
  // optional bool radio_receiver_disabled = 29;
  inline bool has_radio_receiver_disabled() const;
  inline void clear_radio_receiver_disabled();
  static const int kRadioReceiverDisabledFieldNumber = 29;
  inline bool radio_receiver_disabled() const;
  inline void set_radio_receiver_disabled(bool value);
  
  // optional bool radar_actif = 30;
  inline bool has_radar_actif() const;
  inline void clear_radar_actif();
  static const int kRadarActifFieldNumber = 30;
  inline bool radar_actif() const;
  inline void set_radar_actif(bool value);
  
  // optional .Common.UnitIdList transported_units = 31;
  inline bool has_transported_units() const;
  inline void clear_transported_units();
  static const int kTransportedUnitsFieldNumber = 31;
  inline const ::Common::UnitIdList& transported_units() const;
  inline ::Common::UnitIdList* mutable_transported_units();
  
  // optional .Common.UnitId transporting_unit = 32;
  inline bool has_transporting_unit() const;
  inline void clear_transporting_unit();
  static const int kTransportingUnitFieldNumber = 32;
  inline const ::Common::UnitId& transporting_unit() const;
  inline ::Common::UnitId* mutable_transporting_unit();
  
  // optional .MsgsSimToClient.ForceRatio.Value rapport_de_force = 33;
  inline bool has_rapport_de_force() const;
  inline void clear_rapport_de_force();
  static const int kRapportDeForceFieldNumber = 33;
  inline ::MsgsSimToClient::ForceRatio_Value rapport_de_force() const;
  inline void set_rapport_de_force(::MsgsSimToClient::ForceRatio_Value value);
  
  // optional .Common.EnumMeetingEngagementStatus combat_de_rencontre = 34;
  inline bool has_combat_de_rencontre() const;
  inline void clear_combat_de_rencontre();
  static const int kCombatDeRencontreFieldNumber = 34;
  inline Common::EnumMeetingEngagementStatus combat_de_rencontre() const;
  inline void set_combat_de_rencontre(Common::EnumMeetingEngagementStatus value);
  
  // optional .Common.EnumOperationalStatus etat_operationnel = 35;
  inline bool has_etat_operationnel() const;
  inline void clear_etat_operationnel();
  static const int kEtatOperationnelFieldNumber = 35;
  inline Common::EnumOperationalStatus etat_operationnel() const;
  inline void set_etat_operationnel(Common::EnumOperationalStatus value);
  
  // optional .MsgsSimToClient.MsgUnitAttributes.FireAvailability disponibilite_au_tir_indirect = 36;
  inline bool has_disponibilite_au_tir_indirect() const;
  inline void clear_disponibilite_au_tir_indirect();
  static const int kDisponibiliteAuTirIndirectFieldNumber = 36;
  inline ::MsgsSimToClient::MsgUnitAttributes_FireAvailability disponibilite_au_tir_indirect() const;
  inline void set_disponibilite_au_tir_indirect(::MsgsSimToClient::MsgUnitAttributes_FireAvailability value);
  
  // optional .MsgsSimToClient.RulesOfEngagement.Value roe = 37;
  inline bool has_roe() const;
  inline void clear_roe();
  static const int kRoeFieldNumber = 37;
  inline ::MsgsSimToClient::RulesOfEngagement_Value roe() const;
  inline void set_roe(::MsgsSimToClient::RulesOfEngagement_Value value);
  
  // optional .MsgsSimToClient.MsgUnitAttributes.CrowdRoe roe_crowd = 38;
  inline bool has_roe_crowd() const;
  inline void clear_roe_crowd();
  static const int kRoeCrowdFieldNumber = 38;
  inline ::MsgsSimToClient::MsgUnitAttributes_CrowdRoe roe_crowd() const;
  inline void set_roe_crowd(::MsgsSimToClient::MsgUnitAttributes_CrowdRoe value);
  
  // optional .Common.EnumUnitTiredness fatigue = 39;
  inline bool has_fatigue() const;
  inline void clear_fatigue();
  static const int kFatigueFieldNumber = 39;
  inline Common::EnumUnitTiredness fatigue() const;
  inline void set_fatigue(Common::EnumUnitTiredness value);
  
  // optional .Common.EnumUnitMorale moral = 40;
  inline bool has_moral() const;
  inline void clear_moral();
  static const int kMoralFieldNumber = 40;
  inline Common::EnumUnitMorale moral() const;
  inline void set_moral(Common::EnumUnitMorale value);
  
  // optional .Common.EnumUnitExperience experience = 41;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 41;
  inline Common::EnumUnitExperience experience() const;
  inline void set_experience(Common::EnumUnitExperience value);
  
  // optional .Common.UnitId surrendered_unit = 42;
  inline bool has_surrendered_unit() const;
  inline void clear_surrendered_unit();
  static const int kSurrenderedUnitFieldNumber = 42;
  inline const ::Common::UnitId& surrendered_unit() const;
  inline ::Common::UnitId* mutable_surrendered_unit();
  
  // optional bool prisonnier = 43;
  inline bool has_prisonnier() const;
  inline void clear_prisonnier();
  static const int kPrisonnierFieldNumber = 43;
  inline bool prisonnier() const;
  inline void set_prisonnier(bool value);
  
  // optional bool refugie_pris_en_compte = 44;
  inline bool has_refugie_pris_en_compte() const;
  inline void clear_refugie_pris_en_compte();
  static const int kRefugiePrisEnCompteFieldNumber = 44;
  inline bool refugie_pris_en_compte() const;
  inline void set_refugie_pris_en_compte(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  ::MsgsSimToClient::HumanDotations* dotation_eff_personnel_;
  ::MsgsSimToClient::EquipmentDotations* dotation_eff_materiel_;
  ::MsgsSimToClient::ResourceDotations* dotation_eff_ressource_;
  ::MsgsSimToClient::LentEquipments* equipements_pretes_;
  ::MsgsSimToClient::BorrowedEquipments* equipements_empruntes_;
  ::Common::MsgCoordLatLong* position_;
  ::Common::MsgHeading* direction_;
  ::google::protobuf::int32 hauteur_;
  ::google::protobuf::int32 altitude_;
  ::google::protobuf::int32 vitesse_;
  ::google::protobuf::int32 etat_operationnel_brut_;
  ::Common::UnitIdList* reinforcements_;
  ::Common::UnitId* reinforced_unit_;
  bool mort_;
  bool neutralise_;
  bool mode_furtif_actif_;
  bool embarque_;
  bool transporteurs_disponibles_;
  int posture_old_;
  int posture_new_;
  ::google::protobuf::int32 posture_pourcentage_;
  ::google::protobuf::int32 etat_installation_;
  bool en_tenue_de_protection_nbc_;
  ::MsgsSimToClient::NBCAgents* contamine_par_agents_nbc_;
  ::MsgsSimToClient::ContaminationState* etat_contamination_;
  ::MsgsSimToClient::Communication* communications_;
  bool radio_emitter_disabled_;
  bool radio_receiver_disabled_;
  bool radar_actif_;
  ::Common::UnitIdList* transported_units_;
  ::Common::UnitId* transporting_unit_;
  int rapport_de_force_;
  int combat_de_rencontre_;
  int etat_operationnel_;
  int disponibilite_au_tir_indirect_;
  int roe_;
  int roe_crowd_;
  int fatigue_;
  int moral_;
  int experience_;
  ::Common::UnitId* surrendered_unit_;
  bool prisonnier_;
  bool refugie_pris_en_compte_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(44 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitAttributes* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitPathFind : public ::google::protobuf::Message {
 public:
  MsgUnitPathFind();
  virtual ~MsgUnitPathFind();
  
  MsgUnitPathFind(const MsgUnitPathFind& from);
  
  inline MsgUnitPathFind& operator=(const MsgUnitPathFind& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitPathFind& default_instance();
  void Swap(MsgUnitPathFind* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitPathFind* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitPathFind& from);
  void MergeFrom(const MsgUnitPathFind& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required .Common.MsgPath itineraire = 2;
  inline bool has_itineraire() const;
  inline void clear_itineraire();
  static const int kItineraireFieldNumber = 2;
  inline const ::Common::MsgPath& itineraire() const;
  inline ::Common::MsgPath* mutable_itineraire();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  ::Common::MsgPath* itineraire_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitPathFind* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitDestruction : public ::google::protobuf::Message {
 public:
  MsgUnitDestruction();
  virtual ~MsgUnitDestruction();
  
  MsgUnitDestruction(const MsgUnitDestruction& from);
  
  inline MsgUnitDestruction& operator=(const MsgUnitDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitDestruction& default_instance();
  void Swap(MsgUnitDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitDestruction& from);
  void MergeFrom(const MsgUnitDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitEnvironmentType : public ::google::protobuf::Message {
 public:
  MsgUnitEnvironmentType();
  virtual ~MsgUnitEnvironmentType();
  
  MsgUnitEnvironmentType(const MsgUnitEnvironmentType& from);
  
  inline MsgUnitEnvironmentType& operator=(const MsgUnitEnvironmentType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitEnvironmentType& default_instance();
  void Swap(MsgUnitEnvironmentType* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitEnvironmentType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitEnvironmentType& from);
  void MergeFrom(const MsgUnitEnvironmentType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required int32 area = 2;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 2;
  inline ::google::protobuf::int32 area() const;
  inline void set_area(::google::protobuf::int32 value);
  
  // required int32 left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required int32 right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required int32 linear = 5;
  inline bool has_linear() const;
  inline void clear_linear();
  static const int kLinearFieldNumber = 5;
  inline ::google::protobuf::int32 linear() const;
  inline void set_linear(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  ::google::protobuf::int32 area_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 linear_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitEnvironmentType* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgUnitKnowledgeCreation();
  virtual ~MsgUnitKnowledgeCreation();
  
  MsgUnitKnowledgeCreation(const MsgUnitKnowledgeCreation& from);
  
  inline MsgUnitKnowledgeCreation& operator=(const MsgUnitKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitKnowledgeCreation& default_instance();
  void Swap(MsgUnitKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitKnowledgeCreation& from);
  void MergeFrom(const MsgUnitKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::UnitKnowledgeId& knowledge() const;
  inline ::Common::UnitKnowledgeId* mutable_knowledge();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .Common.UnitId unit = 3;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 3;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required .Common.UnitType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::Common::UnitType& type() const;
  inline ::Common::UnitType* mutable_type();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitKnowledgeId* knowledge_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::UnitId* unit_;
  ::Common::UnitType* type_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class AutomatPerception : public ::google::protobuf::Message {
 public:
  AutomatPerception();
  virtual ~AutomatPerception();
  
  AutomatPerception(const AutomatPerception& from);
  
  inline AutomatPerception& operator=(const AutomatPerception& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AutomatPerception& default_instance();
  void Swap(AutomatPerception* other);
  
  // implements Message ----------------------------------------------
  
  AutomatPerception* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutomatPerception& from);
  void MergeFrom(const AutomatPerception& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId automat = 1;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 1;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
  // required .MsgsSimToClient.EnumUnitIdentificationLevel identification_level = 2;
  inline bool has_identification_level() const;
  inline void clear_identification_level();
  static const int kIdentificationLevelFieldNumber = 2;
  inline MsgsSimToClient::EnumUnitIdentificationLevel identification_level() const;
  inline void set_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* automat_;
  int identification_level_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AutomatPerception* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfAutomatPerception : public ::google::protobuf::Message {
 public:
  SeqOfAutomatPerception();
  virtual ~SeqOfAutomatPerception();
  
  SeqOfAutomatPerception(const SeqOfAutomatPerception& from);
  
  inline SeqOfAutomatPerception& operator=(const SeqOfAutomatPerception& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfAutomatPerception& default_instance();
  void Swap(SeqOfAutomatPerception* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfAutomatPerception* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfAutomatPerception& from);
  void MergeFrom(const SeqOfAutomatPerception& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.AutomatPerception elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception >* mutable_elem();
  inline const ::MsgsSimToClient::AutomatPerception& elem(int index) const;
  inline ::MsgsSimToClient::AutomatPerception* mutable_elem(int index);
  inline ::MsgsSimToClient::AutomatPerception* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfAutomatPerception* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgUnitKnowledgeUpdate();
  virtual ~MsgUnitKnowledgeUpdate();
  
  MsgUnitKnowledgeUpdate(const MsgUnitKnowledgeUpdate& from);
  
  inline MsgUnitKnowledgeUpdate& operator=(const MsgUnitKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitKnowledgeUpdate& default_instance();
  void Swap(MsgUnitKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitKnowledgeUpdate& from);
  void MergeFrom(const MsgUnitKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::UnitKnowledgeId& knowledge() const;
  inline ::Common::UnitKnowledgeId* mutable_knowledge();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional int32 pertinence = 3;
  inline bool has_pertinence() const;
  inline void clear_pertinence();
  static const int kPertinenceFieldNumber = 3;
  inline ::google::protobuf::int32 pertinence() const;
  inline void set_pertinence(::google::protobuf::int32 value);
  
  // optional .MsgsSimToClient.EnumUnitIdentificationLevel identification_level = 4;
  inline bool has_identification_level() const;
  inline void clear_identification_level();
  static const int kIdentificationLevelFieldNumber = 4;
  inline MsgsSimToClient::EnumUnitIdentificationLevel identification_level() const;
  inline void set_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value);
  
  // optional .MsgsSimToClient.EnumUnitIdentificationLevel max_identification_level = 5;
  inline bool has_max_identification_level() const;
  inline void clear_max_identification_level();
  static const int kMaxIdentificationLevelFieldNumber = 5;
  inline MsgsSimToClient::EnumUnitIdentificationLevel max_identification_level() const;
  inline void set_max_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value);
  
  // optional int32 etat_op = 6;
  inline bool has_etat_op() const;
  inline void clear_etat_op();
  static const int kEtatOpFieldNumber = 6;
  inline ::google::protobuf::int32 etat_op() const;
  inline void set_etat_op(::google::protobuf::int32 value);
  
  // optional bool mort = 7;
  inline bool has_mort() const;
  inline void clear_mort();
  static const int kMortFieldNumber = 7;
  inline bool mort() const;
  inline void set_mort(bool value);
  
  // optional .Common.MsgCoordLatLong position = 8;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 8;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
  // optional .Common.MsgHeading direction = 9;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 9;
  inline const ::Common::MsgHeading& direction() const;
  inline ::Common::MsgHeading* mutable_direction();
  
  // optional int32 speed = 10;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 10;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);
  
  // optional .Common.PartyId party = 11;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 11;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional bool nature_pc = 12;
  inline bool has_nature_pc() const;
  inline void clear_nature_pc();
  static const int kNaturePcFieldNumber = 12;
  inline bool nature_pc() const;
  inline void set_nature_pc(bool value);
  
  // optional .MsgsSimToClient.SeqOfAutomatPerception perception_par_compagnie = 13;
  inline bool has_perception_par_compagnie() const;
  inline void clear_perception_par_compagnie();
  static const int kPerceptionParCompagnieFieldNumber = 13;
  inline const ::MsgsSimToClient::SeqOfAutomatPerception& perception_par_compagnie() const;
  inline ::MsgsSimToClient::SeqOfAutomatPerception* mutable_perception_par_compagnie();
  
  // optional .Common.UnitId surrendered_unit = 14;
  inline bool has_surrendered_unit() const;
  inline void clear_surrendered_unit();
  static const int kSurrenderedUnitFieldNumber = 14;
  inline const ::Common::UnitId& surrendered_unit() const;
  inline ::Common::UnitId* mutable_surrendered_unit();
  
  // optional bool prisonnier = 15;
  inline bool has_prisonnier() const;
  inline void clear_prisonnier();
  static const int kPrisonnierFieldNumber = 15;
  inline bool prisonnier() const;
  inline void set_prisonnier(bool value);
  
  // optional bool refugie_pris_en_compte = 16;
  inline bool has_refugie_pris_en_compte() const;
  inline void clear_refugie_pris_en_compte();
  static const int kRefugiePrisEnCompteFieldNumber = 16;
  inline bool refugie_pris_en_compte() const;
  inline void set_refugie_pris_en_compte(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitKnowledgeId* knowledge_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::google::protobuf::int32 pertinence_;
  int identification_level_;
  int max_identification_level_;
  ::google::protobuf::int32 etat_op_;
  bool mort_;
  ::Common::MsgCoordLatLong* position_;
  ::Common::MsgHeading* direction_;
  ::google::protobuf::int32 speed_;
  ::Common::PartyId* party_;
  bool nature_pc_;
  ::MsgsSimToClient::SeqOfAutomatPerception* perception_par_compagnie_;
  ::Common::UnitId* surrendered_unit_;
  bool prisonnier_;
  bool refugie_pris_en_compte_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgUnitKnowledgeDestruction();
  virtual ~MsgUnitKnowledgeDestruction();
  
  MsgUnitKnowledgeDestruction(const MsgUnitKnowledgeDestruction& from);
  
  inline MsgUnitKnowledgeDestruction& operator=(const MsgUnitKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitKnowledgeDestruction& default_instance();
  void Swap(MsgUnitKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitKnowledgeDestruction& from);
  void MergeFrom(const MsgUnitKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::UnitKnowledgeId& knowledge() const;
  inline ::Common::UnitKnowledgeId* mutable_knowledge();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitKnowledgeId* knowledge_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class UnitFireTarget : public ::google::protobuf::Message {
 public:
  UnitFireTarget();
  virtual ~UnitFireTarget();
  
  UnitFireTarget(const UnitFireTarget& from);
  
  inline UnitFireTarget& operator=(const UnitFireTarget& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitFireTarget& default_instance();
  void Swap(UnitFireTarget* other);
  
  // implements Message ----------------------------------------------
  
  UnitFireTarget* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitFireTarget& from);
  void MergeFrom(const UnitFireTarget& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // optional .Common.CrowdId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
  // optional .Common.MsgCoordLatLong position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  ::Common::CrowdId* crowd_;
  ::Common::MsgCoordLatLong* position_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UnitFireTarget* default_instance_;
};
// -------------------------------------------------------------------

class MsgStartUnitFire : public ::google::protobuf::Message {
 public:
  MsgStartUnitFire();
  virtual ~MsgStartUnitFire();
  
  MsgStartUnitFire(const MsgStartUnitFire& from);
  
  inline MsgStartUnitFire& operator=(const MsgStartUnitFire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStartUnitFire& default_instance();
  void Swap(MsgStartUnitFire* other);
  
  // implements Message ----------------------------------------------
  
  MsgStartUnitFire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStartUnitFire& from);
  void MergeFrom(const MsgStartUnitFire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireId fire = 1;
  inline bool has_fire() const;
  inline void clear_fire();
  static const int kFireFieldNumber = 1;
  inline const ::Common::FireId& fire() const;
  inline ::Common::FireId* mutable_fire();
  
  // required .Common.UnitId firing_unit = 2;
  inline bool has_firing_unit() const;
  inline void clear_firing_unit();
  static const int kFiringUnitFieldNumber = 2;
  inline const ::Common::UnitId& firing_unit() const;
  inline ::Common::UnitId* mutable_firing_unit();
  
  // required .MsgsSimToClient.UnitFireTarget target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::MsgsSimToClient::UnitFireTarget& target() const;
  inline ::MsgsSimToClient::UnitFireTarget* mutable_target();
  
  // required .Common.UnitFireType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline Common::UnitFireType type() const;
  inline void set_type(Common::UnitFireType value);
  
  // optional .Common.ResourceType ammunition = 5;
  inline bool has_ammunition() const;
  inline void clear_ammunition();
  static const int kAmmunitionFieldNumber = 5;
  inline const ::Common::ResourceType& ammunition() const;
  inline ::Common::ResourceType* mutable_ammunition();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireId* fire_;
  ::Common::UnitId* firing_unit_;
  ::MsgsSimToClient::UnitFireTarget* target_;
  int type_;
  ::Common::ResourceType* ammunition_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStartUnitFire* default_instance_;
};
// -------------------------------------------------------------------

class UnitHumanFireDamage : public ::google::protobuf::Message {
 public:
  UnitHumanFireDamage();
  virtual ~UnitHumanFireDamage();
  
  UnitHumanFireDamage(const UnitHumanFireDamage& from);
  
  inline UnitHumanFireDamage& operator=(const UnitHumanFireDamage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitHumanFireDamage& default_instance();
  void Swap(UnitHumanFireDamage* other);
  
  // implements Message ----------------------------------------------
  
  UnitHumanFireDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitHumanFireDamage& from);
  void MergeFrom(const UnitHumanFireDamage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EnumHumanRank rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline Common::EnumHumanRank rank() const;
  inline void set_rank(Common::EnumHumanRank value);
  
  // required int32 alive_nbr = 2;
  inline bool has_alive_nbr() const;
  inline void clear_alive_nbr();
  static const int kAliveNbrFieldNumber = 2;
  inline ::google::protobuf::int32 alive_nbr() const;
  inline void set_alive_nbr(::google::protobuf::int32 value);
  
  // required int32 dead_nbr = 3;
  inline bool has_dead_nbr() const;
  inline void clear_dead_nbr();
  static const int kDeadNbrFieldNumber = 3;
  inline ::google::protobuf::int32 dead_nbr() const;
  inline void set_dead_nbr(::google::protobuf::int32 value);
  
  // required int32 wounded_u1_nbr = 4;
  inline bool has_wounded_u1_nbr() const;
  inline void clear_wounded_u1_nbr();
  static const int kWoundedU1NbrFieldNumber = 4;
  inline ::google::protobuf::int32 wounded_u1_nbr() const;
  inline void set_wounded_u1_nbr(::google::protobuf::int32 value);
  
  // required int32 wounded_u2_nbr = 5;
  inline bool has_wounded_u2_nbr() const;
  inline void clear_wounded_u2_nbr();
  static const int kWoundedU2NbrFieldNumber = 5;
  inline ::google::protobuf::int32 wounded_u2_nbr() const;
  inline void set_wounded_u2_nbr(::google::protobuf::int32 value);
  
  // required int32 wounded_u3_nbr = 6;
  inline bool has_wounded_u3_nbr() const;
  inline void clear_wounded_u3_nbr();
  static const int kWoundedU3NbrFieldNumber = 6;
  inline ::google::protobuf::int32 wounded_u3_nbr() const;
  inline void set_wounded_u3_nbr(::google::protobuf::int32 value);
  
  // required int32 wounded_ue_nbr = 7;
  inline bool has_wounded_ue_nbr() const;
  inline void clear_wounded_ue_nbr();
  static const int kWoundedUeNbrFieldNumber = 7;
  inline ::google::protobuf::int32 wounded_ue_nbr() const;
  inline void set_wounded_ue_nbr(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int rank_;
  ::google::protobuf::int32 alive_nbr_;
  ::google::protobuf::int32 dead_nbr_;
  ::google::protobuf::int32 wounded_u1_nbr_;
  ::google::protobuf::int32 wounded_u2_nbr_;
  ::google::protobuf::int32 wounded_u3_nbr_;
  ::google::protobuf::int32 wounded_ue_nbr_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UnitHumanFireDamage* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfUnitHumanFireDamage : public ::google::protobuf::Message {
 public:
  SeqOfUnitHumanFireDamage();
  virtual ~SeqOfUnitHumanFireDamage();
  
  SeqOfUnitHumanFireDamage(const SeqOfUnitHumanFireDamage& from);
  
  inline SeqOfUnitHumanFireDamage& operator=(const SeqOfUnitHumanFireDamage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfUnitHumanFireDamage& default_instance();
  void Swap(SeqOfUnitHumanFireDamage* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfUnitHumanFireDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfUnitHumanFireDamage& from);
  void MergeFrom(const SeqOfUnitHumanFireDamage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.UnitHumanFireDamage elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage >* mutable_elem();
  inline const ::MsgsSimToClient::UnitHumanFireDamage& elem(int index) const;
  inline ::MsgsSimToClient::UnitHumanFireDamage* mutable_elem(int index);
  inline ::MsgsSimToClient::UnitHumanFireDamage* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfUnitHumanFireDamage* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitEquipmentFireDamage : public ::google::protobuf::Message {
 public:
  MsgUnitEquipmentFireDamage();
  virtual ~MsgUnitEquipmentFireDamage();
  
  MsgUnitEquipmentFireDamage(const MsgUnitEquipmentFireDamage& from);
  
  inline MsgUnitEquipmentFireDamage& operator=(const MsgUnitEquipmentFireDamage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitEquipmentFireDamage& default_instance();
  void Swap(MsgUnitEquipmentFireDamage* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitEquipmentFireDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitEquipmentFireDamage& from);
  void MergeFrom(const MsgUnitEquipmentFireDamage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EquipmentType equipement_type = 1;
  inline bool has_equipement_type() const;
  inline void clear_equipement_type();
  static const int kEquipementTypeFieldNumber = 1;
  inline const ::Common::EquipmentType& equipement_type() const;
  inline ::Common::EquipmentType* mutable_equipement_type();
  
  // required uint32 available_nbr = 2;
  inline bool has_available_nbr() const;
  inline void clear_available_nbr();
  static const int kAvailableNbrFieldNumber = 2;
  inline ::google::protobuf::uint32 available_nbr() const;
  inline void set_available_nbr(::google::protobuf::uint32 value);
  
  // required uint32 unavailable_nbr = 3;
  inline bool has_unavailable_nbr() const;
  inline void clear_unavailable_nbr();
  static const int kUnavailableNbrFieldNumber = 3;
  inline ::google::protobuf::uint32 unavailable_nbr() const;
  inline void set_unavailable_nbr(::google::protobuf::uint32 value);
  
  // required uint32 repairable_nbr = 4;
  inline bool has_repairable_nbr() const;
  inline void clear_repairable_nbr();
  static const int kRepairableNbrFieldNumber = 4;
  inline ::google::protobuf::uint32 repairable_nbr() const;
  inline void set_repairable_nbr(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::EquipmentType* equipement_type_;
  ::google::protobuf::uint32 available_nbr_;
  ::google::protobuf::uint32 unavailable_nbr_;
  ::google::protobuf::uint32 repairable_nbr_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitEquipmentFireDamage* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfUnitEquipmentFireDamage : public ::google::protobuf::Message {
 public:
  SeqOfUnitEquipmentFireDamage();
  virtual ~SeqOfUnitEquipmentFireDamage();
  
  SeqOfUnitEquipmentFireDamage(const SeqOfUnitEquipmentFireDamage& from);
  
  inline SeqOfUnitEquipmentFireDamage& operator=(const SeqOfUnitEquipmentFireDamage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfUnitEquipmentFireDamage& default_instance();
  void Swap(SeqOfUnitEquipmentFireDamage* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfUnitEquipmentFireDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfUnitEquipmentFireDamage& from);
  void MergeFrom(const SeqOfUnitEquipmentFireDamage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgUnitEquipmentFireDamage elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage >* mutable_elem();
  inline const ::MsgsSimToClient::MsgUnitEquipmentFireDamage& elem(int index) const;
  inline ::MsgsSimToClient::MsgUnitEquipmentFireDamage* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgUnitEquipmentFireDamage* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfUnitEquipmentFireDamage* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitFireDamages : public ::google::protobuf::Message {
 public:
  MsgUnitFireDamages();
  virtual ~MsgUnitFireDamages();
  
  MsgUnitFireDamages(const MsgUnitFireDamages& from);
  
  inline MsgUnitFireDamages& operator=(const MsgUnitFireDamages& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitFireDamages& default_instance();
  void Swap(MsgUnitFireDamages* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitFireDamages* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitFireDamages& from);
  void MergeFrom(const MsgUnitFireDamages& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::Common::UnitId& target() const;
  inline ::Common::UnitId* mutable_target();
  
  // required .MsgsSimToClient.SeqOfUnitHumanFireDamage humans = 2;
  inline bool has_humans() const;
  inline void clear_humans();
  static const int kHumansFieldNumber = 2;
  inline const ::MsgsSimToClient::SeqOfUnitHumanFireDamage& humans() const;
  inline ::MsgsSimToClient::SeqOfUnitHumanFireDamage* mutable_humans();
  
  // required .MsgsSimToClient.SeqOfUnitEquipmentFireDamage equipments = 3;
  inline bool has_equipments() const;
  inline void clear_equipments();
  static const int kEquipmentsFieldNumber = 3;
  inline const ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage& equipments() const;
  inline ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage* mutable_equipments();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* target_;
  ::MsgsSimToClient::SeqOfUnitHumanFireDamage* humans_;
  ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage* equipments_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitFireDamages* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitsFireDamages : public ::google::protobuf::Message {
 public:
  MsgUnitsFireDamages();
  virtual ~MsgUnitsFireDamages();
  
  MsgUnitsFireDamages(const MsgUnitsFireDamages& from);
  
  inline MsgUnitsFireDamages& operator=(const MsgUnitsFireDamages& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitsFireDamages& default_instance();
  void Swap(MsgUnitsFireDamages* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitsFireDamages* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitsFireDamages& from);
  void MergeFrom(const MsgUnitsFireDamages& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgUnitFireDamages elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages >* mutable_elem();
  inline const ::MsgsSimToClient::MsgUnitFireDamages& elem(int index) const;
  inline ::MsgsSimToClient::MsgUnitFireDamages* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgUnitFireDamages* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitsFireDamages* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdFireDamages : public ::google::protobuf::Message {
 public:
  MsgCrowdFireDamages();
  virtual ~MsgCrowdFireDamages();
  
  MsgCrowdFireDamages(const MsgCrowdFireDamages& from);
  
  inline MsgCrowdFireDamages& operator=(const MsgCrowdFireDamages& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdFireDamages& default_instance();
  void Swap(MsgCrowdFireDamages* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdFireDamages* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdFireDamages& from);
  void MergeFrom(const MsgCrowdFireDamages& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdId target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::Common::CrowdId& target() const;
  inline ::Common::CrowdId* mutable_target();
  
  // required int32 dead_nbr = 2;
  inline bool has_dead_nbr() const;
  inline void clear_dead_nbr();
  static const int kDeadNbrFieldNumber = 2;
  inline ::google::protobuf::int32 dead_nbr() const;
  inline void set_dead_nbr(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdId* target_;
  ::google::protobuf::int32 dead_nbr_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdFireDamages* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdsFireDamages : public ::google::protobuf::Message {
 public:
  MsgCrowdsFireDamages();
  virtual ~MsgCrowdsFireDamages();
  
  MsgCrowdsFireDamages(const MsgCrowdsFireDamages& from);
  
  inline MsgCrowdsFireDamages& operator=(const MsgCrowdsFireDamages& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdsFireDamages& default_instance();
  void Swap(MsgCrowdsFireDamages* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdsFireDamages* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdsFireDamages& from);
  void MergeFrom(const MsgCrowdsFireDamages& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgCrowdFireDamages elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgCrowdFireDamages >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgCrowdFireDamages >* mutable_elem();
  inline const ::MsgsSimToClient::MsgCrowdFireDamages& elem(int index) const;
  inline ::MsgsSimToClient::MsgCrowdFireDamages* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgCrowdFireDamages* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgCrowdFireDamages > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdsFireDamages* default_instance_;
};
// -------------------------------------------------------------------

class MsgStopUnitFire : public ::google::protobuf::Message {
 public:
  MsgStopUnitFire();
  virtual ~MsgStopUnitFire();
  
  MsgStopUnitFire(const MsgStopUnitFire& from);
  
  inline MsgStopUnitFire& operator=(const MsgStopUnitFire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStopUnitFire& default_instance();
  void Swap(MsgStopUnitFire* other);
  
  // implements Message ----------------------------------------------
  
  MsgStopUnitFire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStopUnitFire& from);
  void MergeFrom(const MsgStopUnitFire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireId fire = 1;
  inline bool has_fire() const;
  inline void clear_fire();
  static const int kFireFieldNumber = 1;
  inline const ::Common::FireId& fire() const;
  inline ::Common::FireId* mutable_fire();
  
  // optional .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
  inline bool has_units_damages() const;
  inline void clear_units_damages();
  static const int kUnitsDamagesFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgUnitsFireDamages& units_damages() const;
  inline ::MsgsSimToClient::MsgUnitsFireDamages* mutable_units_damages();
  
  // optional .MsgsSimToClient.MsgCrowdsFireDamages crowds_damages = 3;
  inline bool has_crowds_damages() const;
  inline void clear_crowds_damages();
  static const int kCrowdsDamagesFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgCrowdsFireDamages& crowds_damages() const;
  inline ::MsgsSimToClient::MsgCrowdsFireDamages* mutable_crowds_damages();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireId* fire_;
  ::MsgsSimToClient::MsgUnitsFireDamages* units_damages_;
  ::MsgsSimToClient::MsgCrowdsFireDamages* crowds_damages_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStopUnitFire* default_instance_;
};
// -------------------------------------------------------------------

class MsgStartCrowdFire : public ::google::protobuf::Message {
 public:
  MsgStartCrowdFire();
  virtual ~MsgStartCrowdFire();
  
  MsgStartCrowdFire(const MsgStartCrowdFire& from);
  
  inline MsgStartCrowdFire& operator=(const MsgStartCrowdFire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStartCrowdFire& default_instance();
  void Swap(MsgStartCrowdFire* other);
  
  // implements Message ----------------------------------------------
  
  MsgStartCrowdFire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStartCrowdFire& from);
  void MergeFrom(const MsgStartCrowdFire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireId fire = 1;
  inline bool has_fire() const;
  inline void clear_fire();
  static const int kFireFieldNumber = 1;
  inline const ::Common::FireId& fire() const;
  inline ::Common::FireId* mutable_fire();
  
  // required .Common.CrowdId firing_crowd = 2;
  inline bool has_firing_crowd() const;
  inline void clear_firing_crowd();
  static const int kFiringCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& firing_crowd() const;
  inline ::Common::CrowdId* mutable_firing_crowd();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireId* fire_;
  ::Common::CrowdId* firing_crowd_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStartCrowdFire* default_instance_;
};
// -------------------------------------------------------------------

class MsgStopCrowdFire : public ::google::protobuf::Message {
 public:
  MsgStopCrowdFire();
  virtual ~MsgStopCrowdFire();
  
  MsgStopCrowdFire(const MsgStopCrowdFire& from);
  
  inline MsgStopCrowdFire& operator=(const MsgStopCrowdFire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStopCrowdFire& default_instance();
  void Swap(MsgStopCrowdFire* other);
  
  // implements Message ----------------------------------------------
  
  MsgStopCrowdFire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStopCrowdFire& from);
  void MergeFrom(const MsgStopCrowdFire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireId fire = 1;
  inline bool has_fire() const;
  inline void clear_fire();
  static const int kFireFieldNumber = 1;
  inline const ::Common::FireId& fire() const;
  inline ::Common::FireId* mutable_fire();
  
  // required .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
  inline bool has_units_damages() const;
  inline void clear_units_damages();
  static const int kUnitsDamagesFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgUnitsFireDamages& units_damages() const;
  inline ::MsgsSimToClient::MsgUnitsFireDamages* mutable_units_damages();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireId* fire_;
  ::MsgsSimToClient::MsgUnitsFireDamages* units_damages_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStopCrowdFire* default_instance_;
};
// -------------------------------------------------------------------

class MsgExplosion : public ::google::protobuf::Message {
 public:
  MsgExplosion();
  virtual ~MsgExplosion();
  
  MsgExplosion(const MsgExplosion& from);
  
  inline MsgExplosion& operator=(const MsgExplosion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgExplosion& default_instance();
  void Swap(MsgExplosion* other);
  
  // implements Message ----------------------------------------------
  
  MsgExplosion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgExplosion& from);
  void MergeFrom(const MsgExplosion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectId object = 1;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 1;
  inline const ::Common::ObjectId& object() const;
  inline ::Common::ObjectId* mutable_object();
  
  // optional .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
  inline bool has_units_damages() const;
  inline void clear_units_damages();
  static const int kUnitsDamagesFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgUnitsFireDamages& units_damages() const;
  inline ::MsgsSimToClient::MsgUnitsFireDamages* mutable_units_damages();
  
  // optional .MsgsSimToClient.MsgCrowdsFireDamages crowds_damages = 3;
  inline bool has_crowds_damages() const;
  inline void clear_crowds_damages();
  static const int kCrowdsDamagesFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgCrowdsFireDamages& crowds_damages() const;
  inline ::MsgsSimToClient::MsgCrowdsFireDamages* mutable_crowds_damages();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectId* object_;
  ::MsgsSimToClient::MsgUnitsFireDamages* units_damages_;
  ::MsgsSimToClient::MsgCrowdsFireDamages* crowds_damages_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgExplosion* default_instance_;
};
// -------------------------------------------------------------------

class MsgStartFireEffect : public ::google::protobuf::Message {
 public:
  MsgStartFireEffect();
  virtual ~MsgStartFireEffect();
  
  MsgStartFireEffect(const MsgStartFireEffect& from);
  
  inline MsgStartFireEffect& operator=(const MsgStartFireEffect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStartFireEffect& default_instance();
  void Swap(MsgStartFireEffect* other);
  
  // implements Message ----------------------------------------------
  
  MsgStartFireEffect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStartFireEffect& from);
  void MergeFrom(const MsgStartFireEffect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireEffectId fire_effect = 1;
  inline bool has_fire_effect() const;
  inline void clear_fire_effect();
  static const int kFireEffectFieldNumber = 1;
  inline const ::Common::FireEffectId& fire_effect() const;
  inline ::Common::FireEffectId* mutable_fire_effect();
  
  // required .Common.MsgLocation location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // required .Common.EnumFireEffectType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline Common::EnumFireEffectType type() const;
  inline void set_type(Common::EnumFireEffectType value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireEffectId* fire_effect_;
  ::Common::MsgLocation* location_;
  int type_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStartFireEffect* default_instance_;
};
// -------------------------------------------------------------------

class MsgStopFireEffect : public ::google::protobuf::Message {
 public:
  MsgStopFireEffect();
  virtual ~MsgStopFireEffect();
  
  MsgStopFireEffect(const MsgStopFireEffect& from);
  
  inline MsgStopFireEffect& operator=(const MsgStopFireEffect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStopFireEffect& default_instance();
  void Swap(MsgStopFireEffect* other);
  
  // implements Message ----------------------------------------------
  
  MsgStopFireEffect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStopFireEffect& from);
  void MergeFrom(const MsgStopFireEffect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireEffectId fire_effect = 1;
  inline bool has_fire_effect() const;
  inline void clear_fire_effect();
  static const int kFireEffectFieldNumber = 1;
  inline const ::Common::FireEffectId& fire_effect() const;
  inline ::Common::FireEffectId* mutable_fire_effect();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireEffectId* fire_effect_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStopFireEffect* default_instance_;
};
// -------------------------------------------------------------------

class MsgReport : public ::google::protobuf::Message {
 public:
  MsgReport();
  virtual ~MsgReport();
  
  MsgReport(const MsgReport& from);
  
  inline MsgReport& operator=(const MsgReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReport& default_instance();
  void Swap(MsgReport* other);
  
  // implements Message ----------------------------------------------
  
  MsgReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgReport& from);
  void MergeFrom(const MsgReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ReportId report = 1;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::Common::ReportId& report() const;
  inline ::Common::ReportId* mutable_report();
  
  // required .Common.Tasker source = 2;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 2;
  inline const ::Common::Tasker& source() const;
  inline ::Common::Tasker* mutable_source();
  
  // required .Common.ReportType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::Common::ReportType& type() const;
  inline ::Common::ReportType* mutable_type();
  
  // required .MsgsSimToClient.EnumReportType category = 4;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 4;
  inline MsgsSimToClient::EnumReportType category() const;
  inline void set_category(MsgsSimToClient::EnumReportType value);
  
  // required .Common.MsgDateTime time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::Common::MsgDateTime& time() const;
  inline ::Common::MsgDateTime* mutable_time();
  
  // optional .Common.MsgMissionParameters parameters = 6;
  inline bool has_parameters() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 6;
  inline const ::Common::MsgMissionParameters& parameters() const;
  inline ::Common::MsgMissionParameters* mutable_parameters();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ReportId* report_;
  ::Common::Tasker* source_;
  ::Common::ReportType* type_;
  int category_;
  ::Common::MsgDateTime* time_;
  ::Common::MsgMissionParameters* parameters_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgReport* default_instance_;
};
// -------------------------------------------------------------------

class MsgInvalidateReport : public ::google::protobuf::Message {
 public:
  MsgInvalidateReport();
  virtual ~MsgInvalidateReport();
  
  MsgInvalidateReport(const MsgInvalidateReport& from);
  
  inline MsgInvalidateReport& operator=(const MsgInvalidateReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgInvalidateReport& default_instance();
  void Swap(MsgInvalidateReport* other);
  
  // implements Message ----------------------------------------------
  
  MsgInvalidateReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgInvalidateReport& from);
  void MergeFrom(const MsgInvalidateReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ReportId report = 1;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::Common::ReportId& report() const;
  inline ::Common::ReportId* mutable_report();
  
  // required .Common.Tasker source = 2;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 2;
  inline const ::Common::Tasker& source() const;
  inline ::Common::Tasker* mutable_source();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ReportId* report_;
  ::Common::Tasker* source_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgInvalidateReport* default_instance_;
};
// -------------------------------------------------------------------

class MsgTrace : public ::google::protobuf::Message {
 public:
  MsgTrace();
  virtual ~MsgTrace();
  
  MsgTrace(const MsgTrace& from);
  
  inline MsgTrace& operator=(const MsgTrace& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTrace& default_instance();
  void Swap(MsgTrace* other);
  
  // implements Message ----------------------------------------------
  
  MsgTrace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgTrace& from);
  void MergeFrom(const MsgTrace& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.Tasker source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Common::Tasker& source() const;
  inline ::Common::Tasker* mutable_source();
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::Tasker* source_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgTrace* default_instance_;
};
// -------------------------------------------------------------------

class MsgDecisionalState : public ::google::protobuf::Message {
 public:
  MsgDecisionalState();
  virtual ~MsgDecisionalState();
  
  MsgDecisionalState(const MsgDecisionalState& from);
  
  inline MsgDecisionalState& operator=(const MsgDecisionalState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDecisionalState& default_instance();
  void Swap(MsgDecisionalState* other);
  
  // implements Message ----------------------------------------------
  
  MsgDecisionalState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgDecisionalState& from);
  void MergeFrom(const MsgDecisionalState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.Tasker source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Common::Tasker& source() const;
  inline ::Common::Tasker* mutable_source();
  
  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // required string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::Tasker* source_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgDecisionalState* default_instance_;
};
// -------------------------------------------------------------------

class MsgDebugPoints : public ::google::protobuf::Message {
 public:
  MsgDebugPoints();
  virtual ~MsgDebugPoints();
  
  MsgDebugPoints(const MsgDebugPoints& from);
  
  inline MsgDebugPoints& operator=(const MsgDebugPoints& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDebugPoints& default_instance();
  void Swap(MsgDebugPoints* other);
  
  // implements Message ----------------------------------------------
  
  MsgDebugPoints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgDebugPoints& from);
  void MergeFrom(const MsgDebugPoints& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.Tasker source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Common::Tasker& source() const;
  inline ::Common::Tasker* mutable_source();
  
  // required .Common.MsgCoordLatLongList coordinates = 2;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 2;
  inline const ::Common::MsgCoordLatLongList& coordinates() const;
  inline ::Common::MsgCoordLatLongList* mutable_coordinates();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::Tasker* source_;
  ::Common::MsgCoordLatLongList* coordinates_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgDebugPoints* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfHeading : public ::google::protobuf::Message {
 public:
  SeqOfHeading();
  virtual ~SeqOfHeading();
  
  SeqOfHeading(const SeqOfHeading& from);
  
  inline SeqOfHeading& operator=(const SeqOfHeading& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfHeading& default_instance();
  void Swap(SeqOfHeading* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfHeading* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfHeading& from);
  void MergeFrom(const SeqOfHeading& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Common.MsgHeading elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading >* mutable_elem();
  inline const ::Common::MsgHeading& elem(int index) const;
  inline ::Common::MsgHeading* mutable_elem(int index);
  inline ::Common::MsgHeading* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfHeading* default_instance_;
};
// -------------------------------------------------------------------

class MsgVisionCone : public ::google::protobuf::Message {
 public:
  MsgVisionCone();
  virtual ~MsgVisionCone();
  
  MsgVisionCone(const MsgVisionCone& from);
  
  inline MsgVisionCone& operator=(const MsgVisionCone& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgVisionCone& default_instance();
  void Swap(MsgVisionCone* other);
  
  // implements Message ----------------------------------------------
  
  MsgVisionCone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgVisionCone& from);
  void MergeFrom(const MsgVisionCone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MsgCoordLatLong origin = 1;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 1;
  inline const ::Common::MsgCoordLatLong& origin() const;
  inline ::Common::MsgCoordLatLong* mutable_origin();
  
  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // required string sensor = 3;
  inline bool has_sensor() const;
  inline void clear_sensor();
  static const int kSensorFieldNumber = 3;
  inline const ::std::string& sensor() const;
  inline void set_sensor(const ::std::string& value);
  inline void set_sensor(const char* value);
  inline void set_sensor(const char* value, size_t size);
  inline ::std::string* mutable_sensor();
  
  // required .MsgsSimToClient.SeqOfHeading directions = 4;
  inline bool has_directions() const;
  inline void clear_directions();
  static const int kDirectionsFieldNumber = 4;
  inline const ::MsgsSimToClient::SeqOfHeading& directions() const;
  inline ::MsgsSimToClient::SeqOfHeading* mutable_directions();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MsgCoordLatLong* origin_;
  ::google::protobuf::int32 height_;
  ::std::string* sensor_;
  static const ::std::string _default_sensor_;
  ::MsgsSimToClient::SeqOfHeading* directions_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgVisionCone* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfVisionCone : public ::google::protobuf::Message {
 public:
  SeqOfVisionCone();
  virtual ~SeqOfVisionCone();
  
  SeqOfVisionCone(const SeqOfVisionCone& from);
  
  inline SeqOfVisionCone& operator=(const SeqOfVisionCone& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfVisionCone& default_instance();
  void Swap(SeqOfVisionCone* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfVisionCone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfVisionCone& from);
  void MergeFrom(const SeqOfVisionCone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgVisionCone elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone >* mutable_elem();
  inline const ::MsgsSimToClient::MsgVisionCone& elem(int index) const;
  inline ::MsgsSimToClient::MsgVisionCone* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgVisionCone* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfVisionCone* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitVisionCones : public ::google::protobuf::Message {
 public:
  MsgUnitVisionCones();
  virtual ~MsgUnitVisionCones();
  
  MsgUnitVisionCones(const MsgUnitVisionCones& from);
  
  inline MsgUnitVisionCones& operator=(const MsgUnitVisionCones& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitVisionCones& default_instance();
  void Swap(MsgUnitVisionCones* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitVisionCones* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitVisionCones& from);
  void MergeFrom(const MsgUnitVisionCones& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required .MsgsSimToClient.SeqOfVisionCone cones = 2;
  inline bool has_cones() const;
  inline void clear_cones();
  static const int kConesFieldNumber = 2;
  inline const ::MsgsSimToClient::SeqOfVisionCone& cones() const;
  inline ::MsgsSimToClient::SeqOfVisionCone* mutable_cones();
  
  // required float elongation = 3;
  inline bool has_elongation() const;
  inline void clear_elongation();
  static const int kElongationFieldNumber = 3;
  inline float elongation() const;
  inline void set_elongation(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  ::MsgsSimToClient::SeqOfVisionCone* cones_;
  float elongation_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitVisionCones* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitDetection : public ::google::protobuf::Message {
 public:
  MsgUnitDetection();
  virtual ~MsgUnitDetection();
  
  MsgUnitDetection(const MsgUnitDetection& from);
  
  inline MsgUnitDetection& operator=(const MsgUnitDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitDetection& default_instance();
  void Swap(MsgUnitDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitDetection& from);
  void MergeFrom(const MsgUnitDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId observer = 1;
  inline bool has_observer() const;
  inline void clear_observer();
  static const int kObserverFieldNumber = 1;
  inline const ::Common::UnitId& observer() const;
  inline ::Common::UnitId* mutable_observer();
  
  // required .Common.UnitId detected_unit = 2;
  inline bool has_detected_unit() const;
  inline void clear_detected_unit();
  static const int kDetectedUnitFieldNumber = 2;
  inline const ::Common::UnitId& detected_unit() const;
  inline ::Common::UnitId* mutable_detected_unit();
  
  // required .Common.EnumUnitVisibility current_visibility = 3;
  inline bool has_current_visibility() const;
  inline void clear_current_visibility();
  static const int kCurrentVisibilityFieldNumber = 3;
  inline Common::EnumUnitVisibility current_visibility() const;
  inline void set_current_visibility(Common::EnumUnitVisibility value);
  
  // required .Common.EnumUnitVisibility max_visibility = 4;
  inline bool has_max_visibility() const;
  inline void clear_max_visibility();
  static const int kMaxVisibilityFieldNumber = 4;
  inline Common::EnumUnitVisibility max_visibility() const;
  inline void set_max_visibility(Common::EnumUnitVisibility value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* observer_;
  ::Common::UnitId* detected_unit_;
  int current_visibility_;
  int max_visibility_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectDetection : public ::google::protobuf::Message {
 public:
  MsgObjectDetection();
  virtual ~MsgObjectDetection();
  
  MsgObjectDetection(const MsgObjectDetection& from);
  
  inline MsgObjectDetection& operator=(const MsgObjectDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectDetection& default_instance();
  void Swap(MsgObjectDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectDetection& from);
  void MergeFrom(const MsgObjectDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId observer = 1;
  inline bool has_observer() const;
  inline void clear_observer();
  static const int kObserverFieldNumber = 1;
  inline const ::Common::UnitId& observer() const;
  inline ::Common::UnitId* mutable_observer();
  
  // required .Common.ObjectId detected_object = 2;
  inline bool has_detected_object() const;
  inline void clear_detected_object();
  static const int kDetectedObjectFieldNumber = 2;
  inline const ::Common::ObjectId& detected_object() const;
  inline ::Common::ObjectId* mutable_detected_object();
  
  // required .Common.EnumUnitVisibility visibility = 3;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 3;
  inline Common::EnumUnitVisibility visibility() const;
  inline void set_visibility(Common::EnumUnitVisibility value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* observer_;
  ::Common::ObjectId* detected_object_;
  int visibility_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdConcentrationDetection : public ::google::protobuf::Message {
 public:
  MsgCrowdConcentrationDetection();
  virtual ~MsgCrowdConcentrationDetection();
  
  MsgCrowdConcentrationDetection(const MsgCrowdConcentrationDetection& from);
  
  inline MsgCrowdConcentrationDetection& operator=(const MsgCrowdConcentrationDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdConcentrationDetection& default_instance();
  void Swap(MsgCrowdConcentrationDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdConcentrationDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdConcentrationDetection& from);
  void MergeFrom(const MsgCrowdConcentrationDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId observer = 1;
  inline bool has_observer() const;
  inline void clear_observer();
  static const int kObserverFieldNumber = 1;
  inline const ::Common::UnitId& observer() const;
  inline ::Common::UnitId* mutable_observer();
  
  // required .Common.CrowdId detected_crowd = 2;
  inline bool has_detected_crowd() const;
  inline void clear_detected_crowd();
  static const int kDetectedCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& detected_crowd() const;
  inline ::Common::CrowdId* mutable_detected_crowd();
  
  // required .Common.CrowdConcentrationId detected_concentration = 3;
  inline bool has_detected_concentration() const;
  inline void clear_detected_concentration();
  static const int kDetectedConcentrationFieldNumber = 3;
  inline const ::Common::CrowdConcentrationId& detected_concentration() const;
  inline ::Common::CrowdConcentrationId* mutable_detected_concentration();
  
  // required .Common.EnumUnitVisibility visibility = 4;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 4;
  inline Common::EnumUnitVisibility visibility() const;
  inline void set_visibility(Common::EnumUnitVisibility value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* observer_;
  ::Common::CrowdId* detected_crowd_;
  ::Common::CrowdConcentrationId* detected_concentration_;
  int visibility_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdConcentrationDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdFlowDetection : public ::google::protobuf::Message {
 public:
  MsgCrowdFlowDetection();
  virtual ~MsgCrowdFlowDetection();
  
  MsgCrowdFlowDetection(const MsgCrowdFlowDetection& from);
  
  inline MsgCrowdFlowDetection& operator=(const MsgCrowdFlowDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdFlowDetection& default_instance();
  void Swap(MsgCrowdFlowDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdFlowDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdFlowDetection& from);
  void MergeFrom(const MsgCrowdFlowDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId observer = 1;
  inline bool has_observer() const;
  inline void clear_observer();
  static const int kObserverFieldNumber = 1;
  inline const ::Common::UnitId& observer() const;
  inline ::Common::UnitId* mutable_observer();
  
  // required .Common.CrowdId detected_crowd = 2;
  inline bool has_detected_crowd() const;
  inline void clear_detected_crowd();
  static const int kDetectedCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& detected_crowd() const;
  inline ::Common::CrowdId* mutable_detected_crowd();
  
  // required .Common.CrowdFlowId detected_flow = 3;
  inline bool has_detected_flow() const;
  inline void clear_detected_flow();
  static const int kDetectedFlowFieldNumber = 3;
  inline const ::Common::CrowdFlowId& detected_flow() const;
  inline ::Common::CrowdFlowId* mutable_detected_flow();
  
  // required .Common.MsgPath visible_flow = 4;
  inline bool has_visible_flow() const;
  inline void clear_visible_flow();
  static const int kVisibleFlowFieldNumber = 4;
  inline const ::Common::MsgPath& visible_flow() const;
  inline ::Common::MsgPath* mutable_visible_flow();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* observer_;
  ::Common::CrowdId* detected_crowd_;
  ::Common::CrowdFlowId* detected_flow_;
  ::Common::MsgPath* visible_flow_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdFlowDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectCreation : public ::google::protobuf::Message {
 public:
  MsgObjectCreation();
  virtual ~MsgObjectCreation();
  
  MsgObjectCreation(const MsgObjectCreation& from);
  
  inline MsgObjectCreation& operator=(const MsgObjectCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectCreation& default_instance();
  void Swap(MsgObjectCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectCreation& from);
  void MergeFrom(const MsgObjectCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectId object = 1;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 1;
  inline const ::Common::ObjectId& object() const;
  inline ::Common::ObjectId* mutable_object();
  
  // required .Common.ObjectType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::ObjectType& type() const;
  inline ::Common::ObjectType* mutable_type();
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .Common.PartyId party = 4;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 4;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required .Common.MsgLocation location = 5;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 5;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // required .Common.ObjectAttributes attributes = 6;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 6;
  inline const ::Common::ObjectAttributes& attributes() const;
  inline ::Common::ObjectAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectId* object_;
  ::Common::ObjectType* type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::Common::PartyId* party_;
  ::Common::MsgLocation* location_;
  ::Common::ObjectAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectDestruction : public ::google::protobuf::Message {
 public:
  MsgObjectDestruction();
  virtual ~MsgObjectDestruction();
  
  MsgObjectDestruction(const MsgObjectDestruction& from);
  
  inline MsgObjectDestruction& operator=(const MsgObjectDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectDestruction& default_instance();
  void Swap(MsgObjectDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectDestruction& from);
  void MergeFrom(const MsgObjectDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectId object = 1;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 1;
  inline const ::Common::ObjectId& object() const;
  inline ::Common::ObjectId* mutable_object();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectId* object_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectUpdate : public ::google::protobuf::Message {
 public:
  MsgObjectUpdate();
  virtual ~MsgObjectUpdate();
  
  MsgObjectUpdate(const MsgObjectUpdate& from);
  
  inline MsgObjectUpdate& operator=(const MsgObjectUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectUpdate& default_instance();
  void Swap(MsgObjectUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectUpdate& from);
  void MergeFrom(const MsgObjectUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectId object = 1;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 1;
  inline const ::Common::ObjectId& object() const;
  inline ::Common::ObjectId* mutable_object();
  
  // optional .Common.MsgLocation location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // required .Common.ObjectAttributes attributes = 3;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  inline const ::Common::ObjectAttributes& attributes() const;
  inline ::Common::ObjectAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectId* object_;
  ::Common::MsgLocation* location_;
  ::Common::ObjectAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgObjectKnowledgeCreation();
  virtual ~MsgObjectKnowledgeCreation();
  
  MsgObjectKnowledgeCreation(const MsgObjectKnowledgeCreation& from);
  
  inline MsgObjectKnowledgeCreation& operator=(const MsgObjectKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectKnowledgeCreation& default_instance();
  void Swap(MsgObjectKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectKnowledgeCreation& from);
  void MergeFrom(const MsgObjectKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::ObjectKnowledgeId& knowledge() const;
  inline ::Common::ObjectKnowledgeId* mutable_knowledge();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required .Common.ObjectId object = 3;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 3;
  inline const ::Common::ObjectId& object() const;
  inline ::Common::ObjectId* mutable_object();
  
  // required .Common.ObjectType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::Common::ObjectType& type() const;
  inline ::Common::ObjectType* mutable_type();
  
  // required .Common.ObjectAttributes attributes = 5;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::Common::ObjectAttributes& attributes() const;
  inline ::Common::ObjectAttributes* mutable_attributes();
  
  // optional .Common.KnowledgeGroupId knowledge_group = 6;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 6;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectKnowledgeId* knowledge_;
  ::Common::PartyId* party_;
  ::Common::ObjectId* object_;
  ::Common::ObjectType* type_;
  ::Common::ObjectAttributes* attributes_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgObjectKnowledgeUpdate();
  virtual ~MsgObjectKnowledgeUpdate();
  
  MsgObjectKnowledgeUpdate(const MsgObjectKnowledgeUpdate& from);
  
  inline MsgObjectKnowledgeUpdate& operator=(const MsgObjectKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectKnowledgeUpdate& default_instance();
  void Swap(MsgObjectKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectKnowledgeUpdate& from);
  void MergeFrom(const MsgObjectKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::ObjectKnowledgeId& knowledge() const;
  inline ::Common::ObjectKnowledgeId* mutable_knowledge();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.ObjectId object = 3;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 3;
  inline const ::Common::ObjectId& object() const;
  inline ::Common::ObjectId* mutable_object();
  
  // optional int32 relevance = 4;
  inline bool has_relevance() const;
  inline void clear_relevance();
  static const int kRelevanceFieldNumber = 4;
  inline ::google::protobuf::int32 relevance() const;
  inline void set_relevance(::google::protobuf::int32 value);
  
  // optional .Common.MsgLocation location = 5;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 5;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // optional .Common.ObjectAttributes attributes = 6;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 6;
  inline const ::Common::ObjectAttributes& attributes() const;
  inline ::Common::ObjectAttributes* mutable_attributes();
  
  // optional bool perceived = 7;
  inline bool has_perceived() const;
  inline void clear_perceived();
  static const int kPerceivedFieldNumber = 7;
  inline bool perceived() const;
  inline void set_perceived(bool value);
  
  // optional .Common.AutomatIdList perceiving_automats = 8;
  inline bool has_perceiving_automats() const;
  inline void clear_perceiving_automats();
  static const int kPerceivingAutomatsFieldNumber = 8;
  inline const ::Common::AutomatIdList& perceiving_automats() const;
  inline ::Common::AutomatIdList* mutable_perceiving_automats();
  
  // optional .Common.KnowledgeGroupId knowledge_group = 9;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 9;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectKnowledgeId* knowledge_;
  ::Common::PartyId* party_;
  ::Common::ObjectId* object_;
  ::google::protobuf::int32 relevance_;
  ::Common::MsgLocation* location_;
  ::Common::ObjectAttributes* attributes_;
  bool perceived_;
  ::Common::AutomatIdList* perceiving_automats_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgObjectKnowledgeDestruction();
  virtual ~MsgObjectKnowledgeDestruction();
  
  MsgObjectKnowledgeDestruction(const MsgObjectKnowledgeDestruction& from);
  
  inline MsgObjectKnowledgeDestruction& operator=(const MsgObjectKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectKnowledgeDestruction& default_instance();
  void Swap(MsgObjectKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectKnowledgeDestruction& from);
  void MergeFrom(const MsgObjectKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::ObjectKnowledgeId& knowledge() const;
  inline ::Common::ObjectKnowledgeId* mutable_knowledge();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectKnowledgeId* knowledge_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgUrbanKnowledgeCreation();
  virtual ~MsgUrbanKnowledgeCreation();
  
  MsgUrbanKnowledgeCreation(const MsgUrbanKnowledgeCreation& from);
  
  inline MsgUrbanKnowledgeCreation& operator=(const MsgUrbanKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanKnowledgeCreation& default_instance();
  void Swap(MsgUrbanKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanKnowledgeCreation& from);
  void MergeFrom(const MsgUrbanKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UrbanObjectKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::UrbanObjectKnowledgeId& knowledge() const;
  inline ::Common::UrbanObjectKnowledgeId* mutable_knowledge();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required .Common.UrbanObjectId urban_block = 3;
  inline bool has_urban_block() const;
  inline void clear_urban_block();
  static const int kUrbanBlockFieldNumber = 3;
  inline const ::Common::UrbanObjectId& urban_block() const;
  inline ::Common::UrbanObjectId* mutable_urban_block();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UrbanObjectKnowledgeId* knowledge_;
  ::Common::PartyId* party_;
  ::Common::UrbanObjectId* urban_block_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgUrbanKnowledgeUpdate();
  virtual ~MsgUrbanKnowledgeUpdate();
  
  MsgUrbanKnowledgeUpdate(const MsgUrbanKnowledgeUpdate& from);
  
  inline MsgUrbanKnowledgeUpdate& operator=(const MsgUrbanKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanKnowledgeUpdate& default_instance();
  void Swap(MsgUrbanKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanKnowledgeUpdate& from);
  void MergeFrom(const MsgUrbanKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UrbanObjectKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::UrbanObjectKnowledgeId& knowledge() const;
  inline ::Common::UrbanObjectKnowledgeId* mutable_knowledge();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required .Common.UrbanObjectId urban_block = 3;
  inline bool has_urban_block() const;
  inline void clear_urban_block();
  static const int kUrbanBlockFieldNumber = 3;
  inline const ::Common::UrbanObjectId& urban_block() const;
  inline ::Common::UrbanObjectId* mutable_urban_block();
  
  // optional int32 progress = 4;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 4;
  inline ::google::protobuf::int32 progress() const;
  inline void set_progress(::google::protobuf::int32 value);
  
  // optional int32 max_progress = 5;
  inline bool has_max_progress() const;
  inline void clear_max_progress();
  static const int kMaxProgressFieldNumber = 5;
  inline ::google::protobuf::int32 max_progress() const;
  inline void set_max_progress(::google::protobuf::int32 value);
  
  // optional bool perceived = 6;
  inline bool has_perceived() const;
  inline void clear_perceived();
  static const int kPerceivedFieldNumber = 6;
  inline bool perceived() const;
  inline void set_perceived(bool value);
  
  // optional .Common.AutomatIdList automat_perceptions = 7;
  inline bool has_automat_perceptions() const;
  inline void clear_automat_perceptions();
  static const int kAutomatPerceptionsFieldNumber = 7;
  inline const ::Common::AutomatIdList& automat_perceptions() const;
  inline ::Common::AutomatIdList* mutable_automat_perceptions();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UrbanObjectKnowledgeId* knowledge_;
  ::Common::PartyId* party_;
  ::Common::UrbanObjectId* urban_block_;
  ::google::protobuf::int32 progress_;
  ::google::protobuf::int32 max_progress_;
  bool perceived_;
  ::Common::AutomatIdList* automat_perceptions_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgUrbanKnowledgeDestruction();
  virtual ~MsgUrbanKnowledgeDestruction();
  
  MsgUrbanKnowledgeDestruction(const MsgUrbanKnowledgeDestruction& from);
  
  inline MsgUrbanKnowledgeDestruction& operator=(const MsgUrbanKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanKnowledgeDestruction& default_instance();
  void Swap(MsgUrbanKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanKnowledgeDestruction& from);
  void MergeFrom(const MsgUrbanKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UrbanObjectKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::UrbanObjectKnowledgeId& knowledge() const;
  inline ::Common::UrbanObjectKnowledgeId* mutable_knowledge();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UrbanObjectKnowledgeId* knowledge_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalHandlingCreation : public ::google::protobuf::Message {
 public:
  MsgLogMedicalHandlingCreation();
  virtual ~MsgLogMedicalHandlingCreation();
  
  MsgLogMedicalHandlingCreation(const MsgLogMedicalHandlingCreation& from);
  
  inline MsgLogMedicalHandlingCreation& operator=(const MsgLogMedicalHandlingCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalHandlingCreation& default_instance();
  void Swap(MsgLogMedicalHandlingCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalHandlingCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalHandlingCreation& from);
  void MergeFrom(const MsgLogMedicalHandlingCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MedicalRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::MedicalRequestId& request() const;
  inline ::Common::MedicalRequestId* mutable_request();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required int32 tick_creation = 3;
  inline bool has_tick_creation() const;
  inline void clear_tick_creation();
  static const int kTickCreationFieldNumber = 3;
  inline ::google::protobuf::int32 tick_creation() const;
  inline void set_tick_creation(::google::protobuf::int32 value);
  
  // required .Common.EnumHumanRank rang = 4;
  inline bool has_rang() const;
  inline void clear_rang();
  static const int kRangFieldNumber = 4;
  inline Common::EnumHumanRank rang() const;
  inline void set_rang(Common::EnumHumanRank value);
  
  // required .Common.EnumHumanWound blessure = 5;
  inline bool has_blessure() const;
  inline void clear_blessure();
  static const int kBlessureFieldNumber = 5;
  inline Common::EnumHumanWound blessure() const;
  inline void set_blessure(Common::EnumHumanWound value);
  
  // optional bool blesse_mental = 6;
  inline bool has_blesse_mental() const;
  inline void clear_blesse_mental();
  static const int kBlesseMentalFieldNumber = 6;
  inline bool blesse_mental() const;
  inline void set_blesse_mental(bool value);
  
  // optional bool contamine_nbc = 7;
  inline bool has_contamine_nbc() const;
  inline void clear_contamine_nbc();
  static const int kContamineNbcFieldNumber = 7;
  inline bool contamine_nbc() const;
  inline void set_contamine_nbc(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MedicalRequestId* request_;
  ::Common::UnitId* unit_;
  ::google::protobuf::int32 tick_creation_;
  int rang_;
  int blessure_;
  bool blesse_mental_;
  bool contamine_nbc_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalHandlingCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalHandlingUpdate : public ::google::protobuf::Message {
 public:
  MsgLogMedicalHandlingUpdate();
  virtual ~MsgLogMedicalHandlingUpdate();
  
  MsgLogMedicalHandlingUpdate(const MsgLogMedicalHandlingUpdate& from);
  
  inline MsgLogMedicalHandlingUpdate& operator=(const MsgLogMedicalHandlingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalHandlingUpdate& default_instance();
  void Swap(MsgLogMedicalHandlingUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalHandlingUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalHandlingUpdate& from);
  void MergeFrom(const MsgLogMedicalHandlingUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MedicalRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::MedicalRequestId& request() const;
  inline ::Common::MedicalRequestId* mutable_request();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // optional .Common.UnitId provider = 3;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 3;
  inline const ::Common::UnitId& provider() const;
  inline ::Common::UnitId* mutable_provider();
  
  // optional .Common.EnumHumanWound blessure = 4;
  inline bool has_blessure() const;
  inline void clear_blessure();
  static const int kBlessureFieldNumber = 4;
  inline Common::EnumHumanWound blessure() const;
  inline void set_blessure(Common::EnumHumanWound value);
  
  // optional bool blesse_mental = 5;
  inline bool has_blesse_mental() const;
  inline void clear_blesse_mental();
  static const int kBlesseMentalFieldNumber = 5;
  inline bool blesse_mental() const;
  inline void set_blesse_mental(bool value);
  
  // optional bool contamine_nbc = 6;
  inline bool has_contamine_nbc() const;
  inline void clear_contamine_nbc();
  static const int kContamineNbcFieldNumber = 6;
  inline bool contamine_nbc() const;
  inline void set_contamine_nbc(bool value);
  
  // optional .Common.EnumLogMedicalHandlingStatus etat = 7;
  inline bool has_etat() const;
  inline void clear_etat();
  static const int kEtatFieldNumber = 7;
  inline Common::EnumLogMedicalHandlingStatus etat() const;
  inline void set_etat(Common::EnumLogMedicalHandlingStatus value);
  
  // optional bool diagnostique_effectue = 8;
  inline bool has_diagnostique_effectue() const;
  inline void clear_diagnostique_effectue();
  static const int kDiagnostiqueEffectueFieldNumber = 8;
  inline bool diagnostique_effectue() const;
  inline void set_diagnostique_effectue(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MedicalRequestId* request_;
  ::Common::UnitId* unit_;
  ::Common::UnitId* provider_;
  int blessure_;
  bool blesse_mental_;
  bool contamine_nbc_;
  int etat_;
  bool diagnostique_effectue_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalHandlingUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalHandlingDestruction : public ::google::protobuf::Message {
 public:
  MsgLogMedicalHandlingDestruction();
  virtual ~MsgLogMedicalHandlingDestruction();
  
  MsgLogMedicalHandlingDestruction(const MsgLogMedicalHandlingDestruction& from);
  
  inline MsgLogMedicalHandlingDestruction& operator=(const MsgLogMedicalHandlingDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalHandlingDestruction& default_instance();
  void Swap(MsgLogMedicalHandlingDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalHandlingDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalHandlingDestruction& from);
  void MergeFrom(const MsgLogMedicalHandlingDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MedicalRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::MedicalRequestId& request() const;
  inline ::Common::MedicalRequestId* mutable_request();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MedicalRequestId* request_;
  ::Common::UnitId* unit_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalHandlingDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalEquipmentAvailability : public ::google::protobuf::Message {
 public:
  MsgLogMedicalEquipmentAvailability();
  virtual ~MsgLogMedicalEquipmentAvailability();
  
  MsgLogMedicalEquipmentAvailability(const MsgLogMedicalEquipmentAvailability& from);
  
  inline MsgLogMedicalEquipmentAvailability& operator=(const MsgLogMedicalEquipmentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalEquipmentAvailability& default_instance();
  void Swap(MsgLogMedicalEquipmentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalEquipmentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalEquipmentAvailability& from);
  void MergeFrom(const MsgLogMedicalEquipmentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EquipmentType equipment_type = 1;
  inline bool has_equipment_type() const;
  inline void clear_equipment_type();
  static const int kEquipmentTypeFieldNumber = 1;
  inline const ::Common::EquipmentType& equipment_type() const;
  inline ::Common::EquipmentType* mutable_equipment_type();
  
  // required int32 nbr_total = 2;
  inline bool has_nbr_total() const;
  inline void clear_nbr_total();
  static const int kNbrTotalFieldNumber = 2;
  inline ::google::protobuf::int32 nbr_total() const;
  inline void set_nbr_total(::google::protobuf::int32 value);
  
  // required int32 nbr_disponibles = 3;
  inline bool has_nbr_disponibles() const;
  inline void clear_nbr_disponibles();
  static const int kNbrDisponiblesFieldNumber = 3;
  inline ::google::protobuf::int32 nbr_disponibles() const;
  inline void set_nbr_disponibles(::google::protobuf::int32 value);
  
  // required int32 nbr_au_travail = 4;
  inline bool has_nbr_au_travail() const;
  inline void clear_nbr_au_travail();
  static const int kNbrAuTravailFieldNumber = 4;
  inline ::google::protobuf::int32 nbr_au_travail() const;
  inline void set_nbr_au_travail(::google::protobuf::int32 value);
  
  // optional int32 nbr_pretes = 5;
  inline bool has_nbr_pretes() const;
  inline void clear_nbr_pretes();
  static const int kNbrPretesFieldNumber = 5;
  inline ::google::protobuf::int32 nbr_pretes() const;
  inline void set_nbr_pretes(::google::protobuf::int32 value);
  
  // optional int32 nbr_au_repos = 6;
  inline bool has_nbr_au_repos() const;
  inline void clear_nbr_au_repos();
  static const int kNbrAuReposFieldNumber = 6;
  inline ::google::protobuf::int32 nbr_au_repos() const;
  inline void set_nbr_au_repos(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::EquipmentType* equipment_type_;
  ::google::protobuf::int32 nbr_total_;
  ::google::protobuf::int32 nbr_disponibles_;
  ::google::protobuf::int32 nbr_au_travail_;
  ::google::protobuf::int32 nbr_pretes_;
  ::google::protobuf::int32 nbr_au_repos_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalEquipmentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfLogMedicalEquipmentAvailability : public ::google::protobuf::Message {
 public:
  SeqOfLogMedicalEquipmentAvailability();
  virtual ~SeqOfLogMedicalEquipmentAvailability();
  
  SeqOfLogMedicalEquipmentAvailability(const SeqOfLogMedicalEquipmentAvailability& from);
  
  inline SeqOfLogMedicalEquipmentAvailability& operator=(const SeqOfLogMedicalEquipmentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfLogMedicalEquipmentAvailability& default_instance();
  void Swap(SeqOfLogMedicalEquipmentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfLogMedicalEquipmentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfLogMedicalEquipmentAvailability& from);
  void MergeFrom(const SeqOfLogMedicalEquipmentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgLogMedicalEquipmentAvailability elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability >* mutable_elem();
  inline const ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability& elem(int index) const;
  inline ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfLogMedicalEquipmentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalState : public ::google::protobuf::Message {
 public:
  MsgLogMedicalState();
  virtual ~MsgLogMedicalState();
  
  MsgLogMedicalState(const MsgLogMedicalState& from);
  
  inline MsgLogMedicalState& operator=(const MsgLogMedicalState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalState& default_instance();
  void Swap(MsgLogMedicalState* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalState& from);
  void MergeFrom(const MsgLogMedicalState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // optional bool chaine_activee = 2;
  inline bool has_chaine_activee() const;
  inline void clear_chaine_activee();
  static const int kChaineActiveeFieldNumber = 2;
  inline bool chaine_activee() const;
  inline void set_chaine_activee(bool value);
  
  // optional .Common.MsgLogMedicalPriorities priorites = 3;
  inline bool has_priorites() const;
  inline void clear_priorites();
  static const int kPrioritesFieldNumber = 3;
  inline const ::Common::MsgLogMedicalPriorities& priorites() const;
  inline ::Common::MsgLogMedicalPriorities* mutable_priorites();
  
  // optional .Common.AutomatIdList tactical_priorities = 4;
  inline bool has_tactical_priorities() const;
  inline void clear_tactical_priorities();
  static const int kTacticalPrioritiesFieldNumber = 4;
  inline const ::Common::AutomatIdList& tactical_priorities() const;
  inline ::Common::AutomatIdList* mutable_tactical_priorities();
  
  // optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_releve = 5;
  inline bool has_disponibilites_ambulances_releve() const;
  inline void clear_disponibilites_ambulances_releve();
  static const int kDisponibilitesAmbulancesReleveFieldNumber = 5;
  inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& disponibilites_ambulances_releve() const;
  inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* mutable_disponibilites_ambulances_releve();
  
  // optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_ramassage = 6;
  inline bool has_disponibilites_ambulances_ramassage() const;
  inline void clear_disponibilites_ambulances_ramassage();
  static const int kDisponibilitesAmbulancesRamassageFieldNumber = 6;
  inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& disponibilites_ambulances_ramassage() const;
  inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* mutable_disponibilites_ambulances_ramassage();
  
  // optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_medecins = 7;
  inline bool has_disponibilites_medecins() const;
  inline void clear_disponibilites_medecins();
  static const int kDisponibilitesMedecinsFieldNumber = 7;
  inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& disponibilites_medecins() const;
  inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* mutable_disponibilites_medecins();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  bool chaine_activee_;
  ::Common::MsgLogMedicalPriorities* priorites_;
  ::Common::AutomatIdList* tactical_priorities_;
  ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* disponibilites_ambulances_releve_;
  ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* disponibilites_ambulances_ramassage_;
  ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* disponibilites_medecins_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalState* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceHandlingCreation : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceHandlingCreation();
  virtual ~MsgLogMaintenanceHandlingCreation();
  
  MsgLogMaintenanceHandlingCreation(const MsgLogMaintenanceHandlingCreation& from);
  
  inline MsgLogMaintenanceHandlingCreation& operator=(const MsgLogMaintenanceHandlingCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceHandlingCreation& default_instance();
  void Swap(MsgLogMaintenanceHandlingCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceHandlingCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceHandlingCreation& from);
  void MergeFrom(const MsgLogMaintenanceHandlingCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MaintenanceRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::MaintenanceRequestId& request() const;
  inline ::Common::MaintenanceRequestId* mutable_request();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required int32 tick_creation = 3;
  inline bool has_tick_creation() const;
  inline void clear_tick_creation();
  static const int kTickCreationFieldNumber = 3;
  inline ::google::protobuf::int32 tick_creation() const;
  inline void set_tick_creation(::google::protobuf::int32 value);
  
  // required .Common.EquipmentType equipement = 4;
  inline bool has_equipement() const;
  inline void clear_equipement();
  static const int kEquipementFieldNumber = 4;
  inline const ::Common::EquipmentType& equipement() const;
  inline ::Common::EquipmentType* mutable_equipement();
  
  // required .Common.BreakdownType breakdown = 5;
  inline bool has_breakdown() const;
  inline void clear_breakdown();
  static const int kBreakdownFieldNumber = 5;
  inline const ::Common::BreakdownType& breakdown() const;
  inline ::Common::BreakdownType* mutable_breakdown();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MaintenanceRequestId* request_;
  ::Common::UnitId* unit_;
  ::google::protobuf::int32 tick_creation_;
  ::Common::EquipmentType* equipement_;
  ::Common::BreakdownType* breakdown_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceHandlingCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceHandlingUpdate : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceHandlingUpdate();
  virtual ~MsgLogMaintenanceHandlingUpdate();
  
  MsgLogMaintenanceHandlingUpdate(const MsgLogMaintenanceHandlingUpdate& from);
  
  inline MsgLogMaintenanceHandlingUpdate& operator=(const MsgLogMaintenanceHandlingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceHandlingUpdate& default_instance();
  void Swap(MsgLogMaintenanceHandlingUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceHandlingUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceHandlingUpdate& from);
  void MergeFrom(const MsgLogMaintenanceHandlingUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MaintenanceRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::MaintenanceRequestId& request() const;
  inline ::Common::MaintenanceRequestId* mutable_request();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required .Common.UnitId provider = 3;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 3;
  inline const ::Common::UnitId& provider() const;
  inline ::Common::UnitId* mutable_provider();
  
  // optional .Common.EnumLogMaintenanceHandlingStatus etat = 4;
  inline bool has_etat() const;
  inline void clear_etat();
  static const int kEtatFieldNumber = 4;
  inline Common::EnumLogMaintenanceHandlingStatus etat() const;
  inline void set_etat(Common::EnumLogMaintenanceHandlingStatus value);
  
  // optional bool diagnostique_effectue = 5;
  inline bool has_diagnostique_effectue() const;
  inline void clear_diagnostique_effectue();
  static const int kDiagnostiqueEffectueFieldNumber = 5;
  inline bool diagnostique_effectue() const;
  inline void set_diagnostique_effectue(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MaintenanceRequestId* request_;
  ::Common::UnitId* unit_;
  ::Common::UnitId* provider_;
  int etat_;
  bool diagnostique_effectue_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceHandlingUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceHandlingDestruction : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceHandlingDestruction();
  virtual ~MsgLogMaintenanceHandlingDestruction();
  
  MsgLogMaintenanceHandlingDestruction(const MsgLogMaintenanceHandlingDestruction& from);
  
  inline MsgLogMaintenanceHandlingDestruction& operator=(const MsgLogMaintenanceHandlingDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceHandlingDestruction& default_instance();
  void Swap(MsgLogMaintenanceHandlingDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceHandlingDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceHandlingDestruction& from);
  void MergeFrom(const MsgLogMaintenanceHandlingDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MaintenanceRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::MaintenanceRequestId& request() const;
  inline ::Common::MaintenanceRequestId* mutable_request();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MaintenanceRequestId* request_;
  ::Common::UnitId* unit_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceHandlingDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceEquipmentAvailability : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceEquipmentAvailability();
  virtual ~MsgLogMaintenanceEquipmentAvailability();
  
  MsgLogMaintenanceEquipmentAvailability(const MsgLogMaintenanceEquipmentAvailability& from);
  
  inline MsgLogMaintenanceEquipmentAvailability& operator=(const MsgLogMaintenanceEquipmentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceEquipmentAvailability& default_instance();
  void Swap(MsgLogMaintenanceEquipmentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceEquipmentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceEquipmentAvailability& from);
  void MergeFrom(const MsgLogMaintenanceEquipmentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EquipmentType equipment_type = 1;
  inline bool has_equipment_type() const;
  inline void clear_equipment_type();
  static const int kEquipmentTypeFieldNumber = 1;
  inline const ::Common::EquipmentType& equipment_type() const;
  inline ::Common::EquipmentType* mutable_equipment_type();
  
  // required int32 nbr_total = 2;
  inline bool has_nbr_total() const;
  inline void clear_nbr_total();
  static const int kNbrTotalFieldNumber = 2;
  inline ::google::protobuf::int32 nbr_total() const;
  inline void set_nbr_total(::google::protobuf::int32 value);
  
  // required int32 nbr_disponibles = 3;
  inline bool has_nbr_disponibles() const;
  inline void clear_nbr_disponibles();
  static const int kNbrDisponiblesFieldNumber = 3;
  inline ::google::protobuf::int32 nbr_disponibles() const;
  inline void set_nbr_disponibles(::google::protobuf::int32 value);
  
  // required int32 nbr_au_travail = 4;
  inline bool has_nbr_au_travail() const;
  inline void clear_nbr_au_travail();
  static const int kNbrAuTravailFieldNumber = 4;
  inline ::google::protobuf::int32 nbr_au_travail() const;
  inline void set_nbr_au_travail(::google::protobuf::int32 value);
  
  // optional int32 nbr_pretes = 5;
  inline bool has_nbr_pretes() const;
  inline void clear_nbr_pretes();
  static const int kNbrPretesFieldNumber = 5;
  inline ::google::protobuf::int32 nbr_pretes() const;
  inline void set_nbr_pretes(::google::protobuf::int32 value);
  
  // optional int32 nbr_au_repos = 6;
  inline bool has_nbr_au_repos() const;
  inline void clear_nbr_au_repos();
  static const int kNbrAuReposFieldNumber = 6;
  inline ::google::protobuf::int32 nbr_au_repos() const;
  inline void set_nbr_au_repos(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::EquipmentType* equipment_type_;
  ::google::protobuf::int32 nbr_total_;
  ::google::protobuf::int32 nbr_disponibles_;
  ::google::protobuf::int32 nbr_au_travail_;
  ::google::protobuf::int32 nbr_pretes_;
  ::google::protobuf::int32 nbr_au_repos_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceEquipmentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfLogMaintenanceEquipmentAvailability : public ::google::protobuf::Message {
 public:
  SeqOfLogMaintenanceEquipmentAvailability();
  virtual ~SeqOfLogMaintenanceEquipmentAvailability();
  
  SeqOfLogMaintenanceEquipmentAvailability(const SeqOfLogMaintenanceEquipmentAvailability& from);
  
  inline SeqOfLogMaintenanceEquipmentAvailability& operator=(const SeqOfLogMaintenanceEquipmentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfLogMaintenanceEquipmentAvailability& default_instance();
  void Swap(SeqOfLogMaintenanceEquipmentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfLogMaintenanceEquipmentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfLogMaintenanceEquipmentAvailability& from);
  void MergeFrom(const SeqOfLogMaintenanceEquipmentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgLogMaintenanceEquipmentAvailability elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability >* mutable_elem();
  inline const ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability& elem(int index) const;
  inline ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfLogMaintenanceEquipmentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceState : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceState();
  virtual ~MsgLogMaintenanceState();
  
  MsgLogMaintenanceState(const MsgLogMaintenanceState& from);
  
  inline MsgLogMaintenanceState& operator=(const MsgLogMaintenanceState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceState& default_instance();
  void Swap(MsgLogMaintenanceState* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceState& from);
  void MergeFrom(const MsgLogMaintenanceState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // optional bool chaine_activee = 2;
  inline bool has_chaine_activee() const;
  inline void clear_chaine_activee();
  static const int kChaineActiveeFieldNumber = 2;
  inline bool chaine_activee() const;
  inline void set_chaine_activee(bool value);
  
  // optional .Common.EnumLogMaintenanceRegimeTravail regime_travail = 3;
  inline bool has_regime_travail() const;
  inline void clear_regime_travail();
  static const int kRegimeTravailFieldNumber = 3;
  inline Common::EnumLogMaintenanceRegimeTravail regime_travail() const;
  inline void set_regime_travail(Common::EnumLogMaintenanceRegimeTravail value);
  
  // optional .Common.MsgLogMaintenancePriorities priorites = 4;
  inline bool has_priorites() const;
  inline void clear_priorites();
  static const int kPrioritesFieldNumber = 4;
  inline const ::Common::MsgLogMaintenancePriorities& priorites() const;
  inline ::Common::MsgLogMaintenancePriorities* mutable_priorites();
  
  // optional .Common.AutomatIdList priorites_tactiques = 5;
  inline bool has_priorites_tactiques() const;
  inline void clear_priorites_tactiques();
  static const int kPrioritesTactiquesFieldNumber = 5;
  inline const ::Common::AutomatIdList& priorites_tactiques() const;
  inline ::Common::AutomatIdList* mutable_priorites_tactiques();
  
  // optional .MsgsSimToClient.SeqOfLogMaintenanceEquipmentAvailability disponibilites_remorqueurs = 6;
  inline bool has_disponibilites_remorqueurs() const;
  inline void clear_disponibilites_remorqueurs();
  static const int kDisponibilitesRemorqueursFieldNumber = 6;
  inline const ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability& disponibilites_remorqueurs() const;
  inline ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* mutable_disponibilites_remorqueurs();
  
  // optional .MsgsSimToClient.SeqOfLogMaintenanceEquipmentAvailability disponibilites_reparateurs = 7;
  inline bool has_disponibilites_reparateurs() const;
  inline void clear_disponibilites_reparateurs();
  static const int kDisponibilitesReparateursFieldNumber = 7;
  inline const ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability& disponibilites_reparateurs() const;
  inline ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* mutable_disponibilites_reparateurs();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  bool chaine_activee_;
  int regime_travail_;
  ::Common::MsgLogMaintenancePriorities* priorites_;
  ::Common::AutomatIdList* priorites_tactiques_;
  ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* disponibilites_remorqueurs_;
  ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* disponibilites_reparateurs_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceState* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyHandlingCreation : public ::google::protobuf::Message {
 public:
  MsgLogSupplyHandlingCreation();
  virtual ~MsgLogSupplyHandlingCreation();
  
  MsgLogSupplyHandlingCreation(const MsgLogSupplyHandlingCreation& from);
  
  inline MsgLogSupplyHandlingCreation& operator=(const MsgLogSupplyHandlingCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyHandlingCreation& default_instance();
  void Swap(MsgLogSupplyHandlingCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyHandlingCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyHandlingCreation& from);
  void MergeFrom(const MsgLogSupplyHandlingCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.SupplyRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::SupplyRequestId& request() const;
  inline ::Common::SupplyRequestId* mutable_request();
  
  // optional .Common.AutomatId consumer = 2;
  inline bool has_consumer() const;
  inline void clear_consumer();
  static const int kConsumerFieldNumber = 2;
  inline const ::Common::AutomatId& consumer() const;
  inline ::Common::AutomatId* mutable_consumer();
  
  // optional int32 tick_creation = 3;
  inline bool has_tick_creation() const;
  inline void clear_tick_creation();
  static const int kTickCreationFieldNumber = 3;
  inline ::google::protobuf::int32 tick_creation() const;
  inline void set_tick_creation(::google::protobuf::int32 value);
  
  // optional .MsgsSimToClient.SeqOfDotationQuery dotations = 4;
  inline bool has_dotations() const;
  inline void clear_dotations();
  static const int kDotationsFieldNumber = 4;
  inline const ::MsgsSimToClient::SeqOfDotationQuery& dotations() const;
  inline ::MsgsSimToClient::SeqOfDotationQuery* mutable_dotations();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::SupplyRequestId* request_;
  ::Common::AutomatId* consumer_;
  ::google::protobuf::int32 tick_creation_;
  ::MsgsSimToClient::SeqOfDotationQuery* dotations_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyHandlingCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgDotationQuery : public ::google::protobuf::Message {
 public:
  MsgDotationQuery();
  virtual ~MsgDotationQuery();
  
  MsgDotationQuery(const MsgDotationQuery& from);
  
  inline MsgDotationQuery& operator=(const MsgDotationQuery& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDotationQuery& default_instance();
  void Swap(MsgDotationQuery* other);
  
  // implements Message ----------------------------------------------
  
  MsgDotationQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgDotationQuery& from);
  void MergeFrom(const MsgDotationQuery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.ResourceType resource = 1;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 1;
  inline const ::Common::ResourceType& resource() const;
  inline ::Common::ResourceType* mutable_resource();
  
  // optional int32 quantite_demandee = 2;
  inline bool has_quantite_demandee() const;
  inline void clear_quantite_demandee();
  static const int kQuantiteDemandeeFieldNumber = 2;
  inline ::google::protobuf::int32 quantite_demandee() const;
  inline void set_quantite_demandee(::google::protobuf::int32 value);
  
  // optional int32 quantite_accordee = 3;
  inline bool has_quantite_accordee() const;
  inline void clear_quantite_accordee();
  static const int kQuantiteAccordeeFieldNumber = 3;
  inline ::google::protobuf::int32 quantite_accordee() const;
  inline void set_quantite_accordee(::google::protobuf::int32 value);
  
  // optional int32 quantite_en_transit = 4;
  inline bool has_quantite_en_transit() const;
  inline void clear_quantite_en_transit();
  static const int kQuantiteEnTransitFieldNumber = 4;
  inline ::google::protobuf::int32 quantite_en_transit() const;
  inline void set_quantite_en_transit(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ResourceType* resource_;
  ::google::protobuf::int32 quantite_demandee_;
  ::google::protobuf::int32 quantite_accordee_;
  ::google::protobuf::int32 quantite_en_transit_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgDotationQuery* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfDotationQuery : public ::google::protobuf::Message {
 public:
  SeqOfDotationQuery();
  virtual ~SeqOfDotationQuery();
  
  SeqOfDotationQuery(const SeqOfDotationQuery& from);
  
  inline SeqOfDotationQuery& operator=(const SeqOfDotationQuery& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfDotationQuery& default_instance();
  void Swap(SeqOfDotationQuery* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfDotationQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfDotationQuery& from);
  void MergeFrom(const SeqOfDotationQuery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgDotationQuery elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery >* mutable_elem();
  inline const ::MsgsSimToClient::MsgDotationQuery& elem(int index) const;
  inline ::MsgsSimToClient::MsgDotationQuery* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgDotationQuery* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfDotationQuery* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyHandlingUpdate : public ::google::protobuf::Message {
 public:
  MsgLogSupplyHandlingUpdate();
  virtual ~MsgLogSupplyHandlingUpdate();
  
  MsgLogSupplyHandlingUpdate(const MsgLogSupplyHandlingUpdate& from);
  
  inline MsgLogSupplyHandlingUpdate& operator=(const MsgLogSupplyHandlingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyHandlingUpdate& default_instance();
  void Swap(MsgLogSupplyHandlingUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyHandlingUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyHandlingUpdate& from);
  void MergeFrom(const MsgLogSupplyHandlingUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.SupplyRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::SupplyRequestId& request() const;
  inline ::Common::SupplyRequestId* mutable_request();
  
  // optional .Common.AutomatId consumer = 2;
  inline bool has_consumer() const;
  inline void clear_consumer();
  static const int kConsumerFieldNumber = 2;
  inline const ::Common::AutomatId& consumer() const;
  inline ::Common::AutomatId* mutable_consumer();
  
  // optional .Common.AutomatId supplier = 3;
  inline bool has_supplier() const;
  inline void clear_supplier();
  static const int kSupplierFieldNumber = 3;
  inline const ::Common::AutomatId& supplier() const;
  inline ::Common::AutomatId* mutable_supplier();
  
  // optional .Common.AutomatId convoy_provider = 4;
  inline bool has_convoy_provider() const;
  inline void clear_convoy_provider();
  static const int kConvoyProviderFieldNumber = 4;
  inline const ::Common::AutomatId& convoy_provider() const;
  inline ::Common::AutomatId* mutable_convoy_provider();
  
  // optional .Common.UnitId convoying_unit = 5;
  inline bool has_convoying_unit() const;
  inline void clear_convoying_unit();
  static const int kConvoyingUnitFieldNumber = 5;
  inline const ::Common::UnitId& convoying_unit() const;
  inline ::Common::UnitId* mutable_convoying_unit();
  
  // optional .MsgsSimToClient.EnumLogSupplyHandlingStatus etat = 6;
  inline bool has_etat() const;
  inline void clear_etat();
  static const int kEtatFieldNumber = 6;
  inline MsgsSimToClient::EnumLogSupplyHandlingStatus etat() const;
  inline void set_etat(MsgsSimToClient::EnumLogSupplyHandlingStatus value);
  
  // optional .MsgsSimToClient.SeqOfDotationQuery dotations = 7;
  inline bool has_dotations() const;
  inline void clear_dotations();
  static const int kDotationsFieldNumber = 7;
  inline const ::MsgsSimToClient::SeqOfDotationQuery& dotations() const;
  inline ::MsgsSimToClient::SeqOfDotationQuery* mutable_dotations();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::SupplyRequestId* request_;
  ::Common::AutomatId* consumer_;
  ::Common::AutomatId* supplier_;
  ::Common::AutomatId* convoy_provider_;
  ::Common::UnitId* convoying_unit_;
  int etat_;
  ::MsgsSimToClient::SeqOfDotationQuery* dotations_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyHandlingUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyHandlingDestruction : public ::google::protobuf::Message {
 public:
  MsgLogSupplyHandlingDestruction();
  virtual ~MsgLogSupplyHandlingDestruction();
  
  MsgLogSupplyHandlingDestruction(const MsgLogSupplyHandlingDestruction& from);
  
  inline MsgLogSupplyHandlingDestruction& operator=(const MsgLogSupplyHandlingDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyHandlingDestruction& default_instance();
  void Swap(MsgLogSupplyHandlingDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyHandlingDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyHandlingDestruction& from);
  void MergeFrom(const MsgLogSupplyHandlingDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.SupplyRequestId request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::Common::SupplyRequestId& request() const;
  inline ::Common::SupplyRequestId* mutable_request();
  
  // required .Common.AutomatId consumer = 2;
  inline bool has_consumer() const;
  inline void clear_consumer();
  static const int kConsumerFieldNumber = 2;
  inline const ::Common::AutomatId& consumer() const;
  inline ::Common::AutomatId* mutable_consumer();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::SupplyRequestId* request_;
  ::Common::AutomatId* consumer_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyHandlingDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyEquimentAvailability : public ::google::protobuf::Message {
 public:
  MsgLogSupplyEquimentAvailability();
  virtual ~MsgLogSupplyEquimentAvailability();
  
  MsgLogSupplyEquimentAvailability(const MsgLogSupplyEquimentAvailability& from);
  
  inline MsgLogSupplyEquimentAvailability& operator=(const MsgLogSupplyEquimentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyEquimentAvailability& default_instance();
  void Swap(MsgLogSupplyEquimentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyEquimentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyEquimentAvailability& from);
  void MergeFrom(const MsgLogSupplyEquimentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.EquipmentType equipment = 1;
  inline bool has_equipment() const;
  inline void clear_equipment();
  static const int kEquipmentFieldNumber = 1;
  inline const ::Common::EquipmentType& equipment() const;
  inline ::Common::EquipmentType* mutable_equipment();
  
  // optional int32 nbr_total = 2;
  inline bool has_nbr_total() const;
  inline void clear_nbr_total();
  static const int kNbrTotalFieldNumber = 2;
  inline ::google::protobuf::int32 nbr_total() const;
  inline void set_nbr_total(::google::protobuf::int32 value);
  
  // optional int32 nbr_disponibles = 3;
  inline bool has_nbr_disponibles() const;
  inline void clear_nbr_disponibles();
  static const int kNbrDisponiblesFieldNumber = 3;
  inline ::google::protobuf::int32 nbr_disponibles() const;
  inline void set_nbr_disponibles(::google::protobuf::int32 value);
  
  // optional int32 nbr_au_travail = 4;
  inline bool has_nbr_au_travail() const;
  inline void clear_nbr_au_travail();
  static const int kNbrAuTravailFieldNumber = 4;
  inline ::google::protobuf::int32 nbr_au_travail() const;
  inline void set_nbr_au_travail(::google::protobuf::int32 value);
  
  // optional int32 nbr_pretes = 5;
  inline bool has_nbr_pretes() const;
  inline void clear_nbr_pretes();
  static const int kNbrPretesFieldNumber = 5;
  inline ::google::protobuf::int32 nbr_pretes() const;
  inline void set_nbr_pretes(::google::protobuf::int32 value);
  
  // optional int32 nbr_au_repos = 6;
  inline bool has_nbr_au_repos() const;
  inline void clear_nbr_au_repos();
  static const int kNbrAuReposFieldNumber = 6;
  inline ::google::protobuf::int32 nbr_au_repos() const;
  inline void set_nbr_au_repos(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::EquipmentType* equipment_;
  ::google::protobuf::int32 nbr_total_;
  ::google::protobuf::int32 nbr_disponibles_;
  ::google::protobuf::int32 nbr_au_travail_;
  ::google::protobuf::int32 nbr_pretes_;
  ::google::protobuf::int32 nbr_au_repos_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyEquimentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfLogSupplyEquimentAvailability : public ::google::protobuf::Message {
 public:
  SeqOfLogSupplyEquimentAvailability();
  virtual ~SeqOfLogSupplyEquimentAvailability();
  
  SeqOfLogSupplyEquimentAvailability(const SeqOfLogSupplyEquimentAvailability& from);
  
  inline SeqOfLogSupplyEquimentAvailability& operator=(const SeqOfLogSupplyEquimentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfLogSupplyEquimentAvailability& default_instance();
  void Swap(SeqOfLogSupplyEquimentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfLogSupplyEquimentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfLogSupplyEquimentAvailability& from);
  void MergeFrom(const SeqOfLogSupplyEquimentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgLogSupplyEquimentAvailability elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability >* mutable_elem();
  inline const ::MsgsSimToClient::MsgLogSupplyEquimentAvailability& elem(int index) const;
  inline ::MsgsSimToClient::MsgLogSupplyEquimentAvailability* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgLogSupplyEquimentAvailability* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfLogSupplyEquimentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyState : public ::google::protobuf::Message {
 public:
  MsgLogSupplyState();
  virtual ~MsgLogSupplyState();
  
  MsgLogSupplyState(const MsgLogSupplyState& from);
  
  inline MsgLogSupplyState& operator=(const MsgLogSupplyState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyState& default_instance();
  void Swap(MsgLogSupplyState* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyState& from);
  void MergeFrom(const MsgLogSupplyState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // optional bool chaine_activee = 2;
  inline bool has_chaine_activee() const;
  inline void clear_chaine_activee();
  static const int kChaineActiveeFieldNumber = 2;
  inline bool chaine_activee() const;
  inline void set_chaine_activee(bool value);
  
  // optional .Common.SeqOfDotationStock stocks = 3;
  inline bool has_stocks() const;
  inline void clear_stocks();
  static const int kStocksFieldNumber = 3;
  inline const ::Common::SeqOfDotationStock& stocks() const;
  inline ::Common::SeqOfDotationStock* mutable_stocks();
  
  // optional .MsgsSimToClient.SeqOfLogSupplyEquimentAvailability disponibilites_transporteurs_convois = 4;
  inline bool has_disponibilites_transporteurs_convois() const;
  inline void clear_disponibilites_transporteurs_convois();
  static const int kDisponibilitesTransporteursConvoisFieldNumber = 4;
  inline const ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability& disponibilites_transporteurs_convois() const;
  inline ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability* mutable_disponibilites_transporteurs_convois();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  bool chaine_activee_;
  ::Common::SeqOfDotationStock* stocks_;
  ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability* disponibilites_transporteurs_convois_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyState* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyQuotas : public ::google::protobuf::Message {
 public:
  MsgLogSupplyQuotas();
  virtual ~MsgLogSupplyQuotas();
  
  MsgLogSupplyQuotas(const MsgLogSupplyQuotas& from);
  
  inline MsgLogSupplyQuotas& operator=(const MsgLogSupplyQuotas& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyQuotas& default_instance();
  void Swap(MsgLogSupplyQuotas* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyQuotas* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyQuotas& from);
  void MergeFrom(const MsgLogSupplyQuotas& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId automat = 1;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 1;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
  // required .Common.SeqOfDotationQuota quotas = 2;
  inline bool has_quotas() const;
  inline void clear_quotas();
  static const int kQuotasFieldNumber = 2;
  inline const ::Common::SeqOfDotationQuota& quotas() const;
  inline ::Common::SeqOfDotationQuota* mutable_quotas();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* automat_;
  ::Common::SeqOfDotationQuota* quotas_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyQuotas* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdCreation : public ::google::protobuf::Message {
 public:
  MsgCrowdCreation();
  virtual ~MsgCrowdCreation();
  
  MsgCrowdCreation(const MsgCrowdCreation& from);
  
  inline MsgCrowdCreation& operator=(const MsgCrowdCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdCreation& default_instance();
  void Swap(MsgCrowdCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdCreation& from);
  void MergeFrom(const MsgCrowdCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdId crowd = 1;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 1;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
  // required .Common.CrowdType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::CrowdType& type() const;
  inline ::Common::CrowdType* mutable_type();
  
  // optional string nom = 3;
  inline bool has_nom() const;
  inline void clear_nom();
  static const int kNomFieldNumber = 3;
  inline const ::std::string& nom() const;
  inline void set_nom(const ::std::string& value);
  inline void set_nom(const char* value);
  inline void set_nom(const char* value, size_t size);
  inline ::std::string* mutable_nom();
  
  // required .Common.PartyId party = 4;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 4;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdId* crowd_;
  ::Common::CrowdType* type_;
  ::std::string* nom_;
  static const ::std::string _default_nom_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdUpdate : public ::google::protobuf::Message {
 public:
  MsgCrowdUpdate();
  virtual ~MsgCrowdUpdate();
  
  MsgCrowdUpdate(const MsgCrowdUpdate& from);
  
  inline MsgCrowdUpdate& operator=(const MsgCrowdUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdUpdate& default_instance();
  void Swap(MsgCrowdUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdUpdate& from);
  void MergeFrom(const MsgCrowdUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdId crowd = 1;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 1;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
  // optional int32 etat_domination = 2;
  inline bool has_etat_domination() const;
  inline void clear_etat_domination();
  static const int kEtatDominationFieldNumber = 2;
  inline ::google::protobuf::int32 etat_domination() const;
  inline void set_etat_domination(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdId* crowd_;
  ::google::protobuf::int32 etat_domination_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdConcentrationCreation : public ::google::protobuf::Message {
 public:
  MsgCrowdConcentrationCreation();
  virtual ~MsgCrowdConcentrationCreation();
  
  MsgCrowdConcentrationCreation(const MsgCrowdConcentrationCreation& from);
  
  inline MsgCrowdConcentrationCreation& operator=(const MsgCrowdConcentrationCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdConcentrationCreation& default_instance();
  void Swap(MsgCrowdConcentrationCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdConcentrationCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdConcentrationCreation& from);
  void MergeFrom(const MsgCrowdConcentrationCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdConcentrationId concentration = 1;
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 1;
  inline const ::Common::CrowdConcentrationId& concentration() const;
  inline ::Common::CrowdConcentrationId* mutable_concentration();
  
  // required .Common.CrowdId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
  // required .Common.MsgCoordLatLong position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdConcentrationId* concentration_;
  ::Common::CrowdId* crowd_;
  ::Common::MsgCoordLatLong* position_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdConcentrationCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdConcentrationDestruction : public ::google::protobuf::Message {
 public:
  MsgCrowdConcentrationDestruction();
  virtual ~MsgCrowdConcentrationDestruction();
  
  MsgCrowdConcentrationDestruction(const MsgCrowdConcentrationDestruction& from);
  
  inline MsgCrowdConcentrationDestruction& operator=(const MsgCrowdConcentrationDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdConcentrationDestruction& default_instance();
  void Swap(MsgCrowdConcentrationDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdConcentrationDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdConcentrationDestruction& from);
  void MergeFrom(const MsgCrowdConcentrationDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdConcentrationId concentration = 1;
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 1;
  inline const ::Common::CrowdConcentrationId& concentration() const;
  inline ::Common::CrowdConcentrationId* mutable_concentration();
  
  // required .Common.CrowdId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdConcentrationId* concentration_;
  ::Common::CrowdId* crowd_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdConcentrationDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdConcentrationUpdate : public ::google::protobuf::Message {
 public:
  MsgCrowdConcentrationUpdate();
  virtual ~MsgCrowdConcentrationUpdate();
  
  MsgCrowdConcentrationUpdate(const MsgCrowdConcentrationUpdate& from);
  
  inline MsgCrowdConcentrationUpdate& operator=(const MsgCrowdConcentrationUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdConcentrationUpdate& default_instance();
  void Swap(MsgCrowdConcentrationUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdConcentrationUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdConcentrationUpdate& from);
  void MergeFrom(const MsgCrowdConcentrationUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdConcentrationId concentration = 1;
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 1;
  inline const ::Common::CrowdConcentrationId& concentration() const;
  inline ::Common::CrowdConcentrationId* mutable_concentration();
  
  // required .Common.CrowdId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
  // optional int32 nb_humains_vivants = 3;
  inline bool has_nb_humains_vivants() const;
  inline void clear_nb_humains_vivants();
  static const int kNbHumainsVivantsFieldNumber = 3;
  inline ::google::protobuf::int32 nb_humains_vivants() const;
  inline void set_nb_humains_vivants(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_morts = 4;
  inline bool has_nb_humains_morts() const;
  inline void clear_nb_humains_morts();
  static const int kNbHumainsMortsFieldNumber = 4;
  inline ::google::protobuf::int32 nb_humains_morts() const;
  inline void set_nb_humains_morts(::google::protobuf::int32 value);
  
  // optional .Common.EnumCrowdAttitude attitude = 5;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 5;
  inline Common::EnumCrowdAttitude attitude() const;
  inline void set_attitude(Common::EnumCrowdAttitude value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdConcentrationId* concentration_;
  ::Common::CrowdId* crowd_;
  ::google::protobuf::int32 nb_humains_vivants_;
  ::google::protobuf::int32 nb_humains_morts_;
  int attitude_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdConcentrationUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdFlowCreation : public ::google::protobuf::Message {
 public:
  MsgCrowdFlowCreation();
  virtual ~MsgCrowdFlowCreation();
  
  MsgCrowdFlowCreation(const MsgCrowdFlowCreation& from);
  
  inline MsgCrowdFlowCreation& operator=(const MsgCrowdFlowCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdFlowCreation& default_instance();
  void Swap(MsgCrowdFlowCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdFlowCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdFlowCreation& from);
  void MergeFrom(const MsgCrowdFlowCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdFlowId flow = 1;
  inline bool has_flow() const;
  inline void clear_flow();
  static const int kFlowFieldNumber = 1;
  inline const ::Common::CrowdFlowId& flow() const;
  inline ::Common::CrowdFlowId* mutable_flow();
  
  // required .Common.CrowdId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdFlowId* flow_;
  ::Common::CrowdId* crowd_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdFlowCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdFlowDestruction : public ::google::protobuf::Message {
 public:
  MsgCrowdFlowDestruction();
  virtual ~MsgCrowdFlowDestruction();
  
  MsgCrowdFlowDestruction(const MsgCrowdFlowDestruction& from);
  
  inline MsgCrowdFlowDestruction& operator=(const MsgCrowdFlowDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdFlowDestruction& default_instance();
  void Swap(MsgCrowdFlowDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdFlowDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdFlowDestruction& from);
  void MergeFrom(const MsgCrowdFlowDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdFlowId flow = 1;
  inline bool has_flow() const;
  inline void clear_flow();
  static const int kFlowFieldNumber = 1;
  inline const ::Common::CrowdFlowId& flow() const;
  inline ::Common::CrowdFlowId* mutable_flow();
  
  // required .Common.CrowdId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdFlowId* flow_;
  ::Common::CrowdId* crowd_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdFlowDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdFlowUpdate : public ::google::protobuf::Message {
 public:
  MsgCrowdFlowUpdate();
  virtual ~MsgCrowdFlowUpdate();
  
  MsgCrowdFlowUpdate(const MsgCrowdFlowUpdate& from);
  
  inline MsgCrowdFlowUpdate& operator=(const MsgCrowdFlowUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdFlowUpdate& default_instance();
  void Swap(MsgCrowdFlowUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdFlowUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdFlowUpdate& from);
  void MergeFrom(const MsgCrowdFlowUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdFlowId flow = 1;
  inline bool has_flow() const;
  inline void clear_flow();
  static const int kFlowFieldNumber = 1;
  inline const ::Common::CrowdFlowId& flow() const;
  inline ::Common::CrowdFlowId* mutable_flow();
  
  // required .Common.CrowdId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
  // optional .Common.MsgPath itineraire = 3;
  inline bool has_itineraire() const;
  inline void clear_itineraire();
  static const int kItineraireFieldNumber = 3;
  inline const ::Common::MsgPath& itineraire() const;
  inline ::Common::MsgPath* mutable_itineraire();
  
  // optional .Common.MsgPath parts = 4;
  inline bool has_parts() const;
  inline void clear_parts();
  static const int kPartsFieldNumber = 4;
  inline const ::Common::MsgPath& parts() const;
  inline ::Common::MsgPath* mutable_parts();
  
  // optional .Common.MsgHeading direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline const ::Common::MsgHeading& direction() const;
  inline ::Common::MsgHeading* mutable_direction();
  
  // optional int32 vitesse = 6;
  inline bool has_vitesse() const;
  inline void clear_vitesse();
  static const int kVitesseFieldNumber = 6;
  inline ::google::protobuf::int32 vitesse() const;
  inline void set_vitesse(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_vivants = 7;
  inline bool has_nb_humains_vivants() const;
  inline void clear_nb_humains_vivants();
  static const int kNbHumainsVivantsFieldNumber = 7;
  inline ::google::protobuf::int32 nb_humains_vivants() const;
  inline void set_nb_humains_vivants(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_morts = 8;
  inline bool has_nb_humains_morts() const;
  inline void clear_nb_humains_morts();
  static const int kNbHumainsMortsFieldNumber = 8;
  inline ::google::protobuf::int32 nb_humains_morts() const;
  inline void set_nb_humains_morts(::google::protobuf::int32 value);
  
  // optional .Common.EnumCrowdAttitude attitude = 9;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 9;
  inline Common::EnumCrowdAttitude attitude() const;
  inline void set_attitude(Common::EnumCrowdAttitude value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdFlowId* flow_;
  ::Common::CrowdId* crowd_;
  ::Common::MsgPath* itineraire_;
  ::Common::MsgPath* parts_;
  ::Common::MsgHeading* direction_;
  ::google::protobuf::int32 vitesse_;
  ::google::protobuf::int32 nb_humains_vivants_;
  ::google::protobuf::int32 nb_humains_morts_;
  int attitude_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdFlowUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgCrowdKnowledgeCreation();
  virtual ~MsgCrowdKnowledgeCreation();
  
  MsgCrowdKnowledgeCreation(const MsgCrowdKnowledgeCreation& from);
  
  inline MsgCrowdKnowledgeCreation& operator=(const MsgCrowdKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdKnowledgeCreation& default_instance();
  void Swap(MsgCrowdKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdKnowledgeCreation& from);
  void MergeFrom(const MsgCrowdKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdKnowledgeId& knowledge() const;
  inline ::Common::CrowdKnowledgeId* mutable_knowledge();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional .Common.CrowdId crowd = 3;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 3;
  inline const ::Common::CrowdId& crowd() const;
  inline ::Common::CrowdId* mutable_crowd();
  
  // optional .Common.PartyId party = 4;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 4;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdKnowledgeId* knowledge_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::CrowdId* crowd_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgCrowdKnowledgeUpdate();
  virtual ~MsgCrowdKnowledgeUpdate();
  
  MsgCrowdKnowledgeUpdate(const MsgCrowdKnowledgeUpdate& from);
  
  inline MsgCrowdKnowledgeUpdate& operator=(const MsgCrowdKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdKnowledgeUpdate& default_instance();
  void Swap(MsgCrowdKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdKnowledgeUpdate& from);
  void MergeFrom(const MsgCrowdKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdKnowledgeId& knowledge() const;
  inline ::Common::CrowdKnowledgeId* mutable_knowledge();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional int32 etat_domination = 3;
  inline bool has_etat_domination() const;
  inline void clear_etat_domination();
  static const int kEtatDominationFieldNumber = 3;
  inline ::google::protobuf::int32 etat_domination() const;
  inline void set_etat_domination(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdKnowledgeId* knowledge_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::google::protobuf::int32 etat_domination_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgCrowdKnowledgeDestruction();
  virtual ~MsgCrowdKnowledgeDestruction();
  
  MsgCrowdKnowledgeDestruction(const MsgCrowdKnowledgeDestruction& from);
  
  inline MsgCrowdKnowledgeDestruction& operator=(const MsgCrowdKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdKnowledgeDestruction& default_instance();
  void Swap(MsgCrowdKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdKnowledgeDestruction& from);
  void MergeFrom(const MsgCrowdKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdKnowledgeId& knowledge() const;
  inline ::Common::CrowdKnowledgeId* mutable_knowledge();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdKnowledgeId* knowledge_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdConcentrationKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgCrowdConcentrationKnowledgeCreation();
  virtual ~MsgCrowdConcentrationKnowledgeCreation();
  
  MsgCrowdConcentrationKnowledgeCreation(const MsgCrowdConcentrationKnowledgeCreation& from);
  
  inline MsgCrowdConcentrationKnowledgeCreation& operator=(const MsgCrowdConcentrationKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdConcentrationKnowledgeCreation& default_instance();
  void Swap(MsgCrowdConcentrationKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdConcentrationKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdConcentrationKnowledgeCreation& from);
  void MergeFrom(const MsgCrowdConcentrationKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdConcentrationKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdConcentrationKnowledgeId& knowledge() const;
  inline ::Common::CrowdConcentrationKnowledgeId* mutable_knowledge();
  
  // required .Common.CrowdKnowledgeId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdKnowledgeId& crowd() const;
  inline ::Common::CrowdKnowledgeId* mutable_crowd();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .Common.CrowdConcentrationId concentration = 4;
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 4;
  inline const ::Common::CrowdConcentrationId& concentration() const;
  inline ::Common::CrowdConcentrationId* mutable_concentration();
  
  // optional .Common.MsgCoordLatLong position = 5;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 5;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdConcentrationKnowledgeId* knowledge_;
  ::Common::CrowdKnowledgeId* crowd_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::CrowdConcentrationId* concentration_;
  ::Common::MsgCoordLatLong* position_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdConcentrationKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdConcentrationKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgCrowdConcentrationKnowledgeUpdate();
  virtual ~MsgCrowdConcentrationKnowledgeUpdate();
  
  MsgCrowdConcentrationKnowledgeUpdate(const MsgCrowdConcentrationKnowledgeUpdate& from);
  
  inline MsgCrowdConcentrationKnowledgeUpdate& operator=(const MsgCrowdConcentrationKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdConcentrationKnowledgeUpdate& default_instance();
  void Swap(MsgCrowdConcentrationKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdConcentrationKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdConcentrationKnowledgeUpdate& from);
  void MergeFrom(const MsgCrowdConcentrationKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdConcentrationKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdConcentrationKnowledgeId& knowledge() const;
  inline ::Common::CrowdConcentrationKnowledgeId* mutable_knowledge();
  
  // required .Common.CrowdKnowledgeId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdKnowledgeId& crowd() const;
  inline ::Common::CrowdKnowledgeId* mutable_crowd();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional .Common.CrowdConcentrationId concentration = 4;
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 4;
  inline const ::Common::CrowdConcentrationId& concentration() const;
  inline ::Common::CrowdConcentrationId* mutable_concentration();
  
  // optional int32 nb_humains_vivants = 5;
  inline bool has_nb_humains_vivants() const;
  inline void clear_nb_humains_vivants();
  static const int kNbHumainsVivantsFieldNumber = 5;
  inline ::google::protobuf::int32 nb_humains_vivants() const;
  inline void set_nb_humains_vivants(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_morts = 6;
  inline bool has_nb_humains_morts() const;
  inline void clear_nb_humains_morts();
  static const int kNbHumainsMortsFieldNumber = 6;
  inline ::google::protobuf::int32 nb_humains_morts() const;
  inline void set_nb_humains_morts(::google::protobuf::int32 value);
  
  // optional .Common.EnumCrowdAttitude attitude = 7;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 7;
  inline Common::EnumCrowdAttitude attitude() const;
  inline void set_attitude(Common::EnumCrowdAttitude value);
  
  // optional int32 pertinence = 8;
  inline bool has_pertinence() const;
  inline void clear_pertinence();
  static const int kPertinenceFieldNumber = 8;
  inline ::google::protobuf::int32 pertinence() const;
  inline void set_pertinence(::google::protobuf::int32 value);
  
  // optional bool est_percu = 9;
  inline bool has_est_percu() const;
  inline void clear_est_percu();
  static const int kEstPercuFieldNumber = 9;
  inline bool est_percu() const;
  inline void set_est_percu(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdConcentrationKnowledgeId* knowledge_;
  ::Common::CrowdKnowledgeId* crowd_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::CrowdConcentrationId* concentration_;
  ::google::protobuf::int32 nb_humains_vivants_;
  ::google::protobuf::int32 nb_humains_morts_;
  int attitude_;
  ::google::protobuf::int32 pertinence_;
  bool est_percu_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdConcentrationKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdConcentrationKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgCrowdConcentrationKnowledgeDestruction();
  virtual ~MsgCrowdConcentrationKnowledgeDestruction();
  
  MsgCrowdConcentrationKnowledgeDestruction(const MsgCrowdConcentrationKnowledgeDestruction& from);
  
  inline MsgCrowdConcentrationKnowledgeDestruction& operator=(const MsgCrowdConcentrationKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdConcentrationKnowledgeDestruction& default_instance();
  void Swap(MsgCrowdConcentrationKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdConcentrationKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdConcentrationKnowledgeDestruction& from);
  void MergeFrom(const MsgCrowdConcentrationKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdConcentrationKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdConcentrationKnowledgeId& knowledge() const;
  inline ::Common::CrowdConcentrationKnowledgeId* mutable_knowledge();
  
  // required .Common.CrowdKnowledgeId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdKnowledgeId& crowd() const;
  inline ::Common::CrowdKnowledgeId* mutable_crowd();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdConcentrationKnowledgeId* knowledge_;
  ::Common::CrowdKnowledgeId* crowd_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdConcentrationKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdFlowKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgCrowdFlowKnowledgeCreation();
  virtual ~MsgCrowdFlowKnowledgeCreation();
  
  MsgCrowdFlowKnowledgeCreation(const MsgCrowdFlowKnowledgeCreation& from);
  
  inline MsgCrowdFlowKnowledgeCreation& operator=(const MsgCrowdFlowKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdFlowKnowledgeCreation& default_instance();
  void Swap(MsgCrowdFlowKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdFlowKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdFlowKnowledgeCreation& from);
  void MergeFrom(const MsgCrowdFlowKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdFlowKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdFlowKnowledgeId& knowledge() const;
  inline ::Common::CrowdFlowKnowledgeId* mutable_knowledge();
  
  // required .Common.CrowdKnowledgeId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdKnowledgeId& crowd() const;
  inline ::Common::CrowdKnowledgeId* mutable_crowd();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .Common.CrowdFlowId flow = 4;
  inline bool has_flow() const;
  inline void clear_flow();
  static const int kFlowFieldNumber = 4;
  inline const ::Common::CrowdFlowId& flow() const;
  inline ::Common::CrowdFlowId* mutable_flow();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdFlowKnowledgeId* knowledge_;
  ::Common::CrowdKnowledgeId* crowd_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::CrowdFlowId* flow_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdFlowKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgFlowPart : public ::google::protobuf::Message {
 public:
  MsgFlowPart();
  virtual ~MsgFlowPart();
  
  MsgFlowPart(const MsgFlowPart& from);
  
  inline MsgFlowPart& operator=(const MsgFlowPart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFlowPart& default_instance();
  void Swap(MsgFlowPart* other);
  
  // implements Message ----------------------------------------------
  
  MsgFlowPart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFlowPart& from);
  void MergeFrom(const MsgFlowPart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MsgPath forme = 1;
  inline bool has_forme() const;
  inline void clear_forme();
  static const int kFormeFieldNumber = 1;
  inline const ::Common::MsgPath& forme() const;
  inline ::Common::MsgPath* mutable_forme();
  
  // required int32 pertinence = 2;
  inline bool has_pertinence() const;
  inline void clear_pertinence();
  static const int kPertinenceFieldNumber = 2;
  inline ::google::protobuf::int32 pertinence() const;
  inline void set_pertinence(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MsgPath* forme_;
  ::google::protobuf::int32 pertinence_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFlowPart* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfFlowPart : public ::google::protobuf::Message {
 public:
  SeqOfFlowPart();
  virtual ~SeqOfFlowPart();
  
  SeqOfFlowPart(const SeqOfFlowPart& from);
  
  inline SeqOfFlowPart& operator=(const SeqOfFlowPart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfFlowPart& default_instance();
  void Swap(SeqOfFlowPart* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfFlowPart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfFlowPart& from);
  void MergeFrom(const SeqOfFlowPart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgFlowPart elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart >* mutable_elem();
  inline const ::MsgsSimToClient::MsgFlowPart& elem(int index) const;
  inline ::MsgsSimToClient::MsgFlowPart* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgFlowPart* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfFlowPart* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdFlowKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgCrowdFlowKnowledgeUpdate();
  virtual ~MsgCrowdFlowKnowledgeUpdate();
  
  MsgCrowdFlowKnowledgeUpdate(const MsgCrowdFlowKnowledgeUpdate& from);
  
  inline MsgCrowdFlowKnowledgeUpdate& operator=(const MsgCrowdFlowKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdFlowKnowledgeUpdate& default_instance();
  void Swap(MsgCrowdFlowKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdFlowKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdFlowKnowledgeUpdate& from);
  void MergeFrom(const MsgCrowdFlowKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdFlowKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdFlowKnowledgeId& knowledge() const;
  inline ::Common::CrowdFlowKnowledgeId* mutable_knowledge();
  
  // required .Common.CrowdKnowledgeId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdKnowledgeId& crowd() const;
  inline ::Common::CrowdKnowledgeId* mutable_crowd();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional .Common.CrowdFlowId flow = 4;
  inline bool has_flow() const;
  inline void clear_flow();
  static const int kFlowFieldNumber = 4;
  inline const ::Common::CrowdFlowId& flow() const;
  inline ::Common::CrowdFlowId* mutable_flow();
  
  // optional .MsgsSimToClient.SeqOfFlowPart portions_flux = 5;
  inline bool has_portions_flux() const;
  inline void clear_portions_flux();
  static const int kPortionsFluxFieldNumber = 5;
  inline const ::MsgsSimToClient::SeqOfFlowPart& portions_flux() const;
  inline ::MsgsSimToClient::SeqOfFlowPart* mutable_portions_flux();
  
  // optional .Common.MsgHeading direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline const ::Common::MsgHeading& direction() const;
  inline ::Common::MsgHeading* mutable_direction();
  
  // optional int32 vitesse = 7;
  inline bool has_vitesse() const;
  inline void clear_vitesse();
  static const int kVitesseFieldNumber = 7;
  inline ::google::protobuf::int32 vitesse() const;
  inline void set_vitesse(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_vivants = 8;
  inline bool has_nb_humains_vivants() const;
  inline void clear_nb_humains_vivants();
  static const int kNbHumainsVivantsFieldNumber = 8;
  inline ::google::protobuf::int32 nb_humains_vivants() const;
  inline void set_nb_humains_vivants(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_morts = 9;
  inline bool has_nb_humains_morts() const;
  inline void clear_nb_humains_morts();
  static const int kNbHumainsMortsFieldNumber = 9;
  inline ::google::protobuf::int32 nb_humains_morts() const;
  inline void set_nb_humains_morts(::google::protobuf::int32 value);
  
  // optional .Common.EnumCrowdAttitude attitude = 10;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 10;
  inline Common::EnumCrowdAttitude attitude() const;
  inline void set_attitude(Common::EnumCrowdAttitude value);
  
  // optional bool est_percu = 11;
  inline bool has_est_percu() const;
  inline void clear_est_percu();
  static const int kEstPercuFieldNumber = 11;
  inline bool est_percu() const;
  inline void set_est_percu(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdFlowKnowledgeId* knowledge_;
  ::Common::CrowdKnowledgeId* crowd_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::CrowdFlowId* flow_;
  ::MsgsSimToClient::SeqOfFlowPart* portions_flux_;
  ::Common::MsgHeading* direction_;
  ::google::protobuf::int32 vitesse_;
  ::google::protobuf::int32 nb_humains_vivants_;
  ::google::protobuf::int32 nb_humains_morts_;
  int attitude_;
  bool est_percu_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdFlowKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgCrowdFlowKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgCrowdFlowKnowledgeDestruction();
  virtual ~MsgCrowdFlowKnowledgeDestruction();
  
  MsgCrowdFlowKnowledgeDestruction(const MsgCrowdFlowKnowledgeDestruction& from);
  
  inline MsgCrowdFlowKnowledgeDestruction& operator=(const MsgCrowdFlowKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCrowdFlowKnowledgeDestruction& default_instance();
  void Swap(MsgCrowdFlowKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgCrowdFlowKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgCrowdFlowKnowledgeDestruction& from);
  void MergeFrom(const MsgCrowdFlowKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.CrowdFlowKnowledgeId knowledge = 1;
  inline bool has_knowledge() const;
  inline void clear_knowledge();
  static const int kKnowledgeFieldNumber = 1;
  inline const ::Common::CrowdFlowKnowledgeId& knowledge() const;
  inline ::Common::CrowdFlowKnowledgeId* mutable_knowledge();
  
  // required .Common.CrowdKnowledgeId crowd = 2;
  inline bool has_crowd() const;
  inline void clear_crowd();
  static const int kCrowdFieldNumber = 2;
  inline const ::Common::CrowdKnowledgeId& crowd() const;
  inline ::Common::CrowdKnowledgeId* mutable_crowd();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::CrowdFlowKnowledgeId* knowledge_;
  ::Common::CrowdKnowledgeId* crowd_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgCrowdFlowKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkCreation_profiles : public ::google::protobuf::Message {
 public:
  MsgFolkCreation_profiles();
  virtual ~MsgFolkCreation_profiles();
  
  MsgFolkCreation_profiles(const MsgFolkCreation_profiles& from);
  
  inline MsgFolkCreation_profiles& operator=(const MsgFolkCreation_profiles& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkCreation_profiles& default_instance();
  void Swap(MsgFolkCreation_profiles* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkCreation_profiles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkCreation_profiles& from);
  void MergeFrom(const MsgFolkCreation_profiles& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_elem();
  inline const ::std::string& elem(int index) const;
  inline ::std::string* mutable_elem(int index);
  inline void set_elem(int index, const ::std::string& value);
  inline void set_elem(int index, const char* value);
  inline void set_elem(int index, const char* value, size_t size);
  inline ::std::string* add_elem();
  inline void add_elem(const ::std::string& value);
  inline void add_elem(const char* value);
  inline void add_elem(const char* value, size_t size);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkCreation_profiles* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkCreation_activities : public ::google::protobuf::Message {
 public:
  MsgFolkCreation_activities();
  virtual ~MsgFolkCreation_activities();
  
  MsgFolkCreation_activities(const MsgFolkCreation_activities& from);
  
  inline MsgFolkCreation_activities& operator=(const MsgFolkCreation_activities& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkCreation_activities& default_instance();
  void Swap(MsgFolkCreation_activities* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkCreation_activities* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkCreation_activities& from);
  void MergeFrom(const MsgFolkCreation_activities& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_elem();
  inline const ::std::string& elem(int index) const;
  inline ::std::string* mutable_elem(int index);
  inline void set_elem(int index, const ::std::string& value);
  inline void set_elem(int index, const char* value);
  inline void set_elem(int index, const char* value, size_t size);
  inline ::std::string* add_elem();
  inline void add_elem(const ::std::string& value);
  inline void add_elem(const char* value);
  inline void add_elem(const char* value, size_t size);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkCreation_activities* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkCreation : public ::google::protobuf::Message {
 public:
  MsgFolkCreation();
  virtual ~MsgFolkCreation();
  
  MsgFolkCreation(const MsgFolkCreation& from);
  
  inline MsgFolkCreation& operator=(const MsgFolkCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkCreation& default_instance();
  void Swap(MsgFolkCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkCreation& from);
  void MergeFrom(const MsgFolkCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgFolkCreation_profiles profiles = 1;
  inline bool has_profiles() const;
  inline void clear_profiles();
  static const int kProfilesFieldNumber = 1;
  inline const ::MsgsSimToClient::MsgFolkCreation_profiles& profiles() const;
  inline ::MsgsSimToClient::MsgFolkCreation_profiles* mutable_profiles();
  
  // required .MsgsSimToClient.MsgFolkCreation_activities activities = 2;
  inline bool has_activities() const;
  inline void clear_activities();
  static const int kActivitiesFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgFolkCreation_activities& activities() const;
  inline ::MsgsSimToClient::MsgFolkCreation_activities* mutable_activities();
  
  // optional int32 container_size = 3;
  inline bool has_container_size() const;
  inline void clear_container_size();
  static const int kContainerSizeFieldNumber = 3;
  inline ::google::protobuf::int32 container_size() const;
  inline void set_container_size(::google::protobuf::int32 value);
  
  // optional int32 edge_number = 4;
  inline bool has_edge_number() const;
  inline void clear_edge_number();
  static const int kEdgeNumberFieldNumber = 4;
  inline ::google::protobuf::int32 edge_number() const;
  inline void set_edge_number(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsSimToClient::MsgFolkCreation_profiles* profiles_;
  ::MsgsSimToClient::MsgFolkCreation_activities* activities_;
  ::google::protobuf::int32 container_size_;
  ::google::protobuf::int32 edge_number_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkGraphEdgeUpdate : public ::google::protobuf::Message {
 public:
  MsgFolkGraphEdgeUpdate();
  virtual ~MsgFolkGraphEdgeUpdate();
  
  MsgFolkGraphEdgeUpdate(const MsgFolkGraphEdgeUpdate& from);
  
  inline MsgFolkGraphEdgeUpdate& operator=(const MsgFolkGraphEdgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkGraphEdgeUpdate& default_instance();
  void Swap(MsgFolkGraphEdgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkGraphEdgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkGraphEdgeUpdate& from);
  void MergeFrom(const MsgFolkGraphEdgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 folk = 1;
  inline bool has_folk() const;
  inline void clear_folk();
  static const int kFolkFieldNumber = 1;
  inline ::google::protobuf::int32 folk() const;
  inline void set_folk(::google::protobuf::int32 value);
  
  // required int32 shape_id = 2;
  inline bool has_shape_id() const;
  inline void clear_shape_id();
  static const int kShapeIdFieldNumber = 2;
  inline ::google::protobuf::int32 shape_id() const;
  inline void set_shape_id(::google::protobuf::int32 value);
  
  // repeated int32 crowd_occupation = 3;
  inline int crowd_occupation_size() const;
  inline void clear_crowd_occupation();
  static const int kCrowdOccupationFieldNumber = 3;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >& crowd_occupation() const
      ;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >* mutable_crowd_occupation();
  inline ::google::protobuf::int32 crowd_occupation(int index) const;
  inline void set_crowd_occupation(int index, ::google::protobuf::int32 value);
  inline void add_crowd_occupation(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 folk_;
  ::google::protobuf::int32 shape_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > crowd_occupation_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkGraphEdgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkGraphUpdate : public ::google::protobuf::Message {
 public:
  MsgFolkGraphUpdate();
  virtual ~MsgFolkGraphUpdate();
  
  MsgFolkGraphUpdate(const MsgFolkGraphUpdate& from);
  
  inline MsgFolkGraphUpdate& operator=(const MsgFolkGraphUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkGraphUpdate& default_instance();
  void Swap(MsgFolkGraphUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkGraphUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkGraphUpdate& from);
  void MergeFrom(const MsgFolkGraphUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgFolkGraphEdgeUpdate elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate >* mutable_elem();
  inline const ::MsgsSimToClient::MsgFolkGraphEdgeUpdate& elem(int index) const;
  inline ::MsgsSimToClient::MsgFolkGraphEdgeUpdate* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgFolkGraphEdgeUpdate* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkGraphUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSetFrequencyAck : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSetFrequencyAck();
  virtual ~MsgControlCheckPointSetFrequencyAck();
  
  MsgControlCheckPointSetFrequencyAck(const MsgControlCheckPointSetFrequencyAck& from);
  
  inline MsgControlCheckPointSetFrequencyAck& operator=(const MsgControlCheckPointSetFrequencyAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSetFrequencyAck& default_instance();
  void Swap(MsgControlCheckPointSetFrequencyAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSetFrequencyAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSetFrequencyAck& from);
  void MergeFrom(const MsgControlCheckPointSetFrequencyAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSetFrequencyAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSaveNowAck : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSaveNowAck();
  virtual ~MsgControlCheckPointSaveNowAck();
  
  MsgControlCheckPointSaveNowAck(const MsgControlCheckPointSaveNowAck& from);
  
  inline MsgControlCheckPointSaveNowAck& operator=(const MsgControlCheckPointSaveNowAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSaveNowAck& default_instance();
  void Swap(MsgControlCheckPointSaveNowAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSaveNowAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSaveNowAck& from);
  void MergeFrom(const MsgControlCheckPointSaveNowAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSaveNowAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSaveBegin : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSaveBegin();
  virtual ~MsgControlCheckPointSaveBegin();
  
  MsgControlCheckPointSaveBegin(const MsgControlCheckPointSaveBegin& from);
  
  inline MsgControlCheckPointSaveBegin& operator=(const MsgControlCheckPointSaveBegin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSaveBegin& default_instance();
  void Swap(MsgControlCheckPointSaveBegin* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSaveBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSaveBegin& from);
  void MergeFrom(const MsgControlCheckPointSaveBegin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSaveBegin* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSaveBeginAck : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSaveBeginAck();
  virtual ~MsgControlCheckPointSaveBeginAck();
  
  MsgControlCheckPointSaveBeginAck(const MsgControlCheckPointSaveBeginAck& from);
  
  inline MsgControlCheckPointSaveBeginAck& operator=(const MsgControlCheckPointSaveBeginAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSaveBeginAck& default_instance();
  void Swap(MsgControlCheckPointSaveBeginAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSaveBeginAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSaveBeginAck& from);
  void MergeFrom(const MsgControlCheckPointSaveBeginAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSaveBeginAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSaveEnd : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSaveEnd();
  virtual ~MsgControlCheckPointSaveEnd();
  
  MsgControlCheckPointSaveEnd(const MsgControlCheckPointSaveEnd& from);
  
  inline MsgControlCheckPointSaveEnd& operator=(const MsgControlCheckPointSaveEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSaveEnd& default_instance();
  void Swap(MsgControlCheckPointSaveEnd* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSaveEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSaveEnd& from);
  void MergeFrom(const MsgControlCheckPointSaveEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSaveEnd* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointListAck : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointListAck();
  virtual ~MsgControlCheckPointListAck();
  
  MsgControlCheckPointListAck(const MsgControlCheckPointListAck& from);
  
  inline MsgControlCheckPointListAck& operator=(const MsgControlCheckPointListAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointListAck& default_instance();
  void Swap(MsgControlCheckPointListAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointListAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointListAck& from);
  void MergeFrom(const MsgControlCheckPointListAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointListAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointList : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointList();
  virtual ~MsgControlCheckPointList();
  
  MsgControlCheckPointList(const MsgControlCheckPointList& from);
  
  inline MsgControlCheckPointList& operator=(const MsgControlCheckPointList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointList& default_instance();
  void Swap(MsgControlCheckPointList* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointList& from);
  void MergeFrom(const MsgControlCheckPointList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string checkpoint = 1;
  inline int checkpoint_size() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& checkpoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_checkpoint();
  inline const ::std::string& checkpoint(int index) const;
  inline ::std::string* mutable_checkpoint(int index);
  inline void set_checkpoint(int index, const ::std::string& value);
  inline void set_checkpoint(int index, const char* value);
  inline void set_checkpoint(int index, const char* value, size_t size);
  inline ::std::string* add_checkpoint();
  inline void add_checkpoint(const ::std::string& value);
  inline void add_checkpoint(const char* value);
  inline void add_checkpoint(const char* value, size_t size);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> checkpoint_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointList* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointDeleteAck : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointDeleteAck();
  virtual ~MsgControlCheckPointDeleteAck();
  
  MsgControlCheckPointDeleteAck(const MsgControlCheckPointDeleteAck& from);
  
  inline MsgControlCheckPointDeleteAck& operator=(const MsgControlCheckPointDeleteAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointDeleteAck& default_instance();
  void Swap(MsgControlCheckPointDeleteAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointDeleteAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointDeleteAck& from);
  void MergeFrom(const MsgControlCheckPointDeleteAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointDeleteAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlSendCurrentStateBegin : public ::google::protobuf::Message {
 public:
  MsgControlSendCurrentStateBegin();
  virtual ~MsgControlSendCurrentStateBegin();
  
  MsgControlSendCurrentStateBegin(const MsgControlSendCurrentStateBegin& from);
  
  inline MsgControlSendCurrentStateBegin& operator=(const MsgControlSendCurrentStateBegin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlSendCurrentStateBegin& default_instance();
  void Swap(MsgControlSendCurrentStateBegin* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlSendCurrentStateBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlSendCurrentStateBegin& from);
  void MergeFrom(const MsgControlSendCurrentStateBegin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlSendCurrentStateBegin* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlSendCurrentStateEnd : public ::google::protobuf::Message {
 public:
  MsgControlSendCurrentStateEnd();
  virtual ~MsgControlSendCurrentStateEnd();
  
  MsgControlSendCurrentStateEnd(const MsgControlSendCurrentStateEnd& from);
  
  inline MsgControlSendCurrentStateEnd& operator=(const MsgControlSendCurrentStateEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlSendCurrentStateEnd& default_instance();
  void Swap(MsgControlSendCurrentStateEnd* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlSendCurrentStateEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlSendCurrentStateEnd& from);
  void MergeFrom(const MsgControlSendCurrentStateEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlSendCurrentStateEnd* default_instance_;
};
// -------------------------------------------------------------------

class MagicActionCreateUrban : public ::google::protobuf::Message {
 public:
  MagicActionCreateUrban();
  virtual ~MagicActionCreateUrban();
  
  MagicActionCreateUrban(const MagicActionCreateUrban& from);
  
  inline MagicActionCreateUrban& operator=(const MagicActionCreateUrban& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MagicActionCreateUrban& default_instance();
  void Swap(MagicActionCreateUrban* other);
  
  // implements Message ----------------------------------------------
  
  MagicActionCreateUrban* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MagicActionCreateUrban& from);
  void MergeFrom(const MagicActionCreateUrban& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .Common.MsgLocation location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::Common::MsgLocation* location_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MagicActionCreateUrban* default_instance_;
};
// -------------------------------------------------------------------

class MagicActionUpdateUrban : public ::google::protobuf::Message {
 public:
  MagicActionUpdateUrban();
  virtual ~MagicActionUpdateUrban();
  
  MagicActionUpdateUrban(const MagicActionUpdateUrban& from);
  
  inline MagicActionUpdateUrban& operator=(const MagicActionUpdateUrban& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MagicActionUpdateUrban& default_instance();
  void Swap(MagicActionUpdateUrban* other);
  
  // implements Message ----------------------------------------------
  
  MagicActionUpdateUrban* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MagicActionUpdateUrban& from);
  void MergeFrom(const MagicActionUpdateUrban& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline ::google::protobuf::uint32 oid() const;
  inline void set_oid(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 oid_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MagicActionUpdateUrban* default_instance_;
};
// -------------------------------------------------------------------

class MagicActionDestroyUrban : public ::google::protobuf::Message {
 public:
  MagicActionDestroyUrban();
  virtual ~MagicActionDestroyUrban();
  
  MagicActionDestroyUrban(const MagicActionDestroyUrban& from);
  
  inline MagicActionDestroyUrban& operator=(const MagicActionDestroyUrban& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MagicActionDestroyUrban& default_instance();
  void Swap(MagicActionDestroyUrban* other);
  
  // implements Message ----------------------------------------------
  
  MagicActionDestroyUrban* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MagicActionDestroyUrban& from);
  void MergeFrom(const MagicActionDestroyUrban& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline ::google::protobuf::uint32 oid() const;
  inline void set_oid(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 oid_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MagicActionDestroyUrban* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanMagicAction : public ::google::protobuf::Message {
 public:
  MsgUrbanMagicAction();
  virtual ~MsgUrbanMagicAction();
  
  MsgUrbanMagicAction(const MsgUrbanMagicAction& from);
  
  inline MsgUrbanMagicAction& operator=(const MsgUrbanMagicAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanMagicAction& default_instance();
  void Swap(MsgUrbanMagicAction* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanMagicAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanMagicAction& from);
  void MergeFrom(const MsgUrbanMagicAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MagicActionCreateUrban create_urban = 1;
  inline bool has_create_urban() const;
  inline void clear_create_urban();
  static const int kCreateUrbanFieldNumber = 1;
  inline const ::MsgsSimToClient::MagicActionCreateUrban& create_urban() const;
  inline ::MsgsSimToClient::MagicActionCreateUrban* mutable_create_urban();
  
  // optional .MsgsSimToClient.MagicActionUpdateUrban update_urban = 2;
  inline bool has_update_urban() const;
  inline void clear_update_urban();
  static const int kUpdateUrbanFieldNumber = 2;
  inline const ::MsgsSimToClient::MagicActionUpdateUrban& update_urban() const;
  inline ::MsgsSimToClient::MagicActionUpdateUrban* mutable_update_urban();
  
  // optional .MsgsSimToClient.MagicActionDestroyUrban destroy_urban = 3;
  inline bool has_destroy_urban() const;
  inline void clear_destroy_urban();
  static const int kDestroyUrbanFieldNumber = 3;
  inline const ::MsgsSimToClient::MagicActionDestroyUrban& destroy_urban() const;
  inline ::MsgsSimToClient::MagicActionDestroyUrban* mutable_destroy_urban();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsSimToClient::MagicActionCreateUrban* create_urban_;
  ::MsgsSimToClient::MagicActionUpdateUrban* update_urban_;
  ::MsgsSimToClient::MagicActionDestroyUrban* destroy_urban_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanMagicAction* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgUrbanMagicActionAck();
  virtual ~MsgUrbanMagicActionAck();
  
  MsgUrbanMagicActionAck(const MsgUrbanMagicActionAck& from);
  
  inline MsgUrbanMagicActionAck& operator=(const MsgUrbanMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanMagicActionAck& default_instance();
  void Swap(MsgUrbanMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanMagicActionAck& from);
  void MergeFrom(const MsgUrbanMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgUrbanMagicActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgUrbanMagicActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_urban = MsgUrbanMagicActionAck_ErrorCode_error_invalid_urban;
  static const ErrorCode error_invalid_id = MsgUrbanMagicActionAck_ErrorCode_error_invalid_id;
  static const ErrorCode error_invalid_camp = MsgUrbanMagicActionAck_ErrorCode_error_invalid_camp;
  static const ErrorCode error_invalid_localisation = MsgUrbanMagicActionAck_ErrorCode_error_invalid_localisation;
  static const ErrorCode error_missing_specific_attributes = MsgUrbanMagicActionAck_ErrorCode_error_missing_specific_attributes;
  static const ErrorCode error_invalid_specific_attributes = MsgUrbanMagicActionAck_ErrorCode_error_invalid_specific_attributes;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgUrbanMagicActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgUrbanMagicActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgUrbanMagicActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgUrbanMagicActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgUrbanMagicActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgUrbanMagicActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgUrbanMagicActionAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class UrbanAttributes_Architecture : public ::google::protobuf::Message {
 public:
  UrbanAttributes_Architecture();
  virtual ~UrbanAttributes_Architecture();
  
  UrbanAttributes_Architecture(const UrbanAttributes_Architecture& from);
  
  inline UrbanAttributes_Architecture& operator=(const UrbanAttributes_Architecture& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UrbanAttributes_Architecture& default_instance();
  void Swap(UrbanAttributes_Architecture* other);
  
  // implements Message ----------------------------------------------
  
  UrbanAttributes_Architecture* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UrbanAttributes_Architecture& from);
  void MergeFrom(const UrbanAttributes_Architecture& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float height = 1;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 1;
  inline float height() const;
  inline void set_height(float value);
  
  // required int32 floor_number = 2;
  inline bool has_floor_number() const;
  inline void clear_floor_number();
  static const int kFloorNumberFieldNumber = 2;
  inline ::google::protobuf::int32 floor_number() const;
  inline void set_floor_number(::google::protobuf::int32 value);
  
  // required string roof_shape = 3;
  inline bool has_roof_shape() const;
  inline void clear_roof_shape();
  static const int kRoofShapeFieldNumber = 3;
  inline const ::std::string& roof_shape() const;
  inline void set_roof_shape(const ::std::string& value);
  inline void set_roof_shape(const char* value);
  inline void set_roof_shape(const char* value, size_t size);
  inline ::std::string* mutable_roof_shape();
  
  // required string material = 4;
  inline bool has_material() const;
  inline void clear_material();
  static const int kMaterialFieldNumber = 4;
  inline const ::std::string& material() const;
  inline void set_material(const ::std::string& value);
  inline void set_material(const char* value);
  inline void set_material(const char* value, size_t size);
  inline ::std::string* mutable_material();
  
  // required float occupation = 5;
  inline bool has_occupation() const;
  inline void clear_occupation();
  static const int kOccupationFieldNumber = 5;
  inline float occupation() const;
  inline void set_occupation(float value);
  
  // required float trafficability = 6;
  inline bool has_trafficability() const;
  inline void clear_trafficability();
  static const int kTrafficabilityFieldNumber = 6;
  inline float trafficability() const;
  inline void set_trafficability(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float height_;
  ::google::protobuf::int32 floor_number_;
  ::std::string* roof_shape_;
  static const ::std::string _default_roof_shape_;
  ::std::string* material_;
  static const ::std::string _default_material_;
  float occupation_;
  float trafficability_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UrbanAttributes_Architecture* default_instance_;
};
// -------------------------------------------------------------------

class UrbanAttributes_Structure : public ::google::protobuf::Message {
 public:
  UrbanAttributes_Structure();
  virtual ~UrbanAttributes_Structure();
  
  UrbanAttributes_Structure(const UrbanAttributes_Structure& from);
  
  inline UrbanAttributes_Structure& operator=(const UrbanAttributes_Structure& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UrbanAttributes_Structure& default_instance();
  void Swap(UrbanAttributes_Structure* other);
  
  // implements Message ----------------------------------------------
  
  UrbanAttributes_Structure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UrbanAttributes_Structure& from);
  void MergeFrom(const UrbanAttributes_Structure& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 state_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UrbanAttributes_Structure* default_instance_;
};
// -------------------------------------------------------------------

class UrbanAttributes_Infrastructures : public ::google::protobuf::Message {
 public:
  UrbanAttributes_Infrastructures();
  virtual ~UrbanAttributes_Infrastructures();
  
  UrbanAttributes_Infrastructures(const UrbanAttributes_Infrastructures& from);
  
  inline UrbanAttributes_Infrastructures& operator=(const UrbanAttributes_Infrastructures& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UrbanAttributes_Infrastructures& default_instance();
  void Swap(UrbanAttributes_Infrastructures* other);
  
  // implements Message ----------------------------------------------
  
  UrbanAttributes_Infrastructures* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UrbanAttributes_Infrastructures& from);
  void MergeFrom(const UrbanAttributes_Infrastructures& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Common.ResourceNetwork resource_network = 1;
  inline int resource_network_size() const;
  inline void clear_resource_network();
  static const int kResourceNetworkFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork >& resource_network() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork >* mutable_resource_network();
  inline const ::Common::ResourceNetwork& resource_network(int index) const;
  inline ::Common::ResourceNetwork* mutable_resource_network(int index);
  inline ::Common::ResourceNetwork* add_resource_network();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork > resource_network_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UrbanAttributes_Infrastructures* default_instance_;
};
// -------------------------------------------------------------------

class UrbanAttributes : public ::google::protobuf::Message {
 public:
  UrbanAttributes();
  virtual ~UrbanAttributes();
  
  UrbanAttributes(const UrbanAttributes& from);
  
  inline UrbanAttributes& operator=(const UrbanAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UrbanAttributes& default_instance();
  void Swap(UrbanAttributes* other);
  
  // implements Message ----------------------------------------------
  
  UrbanAttributes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UrbanAttributes& from);
  void MergeFrom(const UrbanAttributes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef UrbanAttributes_Architecture Architecture;
  typedef UrbanAttributes_Structure Structure;
  typedef UrbanAttributes_Infrastructures Infrastructures;
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.UrbanAttributes.Architecture architecture = 1;
  inline bool has_architecture() const;
  inline void clear_architecture();
  static const int kArchitectureFieldNumber = 1;
  inline const ::MsgsSimToClient::UrbanAttributes_Architecture& architecture() const;
  inline ::MsgsSimToClient::UrbanAttributes_Architecture* mutable_architecture();
  
  // optional .MsgsSimToClient.UrbanAttributes.Structure structure = 2;
  inline bool has_structure() const;
  inline void clear_structure();
  static const int kStructureFieldNumber = 2;
  inline const ::MsgsSimToClient::UrbanAttributes_Structure& structure() const;
  inline ::MsgsSimToClient::UrbanAttributes_Structure* mutable_structure();
  
  // optional .Common.RgbaColor color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline const ::Common::RgbaColor& color() const;
  inline ::Common::RgbaColor* mutable_color();
  
  // optional .MsgsSimToClient.UrbanAttributes.Infrastructures infrastructures = 4;
  inline bool has_infrastructures() const;
  inline void clear_infrastructures();
  static const int kInfrastructuresFieldNumber = 4;
  inline const ::MsgsSimToClient::UrbanAttributes_Infrastructures& infrastructures() const;
  inline ::MsgsSimToClient::UrbanAttributes_Infrastructures* mutable_infrastructures();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsSimToClient::UrbanAttributes_Architecture* architecture_;
  ::MsgsSimToClient::UrbanAttributes_Structure* structure_;
  ::Common::RgbaColor* color_;
  ::MsgsSimToClient::UrbanAttributes_Infrastructures* infrastructures_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UrbanAttributes* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanCreation : public ::google::protobuf::Message {
 public:
  MsgUrbanCreation();
  virtual ~MsgUrbanCreation();
  
  MsgUrbanCreation(const MsgUrbanCreation& from);
  
  inline MsgUrbanCreation& operator=(const MsgUrbanCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanCreation& default_instance();
  void Swap(MsgUrbanCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanCreation& from);
  void MergeFrom(const MsgUrbanCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UrbanObjectId urban_object = 1;
  inline bool has_urban_object() const;
  inline void clear_urban_object();
  static const int kUrbanObjectFieldNumber = 1;
  inline const ::Common::UrbanObjectId& urban_object() const;
  inline ::Common::UrbanObjectId* mutable_urban_object();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .Common.MsgLocation location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // optional .MsgsSimToClient.UrbanAttributes attributes = 4;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  inline const ::MsgsSimToClient::UrbanAttributes& attributes() const;
  inline ::MsgsSimToClient::UrbanAttributes* mutable_attributes();
  
  // optional .Common.UrbanObjectId parent = 5;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 5;
  inline const ::Common::UrbanObjectId& parent() const;
  inline ::Common::UrbanObjectId* mutable_parent();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UrbanObjectId* urban_object_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::Common::MsgLocation* location_;
  ::MsgsSimToClient::UrbanAttributes* attributes_;
  ::Common::UrbanObjectId* parent_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanDetection : public ::google::protobuf::Message {
 public:
  MsgUrbanDetection();
  virtual ~MsgUrbanDetection();
  
  MsgUrbanDetection(const MsgUrbanDetection& from);
  
  inline MsgUrbanDetection& operator=(const MsgUrbanDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanDetection& default_instance();
  void Swap(MsgUrbanDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanDetection& from);
  void MergeFrom(const MsgUrbanDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId observer = 1;
  inline bool has_observer() const;
  inline void clear_observer();
  static const int kObserverFieldNumber = 1;
  inline const ::Common::UnitId& observer() const;
  inline ::Common::UnitId* mutable_observer();
  
  // required .Common.UrbanObjectId urban_object = 2;
  inline bool has_urban_object() const;
  inline void clear_urban_object();
  static const int kUrbanObjectFieldNumber = 2;
  inline const ::Common::UrbanObjectId& urban_object() const;
  inline ::Common::UrbanObjectId* mutable_urban_object();
  
  // required .Common.EnumUnitVisibility visibility = 3;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 3;
  inline Common::EnumUnitVisibility visibility() const;
  inline void set_visibility(Common::EnumUnitVisibility value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* observer_;
  ::Common::UrbanObjectId* urban_object_;
  int visibility_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanUpdate : public ::google::protobuf::Message {
 public:
  MsgUrbanUpdate();
  virtual ~MsgUrbanUpdate();
  
  MsgUrbanUpdate(const MsgUrbanUpdate& from);
  
  inline MsgUrbanUpdate& operator=(const MsgUrbanUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanUpdate& default_instance();
  void Swap(MsgUrbanUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanUpdate& from);
  void MergeFrom(const MsgUrbanUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UrbanObjectId urban_object = 1;
  inline bool has_urban_object() const;
  inline void clear_urban_object();
  static const int kUrbanObjectFieldNumber = 1;
  inline const ::Common::UrbanObjectId& urban_object() const;
  inline ::Common::UrbanObjectId* mutable_urban_object();
  
  // optional .Common.MsgLocation location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // optional .MsgsSimToClient.UrbanAttributes attributes = 3;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  inline const ::MsgsSimToClient::UrbanAttributes& attributes() const;
  inline ::MsgsSimToClient::UrbanAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UrbanObjectId* urban_object_;
  ::Common::MsgLocation* location_;
  ::MsgsSimToClient::UrbanAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupCreation : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupCreation();
  virtual ~MsgKnowledgeGroupCreation();
  
  MsgKnowledgeGroupCreation(const MsgKnowledgeGroupCreation& from);
  
  inline MsgKnowledgeGroupCreation& operator=(const MsgKnowledgeGroupCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupCreation& default_instance();
  void Swap(MsgKnowledgeGroupCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupCreation& from);
  void MergeFrom(const MsgKnowledgeGroupCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId knowledge_group = 1;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.KnowledgeGroupId parent = 3;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& parent() const;
  inline ::Common::KnowledgeGroupId* mutable_parent();
  
  // required string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
  // optional bool jam = 5;
  inline bool has_jam() const;
  inline void clear_jam();
  static const int kJamFieldNumber = 5;
  inline bool jam() const;
  inline void set_jam(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::PartyId* party_;
  ::Common::KnowledgeGroupId* parent_;
  ::std::string* type_;
  static const ::std::string _default_type_;
  bool jam_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupUpdate : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupUpdate();
  virtual ~MsgKnowledgeGroupUpdate();
  
  MsgKnowledgeGroupUpdate(const MsgKnowledgeGroupUpdate& from);
  
  inline MsgKnowledgeGroupUpdate& operator=(const MsgKnowledgeGroupUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupUpdate& default_instance();
  void Swap(MsgKnowledgeGroupUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupUpdate& from);
  void MergeFrom(const MsgKnowledgeGroupUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId knowledge_group = 1;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.KnowledgeGroupId parent = 3;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& parent() const;
  inline ::Common::KnowledgeGroupId* mutable_parent();
  
  // optional bool enabled = 4;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 4;
  inline bool enabled() const;
  inline void set_enabled(bool value);
  
  // optional string type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::PartyId* party_;
  ::Common::KnowledgeGroupId* parent_;
  bool enabled_;
  ::std::string* type_;
  static const ::std::string _default_type_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupUpdate* default_instance_;
};
// -------------------------------------------------------------------

class KnowledgeGroupAck : public ::google::protobuf::Message {
 public:
  KnowledgeGroupAck();
  virtual ~KnowledgeGroupAck();
  
  KnowledgeGroupAck(const KnowledgeGroupAck& from);
  
  inline KnowledgeGroupAck& operator=(const KnowledgeGroupAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KnowledgeGroupAck& default_instance();
  void Swap(KnowledgeGroupAck* other);
  
  // implements Message ----------------------------------------------
  
  KnowledgeGroupAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KnowledgeGroupAck& from);
  void MergeFrom(const KnowledgeGroupAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef KnowledgeGroupAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = KnowledgeGroupAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = KnowledgeGroupAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_invalid_superior = KnowledgeGroupAck_ErrorCode_error_invalid_superior;
  static const ErrorCode error_invalid_camp = KnowledgeGroupAck_ErrorCode_error_invalid_camp;
  static const ErrorCode error_invalid_knowledgegroup = KnowledgeGroupAck_ErrorCode_error_invalid_knowledgegroup;
  static const ErrorCode error_invalid_type = KnowledgeGroupAck_ErrorCode_error_invalid_type;
  static inline bool ErrorCode_IsValid(int value) {
    return KnowledgeGroupAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    KnowledgeGroupAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    KnowledgeGroupAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return KnowledgeGroupAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return KnowledgeGroupAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return KnowledgeGroupAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static KnowledgeGroupAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupMagicActionAck();
  virtual ~MsgKnowledgeGroupMagicActionAck();
  
  MsgKnowledgeGroupMagicActionAck(const MsgKnowledgeGroupMagicActionAck& from);
  
  inline MsgKnowledgeGroupMagicActionAck& operator=(const MsgKnowledgeGroupMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupMagicActionAck& default_instance();
  void Swap(MsgKnowledgeGroupMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupMagicActionAck& from);
  void MergeFrom(const MsgKnowledgeGroupMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId knowledge_group = 1;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* knowledge_group_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupCreationAck : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupCreationAck();
  virtual ~MsgKnowledgeGroupCreationAck();
  
  MsgKnowledgeGroupCreationAck(const MsgKnowledgeGroupCreationAck& from);
  
  inline MsgKnowledgeGroupCreationAck& operator=(const MsgKnowledgeGroupCreationAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupCreationAck& default_instance();
  void Swap(MsgKnowledgeGroupCreationAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupCreationAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupCreationAck& from);
  void MergeFrom(const MsgKnowledgeGroupCreationAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId knowledge_group = 1;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* knowledge_group_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupCreationAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupUpdateAck : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupUpdateAck();
  virtual ~MsgKnowledgeGroupUpdateAck();
  
  MsgKnowledgeGroupUpdateAck(const MsgKnowledgeGroupUpdateAck& from);
  
  inline MsgKnowledgeGroupUpdateAck& operator=(const MsgKnowledgeGroupUpdateAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupUpdateAck& default_instance();
  void Swap(MsgKnowledgeGroupUpdateAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupUpdateAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupUpdateAck& from);
  void MergeFrom(const MsgKnowledgeGroupUpdateAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId knowledge_group = 1;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* knowledge_group_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupUpdateAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupDestruction : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupDestruction();
  virtual ~MsgKnowledgeGroupDestruction();
  
  MsgKnowledgeGroupDestruction(const MsgKnowledgeGroupDestruction& from);
  
  inline MsgKnowledgeGroupDestruction& operator=(const MsgKnowledgeGroupDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupDestruction& default_instance();
  void Swap(MsgKnowledgeGroupDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupDestruction& from);
  void MergeFrom(const MsgKnowledgeGroupDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId knowledge_group = 1;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlGlobalWeatherAck : public ::google::protobuf::Message {
 public:
  MsgControlGlobalWeatherAck();
  virtual ~MsgControlGlobalWeatherAck();
  
  MsgControlGlobalWeatherAck(const MsgControlGlobalWeatherAck& from);
  
  inline MsgControlGlobalWeatherAck& operator=(const MsgControlGlobalWeatherAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlGlobalWeatherAck& default_instance();
  void Swap(MsgControlGlobalWeatherAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlGlobalWeatherAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlGlobalWeatherAck& from);
  void MergeFrom(const MsgControlGlobalWeatherAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlGlobalWeatherAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlLocalWeatherAck : public ::google::protobuf::Message {
 public:
  MsgControlLocalWeatherAck();
  virtual ~MsgControlLocalWeatherAck();
  
  MsgControlLocalWeatherAck(const MsgControlLocalWeatherAck& from);
  
  inline MsgControlLocalWeatherAck& operator=(const MsgControlLocalWeatherAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlLocalWeatherAck& default_instance();
  void Swap(MsgControlLocalWeatherAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlLocalWeatherAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlLocalWeatherAck& from);
  void MergeFrom(const MsgControlLocalWeatherAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlLocalWeatherAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlGlobalWeather : public ::google::protobuf::Message {
 public:
  MsgControlGlobalWeather();
  virtual ~MsgControlGlobalWeather();
  
  MsgControlGlobalWeather(const MsgControlGlobalWeather& from);
  
  inline MsgControlGlobalWeather& operator=(const MsgControlGlobalWeather& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlGlobalWeather& default_instance();
  void Swap(MsgControlGlobalWeather* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlGlobalWeather* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlGlobalWeather& from);
  void MergeFrom(const MsgControlGlobalWeather& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.WeatherId weather = 1;
  inline bool has_weather() const;
  inline void clear_weather();
  static const int kWeatherFieldNumber = 1;
  inline const ::Common::WeatherId& weather() const;
  inline ::Common::WeatherId* mutable_weather();
  
  // required .Common.MsgWeatherAttributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::Common::MsgWeatherAttributes& attributes() const;
  inline ::Common::MsgWeatherAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::WeatherId* weather_;
  ::Common::MsgWeatherAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlGlobalWeather* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlLocalWeatherCreation : public ::google::protobuf::Message {
 public:
  MsgControlLocalWeatherCreation();
  virtual ~MsgControlLocalWeatherCreation();
  
  MsgControlLocalWeatherCreation(const MsgControlLocalWeatherCreation& from);
  
  inline MsgControlLocalWeatherCreation& operator=(const MsgControlLocalWeatherCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlLocalWeatherCreation& default_instance();
  void Swap(MsgControlLocalWeatherCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlLocalWeatherCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlLocalWeatherCreation& from);
  void MergeFrom(const MsgControlLocalWeatherCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.WeatherId weather = 1;
  inline bool has_weather() const;
  inline void clear_weather();
  static const int kWeatherFieldNumber = 1;
  inline const ::Common::WeatherId& weather() const;
  inline ::Common::WeatherId* mutable_weather();
  
  // optional .Common.MsgCoordLatLong top_left_coordinate = 2;
  inline bool has_top_left_coordinate() const;
  inline void clear_top_left_coordinate();
  static const int kTopLeftCoordinateFieldNumber = 2;
  inline const ::Common::MsgCoordLatLong& top_left_coordinate() const;
  inline ::Common::MsgCoordLatLong* mutable_top_left_coordinate();
  
  // optional .Common.MsgCoordLatLong bottom_right_coordinate = 3;
  inline bool has_bottom_right_coordinate() const;
  inline void clear_bottom_right_coordinate();
  static const int kBottomRightCoordinateFieldNumber = 3;
  inline const ::Common::MsgCoordLatLong& bottom_right_coordinate() const;
  inline ::Common::MsgCoordLatLong* mutable_bottom_right_coordinate();
  
  // optional .Common.MsgWeatherAttributes attributes = 4;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  inline const ::Common::MsgWeatherAttributes& attributes() const;
  inline ::Common::MsgWeatherAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::WeatherId* weather_;
  ::Common::MsgCoordLatLong* top_left_coordinate_;
  ::Common::MsgCoordLatLong* bottom_right_coordinate_;
  ::Common::MsgWeatherAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlLocalWeatherCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlLocalWeatherDestruction : public ::google::protobuf::Message {
 public:
  MsgControlLocalWeatherDestruction();
  virtual ~MsgControlLocalWeatherDestruction();
  
  MsgControlLocalWeatherDestruction(const MsgControlLocalWeatherDestruction& from);
  
  inline MsgControlLocalWeatherDestruction& operator=(const MsgControlLocalWeatherDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlLocalWeatherDestruction& default_instance();
  void Swap(MsgControlLocalWeatherDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlLocalWeatherDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlLocalWeatherDestruction& from);
  void MergeFrom(const MsgControlLocalWeatherDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.WeatherId weather = 1;
  inline bool has_weather() const;
  inline void clear_weather();
  static const int kWeatherFieldNumber = 1;
  inline const ::Common::WeatherId& weather() const;
  inline ::Common::WeatherId* mutable_weather();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::WeatherId* weather_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlLocalWeatherDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgSimToClient_Content : public ::google::protobuf::Message {
 public:
  MsgSimToClient_Content();
  virtual ~MsgSimToClient_Content();
  
  MsgSimToClient_Content(const MsgSimToClient_Content& from);
  
  inline MsgSimToClient_Content& operator=(const MsgSimToClient_Content& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgSimToClient_Content& default_instance();
  void Swap(MsgSimToClient_Content* other);
  
  // implements Message ----------------------------------------------
  
  MsgSimToClient_Content* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgSimToClient_Content& from);
  void MergeFrom(const MsgSimToClient_Content& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MsgUnitOrderAck unit_order_ack = 1;
  inline bool has_unit_order_ack() const;
  inline void clear_unit_order_ack();
  static const int kUnitOrderAckFieldNumber = 1;
  inline const ::MsgsSimToClient::MsgUnitOrderAck& unit_order_ack() const;
  inline ::MsgsSimToClient::MsgUnitOrderAck* mutable_unit_order_ack();
  
  // optional .MsgsSimToClient.MsgAutomatOrderAck automat_order_ack = 2;
  inline bool has_automat_order_ack() const;
  inline void clear_automat_order_ack();
  static const int kAutomatOrderAckFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgAutomatOrderAck& automat_order_ack() const;
  inline ::MsgsSimToClient::MsgAutomatOrderAck* mutable_automat_order_ack();
  
  // optional .MsgsSimToClient.MsgCrowdOrderAck crowd_order_ack = 3;
  inline bool has_crowd_order_ack() const;
  inline void clear_crowd_order_ack();
  static const int kCrowdOrderAckFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgCrowdOrderAck& crowd_order_ack() const;
  inline ::MsgsSimToClient::MsgCrowdOrderAck* mutable_crowd_order_ack();
  
  // optional .MsgsSimToClient.MsgFragOrderAck frag_order_ack = 4;
  inline bool has_frag_order_ack() const;
  inline void clear_frag_order_ack();
  static const int kFragOrderAckFieldNumber = 4;
  inline const ::MsgsSimToClient::MsgFragOrderAck& frag_order_ack() const;
  inline ::MsgsSimToClient::MsgFragOrderAck* mutable_frag_order_ack();
  
  // optional .MsgsSimToClient.MsgSetAutomatModeAck set_automat_mode_ack = 5;
  inline bool has_set_automat_mode_ack() const;
  inline void clear_set_automat_mode_ack();
  static const int kSetAutomatModeAckFieldNumber = 5;
  inline const ::MsgsSimToClient::MsgSetAutomatModeAck& set_automat_mode_ack() const;
  inline ::MsgsSimToClient::MsgSetAutomatModeAck* mutable_set_automat_mode_ack();
  
  // optional .MsgsSimToClient.MsgUnitCreationRequestAck unit_creation_request_ack = 6;
  inline bool has_unit_creation_request_ack() const;
  inline void clear_unit_creation_request_ack();
  static const int kUnitCreationRequestAckFieldNumber = 6;
  inline const ::MsgsSimToClient::MsgUnitCreationRequestAck& unit_creation_request_ack() const;
  inline ::MsgsSimToClient::MsgUnitCreationRequestAck* mutable_unit_creation_request_ack();
  
  // optional .MsgsSimToClient.MsgMagicActionAck magic_action_ack = 7;
  inline bool has_magic_action_ack() const;
  inline void clear_magic_action_ack();
  static const int kMagicActionAckFieldNumber = 7;
  inline const ::MsgsSimToClient::MsgMagicActionAck& magic_action_ack() const;
  inline ::MsgsSimToClient::MsgMagicActionAck* mutable_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgUnitMagicActionAck unit_magic_action_ack = 8;
  inline bool has_unit_magic_action_ack() const;
  inline void clear_unit_magic_action_ack();
  static const int kUnitMagicActionAckFieldNumber = 8;
  inline const ::MsgsSimToClient::MsgUnitMagicActionAck& unit_magic_action_ack() const;
  inline ::MsgsSimToClient::MsgUnitMagicActionAck* mutable_unit_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgObjectMagicActionAck object_magic_action_ack = 9;
  inline bool has_object_magic_action_ack() const;
  inline void clear_object_magic_action_ack();
  static const int kObjectMagicActionAckFieldNumber = 9;
  inline const ::MsgsSimToClient::MsgObjectMagicActionAck& object_magic_action_ack() const;
  inline ::MsgsSimToClient::MsgObjectMagicActionAck* mutable_object_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgCrowdMagicActionAck crowd_magic_action_ack = 10;
  inline bool has_crowd_magic_action_ack() const;
  inline void clear_crowd_magic_action_ack();
  static const int kCrowdMagicActionAckFieldNumber = 10;
  inline const ::MsgsSimToClient::MsgCrowdMagicActionAck& crowd_magic_action_ack() const;
  inline ::MsgsSimToClient::MsgCrowdMagicActionAck* mutable_crowd_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgChangeDiplomacyAck change_diplomacy_ack = 11;
  inline bool has_change_diplomacy_ack() const;
  inline void clear_change_diplomacy_ack();
  static const int kChangeDiplomacyAckFieldNumber = 11;
  inline const ::MsgsSimToClient::MsgChangeDiplomacyAck& change_diplomacy_ack() const;
  inline ::MsgsSimToClient::MsgChangeDiplomacyAck* mutable_change_diplomacy_ack();
  
  // optional .MsgsSimToClient.MsgAutomatChangeKnowledgeGroupAck automat_change_knowledge_group_ack = 12;
  inline bool has_automat_change_knowledge_group_ack() const;
  inline void clear_automat_change_knowledge_group_ack();
  static const int kAutomatChangeKnowledgeGroupAckFieldNumber = 12;
  inline const ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck& automat_change_knowledge_group_ack() const;
  inline ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck* mutable_automat_change_knowledge_group_ack();
  
  // optional .MsgsSimToClient.MsgAutomatChangeLogisticLinksAck automat_change_logistic_links_ack = 13;
  inline bool has_automat_change_logistic_links_ack() const;
  inline void clear_automat_change_logistic_links_ack();
  static const int kAutomatChangeLogisticLinksAckFieldNumber = 13;
  inline const ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck& automat_change_logistic_links_ack() const;
  inline ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck* mutable_automat_change_logistic_links_ack();
  
  // optional .MsgsSimToClient.MsgAutomatChangeSuperiorAck automat_change_superior_ack = 14;
  inline bool has_automat_change_superior_ack() const;
  inline void clear_automat_change_superior_ack();
  static const int kAutomatChangeSuperiorAckFieldNumber = 14;
  inline const ::MsgsSimToClient::MsgAutomatChangeSuperiorAck& automat_change_superior_ack() const;
  inline ::MsgsSimToClient::MsgAutomatChangeSuperiorAck* mutable_automat_change_superior_ack();
  
  // optional .MsgsSimToClient.MsgUnitChangeSuperiorAck unit_change_superior_ack = 15;
  inline bool has_unit_change_superior_ack() const;
  inline void clear_unit_change_superior_ack();
  static const int kUnitChangeSuperiorAckFieldNumber = 15;
  inline const ::MsgsSimToClient::MsgUnitChangeSuperiorAck& unit_change_superior_ack() const;
  inline ::MsgsSimToClient::MsgUnitChangeSuperiorAck* mutable_unit_change_superior_ack();
  
  // optional .MsgsSimToClient.MsgLogSupplyPushFlowAck log_supply_push_flow_ack = 16;
  inline bool has_log_supply_push_flow_ack() const;
  inline void clear_log_supply_push_flow_ack();
  static const int kLogSupplyPushFlowAckFieldNumber = 16;
  inline const ::MsgsSimToClient::MsgLogSupplyPushFlowAck& log_supply_push_flow_ack() const;
  inline ::MsgsSimToClient::MsgLogSupplyPushFlowAck* mutable_log_supply_push_flow_ack();
  
  // optional .MsgsSimToClient.MsgLogSupplyChangeQuotasAck log_supply_change_quotas_ack = 17;
  inline bool has_log_supply_change_quotas_ack() const;
  inline void clear_log_supply_change_quotas_ack();
  static const int kLogSupplyChangeQuotasAckFieldNumber = 17;
  inline const ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck& log_supply_change_quotas_ack() const;
  inline ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck* mutable_log_supply_change_quotas_ack();
  
  // optional .MsgsSimToClient.MsgControlInformation control_information = 18;
  inline bool has_control_information() const;
  inline void clear_control_information();
  static const int kControlInformationFieldNumber = 18;
  inline const ::MsgsSimToClient::MsgControlInformation& control_information() const;
  inline ::MsgsSimToClient::MsgControlInformation* mutable_control_information();
  
  // optional .MsgsSimToClient.MsgControlProfilingInformation control_profiling_information = 19;
  inline bool has_control_profiling_information() const;
  inline void clear_control_profiling_information();
  static const int kControlProfilingInformationFieldNumber = 19;
  inline const ::MsgsSimToClient::MsgControlProfilingInformation& control_profiling_information() const;
  inline ::MsgsSimToClient::MsgControlProfilingInformation* mutable_control_profiling_information();
  
  // optional .MsgsSimToClient.MsgControlBeginTick control_begin_tick = 20;
  inline bool has_control_begin_tick() const;
  inline void clear_control_begin_tick();
  static const int kControlBeginTickFieldNumber = 20;
  inline const ::MsgsSimToClient::MsgControlBeginTick& control_begin_tick() const;
  inline ::MsgsSimToClient::MsgControlBeginTick* mutable_control_begin_tick();
  
  // optional .MsgsSimToClient.MsgControlEndTick control_end_tick = 21;
  inline bool has_control_end_tick() const;
  inline void clear_control_end_tick();
  static const int kControlEndTickFieldNumber = 21;
  inline const ::MsgsSimToClient::MsgControlEndTick& control_end_tick() const;
  inline ::MsgsSimToClient::MsgControlEndTick* mutable_control_end_tick();
  
  // optional .MsgsSimToClient.MsgControlStopAck control_stop_ack = 22;
  inline bool has_control_stop_ack() const;
  inline void clear_control_stop_ack();
  static const int kControlStopAckFieldNumber = 22;
  inline const ::MsgsSimToClient::MsgControlStopAck& control_stop_ack() const;
  inline ::MsgsSimToClient::MsgControlStopAck* mutable_control_stop_ack();
  
  // optional .MsgsSimToClient.MsgControlPauseAck control_pause_ack = 23;
  inline bool has_control_pause_ack() const;
  inline void clear_control_pause_ack();
  static const int kControlPauseAckFieldNumber = 23;
  inline const ::MsgsSimToClient::MsgControlPauseAck& control_pause_ack() const;
  inline ::MsgsSimToClient::MsgControlPauseAck* mutable_control_pause_ack();
  
  // optional .MsgsSimToClient.MsgControlResumeAck control_resume_ack = 24;
  inline bool has_control_resume_ack() const;
  inline void clear_control_resume_ack();
  static const int kControlResumeAckFieldNumber = 24;
  inline const ::MsgsSimToClient::MsgControlResumeAck& control_resume_ack() const;
  inline ::MsgsSimToClient::MsgControlResumeAck* mutable_control_resume_ack();
  
  // optional .MsgsSimToClient.MsgControlChangeTimeFactorAck control_change_time_factor_ack = 25;
  inline bool has_control_change_time_factor_ack() const;
  inline void clear_control_change_time_factor_ack();
  static const int kControlChangeTimeFactorAckFieldNumber = 25;
  inline const ::MsgsSimToClient::MsgControlChangeTimeFactorAck& control_change_time_factor_ack() const;
  inline ::MsgsSimToClient::MsgControlChangeTimeFactorAck* mutable_control_change_time_factor_ack();
  
  // optional .MsgsSimToClient.MsgControlDatetimeChangeAck control_date_time_change_ack = 26;
  inline bool has_control_date_time_change_ack() const;
  inline void clear_control_date_time_change_ack();
  static const int kControlDateTimeChangeAckFieldNumber = 26;
  inline const ::MsgsSimToClient::MsgControlDatetimeChangeAck& control_date_time_change_ack() const;
  inline ::MsgsSimToClient::MsgControlDatetimeChangeAck* mutable_control_date_time_change_ack();
  
  // optional .MsgsSimToClient.MsgControlCheckPointSaveEnd control_checkpoint_save_end = 27;
  inline bool has_control_checkpoint_save_end() const;
  inline void clear_control_checkpoint_save_end();
  static const int kControlCheckpointSaveEndFieldNumber = 27;
  inline const ::MsgsSimToClient::MsgControlCheckPointSaveEnd& control_checkpoint_save_end() const;
  inline ::MsgsSimToClient::MsgControlCheckPointSaveEnd* mutable_control_checkpoint_save_end();
  
  // optional .MsgsSimToClient.MsgFormationCreation formation_creation = 28;
  inline bool has_formation_creation() const;
  inline void clear_formation_creation();
  static const int kFormationCreationFieldNumber = 28;
  inline const ::MsgsSimToClient::MsgFormationCreation& formation_creation() const;
  inline ::MsgsSimToClient::MsgFormationCreation* mutable_formation_creation();
  
  // optional .MsgsSimToClient.MsgPartyCreation party_creation = 29;
  inline bool has_party_creation() const;
  inline void clear_party_creation();
  static const int kPartyCreationFieldNumber = 29;
  inline const ::MsgsSimToClient::MsgPartyCreation& party_creation() const;
  inline ::MsgsSimToClient::MsgPartyCreation* mutable_party_creation();
  
  // optional .MsgsSimToClient.MsgAutomatCreation automat_creation = 30;
  inline bool has_automat_creation() const;
  inline void clear_automat_creation();
  static const int kAutomatCreationFieldNumber = 30;
  inline const ::MsgsSimToClient::MsgAutomatCreation& automat_creation() const;
  inline ::MsgsSimToClient::MsgAutomatCreation* mutable_automat_creation();
  
  // optional .MsgsSimToClient.MsgAutomatAttributes automat_attributes = 31;
  inline bool has_automat_attributes() const;
  inline void clear_automat_attributes();
  static const int kAutomatAttributesFieldNumber = 31;
  inline const ::MsgsSimToClient::MsgAutomatAttributes& automat_attributes() const;
  inline ::MsgsSimToClient::MsgAutomatAttributes* mutable_automat_attributes();
  
  // optional .MsgsSimToClient.MsgUnitCreation unit_creation = 32;
  inline bool has_unit_creation() const;
  inline void clear_unit_creation();
  static const int kUnitCreationFieldNumber = 32;
  inline const ::MsgsSimToClient::MsgUnitCreation& unit_creation() const;
  inline ::MsgsSimToClient::MsgUnitCreation* mutable_unit_creation();
  
  // optional .MsgsSimToClient.MsgUnitAttributes unit_attributes = 33;
  inline bool has_unit_attributes() const;
  inline void clear_unit_attributes();
  static const int kUnitAttributesFieldNumber = 33;
  inline const ::MsgsSimToClient::MsgUnitAttributes& unit_attributes() const;
  inline ::MsgsSimToClient::MsgUnitAttributes* mutable_unit_attributes();
  
  // optional .MsgsSimToClient.MsgUnitPathFind unit_pathfind = 34;
  inline bool has_unit_pathfind() const;
  inline void clear_unit_pathfind();
  static const int kUnitPathfindFieldNumber = 34;
  inline const ::MsgsSimToClient::MsgUnitPathFind& unit_pathfind() const;
  inline ::MsgsSimToClient::MsgUnitPathFind* mutable_unit_pathfind();
  
  // optional .MsgsSimToClient.MsgUnitDestruction unit_destruction = 35;
  inline bool has_unit_destruction() const;
  inline void clear_unit_destruction();
  static const int kUnitDestructionFieldNumber = 35;
  inline const ::MsgsSimToClient::MsgUnitDestruction& unit_destruction() const;
  inline ::MsgsSimToClient::MsgUnitDestruction* mutable_unit_destruction();
  
  // optional .MsgsSimToClient.MsgUnitEnvironmentType unit_environment_type = 36;
  inline bool has_unit_environment_type() const;
  inline void clear_unit_environment_type();
  static const int kUnitEnvironmentTypeFieldNumber = 36;
  inline const ::MsgsSimToClient::MsgUnitEnvironmentType& unit_environment_type() const;
  inline ::MsgsSimToClient::MsgUnitEnvironmentType* mutable_unit_environment_type();
  
  // optional .Common.MsgChangeDiplomacy change_diplomacy = 37;
  inline bool has_change_diplomacy() const;
  inline void clear_change_diplomacy();
  static const int kChangeDiplomacyFieldNumber = 37;
  inline const ::Common::MsgChangeDiplomacy& change_diplomacy() const;
  inline ::Common::MsgChangeDiplomacy* mutable_change_diplomacy();
  
  // optional .Common.MsgUnitChangeSuperior unit_change_superior = 38;
  inline bool has_unit_change_superior() const;
  inline void clear_unit_change_superior();
  static const int kUnitChangeSuperiorFieldNumber = 38;
  inline const ::Common::MsgUnitChangeSuperior& unit_change_superior() const;
  inline ::Common::MsgUnitChangeSuperior* mutable_unit_change_superior();
  
  // optional .Common.MsgAutomatChangeLogisticLinks automat_change_logistic_links = 39;
  inline bool has_automat_change_logistic_links() const;
  inline void clear_automat_change_logistic_links();
  static const int kAutomatChangeLogisticLinksFieldNumber = 39;
  inline const ::Common::MsgAutomatChangeLogisticLinks& automat_change_logistic_links() const;
  inline ::Common::MsgAutomatChangeLogisticLinks* mutable_automat_change_logistic_links();
  
  // optional .Common.MsgAutomatChangeKnowledgeGroup automat_change_knowledge_group = 40;
  inline bool has_automat_change_knowledge_group() const;
  inline void clear_automat_change_knowledge_group();
  static const int kAutomatChangeKnowledgeGroupFieldNumber = 40;
  inline const ::Common::MsgAutomatChangeKnowledgeGroup& automat_change_knowledge_group() const;
  inline ::Common::MsgAutomatChangeKnowledgeGroup* mutable_automat_change_knowledge_group();
  
  // optional .Common.MsgAutomatChangeSuperior automat_change_superior = 41;
  inline bool has_automat_change_superior() const;
  inline void clear_automat_change_superior();
  static const int kAutomatChangeSuperiorFieldNumber = 41;
  inline const ::Common::MsgAutomatChangeSuperior& automat_change_superior() const;
  inline ::Common::MsgAutomatChangeSuperior* mutable_automat_change_superior();
  
  // optional .MsgsSimToClient.MsgUnitKnowledgeCreation unit_knowledge_creation = 42;
  inline bool has_unit_knowledge_creation() const;
  inline void clear_unit_knowledge_creation();
  static const int kUnitKnowledgeCreationFieldNumber = 42;
  inline const ::MsgsSimToClient::MsgUnitKnowledgeCreation& unit_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgUnitKnowledgeCreation* mutable_unit_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgUnitKnowledgeUpdate unit_knowledge_update = 43;
  inline bool has_unit_knowledge_update() const;
  inline void clear_unit_knowledge_update();
  static const int kUnitKnowledgeUpdateFieldNumber = 43;
  inline const ::MsgsSimToClient::MsgUnitKnowledgeUpdate& unit_knowledge_update() const;
  inline ::MsgsSimToClient::MsgUnitKnowledgeUpdate* mutable_unit_knowledge_update();
  
  // optional .MsgsSimToClient.MsgUnitKnowledgeDestruction unit_knowledge_destruction = 44;
  inline bool has_unit_knowledge_destruction() const;
  inline void clear_unit_knowledge_destruction();
  static const int kUnitKnowledgeDestructionFieldNumber = 44;
  inline const ::MsgsSimToClient::MsgUnitKnowledgeDestruction& unit_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgUnitKnowledgeDestruction* mutable_unit_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgStartUnitFire start_unit_fire = 45;
  inline bool has_start_unit_fire() const;
  inline void clear_start_unit_fire();
  static const int kStartUnitFireFieldNumber = 45;
  inline const ::MsgsSimToClient::MsgStartUnitFire& start_unit_fire() const;
  inline ::MsgsSimToClient::MsgStartUnitFire* mutable_start_unit_fire();
  
  // optional .MsgsSimToClient.MsgStopUnitFire stop_unit_fire = 46;
  inline bool has_stop_unit_fire() const;
  inline void clear_stop_unit_fire();
  static const int kStopUnitFireFieldNumber = 46;
  inline const ::MsgsSimToClient::MsgStopUnitFire& stop_unit_fire() const;
  inline ::MsgsSimToClient::MsgStopUnitFire* mutable_stop_unit_fire();
  
  // optional .MsgsSimToClient.MsgStartCrowdFire start_crowd_fire = 47;
  inline bool has_start_crowd_fire() const;
  inline void clear_start_crowd_fire();
  static const int kStartCrowdFireFieldNumber = 47;
  inline const ::MsgsSimToClient::MsgStartCrowdFire& start_crowd_fire() const;
  inline ::MsgsSimToClient::MsgStartCrowdFire* mutable_start_crowd_fire();
  
  // optional .MsgsSimToClient.MsgStopCrowdFire stop_crowd_fire = 48;
  inline bool has_stop_crowd_fire() const;
  inline void clear_stop_crowd_fire();
  static const int kStopCrowdFireFieldNumber = 48;
  inline const ::MsgsSimToClient::MsgStopCrowdFire& stop_crowd_fire() const;
  inline ::MsgsSimToClient::MsgStopCrowdFire* mutable_stop_crowd_fire();
  
  // optional .MsgsSimToClient.MsgExplosion explosion = 49;
  inline bool has_explosion() const;
  inline void clear_explosion();
  static const int kExplosionFieldNumber = 49;
  inline const ::MsgsSimToClient::MsgExplosion& explosion() const;
  inline ::MsgsSimToClient::MsgExplosion* mutable_explosion();
  
  // optional .MsgsSimToClient.MsgStartFireEffect start_fire_effect = 50;
  inline bool has_start_fire_effect() const;
  inline void clear_start_fire_effect();
  static const int kStartFireEffectFieldNumber = 50;
  inline const ::MsgsSimToClient::MsgStartFireEffect& start_fire_effect() const;
  inline ::MsgsSimToClient::MsgStartFireEffect* mutable_start_fire_effect();
  
  // optional .MsgsSimToClient.MsgStopFireEffect stop_fire_effect = 51;
  inline bool has_stop_fire_effect() const;
  inline void clear_stop_fire_effect();
  static const int kStopFireEffectFieldNumber = 51;
  inline const ::MsgsSimToClient::MsgStopFireEffect& stop_fire_effect() const;
  inline ::MsgsSimToClient::MsgStopFireEffect* mutable_stop_fire_effect();
  
  // optional .MsgsSimToClient.MsgReport report = 52;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 52;
  inline const ::MsgsSimToClient::MsgReport& report() const;
  inline ::MsgsSimToClient::MsgReport* mutable_report();
  
  // optional .MsgsSimToClient.MsgInvalidateReport invalidate_report = 53;
  inline bool has_invalidate_report() const;
  inline void clear_invalidate_report();
  static const int kInvalidateReportFieldNumber = 53;
  inline const ::MsgsSimToClient::MsgInvalidateReport& invalidate_report() const;
  inline ::MsgsSimToClient::MsgInvalidateReport* mutable_invalidate_report();
  
  // optional .MsgsSimToClient.MsgTrace trace = 54;
  inline bool has_trace() const;
  inline void clear_trace();
  static const int kTraceFieldNumber = 54;
  inline const ::MsgsSimToClient::MsgTrace& trace() const;
  inline ::MsgsSimToClient::MsgTrace* mutable_trace();
  
  // optional .MsgsSimToClient.MsgDecisionalState decisional_state = 55;
  inline bool has_decisional_state() const;
  inline void clear_decisional_state();
  static const int kDecisionalStateFieldNumber = 55;
  inline const ::MsgsSimToClient::MsgDecisionalState& decisional_state() const;
  inline ::MsgsSimToClient::MsgDecisionalState* mutable_decisional_state();
  
  // optional .MsgsSimToClient.MsgDebugPoints debug_points = 56;
  inline bool has_debug_points() const;
  inline void clear_debug_points();
  static const int kDebugPointsFieldNumber = 56;
  inline const ::MsgsSimToClient::MsgDebugPoints& debug_points() const;
  inline ::MsgsSimToClient::MsgDebugPoints* mutable_debug_points();
  
  // optional .MsgsSimToClient.MsgUnitVisionCones unit_vision_cones = 57;
  inline bool has_unit_vision_cones() const;
  inline void clear_unit_vision_cones();
  static const int kUnitVisionConesFieldNumber = 57;
  inline const ::MsgsSimToClient::MsgUnitVisionCones& unit_vision_cones() const;
  inline ::MsgsSimToClient::MsgUnitVisionCones* mutable_unit_vision_cones();
  
  // optional .MsgsSimToClient.MsgUnitDetection unit_detection = 58;
  inline bool has_unit_detection() const;
  inline void clear_unit_detection();
  static const int kUnitDetectionFieldNumber = 58;
  inline const ::MsgsSimToClient::MsgUnitDetection& unit_detection() const;
  inline ::MsgsSimToClient::MsgUnitDetection* mutable_unit_detection();
  
  // optional .MsgsSimToClient.MsgObjectDetection object_detection = 59;
  inline bool has_object_detection() const;
  inline void clear_object_detection();
  static const int kObjectDetectionFieldNumber = 59;
  inline const ::MsgsSimToClient::MsgObjectDetection& object_detection() const;
  inline ::MsgsSimToClient::MsgObjectDetection* mutable_object_detection();
  
  // optional .MsgsSimToClient.MsgCrowdConcentrationDetection crowd_concentration_detection = 60;
  inline bool has_crowd_concentration_detection() const;
  inline void clear_crowd_concentration_detection();
  static const int kCrowdConcentrationDetectionFieldNumber = 60;
  inline const ::MsgsSimToClient::MsgCrowdConcentrationDetection& crowd_concentration_detection() const;
  inline ::MsgsSimToClient::MsgCrowdConcentrationDetection* mutable_crowd_concentration_detection();
  
  // optional .MsgsSimToClient.MsgCrowdFlowDetection crowd_flow_detection = 61;
  inline bool has_crowd_flow_detection() const;
  inline void clear_crowd_flow_detection();
  static const int kCrowdFlowDetectionFieldNumber = 61;
  inline const ::MsgsSimToClient::MsgCrowdFlowDetection& crowd_flow_detection() const;
  inline ::MsgsSimToClient::MsgCrowdFlowDetection* mutable_crowd_flow_detection();
  
  // optional .Common.MsgUnitOrder unit_order = 62;
  inline bool has_unit_order() const;
  inline void clear_unit_order();
  static const int kUnitOrderFieldNumber = 62;
  inline const ::Common::MsgUnitOrder& unit_order() const;
  inline ::Common::MsgUnitOrder* mutable_unit_order();
  
  // optional .Common.MsgAutomatOrder automat_order = 63;
  inline bool has_automat_order() const;
  inline void clear_automat_order();
  static const int kAutomatOrderFieldNumber = 63;
  inline const ::Common::MsgAutomatOrder& automat_order() const;
  inline ::Common::MsgAutomatOrder* mutable_automat_order();
  
  // optional .Common.MsgCrowdOrder crowd_order = 64;
  inline bool has_crowd_order() const;
  inline void clear_crowd_order();
  static const int kCrowdOrderFieldNumber = 64;
  inline const ::Common::MsgCrowdOrder& crowd_order() const;
  inline ::Common::MsgCrowdOrder* mutable_crowd_order();
  
  // optional .MsgsSimToClient.MsgObjectCreation object_creation = 65;
  inline bool has_object_creation() const;
  inline void clear_object_creation();
  static const int kObjectCreationFieldNumber = 65;
  inline const ::MsgsSimToClient::MsgObjectCreation& object_creation() const;
  inline ::MsgsSimToClient::MsgObjectCreation* mutable_object_creation();
  
  // optional .MsgsSimToClient.MsgObjectDestruction object_destruction = 66;
  inline bool has_object_destruction() const;
  inline void clear_object_destruction();
  static const int kObjectDestructionFieldNumber = 66;
  inline const ::MsgsSimToClient::MsgObjectDestruction& object_destruction() const;
  inline ::MsgsSimToClient::MsgObjectDestruction* mutable_object_destruction();
  
  // optional .MsgsSimToClient.MsgObjectUpdate object_update = 67;
  inline bool has_object_update() const;
  inline void clear_object_update();
  static const int kObjectUpdateFieldNumber = 67;
  inline const ::MsgsSimToClient::MsgObjectUpdate& object_update() const;
  inline ::MsgsSimToClient::MsgObjectUpdate* mutable_object_update();
  
  // optional .MsgsSimToClient.MsgObjectKnowledgeCreation object_knowledge_creation = 68;
  inline bool has_object_knowledge_creation() const;
  inline void clear_object_knowledge_creation();
  static const int kObjectKnowledgeCreationFieldNumber = 68;
  inline const ::MsgsSimToClient::MsgObjectKnowledgeCreation& object_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgObjectKnowledgeCreation* mutable_object_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgObjectKnowledgeUpdate object_knowledge_update = 69;
  inline bool has_object_knowledge_update() const;
  inline void clear_object_knowledge_update();
  static const int kObjectKnowledgeUpdateFieldNumber = 69;
  inline const ::MsgsSimToClient::MsgObjectKnowledgeUpdate& object_knowledge_update() const;
  inline ::MsgsSimToClient::MsgObjectKnowledgeUpdate* mutable_object_knowledge_update();
  
  // optional .MsgsSimToClient.MsgObjectKnowledgeDestruction object_knowledge_destruction = 70;
  inline bool has_object_knowledge_destruction() const;
  inline void clear_object_knowledge_destruction();
  static const int kObjectKnowledgeDestructionFieldNumber = 70;
  inline const ::MsgsSimToClient::MsgObjectKnowledgeDestruction& object_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgObjectKnowledgeDestruction* mutable_object_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgLogMedicalHandlingCreation log_medical_handling_creation = 71;
  inline bool has_log_medical_handling_creation() const;
  inline void clear_log_medical_handling_creation();
  static const int kLogMedicalHandlingCreationFieldNumber = 71;
  inline const ::MsgsSimToClient::MsgLogMedicalHandlingCreation& log_medical_handling_creation() const;
  inline ::MsgsSimToClient::MsgLogMedicalHandlingCreation* mutable_log_medical_handling_creation();
  
  // optional .MsgsSimToClient.MsgLogMedicalHandlingUpdate log_medical_handling_update = 72;
  inline bool has_log_medical_handling_update() const;
  inline void clear_log_medical_handling_update();
  static const int kLogMedicalHandlingUpdateFieldNumber = 72;
  inline const ::MsgsSimToClient::MsgLogMedicalHandlingUpdate& log_medical_handling_update() const;
  inline ::MsgsSimToClient::MsgLogMedicalHandlingUpdate* mutable_log_medical_handling_update();
  
  // optional .MsgsSimToClient.MsgLogMedicalHandlingDestruction log_medical_handling_destruction = 73;
  inline bool has_log_medical_handling_destruction() const;
  inline void clear_log_medical_handling_destruction();
  static const int kLogMedicalHandlingDestructionFieldNumber = 73;
  inline const ::MsgsSimToClient::MsgLogMedicalHandlingDestruction& log_medical_handling_destruction() const;
  inline ::MsgsSimToClient::MsgLogMedicalHandlingDestruction* mutable_log_medical_handling_destruction();
  
  // optional .MsgsSimToClient.MsgLogMedicalState log_medical_state = 74;
  inline bool has_log_medical_state() const;
  inline void clear_log_medical_state();
  static const int kLogMedicalStateFieldNumber = 74;
  inline const ::MsgsSimToClient::MsgLogMedicalState& log_medical_state() const;
  inline ::MsgsSimToClient::MsgLogMedicalState* mutable_log_medical_state();
  
  // optional .MsgsSimToClient.MsgLogMaintenanceHandlingCreation log_maintenance_handling_creation = 75;
  inline bool has_log_maintenance_handling_creation() const;
  inline void clear_log_maintenance_handling_creation();
  static const int kLogMaintenanceHandlingCreationFieldNumber = 75;
  inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation& log_maintenance_handling_creation() const;
  inline ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation* mutable_log_maintenance_handling_creation();
  
  // optional .MsgsSimToClient.MsgLogMaintenanceHandlingUpdate log_maintenance_handling_update = 76;
  inline bool has_log_maintenance_handling_update() const;
  inline void clear_log_maintenance_handling_update();
  static const int kLogMaintenanceHandlingUpdateFieldNumber = 76;
  inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate& log_maintenance_handling_update() const;
  inline ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate* mutable_log_maintenance_handling_update();
  
  // optional .MsgsSimToClient.MsgLogMaintenanceHandlingDestruction log_maintenance_handling_destruction = 77;
  inline bool has_log_maintenance_handling_destruction() const;
  inline void clear_log_maintenance_handling_destruction();
  static const int kLogMaintenanceHandlingDestructionFieldNumber = 77;
  inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction& log_maintenance_handling_destruction() const;
  inline ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction* mutable_log_maintenance_handling_destruction();
  
  // optional .MsgsSimToClient.MsgLogMaintenanceState log_maintenance_state = 78;
  inline bool has_log_maintenance_state() const;
  inline void clear_log_maintenance_state();
  static const int kLogMaintenanceStateFieldNumber = 78;
  inline const ::MsgsSimToClient::MsgLogMaintenanceState& log_maintenance_state() const;
  inline ::MsgsSimToClient::MsgLogMaintenanceState* mutable_log_maintenance_state();
  
  // optional .MsgsSimToClient.MsgLogSupplyHandlingCreation log_supply_handling_creation = 79;
  inline bool has_log_supply_handling_creation() const;
  inline void clear_log_supply_handling_creation();
  static const int kLogSupplyHandlingCreationFieldNumber = 79;
  inline const ::MsgsSimToClient::MsgLogSupplyHandlingCreation& log_supply_handling_creation() const;
  inline ::MsgsSimToClient::MsgLogSupplyHandlingCreation* mutable_log_supply_handling_creation();
  
  // optional .MsgsSimToClient.MsgLogSupplyHandlingUpdate log_supply_handling_update = 80;
  inline bool has_log_supply_handling_update() const;
  inline void clear_log_supply_handling_update();
  static const int kLogSupplyHandlingUpdateFieldNumber = 80;
  inline const ::MsgsSimToClient::MsgLogSupplyHandlingUpdate& log_supply_handling_update() const;
  inline ::MsgsSimToClient::MsgLogSupplyHandlingUpdate* mutable_log_supply_handling_update();
  
  // optional .MsgsSimToClient.MsgLogSupplyHandlingDestruction log_supply_handling_destruction = 81;
  inline bool has_log_supply_handling_destruction() const;
  inline void clear_log_supply_handling_destruction();
  static const int kLogSupplyHandlingDestructionFieldNumber = 81;
  inline const ::MsgsSimToClient::MsgLogSupplyHandlingDestruction& log_supply_handling_destruction() const;
  inline ::MsgsSimToClient::MsgLogSupplyHandlingDestruction* mutable_log_supply_handling_destruction();
  
  // optional .MsgsSimToClient.MsgLogSupplyState log_supply_state = 82;
  inline bool has_log_supply_state() const;
  inline void clear_log_supply_state();
  static const int kLogSupplyStateFieldNumber = 82;
  inline const ::MsgsSimToClient::MsgLogSupplyState& log_supply_state() const;
  inline ::MsgsSimToClient::MsgLogSupplyState* mutable_log_supply_state();
  
  // optional .MsgsSimToClient.MsgLogSupplyQuotas log_supply_quotas = 83;
  inline bool has_log_supply_quotas() const;
  inline void clear_log_supply_quotas();
  static const int kLogSupplyQuotasFieldNumber = 83;
  inline const ::MsgsSimToClient::MsgLogSupplyQuotas& log_supply_quotas() const;
  inline ::MsgsSimToClient::MsgLogSupplyQuotas* mutable_log_supply_quotas();
  
  // optional .MsgsSimToClient.MsgCrowdCreation crowd_creation = 84;
  inline bool has_crowd_creation() const;
  inline void clear_crowd_creation();
  static const int kCrowdCreationFieldNumber = 84;
  inline const ::MsgsSimToClient::MsgCrowdCreation& crowd_creation() const;
  inline ::MsgsSimToClient::MsgCrowdCreation* mutable_crowd_creation();
  
  // optional .MsgsSimToClient.MsgCrowdUpdate crowd_update = 85;
  inline bool has_crowd_update() const;
  inline void clear_crowd_update();
  static const int kCrowdUpdateFieldNumber = 85;
  inline const ::MsgsSimToClient::MsgCrowdUpdate& crowd_update() const;
  inline ::MsgsSimToClient::MsgCrowdUpdate* mutable_crowd_update();
  
  // optional .MsgsSimToClient.MsgCrowdConcentrationCreation crowd_concentration_creation = 86;
  inline bool has_crowd_concentration_creation() const;
  inline void clear_crowd_concentration_creation();
  static const int kCrowdConcentrationCreationFieldNumber = 86;
  inline const ::MsgsSimToClient::MsgCrowdConcentrationCreation& crowd_concentration_creation() const;
  inline ::MsgsSimToClient::MsgCrowdConcentrationCreation* mutable_crowd_concentration_creation();
  
  // optional .MsgsSimToClient.MsgCrowdConcentrationDestruction crowd_concentration_destruction = 87;
  inline bool has_crowd_concentration_destruction() const;
  inline void clear_crowd_concentration_destruction();
  static const int kCrowdConcentrationDestructionFieldNumber = 87;
  inline const ::MsgsSimToClient::MsgCrowdConcentrationDestruction& crowd_concentration_destruction() const;
  inline ::MsgsSimToClient::MsgCrowdConcentrationDestruction* mutable_crowd_concentration_destruction();
  
  // optional .MsgsSimToClient.MsgCrowdConcentrationUpdate crowd_concentration_update = 88;
  inline bool has_crowd_concentration_update() const;
  inline void clear_crowd_concentration_update();
  static const int kCrowdConcentrationUpdateFieldNumber = 88;
  inline const ::MsgsSimToClient::MsgCrowdConcentrationUpdate& crowd_concentration_update() const;
  inline ::MsgsSimToClient::MsgCrowdConcentrationUpdate* mutable_crowd_concentration_update();
  
  // optional .MsgsSimToClient.MsgCrowdFlowCreation crowd_flow_creation = 89;
  inline bool has_crowd_flow_creation() const;
  inline void clear_crowd_flow_creation();
  static const int kCrowdFlowCreationFieldNumber = 89;
  inline const ::MsgsSimToClient::MsgCrowdFlowCreation& crowd_flow_creation() const;
  inline ::MsgsSimToClient::MsgCrowdFlowCreation* mutable_crowd_flow_creation();
  
  // optional .MsgsSimToClient.MsgCrowdFlowDestruction crowd_flow_destruction = 90;
  inline bool has_crowd_flow_destruction() const;
  inline void clear_crowd_flow_destruction();
  static const int kCrowdFlowDestructionFieldNumber = 90;
  inline const ::MsgsSimToClient::MsgCrowdFlowDestruction& crowd_flow_destruction() const;
  inline ::MsgsSimToClient::MsgCrowdFlowDestruction* mutable_crowd_flow_destruction();
  
  // optional .MsgsSimToClient.MsgCrowdFlowUpdate crowd_flow_update = 91;
  inline bool has_crowd_flow_update() const;
  inline void clear_crowd_flow_update();
  static const int kCrowdFlowUpdateFieldNumber = 91;
  inline const ::MsgsSimToClient::MsgCrowdFlowUpdate& crowd_flow_update() const;
  inline ::MsgsSimToClient::MsgCrowdFlowUpdate* mutable_crowd_flow_update();
  
  // optional .MsgsSimToClient.MsgCrowdKnowledgeCreation crowd_knowledge_creation = 92;
  inline bool has_crowd_knowledge_creation() const;
  inline void clear_crowd_knowledge_creation();
  static const int kCrowdKnowledgeCreationFieldNumber = 92;
  inline const ::MsgsSimToClient::MsgCrowdKnowledgeCreation& crowd_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgCrowdKnowledgeCreation* mutable_crowd_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgCrowdKnowledgeUpdate crowd_knowledge_update = 93;
  inline bool has_crowd_knowledge_update() const;
  inline void clear_crowd_knowledge_update();
  static const int kCrowdKnowledgeUpdateFieldNumber = 93;
  inline const ::MsgsSimToClient::MsgCrowdKnowledgeUpdate& crowd_knowledge_update() const;
  inline ::MsgsSimToClient::MsgCrowdKnowledgeUpdate* mutable_crowd_knowledge_update();
  
  // optional .MsgsSimToClient.MsgCrowdKnowledgeDestruction crowd_knowledge_destruction = 94;
  inline bool has_crowd_knowledge_destruction() const;
  inline void clear_crowd_knowledge_destruction();
  static const int kCrowdKnowledgeDestructionFieldNumber = 94;
  inline const ::MsgsSimToClient::MsgCrowdKnowledgeDestruction& crowd_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgCrowdKnowledgeDestruction* mutable_crowd_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgCrowdConcentrationKnowledgeCreation crowd_concentration_knowledge_creation = 95;
  inline bool has_crowd_concentration_knowledge_creation() const;
  inline void clear_crowd_concentration_knowledge_creation();
  static const int kCrowdConcentrationKnowledgeCreationFieldNumber = 95;
  inline const ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeCreation& crowd_concentration_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeCreation* mutable_crowd_concentration_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgCrowdConcentrationKnowledgeDestruction crowd_concentration_knowledge_destruction = 96;
  inline bool has_crowd_concentration_knowledge_destruction() const;
  inline void clear_crowd_concentration_knowledge_destruction();
  static const int kCrowdConcentrationKnowledgeDestructionFieldNumber = 96;
  inline const ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeDestruction& crowd_concentration_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeDestruction* mutable_crowd_concentration_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgCrowdConcentrationKnowledgeUpdate crowd_concentration_knowledge_update = 97;
  inline bool has_crowd_concentration_knowledge_update() const;
  inline void clear_crowd_concentration_knowledge_update();
  static const int kCrowdConcentrationKnowledgeUpdateFieldNumber = 97;
  inline const ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeUpdate& crowd_concentration_knowledge_update() const;
  inline ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeUpdate* mutable_crowd_concentration_knowledge_update();
  
  // optional .MsgsSimToClient.MsgCrowdFlowKnowledgeCreation crowd_flow_knowledge_creation = 98;
  inline bool has_crowd_flow_knowledge_creation() const;
  inline void clear_crowd_flow_knowledge_creation();
  static const int kCrowdFlowKnowledgeCreationFieldNumber = 98;
  inline const ::MsgsSimToClient::MsgCrowdFlowKnowledgeCreation& crowd_flow_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgCrowdFlowKnowledgeCreation* mutable_crowd_flow_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgCrowdFlowKnowledgeDestruction crowd_flow_knowledge_destruction = 99;
  inline bool has_crowd_flow_knowledge_destruction() const;
  inline void clear_crowd_flow_knowledge_destruction();
  static const int kCrowdFlowKnowledgeDestructionFieldNumber = 99;
  inline const ::MsgsSimToClient::MsgCrowdFlowKnowledgeDestruction& crowd_flow_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgCrowdFlowKnowledgeDestruction* mutable_crowd_flow_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgCrowdFlowKnowledgeUpdate crowd_flow_knowledge_update = 100;
  inline bool has_crowd_flow_knowledge_update() const;
  inline void clear_crowd_flow_knowledge_update();
  static const int kCrowdFlowKnowledgeUpdateFieldNumber = 100;
  inline const ::MsgsSimToClient::MsgCrowdFlowKnowledgeUpdate& crowd_flow_knowledge_update() const;
  inline ::MsgsSimToClient::MsgCrowdFlowKnowledgeUpdate* mutable_crowd_flow_knowledge_update();
  
  // optional .MsgsSimToClient.MsgFolkCreation folk_creation = 101;
  inline bool has_folk_creation() const;
  inline void clear_folk_creation();
  static const int kFolkCreationFieldNumber = 101;
  inline const ::MsgsSimToClient::MsgFolkCreation& folk_creation() const;
  inline ::MsgsSimToClient::MsgFolkCreation* mutable_folk_creation();
  
  // optional .MsgsSimToClient.MsgFolkGraphUpdate folk_graph_update = 102;
  inline bool has_folk_graph_update() const;
  inline void clear_folk_graph_update();
  static const int kFolkGraphUpdateFieldNumber = 102;
  inline const ::MsgsSimToClient::MsgFolkGraphUpdate& folk_graph_update() const;
  inline ::MsgsSimToClient::MsgFolkGraphUpdate* mutable_folk_graph_update();
  
  // optional .MsgsSimToClient.MsgControlGlobalWeatherAck control_global_weather_ack = 103;
  inline bool has_control_global_weather_ack() const;
  inline void clear_control_global_weather_ack();
  static const int kControlGlobalWeatherAckFieldNumber = 103;
  inline const ::MsgsSimToClient::MsgControlGlobalWeatherAck& control_global_weather_ack() const;
  inline ::MsgsSimToClient::MsgControlGlobalWeatherAck* mutable_control_global_weather_ack();
  
  // optional .MsgsSimToClient.MsgControlLocalWeatherAck control_local_weather_ack = 104;
  inline bool has_control_local_weather_ack() const;
  inline void clear_control_local_weather_ack();
  static const int kControlLocalWeatherAckFieldNumber = 104;
  inline const ::MsgsSimToClient::MsgControlLocalWeatherAck& control_local_weather_ack() const;
  inline ::MsgsSimToClient::MsgControlLocalWeatherAck* mutable_control_local_weather_ack();
  
  // optional .MsgsSimToClient.MsgControlCheckPointSaveBegin control_checkpoint_save_begin = 105;
  inline bool has_control_checkpoint_save_begin() const;
  inline void clear_control_checkpoint_save_begin();
  static const int kControlCheckpointSaveBeginFieldNumber = 105;
  inline const ::MsgsSimToClient::MsgControlCheckPointSaveBegin& control_checkpoint_save_begin() const;
  inline ::MsgsSimToClient::MsgControlCheckPointSaveBegin* mutable_control_checkpoint_save_begin();
  
  // optional .MsgsSimToClient.MsgControlCheckPointSetFrequencyAck control_checkpoint_set_frequency_ack = 106;
  inline bool has_control_checkpoint_set_frequency_ack() const;
  inline void clear_control_checkpoint_set_frequency_ack();
  static const int kControlCheckpointSetFrequencyAckFieldNumber = 106;
  inline const ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck& control_checkpoint_set_frequency_ack() const;
  inline ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck* mutable_control_checkpoint_set_frequency_ack();
  
  // optional .MsgsSimToClient.MsgControlCheckPointSaveNowAck control_checkpoint_save_now_ack = 107;
  inline bool has_control_checkpoint_save_now_ack() const;
  inline void clear_control_checkpoint_save_now_ack();
  static const int kControlCheckpointSaveNowAckFieldNumber = 107;
  inline const ::MsgsSimToClient::MsgControlCheckPointSaveNowAck& control_checkpoint_save_now_ack() const;
  inline ::MsgsSimToClient::MsgControlCheckPointSaveNowAck* mutable_control_checkpoint_save_now_ack();
  
  // optional .MsgsSimToClient.MsgControlSendCurrentStateBegin control_send_current_state_begin = 108;
  inline bool has_control_send_current_state_begin() const;
  inline void clear_control_send_current_state_begin();
  static const int kControlSendCurrentStateBeginFieldNumber = 108;
  inline const ::MsgsSimToClient::MsgControlSendCurrentStateBegin& control_send_current_state_begin() const;
  inline ::MsgsSimToClient::MsgControlSendCurrentStateBegin* mutable_control_send_current_state_begin();
  
  // optional .MsgsSimToClient.MsgControlSendCurrentStateEnd control_send_current_state_end = 109;
  inline bool has_control_send_current_state_end() const;
  inline void clear_control_send_current_state_end();
  static const int kControlSendCurrentStateEndFieldNumber = 109;
  inline const ::MsgsSimToClient::MsgControlSendCurrentStateEnd& control_send_current_state_end() const;
  inline ::MsgsSimToClient::MsgControlSendCurrentStateEnd* mutable_control_send_current_state_end();
  
  // optional .MsgsSimToClient.MsgUrbanCreation urban_creation = 110;
  inline bool has_urban_creation() const;
  inline void clear_urban_creation();
  static const int kUrbanCreationFieldNumber = 110;
  inline const ::MsgsSimToClient::MsgUrbanCreation& urban_creation() const;
  inline ::MsgsSimToClient::MsgUrbanCreation* mutable_urban_creation();
  
  // optional .MsgsSimToClient.MsgUrbanUpdate urban_update = 111;
  inline bool has_urban_update() const;
  inline void clear_urban_update();
  static const int kUrbanUpdateFieldNumber = 111;
  inline const ::MsgsSimToClient::MsgUrbanUpdate& urban_update() const;
  inline ::MsgsSimToClient::MsgUrbanUpdate* mutable_urban_update();
  
  // optional .MsgsSimToClient.MsgUrbanKnowledgeCreation urban_knowledge_creation = 112;
  inline bool has_urban_knowledge_creation() const;
  inline void clear_urban_knowledge_creation();
  static const int kUrbanKnowledgeCreationFieldNumber = 112;
  inline const ::MsgsSimToClient::MsgUrbanKnowledgeCreation& urban_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgUrbanKnowledgeCreation* mutable_urban_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgUrbanKnowledgeUpdate urban_knowledge_update = 113;
  inline bool has_urban_knowledge_update() const;
  inline void clear_urban_knowledge_update();
  static const int kUrbanKnowledgeUpdateFieldNumber = 113;
  inline const ::MsgsSimToClient::MsgUrbanKnowledgeUpdate& urban_knowledge_update() const;
  inline ::MsgsSimToClient::MsgUrbanKnowledgeUpdate* mutable_urban_knowledge_update();
  
  // optional .MsgsSimToClient.MsgUrbanKnowledgeDestruction urban_knowledge_destruction = 114;
  inline bool has_urban_knowledge_destruction() const;
  inline void clear_urban_knowledge_destruction();
  static const int kUrbanKnowledgeDestructionFieldNumber = 114;
  inline const ::MsgsSimToClient::MsgUrbanKnowledgeDestruction& urban_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgUrbanKnowledgeDestruction* mutable_urban_knowledge_destruction();
  
  // optional .Common.StockResource stock_resource = 115;
  inline bool has_stock_resource() const;
  inline void clear_stock_resource();
  static const int kStockResourceFieldNumber = 115;
  inline const ::Common::StockResource& stock_resource() const;
  inline ::Common::StockResource* mutable_stock_resource();
  
  // optional .MsgsSimToClient.MsgUrbanDetection urban_detection = 116;
  inline bool has_urban_detection() const;
  inline void clear_urban_detection();
  static const int kUrbanDetectionFieldNumber = 116;
  inline const ::MsgsSimToClient::MsgUrbanDetection& urban_detection() const;
  inline ::MsgsSimToClient::MsgUrbanDetection* mutable_urban_detection();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupMagicActionAck knowledge_group_magic_action_ack = 117;
  inline bool has_knowledge_group_magic_action_ack() const;
  inline void clear_knowledge_group_magic_action_ack();
  static const int kKnowledgeGroupMagicActionAckFieldNumber = 117;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck& knowledge_group_magic_action_ack() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck* mutable_knowledge_group_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupCreation knowledge_group_creation = 118;
  inline bool has_knowledge_group_creation() const;
  inline void clear_knowledge_group_creation();
  static const int kKnowledgeGroupCreationFieldNumber = 118;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupCreation& knowledge_group_creation() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupCreation* mutable_knowledge_group_creation();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupUpdate knowledge_group_update = 119;
  inline bool has_knowledge_group_update() const;
  inline void clear_knowledge_group_update();
  static const int kKnowledgeGroupUpdateFieldNumber = 119;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupUpdate& knowledge_group_update() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupUpdate* mutable_knowledge_group_update();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupCreationAck knowledge_group_creation_ack = 120;
  inline bool has_knowledge_group_creation_ack() const;
  inline void clear_knowledge_group_creation_ack();
  static const int kKnowledgeGroupCreationAckFieldNumber = 120;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupCreationAck& knowledge_group_creation_ack() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupCreationAck* mutable_knowledge_group_creation_ack();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupUpdateAck knowledge_group_update_ack = 121;
  inline bool has_knowledge_group_update_ack() const;
  inline void clear_knowledge_group_update_ack();
  static const int kKnowledgeGroupUpdateAckFieldNumber = 121;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck& knowledge_group_update_ack() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck* mutable_knowledge_group_update_ack();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupDestruction knowledge_group_destruction = 122;
  inline bool has_knowledge_group_destruction() const;
  inline void clear_knowledge_group_destruction();
  static const int kKnowledgeGroupDestructionFieldNumber = 122;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupDestruction& knowledge_group_destruction() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupDestruction* mutable_knowledge_group_destruction();
  
  // optional .MsgsSimToClient.MsgActionCreateFireOrderAck action_create_fire_order_ack = 123;
  inline bool has_action_create_fire_order_ack() const;
  inline void clear_action_create_fire_order_ack();
  static const int kActionCreateFireOrderAckFieldNumber = 123;
  inline const ::MsgsSimToClient::MsgActionCreateFireOrderAck& action_create_fire_order_ack() const;
  inline ::MsgsSimToClient::MsgActionCreateFireOrderAck* mutable_action_create_fire_order_ack();
  
  // optional .MsgsSimToClient.MsgControlGlobalWeather control_global_weather = 124;
  inline bool has_control_global_weather() const;
  inline void clear_control_global_weather();
  static const int kControlGlobalWeatherFieldNumber = 124;
  inline const ::MsgsSimToClient::MsgControlGlobalWeather& control_global_weather() const;
  inline ::MsgsSimToClient::MsgControlGlobalWeather* mutable_control_global_weather();
  
  // optional .MsgsSimToClient.MsgControlLocalWeatherCreation control_local_weather_creation = 125;
  inline bool has_control_local_weather_creation() const;
  inline void clear_control_local_weather_creation();
  static const int kControlLocalWeatherCreationFieldNumber = 125;
  inline const ::MsgsSimToClient::MsgControlLocalWeatherCreation& control_local_weather_creation() const;
  inline ::MsgsSimToClient::MsgControlLocalWeatherCreation* mutable_control_local_weather_creation();
  
  // optional .MsgsSimToClient.MsgControlLocalWeatherDestruction control_local_weather_destruction = 126;
  inline bool has_control_local_weather_destruction() const;
  inline void clear_control_local_weather_destruction();
  static const int kControlLocalWeatherDestructionFieldNumber = 126;
  inline const ::MsgsSimToClient::MsgControlLocalWeatherDestruction& control_local_weather_destruction() const;
  inline ::MsgsSimToClient::MsgControlLocalWeatherDestruction* mutable_control_local_weather_destruction();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsSimToClient::MsgUnitOrderAck* unit_order_ack_;
  ::MsgsSimToClient::MsgAutomatOrderAck* automat_order_ack_;
  ::MsgsSimToClient::MsgCrowdOrderAck* crowd_order_ack_;
  ::MsgsSimToClient::MsgFragOrderAck* frag_order_ack_;
  ::MsgsSimToClient::MsgSetAutomatModeAck* set_automat_mode_ack_;
  ::MsgsSimToClient::MsgUnitCreationRequestAck* unit_creation_request_ack_;
  ::MsgsSimToClient::MsgMagicActionAck* magic_action_ack_;
  ::MsgsSimToClient::MsgUnitMagicActionAck* unit_magic_action_ack_;
  ::MsgsSimToClient::MsgObjectMagicActionAck* object_magic_action_ack_;
  ::MsgsSimToClient::MsgCrowdMagicActionAck* crowd_magic_action_ack_;
  ::MsgsSimToClient::MsgChangeDiplomacyAck* change_diplomacy_ack_;
  ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck* automat_change_knowledge_group_ack_;
  ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck* automat_change_logistic_links_ack_;
  ::MsgsSimToClient::MsgAutomatChangeSuperiorAck* automat_change_superior_ack_;
  ::MsgsSimToClient::MsgUnitChangeSuperiorAck* unit_change_superior_ack_;
  ::MsgsSimToClient::MsgLogSupplyPushFlowAck* log_supply_push_flow_ack_;
  ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck* log_supply_change_quotas_ack_;
  ::MsgsSimToClient::MsgControlInformation* control_information_;
  ::MsgsSimToClient::MsgControlProfilingInformation* control_profiling_information_;
  ::MsgsSimToClient::MsgControlBeginTick* control_begin_tick_;
  ::MsgsSimToClient::MsgControlEndTick* control_end_tick_;
  ::MsgsSimToClient::MsgControlStopAck* control_stop_ack_;
  ::MsgsSimToClient::MsgControlPauseAck* control_pause_ack_;
  ::MsgsSimToClient::MsgControlResumeAck* control_resume_ack_;
  ::MsgsSimToClient::MsgControlChangeTimeFactorAck* control_change_time_factor_ack_;
  ::MsgsSimToClient::MsgControlDatetimeChangeAck* control_date_time_change_ack_;
  ::MsgsSimToClient::MsgControlCheckPointSaveEnd* control_checkpoint_save_end_;
  ::MsgsSimToClient::MsgFormationCreation* formation_creation_;
  ::MsgsSimToClient::MsgPartyCreation* party_creation_;
  ::MsgsSimToClient::MsgAutomatCreation* automat_creation_;
  ::MsgsSimToClient::MsgAutomatAttributes* automat_attributes_;
  ::MsgsSimToClient::MsgUnitCreation* unit_creation_;
  ::MsgsSimToClient::MsgUnitAttributes* unit_attributes_;
  ::MsgsSimToClient::MsgUnitPathFind* unit_pathfind_;
  ::MsgsSimToClient::MsgUnitDestruction* unit_destruction_;
  ::MsgsSimToClient::MsgUnitEnvironmentType* unit_environment_type_;
  ::Common::MsgChangeDiplomacy* change_diplomacy_;
  ::Common::MsgUnitChangeSuperior* unit_change_superior_;
  ::Common::MsgAutomatChangeLogisticLinks* automat_change_logistic_links_;
  ::Common::MsgAutomatChangeKnowledgeGroup* automat_change_knowledge_group_;
  ::Common::MsgAutomatChangeSuperior* automat_change_superior_;
  ::MsgsSimToClient::MsgUnitKnowledgeCreation* unit_knowledge_creation_;
  ::MsgsSimToClient::MsgUnitKnowledgeUpdate* unit_knowledge_update_;
  ::MsgsSimToClient::MsgUnitKnowledgeDestruction* unit_knowledge_destruction_;
  ::MsgsSimToClient::MsgStartUnitFire* start_unit_fire_;
  ::MsgsSimToClient::MsgStopUnitFire* stop_unit_fire_;
  ::MsgsSimToClient::MsgStartCrowdFire* start_crowd_fire_;
  ::MsgsSimToClient::MsgStopCrowdFire* stop_crowd_fire_;
  ::MsgsSimToClient::MsgExplosion* explosion_;
  ::MsgsSimToClient::MsgStartFireEffect* start_fire_effect_;
  ::MsgsSimToClient::MsgStopFireEffect* stop_fire_effect_;
  ::MsgsSimToClient::MsgReport* report_;
  ::MsgsSimToClient::MsgInvalidateReport* invalidate_report_;
  ::MsgsSimToClient::MsgTrace* trace_;
  ::MsgsSimToClient::MsgDecisionalState* decisional_state_;
  ::MsgsSimToClient::MsgDebugPoints* debug_points_;
  ::MsgsSimToClient::MsgUnitVisionCones* unit_vision_cones_;
  ::MsgsSimToClient::MsgUnitDetection* unit_detection_;
  ::MsgsSimToClient::MsgObjectDetection* object_detection_;
  ::MsgsSimToClient::MsgCrowdConcentrationDetection* crowd_concentration_detection_;
  ::MsgsSimToClient::MsgCrowdFlowDetection* crowd_flow_detection_;
  ::Common::MsgUnitOrder* unit_order_;
  ::Common::MsgAutomatOrder* automat_order_;
  ::Common::MsgCrowdOrder* crowd_order_;
  ::MsgsSimToClient::MsgObjectCreation* object_creation_;
  ::MsgsSimToClient::MsgObjectDestruction* object_destruction_;
  ::MsgsSimToClient::MsgObjectUpdate* object_update_;
  ::MsgsSimToClient::MsgObjectKnowledgeCreation* object_knowledge_creation_;
  ::MsgsSimToClient::MsgObjectKnowledgeUpdate* object_knowledge_update_;
  ::MsgsSimToClient::MsgObjectKnowledgeDestruction* object_knowledge_destruction_;
  ::MsgsSimToClient::MsgLogMedicalHandlingCreation* log_medical_handling_creation_;
  ::MsgsSimToClient::MsgLogMedicalHandlingUpdate* log_medical_handling_update_;
  ::MsgsSimToClient::MsgLogMedicalHandlingDestruction* log_medical_handling_destruction_;
  ::MsgsSimToClient::MsgLogMedicalState* log_medical_state_;
  ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation* log_maintenance_handling_creation_;
  ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate* log_maintenance_handling_update_;
  ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction* log_maintenance_handling_destruction_;
  ::MsgsSimToClient::MsgLogMaintenanceState* log_maintenance_state_;
  ::MsgsSimToClient::MsgLogSupplyHandlingCreation* log_supply_handling_creation_;
  ::MsgsSimToClient::MsgLogSupplyHandlingUpdate* log_supply_handling_update_;
  ::MsgsSimToClient::MsgLogSupplyHandlingDestruction* log_supply_handling_destruction_;
  ::MsgsSimToClient::MsgLogSupplyState* log_supply_state_;
  ::MsgsSimToClient::MsgLogSupplyQuotas* log_supply_quotas_;
  ::MsgsSimToClient::MsgCrowdCreation* crowd_creation_;
  ::MsgsSimToClient::MsgCrowdUpdate* crowd_update_;
  ::MsgsSimToClient::MsgCrowdConcentrationCreation* crowd_concentration_creation_;
  ::MsgsSimToClient::MsgCrowdConcentrationDestruction* crowd_concentration_destruction_;
  ::MsgsSimToClient::MsgCrowdConcentrationUpdate* crowd_concentration_update_;
  ::MsgsSimToClient::MsgCrowdFlowCreation* crowd_flow_creation_;
  ::MsgsSimToClient::MsgCrowdFlowDestruction* crowd_flow_destruction_;
  ::MsgsSimToClient::MsgCrowdFlowUpdate* crowd_flow_update_;
  ::MsgsSimToClient::MsgCrowdKnowledgeCreation* crowd_knowledge_creation_;
  ::MsgsSimToClient::MsgCrowdKnowledgeUpdate* crowd_knowledge_update_;
  ::MsgsSimToClient::MsgCrowdKnowledgeDestruction* crowd_knowledge_destruction_;
  ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeCreation* crowd_concentration_knowledge_creation_;
  ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeDestruction* crowd_concentration_knowledge_destruction_;
  ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeUpdate* crowd_concentration_knowledge_update_;
  ::MsgsSimToClient::MsgCrowdFlowKnowledgeCreation* crowd_flow_knowledge_creation_;
  ::MsgsSimToClient::MsgCrowdFlowKnowledgeDestruction* crowd_flow_knowledge_destruction_;
  ::MsgsSimToClient::MsgCrowdFlowKnowledgeUpdate* crowd_flow_knowledge_update_;
  ::MsgsSimToClient::MsgFolkCreation* folk_creation_;
  ::MsgsSimToClient::MsgFolkGraphUpdate* folk_graph_update_;
  ::MsgsSimToClient::MsgControlGlobalWeatherAck* control_global_weather_ack_;
  ::MsgsSimToClient::MsgControlLocalWeatherAck* control_local_weather_ack_;
  ::MsgsSimToClient::MsgControlCheckPointSaveBegin* control_checkpoint_save_begin_;
  ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck* control_checkpoint_set_frequency_ack_;
  ::MsgsSimToClient::MsgControlCheckPointSaveNowAck* control_checkpoint_save_now_ack_;
  ::MsgsSimToClient::MsgControlSendCurrentStateBegin* control_send_current_state_begin_;
  ::MsgsSimToClient::MsgControlSendCurrentStateEnd* control_send_current_state_end_;
  ::MsgsSimToClient::MsgUrbanCreation* urban_creation_;
  ::MsgsSimToClient::MsgUrbanUpdate* urban_update_;
  ::MsgsSimToClient::MsgUrbanKnowledgeCreation* urban_knowledge_creation_;
  ::MsgsSimToClient::MsgUrbanKnowledgeUpdate* urban_knowledge_update_;
  ::MsgsSimToClient::MsgUrbanKnowledgeDestruction* urban_knowledge_destruction_;
  ::Common::StockResource* stock_resource_;
  ::MsgsSimToClient::MsgUrbanDetection* urban_detection_;
  ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck* knowledge_group_magic_action_ack_;
  ::MsgsSimToClient::MsgKnowledgeGroupCreation* knowledge_group_creation_;
  ::MsgsSimToClient::MsgKnowledgeGroupUpdate* knowledge_group_update_;
  ::MsgsSimToClient::MsgKnowledgeGroupCreationAck* knowledge_group_creation_ack_;
  ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck* knowledge_group_update_ack_;
  ::MsgsSimToClient::MsgKnowledgeGroupDestruction* knowledge_group_destruction_;
  ::MsgsSimToClient::MsgActionCreateFireOrderAck* action_create_fire_order_ack_;
  ::MsgsSimToClient::MsgControlGlobalWeather* control_global_weather_;
  ::MsgsSimToClient::MsgControlLocalWeatherCreation* control_local_weather_creation_;
  ::MsgsSimToClient::MsgControlLocalWeatherDestruction* control_local_weather_destruction_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(126 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgSimToClient_Content* default_instance_;
};
// -------------------------------------------------------------------

class MsgSimToClient : public ::google::protobuf::Message {
 public:
  MsgSimToClient();
  virtual ~MsgSimToClient();
  
  MsgSimToClient(const MsgSimToClient& from);
  
  inline MsgSimToClient& operator=(const MsgSimToClient& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgSimToClient& default_instance();
  void Swap(MsgSimToClient* other);
  
  // implements Message ----------------------------------------------
  
  MsgSimToClient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgSimToClient& from);
  void MergeFrom(const MsgSimToClient& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgSimToClient_Content Content;
  
  // accessors -------------------------------------------------------
  
  // optional int32 context = 1;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 1;
  inline ::google::protobuf::int32 context() const;
  inline void set_context(::google::protobuf::int32 value);
  
  // required .MsgsSimToClient.MsgSimToClient.Content message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgSimToClient_Content& message() const;
  inline ::MsgsSimToClient::MsgSimToClient_Content* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 context_;
  ::MsgsSimToClient::MsgSimToClient_Content* message_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgSimToClient* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// OrderAck

// -------------------------------------------------------------------

// MsgUnitOrderAck

// required .Common.UnitId tasker = 1;
inline bool MsgUnitOrderAck::has_tasker() const {
  return _has_bit(0);
}
inline void MsgUnitOrderAck::clear_tasker() {
  if (tasker_ != NULL) tasker_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitOrderAck::tasker() const {
  return tasker_ != NULL ? *tasker_ : *default_instance_->tasker_;
}
inline ::Common::UnitId* MsgUnitOrderAck::mutable_tasker() {
  _set_bit(0);
  if (tasker_ == NULL) tasker_ = new ::Common::UnitId;
  return tasker_;
}

// required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
inline bool MsgUnitOrderAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgUnitOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::OrderAck_ErrorCode MsgUnitOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::OrderAck_ErrorCode >(error_code_);
}
inline void MsgUnitOrderAck::set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::OrderAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgAutomatOrderAck

// required .Common.AutomatId tasker = 1;
inline bool MsgAutomatOrderAck::has_tasker() const {
  return _has_bit(0);
}
inline void MsgAutomatOrderAck::clear_tasker() {
  if (tasker_ != NULL) tasker_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgAutomatOrderAck::tasker() const {
  return tasker_ != NULL ? *tasker_ : *default_instance_->tasker_;
}
inline ::Common::AutomatId* MsgAutomatOrderAck::mutable_tasker() {
  _set_bit(0);
  if (tasker_ == NULL) tasker_ = new ::Common::AutomatId;
  return tasker_;
}

// required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
inline bool MsgAutomatOrderAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgAutomatOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::OrderAck_ErrorCode MsgAutomatOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::OrderAck_ErrorCode >(error_code_);
}
inline void MsgAutomatOrderAck::set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::OrderAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdOrderAck

// required .Common.CrowdId tasker = 1;
inline bool MsgCrowdOrderAck::has_tasker() const {
  return _has_bit(0);
}
inline void MsgCrowdOrderAck::clear_tasker() {
  if (tasker_ != NULL) tasker_->::Common::CrowdId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdId& MsgCrowdOrderAck::tasker() const {
  return tasker_ != NULL ? *tasker_ : *default_instance_->tasker_;
}
inline ::Common::CrowdId* MsgCrowdOrderAck::mutable_tasker() {
  _set_bit(0);
  if (tasker_ == NULL) tasker_ = new ::Common::CrowdId;
  return tasker_;
}

// required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
inline bool MsgCrowdOrderAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgCrowdOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::OrderAck_ErrorCode MsgCrowdOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::OrderAck_ErrorCode >(error_code_);
}
inline void MsgCrowdOrderAck::set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::OrderAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgFragOrderAck

// required .Common.Tasker tasker = 1;
inline bool MsgFragOrderAck::has_tasker() const {
  return _has_bit(0);
}
inline void MsgFragOrderAck::clear_tasker() {
  if (tasker_ != NULL) tasker_->::Common::Tasker::Clear();
  _clear_bit(0);
}
inline const ::Common::Tasker& MsgFragOrderAck::tasker() const {
  return tasker_ != NULL ? *tasker_ : *default_instance_->tasker_;
}
inline ::Common::Tasker* MsgFragOrderAck::mutable_tasker() {
  _set_bit(0);
  if (tasker_ == NULL) tasker_ = new ::Common::Tasker;
  return tasker_;
}

// required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
inline bool MsgFragOrderAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgFragOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::OrderAck_ErrorCode MsgFragOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::OrderAck_ErrorCode >(error_code_);
}
inline void MsgFragOrderAck::set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::OrderAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgSetAutomatModeAck

// required .Common.AutomatId automat = 1;
inline bool MsgSetAutomatModeAck::has_automat() const {
  return _has_bit(0);
}
inline void MsgSetAutomatModeAck::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgSetAutomatModeAck::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* MsgSetAutomatModeAck::mutable_automat() {
  _set_bit(0);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// required .MsgsSimToClient.MsgSetAutomatModeAck.ErrorCode error_code = 2;
inline bool MsgSetAutomatModeAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgSetAutomatModeAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode MsgSetAutomatModeAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode >(error_code_);
}
inline void MsgSetAutomatModeAck::set_error_code(::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// UnitActionAck

// -------------------------------------------------------------------

// MsgUnitCreationRequestAck

// required .MsgsSimToClient.UnitActionAck.ErrorCode error = 1;
inline bool MsgUnitCreationRequestAck::has_error() const {
  return _has_bit(0);
}
inline void MsgUnitCreationRequestAck::clear_error() {
  error_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::UnitActionAck_ErrorCode MsgUnitCreationRequestAck::error() const {
  return static_cast< ::MsgsSimToClient::UnitActionAck_ErrorCode >(error_);
}
inline void MsgUnitCreationRequestAck::set_error(::MsgsSimToClient::UnitActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::UnitActionAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_ = value;
}

// -------------------------------------------------------------------

// MsgMagicActionAck

// required .MsgsSimToClient.MsgMagicActionAck.ErrorCode error_code = 1;
inline bool MsgMagicActionAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgMagicActionAck_ErrorCode MsgMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgMagicActionAck_ErrorCode >(error_code_);
}
inline void MsgMagicActionAck::set_error_code(::MsgsSimToClient::MsgMagicActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgMagicActionAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgUnitMagicActionAck

// required .Common.UnitId unit = 1;
inline bool MsgUnitMagicActionAck::has_unit() const {
  return _has_bit(0);
}
inline void MsgUnitMagicActionAck::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitMagicActionAck::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitMagicActionAck::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required .MsgsSimToClient.UnitActionAck.ErrorCode error_code = 2;
inline bool MsgUnitMagicActionAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgUnitMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::UnitActionAck_ErrorCode MsgUnitMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::UnitActionAck_ErrorCode >(error_code_);
}
inline void MsgUnitMagicActionAck::set_error_code(::MsgsSimToClient::UnitActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::UnitActionAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgObjectMagicActionAck

// required .MsgsSimToClient.MsgObjectMagicActionAck.ErrorCode error_code = 1;
inline bool MsgObjectMagicActionAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgObjectMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode MsgObjectMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode >(error_code_);
}
inline void MsgObjectMagicActionAck::set_error_code(::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdMagicActionAck

// required .Common.CrowdId crowd = 1;
inline bool MsgCrowdMagicActionAck::has_crowd() const {
  return _has_bit(0);
}
inline void MsgCrowdMagicActionAck::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdId& MsgCrowdMagicActionAck::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdMagicActionAck::mutable_crowd() {
  _set_bit(0);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// required .MsgsSimToClient.MsgCrowdMagicActionAck.ErrorCode error_code = 2;
inline bool MsgCrowdMagicActionAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgCrowdMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::MsgCrowdMagicActionAck_ErrorCode MsgCrowdMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgCrowdMagicActionAck_ErrorCode >(error_code_);
}
inline void MsgCrowdMagicActionAck::set_error_code(::MsgsSimToClient::MsgCrowdMagicActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgCrowdMagicActionAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgChangeDiplomacyAck

// required .Common.PartyId party1 = 1;
inline bool MsgChangeDiplomacyAck::has_party1() const {
  return _has_bit(0);
}
inline void MsgChangeDiplomacyAck::clear_party1() {
  if (party1_ != NULL) party1_->::Common::PartyId::Clear();
  _clear_bit(0);
}
inline const ::Common::PartyId& MsgChangeDiplomacyAck::party1() const {
  return party1_ != NULL ? *party1_ : *default_instance_->party1_;
}
inline ::Common::PartyId* MsgChangeDiplomacyAck::mutable_party1() {
  _set_bit(0);
  if (party1_ == NULL) party1_ = new ::Common::PartyId;
  return party1_;
}

// required .Common.PartyId party2 = 2;
inline bool MsgChangeDiplomacyAck::has_party2() const {
  return _has_bit(1);
}
inline void MsgChangeDiplomacyAck::clear_party2() {
  if (party2_ != NULL) party2_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgChangeDiplomacyAck::party2() const {
  return party2_ != NULL ? *party2_ : *default_instance_->party2_;
}
inline ::Common::PartyId* MsgChangeDiplomacyAck::mutable_party2() {
  _set_bit(1);
  if (party2_ == NULL) party2_ = new ::Common::PartyId;
  return party2_;
}

// required .Common.EnumDiplomacy diplomatie = 3;
inline bool MsgChangeDiplomacyAck::has_diplomatie() const {
  return _has_bit(2);
}
inline void MsgChangeDiplomacyAck::clear_diplomatie() {
  diplomatie_ = 0;
  _clear_bit(2);
}
inline Common::EnumDiplomacy MsgChangeDiplomacyAck::diplomatie() const {
  return static_cast< Common::EnumDiplomacy >(diplomatie_);
}
inline void MsgChangeDiplomacyAck::set_diplomatie(Common::EnumDiplomacy value) {
  GOOGLE_DCHECK(Common::EnumDiplomacy_IsValid(value));
  _set_bit(2);
  diplomatie_ = value;
}

// required .MsgsSimToClient.MsgChangeDiplomacyAck.EnumChangeDiplomacyErrorCode error_code = 4;
inline bool MsgChangeDiplomacyAck::has_error_code() const {
  return _has_bit(3);
}
inline void MsgChangeDiplomacyAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(3);
}
inline ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode MsgChangeDiplomacyAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode >(error_code_);
}
inline void MsgChangeDiplomacyAck::set_error_code(::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_IsValid(value));
  _set_bit(3);
  error_code_ = value;
}

// -------------------------------------------------------------------

// HierarchyModificationAck

// -------------------------------------------------------------------

// MsgAutomatChangeKnowledgeGroupAck

// required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
inline bool MsgAutomatChangeKnowledgeGroupAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgAutomatChangeKnowledgeGroupAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode MsgAutomatChangeKnowledgeGroupAck::error_code() const {
  return static_cast< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode >(error_code_);
}
inline void MsgAutomatChangeKnowledgeGroupAck::set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::HierarchyModificationAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgAutomatChangeLogisticLinksAck

// required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
inline bool MsgAutomatChangeLogisticLinksAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgAutomatChangeLogisticLinksAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode MsgAutomatChangeLogisticLinksAck::error_code() const {
  return static_cast< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode >(error_code_);
}
inline void MsgAutomatChangeLogisticLinksAck::set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::HierarchyModificationAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgAutomatChangeSuperiorAck

// required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
inline bool MsgAutomatChangeSuperiorAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgAutomatChangeSuperiorAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode MsgAutomatChangeSuperiorAck::error_code() const {
  return static_cast< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode >(error_code_);
}
inline void MsgAutomatChangeSuperiorAck::set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::HierarchyModificationAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgUnitChangeSuperiorAck

// required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
inline bool MsgUnitChangeSuperiorAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgUnitChangeSuperiorAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode MsgUnitChangeSuperiorAck::error_code() const {
  return static_cast< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode >(error_code_);
}
inline void MsgUnitChangeSuperiorAck::set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::HierarchyModificationAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgLogSupplyPushFlowAck

// optional .MsgsSimToClient.MsgLogSupplyPushFlowAck.EnumLogSupplyPushFlow ack = 1;
inline bool MsgLogSupplyPushFlowAck::has_ack() const {
  return _has_bit(0);
}
inline void MsgLogSupplyPushFlowAck::clear_ack() {
  ack_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow MsgLogSupplyPushFlowAck::ack() const {
  return static_cast< ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow >(ack_);
}
inline void MsgLogSupplyPushFlowAck::set_ack(::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_IsValid(value));
  _set_bit(0);
  ack_ = value;
}

// -------------------------------------------------------------------

// MsgLogSupplyChangeQuotasAck

// optional .MsgsSimToClient.MsgLogSupplyChangeQuotasAck.LogSupplyChangeQuotas ack = 1;
inline bool MsgLogSupplyChangeQuotasAck::has_ack() const {
  return _has_bit(0);
}
inline void MsgLogSupplyChangeQuotasAck::clear_ack() {
  ack_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas MsgLogSupplyChangeQuotasAck::ack() const {
  return static_cast< ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas >(ack_);
}
inline void MsgLogSupplyChangeQuotasAck::set_ack(::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_IsValid(value));
  _set_bit(0);
  ack_ = value;
}

// -------------------------------------------------------------------

// MsgActionCreateFireOrderAck

// required .MsgsSimToClient.MsgActionCreateFireOrderAck.EnumActionCreateFireOrderErrorCode error_code = 2;
inline bool MsgActionCreateFireOrderAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgActionCreateFireOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode MsgActionCreateFireOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode >(error_code_);
}
inline void MsgActionCreateFireOrderAck::set_error_code(::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlInformation

// required int32 current_tick = 1;
inline bool MsgControlInformation::has_current_tick() const {
  return _has_bit(0);
}
inline void MsgControlInformation::clear_current_tick() {
  current_tick_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlInformation::current_tick() const {
  return current_tick_;
}
inline void MsgControlInformation::set_current_tick(::google::protobuf::int32 value) {
  _set_bit(0);
  current_tick_ = value;
}

// required .Common.MsgDateTime initial_date_time = 2;
inline bool MsgControlInformation::has_initial_date_time() const {
  return _has_bit(1);
}
inline void MsgControlInformation::clear_initial_date_time() {
  if (initial_date_time_ != NULL) initial_date_time_->::Common::MsgDateTime::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgDateTime& MsgControlInformation::initial_date_time() const {
  return initial_date_time_ != NULL ? *initial_date_time_ : *default_instance_->initial_date_time_;
}
inline ::Common::MsgDateTime* MsgControlInformation::mutable_initial_date_time() {
  _set_bit(1);
  if (initial_date_time_ == NULL) initial_date_time_ = new ::Common::MsgDateTime;
  return initial_date_time_;
}

// required .Common.MsgDateTime date_time = 3;
inline bool MsgControlInformation::has_date_time() const {
  return _has_bit(2);
}
inline void MsgControlInformation::clear_date_time() {
  if (date_time_ != NULL) date_time_->::Common::MsgDateTime::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgDateTime& MsgControlInformation::date_time() const {
  return date_time_ != NULL ? *date_time_ : *default_instance_->date_time_;
}
inline ::Common::MsgDateTime* MsgControlInformation::mutable_date_time() {
  _set_bit(2);
  if (date_time_ == NULL) date_time_ = new ::Common::MsgDateTime;
  return date_time_;
}

// required int32 tick_duration = 4;
inline bool MsgControlInformation::has_tick_duration() const {
  return _has_bit(3);
}
inline void MsgControlInformation::clear_tick_duration() {
  tick_duration_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgControlInformation::tick_duration() const {
  return tick_duration_;
}
inline void MsgControlInformation::set_tick_duration(::google::protobuf::int32 value) {
  _set_bit(3);
  tick_duration_ = value;
}

// required int32 time_factor = 5;
inline bool MsgControlInformation::has_time_factor() const {
  return _has_bit(4);
}
inline void MsgControlInformation::clear_time_factor() {
  time_factor_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgControlInformation::time_factor() const {
  return time_factor_;
}
inline void MsgControlInformation::set_time_factor(::google::protobuf::int32 value) {
  _set_bit(4);
  time_factor_ = value;
}

// required int32 checkpoint_frequency = 6;
inline bool MsgControlInformation::has_checkpoint_frequency() const {
  return _has_bit(5);
}
inline void MsgControlInformation::clear_checkpoint_frequency() {
  checkpoint_frequency_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgControlInformation::checkpoint_frequency() const {
  return checkpoint_frequency_;
}
inline void MsgControlInformation::set_checkpoint_frequency(::google::protobuf::int32 value) {
  _set_bit(5);
  checkpoint_frequency_ = value;
}

// required .Common.EnumSimulationState status = 7;
inline bool MsgControlInformation::has_status() const {
  return _has_bit(6);
}
inline void MsgControlInformation::clear_status() {
  status_ = 0;
  _clear_bit(6);
}
inline Common::EnumSimulationState MsgControlInformation::status() const {
  return static_cast< Common::EnumSimulationState >(status_);
}
inline void MsgControlInformation::set_status(Common::EnumSimulationState value) {
  GOOGLE_DCHECK(Common::EnumSimulationState_IsValid(value));
  _set_bit(6);
  status_ = value;
}

// required bool send_vision_cones = 8;
inline bool MsgControlInformation::has_send_vision_cones() const {
  return _has_bit(7);
}
inline void MsgControlInformation::clear_send_vision_cones() {
  send_vision_cones_ = false;
  _clear_bit(7);
}
inline bool MsgControlInformation::send_vision_cones() const {
  return send_vision_cones_;
}
inline void MsgControlInformation::set_send_vision_cones(bool value) {
  _set_bit(7);
  send_vision_cones_ = value;
}

// required bool profiling_enabled = 9;
inline bool MsgControlInformation::has_profiling_enabled() const {
  return _has_bit(8);
}
inline void MsgControlInformation::clear_profiling_enabled() {
  profiling_enabled_ = false;
  _clear_bit(8);
}
inline bool MsgControlInformation::profiling_enabled() const {
  return profiling_enabled_;
}
inline void MsgControlInformation::set_profiling_enabled(bool value) {
  _set_bit(8);
  profiling_enabled_ = value;
}

// -------------------------------------------------------------------

// MsgControlProfilingInformation

// required float perception = 1;
inline bool MsgControlProfilingInformation::has_perception() const {
  return _has_bit(0);
}
inline void MsgControlProfilingInformation::clear_perception() {
  perception_ = 0;
  _clear_bit(0);
}
inline float MsgControlProfilingInformation::perception() const {
  return perception_;
}
inline void MsgControlProfilingInformation::set_perception(float value) {
  _set_bit(0);
  perception_ = value;
}

// required float decision = 2;
inline bool MsgControlProfilingInformation::has_decision() const {
  return _has_bit(1);
}
inline void MsgControlProfilingInformation::clear_decision() {
  decision_ = 0;
  _clear_bit(1);
}
inline float MsgControlProfilingInformation::decision() const {
  return decision_;
}
inline void MsgControlProfilingInformation::set_decision(float value) {
  _set_bit(1);
  decision_ = value;
}

// required float action = 3;
inline bool MsgControlProfilingInformation::has_action() const {
  return _has_bit(2);
}
inline void MsgControlProfilingInformation::clear_action() {
  action_ = 0;
  _clear_bit(2);
}
inline float MsgControlProfilingInformation::action() const {
  return action_;
}
inline void MsgControlProfilingInformation::set_action(float value) {
  _set_bit(2);
  action_ = value;
}

// required float main_loop = 4;
inline bool MsgControlProfilingInformation::has_main_loop() const {
  return _has_bit(3);
}
inline void MsgControlProfilingInformation::clear_main_loop() {
  main_loop_ = 0;
  _clear_bit(3);
}
inline float MsgControlProfilingInformation::main_loop() const {
  return main_loop_;
}
inline void MsgControlProfilingInformation::set_main_loop(float value) {
  _set_bit(3);
  main_loop_ = value;
}

// -------------------------------------------------------------------

// MsgControlBeginTick

// required int32 current_tick = 1;
inline bool MsgControlBeginTick::has_current_tick() const {
  return _has_bit(0);
}
inline void MsgControlBeginTick::clear_current_tick() {
  current_tick_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlBeginTick::current_tick() const {
  return current_tick_;
}
inline void MsgControlBeginTick::set_current_tick(::google::protobuf::int32 value) {
  _set_bit(0);
  current_tick_ = value;
}

// required .Common.MsgDateTime date_time = 2;
inline bool MsgControlBeginTick::has_date_time() const {
  return _has_bit(1);
}
inline void MsgControlBeginTick::clear_date_time() {
  if (date_time_ != NULL) date_time_->::Common::MsgDateTime::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgDateTime& MsgControlBeginTick::date_time() const {
  return date_time_ != NULL ? *date_time_ : *default_instance_->date_time_;
}
inline ::Common::MsgDateTime* MsgControlBeginTick::mutable_date_time() {
  _set_bit(1);
  if (date_time_ == NULL) date_time_ = new ::Common::MsgDateTime;
  return date_time_;
}

// -------------------------------------------------------------------

// MsgControlEndTick

// required int32 current_tick = 1;
inline bool MsgControlEndTick::has_current_tick() const {
  return _has_bit(0);
}
inline void MsgControlEndTick::clear_current_tick() {
  current_tick_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlEndTick::current_tick() const {
  return current_tick_;
}
inline void MsgControlEndTick::set_current_tick(::google::protobuf::int32 value) {
  _set_bit(0);
  current_tick_ = value;
}

// required int32 tick_duration = 2;
inline bool MsgControlEndTick::has_tick_duration() const {
  return _has_bit(1);
}
inline void MsgControlEndTick::clear_tick_duration() {
  tick_duration_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgControlEndTick::tick_duration() const {
  return tick_duration_;
}
inline void MsgControlEndTick::set_tick_duration(::google::protobuf::int32 value) {
  _set_bit(1);
  tick_duration_ = value;
}

// required int32 long_pathfinds = 3;
inline bool MsgControlEndTick::has_long_pathfinds() const {
  return _has_bit(2);
}
inline void MsgControlEndTick::clear_long_pathfinds() {
  long_pathfinds_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgControlEndTick::long_pathfinds() const {
  return long_pathfinds_;
}
inline void MsgControlEndTick::set_long_pathfinds(::google::protobuf::int32 value) {
  _set_bit(2);
  long_pathfinds_ = value;
}

// required int32 short_pathfinds = 4;
inline bool MsgControlEndTick::has_short_pathfinds() const {
  return _has_bit(3);
}
inline void MsgControlEndTick::clear_short_pathfinds() {
  short_pathfinds_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgControlEndTick::short_pathfinds() const {
  return short_pathfinds_;
}
inline void MsgControlEndTick::set_short_pathfinds(::google::protobuf::int32 value) {
  _set_bit(3);
  short_pathfinds_ = value;
}

// required int32 memory = 5;
inline bool MsgControlEndTick::has_memory() const {
  return _has_bit(4);
}
inline void MsgControlEndTick::clear_memory() {
  memory_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgControlEndTick::memory() const {
  return memory_;
}
inline void MsgControlEndTick::set_memory(::google::protobuf::int32 value) {
  _set_bit(4);
  memory_ = value;
}

// required int32 virtual_memory = 6;
inline bool MsgControlEndTick::has_virtual_memory() const {
  return _has_bit(5);
}
inline void MsgControlEndTick::clear_virtual_memory() {
  virtual_memory_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgControlEndTick::virtual_memory() const {
  return virtual_memory_;
}
inline void MsgControlEndTick::set_virtual_memory(::google::protobuf::int32 value) {
  _set_bit(5);
  virtual_memory_ = value;
}

// -------------------------------------------------------------------

// ControlAck

// -------------------------------------------------------------------

// MsgControlDatetimeChangeAck

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
inline bool MsgControlDatetimeChangeAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgControlDatetimeChangeAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlDatetimeChangeAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlDatetimeChangeAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlChangeTimeFactorAck

// required int32 time_factor = 1;
inline bool MsgControlChangeTimeFactorAck::has_time_factor() const {
  return _has_bit(0);
}
inline void MsgControlChangeTimeFactorAck::clear_time_factor() {
  time_factor_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlChangeTimeFactorAck::time_factor() const {
  return time_factor_;
}
inline void MsgControlChangeTimeFactorAck::set_time_factor(::google::protobuf::int32 value) {
  _set_bit(0);
  time_factor_ = value;
}

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 2;
inline bool MsgControlChangeTimeFactorAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgControlChangeTimeFactorAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlChangeTimeFactorAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlChangeTimeFactorAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlStopAck

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
inline bool MsgControlStopAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgControlStopAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlStopAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlStopAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlPauseAck

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
inline bool MsgControlPauseAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgControlPauseAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlPauseAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlPauseAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlResumeAck

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
inline bool MsgControlResumeAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgControlResumeAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlResumeAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlResumeAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgPartyCreation

// required .Common.PartyId party = 1;
inline bool MsgPartyCreation::has_party() const {
  return _has_bit(0);
}
inline void MsgPartyCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(0);
}
inline const ::Common::PartyId& MsgPartyCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgPartyCreation::mutable_party() {
  _set_bit(0);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required string name = 2;
inline bool MsgPartyCreation::has_name() const {
  return _has_bit(1);
}
inline void MsgPartyCreation::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgPartyCreation::name() const {
  return *name_;
}
inline void MsgPartyCreation::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgPartyCreation::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgPartyCreation::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPartyCreation::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .Common.EnumDiplomacy type = 3;
inline bool MsgPartyCreation::has_type() const {
  return _has_bit(2);
}
inline void MsgPartyCreation::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline Common::EnumDiplomacy MsgPartyCreation::type() const {
  return static_cast< Common::EnumDiplomacy >(type_);
}
inline void MsgPartyCreation::set_type(Common::EnumDiplomacy value) {
  GOOGLE_DCHECK(Common::EnumDiplomacy_IsValid(value));
  _set_bit(2);
  type_ = value;
}

// -------------------------------------------------------------------

// MsgFormationCreation

// required .Common.FormationId formation = 1;
inline bool MsgFormationCreation::has_formation() const {
  return _has_bit(0);
}
inline void MsgFormationCreation::clear_formation() {
  if (formation_ != NULL) formation_->::Common::FormationId::Clear();
  _clear_bit(0);
}
inline const ::Common::FormationId& MsgFormationCreation::formation() const {
  return formation_ != NULL ? *formation_ : *default_instance_->formation_;
}
inline ::Common::FormationId* MsgFormationCreation::mutable_formation() {
  _set_bit(0);
  if (formation_ == NULL) formation_ = new ::Common::FormationId;
  return formation_;
}

// required .Common.PartyId party = 2;
inline bool MsgFormationCreation::has_party() const {
  return _has_bit(1);
}
inline void MsgFormationCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgFormationCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgFormationCreation::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.FormationId parent = 3;
inline bool MsgFormationCreation::has_parent() const {
  return _has_bit(2);
}
inline void MsgFormationCreation::clear_parent() {
  if (parent_ != NULL) parent_->::Common::FormationId::Clear();
  _clear_bit(2);
}
inline const ::Common::FormationId& MsgFormationCreation::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::Common::FormationId* MsgFormationCreation::mutable_parent() {
  _set_bit(2);
  if (parent_ == NULL) parent_ = new ::Common::FormationId;
  return parent_;
}

// required .Common.EnumNatureLevel level = 4;
inline bool MsgFormationCreation::has_level() const {
  return _has_bit(3);
}
inline void MsgFormationCreation::clear_level() {
  level_ = 0;
  _clear_bit(3);
}
inline Common::EnumNatureLevel MsgFormationCreation::level() const {
  return static_cast< Common::EnumNatureLevel >(level_);
}
inline void MsgFormationCreation::set_level(Common::EnumNatureLevel value) {
  GOOGLE_DCHECK(Common::EnumNatureLevel_IsValid(value));
  _set_bit(3);
  level_ = value;
}

// required string name = 5;
inline bool MsgFormationCreation::has_name() const {
  return _has_bit(4);
}
inline void MsgFormationCreation::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MsgFormationCreation::name() const {
  return *name_;
}
inline void MsgFormationCreation::set_name(const ::std::string& value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgFormationCreation::set_name(const char* value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgFormationCreation::set_name(const char* value, size_t size) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgFormationCreation::mutable_name() {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// MsgAutomatCreation

// required .Common.AutomatId automat = 1;
inline bool MsgAutomatCreation::has_automat() const {
  return _has_bit(0);
}
inline void MsgAutomatCreation::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgAutomatCreation::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* MsgAutomatCreation::mutable_automat() {
  _set_bit(0);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// required .Common.AutomatType type = 2;
inline bool MsgAutomatCreation::has_type() const {
  return _has_bit(1);
}
inline void MsgAutomatCreation::clear_type() {
  if (type_ != NULL) type_->::Common::AutomatType::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatType& MsgAutomatCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::AutomatType* MsgAutomatCreation::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::AutomatType;
  return type_;
}

// required string nom = 3;
inline bool MsgAutomatCreation::has_nom() const {
  return _has_bit(2);
}
inline void MsgAutomatCreation::clear_nom() {
  if (nom_ != &_default_nom_) {
    nom_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgAutomatCreation::nom() const {
  return *nom_;
}
inline void MsgAutomatCreation::set_nom(const ::std::string& value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgAutomatCreation::set_nom(const char* value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgAutomatCreation::set_nom(const char* value, size_t size) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgAutomatCreation::mutable_nom() {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  return nom_;
}

// required .Common.ParentEntity parent = 4;
inline bool MsgAutomatCreation::has_parent() const {
  return _has_bit(3);
}
inline void MsgAutomatCreation::clear_parent() {
  if (parent_ != NULL) parent_->::Common::ParentEntity::Clear();
  _clear_bit(3);
}
inline const ::Common::ParentEntity& MsgAutomatCreation::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::Common::ParentEntity* MsgAutomatCreation::mutable_parent() {
  _set_bit(3);
  if (parent_ == NULL) parent_ = new ::Common::ParentEntity;
  return parent_;
}

// required .Common.PartyId party = 5;
inline bool MsgAutomatCreation::has_party() const {
  return _has_bit(4);
}
inline void MsgAutomatCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(4);
}
inline const ::Common::PartyId& MsgAutomatCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgAutomatCreation::mutable_party() {
  _set_bit(4);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.KnowledgeGroupId knowledge_group = 6;
inline bool MsgAutomatCreation::has_knowledge_group() const {
  return _has_bit(5);
}
inline void MsgAutomatCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(5);
}
inline const ::Common::KnowledgeGroupId& MsgAutomatCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgAutomatCreation::mutable_knowledge_group() {
  _set_bit(5);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// RulesOfEngagement

// -------------------------------------------------------------------

// ForceRatio

// -------------------------------------------------------------------

// MsgAutomatAttributes

// required .Common.AutomatId automat = 1;
inline bool MsgAutomatAttributes::has_automat() const {
  return _has_bit(0);
}
inline void MsgAutomatAttributes::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgAutomatAttributes::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* MsgAutomatAttributes::mutable_automat() {
  _set_bit(0);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// optional .Common.EnumAutomatMode etat_automate = 2;
inline bool MsgAutomatAttributes::has_etat_automate() const {
  return _has_bit(1);
}
inline void MsgAutomatAttributes::clear_etat_automate() {
  etat_automate_ = 0;
  _clear_bit(1);
}
inline Common::EnumAutomatMode MsgAutomatAttributes::etat_automate() const {
  return static_cast< Common::EnumAutomatMode >(etat_automate_);
}
inline void MsgAutomatAttributes::set_etat_automate(Common::EnumAutomatMode value) {
  GOOGLE_DCHECK(Common::EnumAutomatMode_IsValid(value));
  _set_bit(1);
  etat_automate_ = value;
}

// optional .MsgsSimToClient.ForceRatio.Value rapport_de_force = 3;
inline bool MsgAutomatAttributes::has_rapport_de_force() const {
  return _has_bit(2);
}
inline void MsgAutomatAttributes::clear_rapport_de_force() {
  rapport_de_force_ = 0;
  _clear_bit(2);
}
inline ::MsgsSimToClient::ForceRatio_Value MsgAutomatAttributes::rapport_de_force() const {
  return static_cast< ::MsgsSimToClient::ForceRatio_Value >(rapport_de_force_);
}
inline void MsgAutomatAttributes::set_rapport_de_force(::MsgsSimToClient::ForceRatio_Value value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ForceRatio_Value_IsValid(value));
  _set_bit(2);
  rapport_de_force_ = value;
}

// optional .Common.EnumMeetingEngagementStatus combat_de_rencontre = 4;
inline bool MsgAutomatAttributes::has_combat_de_rencontre() const {
  return _has_bit(3);
}
inline void MsgAutomatAttributes::clear_combat_de_rencontre() {
  combat_de_rencontre_ = 0;
  _clear_bit(3);
}
inline Common::EnumMeetingEngagementStatus MsgAutomatAttributes::combat_de_rencontre() const {
  return static_cast< Common::EnumMeetingEngagementStatus >(combat_de_rencontre_);
}
inline void MsgAutomatAttributes::set_combat_de_rencontre(Common::EnumMeetingEngagementStatus value) {
  GOOGLE_DCHECK(Common::EnumMeetingEngagementStatus_IsValid(value));
  _set_bit(3);
  combat_de_rencontre_ = value;
}

// optional .Common.EnumOperationalStatus etat_operationnel = 5;
inline bool MsgAutomatAttributes::has_etat_operationnel() const {
  return _has_bit(4);
}
inline void MsgAutomatAttributes::clear_etat_operationnel() {
  etat_operationnel_ = 0;
  _clear_bit(4);
}
inline Common::EnumOperationalStatus MsgAutomatAttributes::etat_operationnel() const {
  return static_cast< Common::EnumOperationalStatus >(etat_operationnel_);
}
inline void MsgAutomatAttributes::set_etat_operationnel(Common::EnumOperationalStatus value) {
  GOOGLE_DCHECK(Common::EnumOperationalStatus_IsValid(value));
  _set_bit(4);
  etat_operationnel_ = value;
}

// optional .MsgsSimToClient.RulesOfEngagement.Value roe = 6;
inline bool MsgAutomatAttributes::has_roe() const {
  return _has_bit(5);
}
inline void MsgAutomatAttributes::clear_roe() {
  roe_ = 0;
  _clear_bit(5);
}
inline ::MsgsSimToClient::RulesOfEngagement_Value MsgAutomatAttributes::roe() const {
  return static_cast< ::MsgsSimToClient::RulesOfEngagement_Value >(roe_);
}
inline void MsgAutomatAttributes::set_roe(::MsgsSimToClient::RulesOfEngagement_Value value) {
  GOOGLE_DCHECK(::MsgsSimToClient::RulesOfEngagement_Value_IsValid(value));
  _set_bit(5);
  roe_ = value;
}

// -------------------------------------------------------------------

// MsgUnitCreation

// required .Common.UnitId unit = 1;
inline bool MsgUnitCreation::has_unit() const {
  return _has_bit(0);
}
inline void MsgUnitCreation::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitCreation::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitCreation::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required .Common.UnitType type = 2;
inline bool MsgUnitCreation::has_type() const {
  return _has_bit(1);
}
inline void MsgUnitCreation::clear_type() {
  if (type_ != NULL) type_->::Common::UnitType::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitType& MsgUnitCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::UnitType* MsgUnitCreation::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::UnitType;
  return type_;
}

// required string nom = 3;
inline bool MsgUnitCreation::has_nom() const {
  return _has_bit(2);
}
inline void MsgUnitCreation::clear_nom() {
  if (nom_ != &_default_nom_) {
    nom_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgUnitCreation::nom() const {
  return *nom_;
}
inline void MsgUnitCreation::set_nom(const ::std::string& value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgUnitCreation::set_nom(const char* value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgUnitCreation::set_nom(const char* value, size_t size) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgUnitCreation::mutable_nom() {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  return nom_;
}

// required .Common.AutomatId automat = 4;
inline bool MsgUnitCreation::has_automat() const {
  return _has_bit(3);
}
inline void MsgUnitCreation::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(3);
}
inline const ::Common::AutomatId& MsgUnitCreation::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* MsgUnitCreation::mutable_automat() {
  _set_bit(3);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// required bool pc = 5;
inline bool MsgUnitCreation::has_pc() const {
  return _has_bit(4);
}
inline void MsgUnitCreation::clear_pc() {
  pc_ = false;
  _clear_bit(4);
}
inline bool MsgUnitCreation::pc() const {
  return pc_;
}
inline void MsgUnitCreation::set_pc(bool value) {
  _set_bit(4);
  pc_ = value;
}

// -------------------------------------------------------------------

// BorrowedEquipments_BorrowedEquipment

// required .Common.UnitId owner = 1;
inline bool BorrowedEquipments_BorrowedEquipment::has_owner() const {
  return _has_bit(0);
}
inline void BorrowedEquipments_BorrowedEquipment::clear_owner() {
  if (owner_ != NULL) owner_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& BorrowedEquipments_BorrowedEquipment::owner() const {
  return owner_ != NULL ? *owner_ : *default_instance_->owner_;
}
inline ::Common::UnitId* BorrowedEquipments_BorrowedEquipment::mutable_owner() {
  _set_bit(0);
  if (owner_ == NULL) owner_ = new ::Common::UnitId;
  return owner_;
}

// required .Common.EquipmentType type = 2;
inline bool BorrowedEquipments_BorrowedEquipment::has_type() const {
  return _has_bit(1);
}
inline void BorrowedEquipments_BorrowedEquipment::clear_type() {
  if (type_ != NULL) type_->::Common::EquipmentType::Clear();
  _clear_bit(1);
}
inline const ::Common::EquipmentType& BorrowedEquipments_BorrowedEquipment::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::EquipmentType* BorrowedEquipments_BorrowedEquipment::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::EquipmentType;
  return type_;
}

// required int32 nombre = 3;
inline bool BorrowedEquipments_BorrowedEquipment::has_nombre() const {
  return _has_bit(2);
}
inline void BorrowedEquipments_BorrowedEquipment::clear_nombre() {
  nombre_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 BorrowedEquipments_BorrowedEquipment::nombre() const {
  return nombre_;
}
inline void BorrowedEquipments_BorrowedEquipment::set_nombre(::google::protobuf::int32 value) {
  _set_bit(2);
  nombre_ = value;
}

// -------------------------------------------------------------------

// BorrowedEquipments

// repeated .MsgsSimToClient.BorrowedEquipments.BorrowedEquipment elem = 1;
inline int BorrowedEquipments::elem_size() const {
  return elem_.size();
}
inline void BorrowedEquipments::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment >&
BorrowedEquipments::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment >*
BorrowedEquipments::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment& BorrowedEquipments::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment* BorrowedEquipments::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment* BorrowedEquipments::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// LentEquipments_LentEquipment

// required .Common.UnitId borrower = 1;
inline bool LentEquipments_LentEquipment::has_borrower() const {
  return _has_bit(0);
}
inline void LentEquipments_LentEquipment::clear_borrower() {
  if (borrower_ != NULL) borrower_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& LentEquipments_LentEquipment::borrower() const {
  return borrower_ != NULL ? *borrower_ : *default_instance_->borrower_;
}
inline ::Common::UnitId* LentEquipments_LentEquipment::mutable_borrower() {
  _set_bit(0);
  if (borrower_ == NULL) borrower_ = new ::Common::UnitId;
  return borrower_;
}

// required .Common.EquipmentType type = 2;
inline bool LentEquipments_LentEquipment::has_type() const {
  return _has_bit(1);
}
inline void LentEquipments_LentEquipment::clear_type() {
  if (type_ != NULL) type_->::Common::EquipmentType::Clear();
  _clear_bit(1);
}
inline const ::Common::EquipmentType& LentEquipments_LentEquipment::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::EquipmentType* LentEquipments_LentEquipment::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::EquipmentType;
  return type_;
}

// required int32 nombre = 3;
inline bool LentEquipments_LentEquipment::has_nombre() const {
  return _has_bit(2);
}
inline void LentEquipments_LentEquipment::clear_nombre() {
  nombre_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 LentEquipments_LentEquipment::nombre() const {
  return nombre_;
}
inline void LentEquipments_LentEquipment::set_nombre(::google::protobuf::int32 value) {
  _set_bit(2);
  nombre_ = value;
}

// -------------------------------------------------------------------

// LentEquipments

// repeated .MsgsSimToClient.LentEquipments.LentEquipment elem = 1;
inline int LentEquipments::elem_size() const {
  return elem_.size();
}
inline void LentEquipments::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment >&
LentEquipments::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment >*
LentEquipments::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::LentEquipments_LentEquipment& LentEquipments::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::LentEquipments_LentEquipment* LentEquipments::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::LentEquipments_LentEquipment* LentEquipments::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// ResourceDotations_ResourceDotation

// required .Common.ResourceType type = 1;
inline bool ResourceDotations_ResourceDotation::has_type() const {
  return _has_bit(0);
}
inline void ResourceDotations_ResourceDotation::clear_type() {
  if (type_ != NULL) type_->::Common::ResourceType::Clear();
  _clear_bit(0);
}
inline const ::Common::ResourceType& ResourceDotations_ResourceDotation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::ResourceType* ResourceDotations_ResourceDotation::mutable_type() {
  _set_bit(0);
  if (type_ == NULL) type_ = new ::Common::ResourceType;
  return type_;
}

// required int32 quantite_disponible = 2;
inline bool ResourceDotations_ResourceDotation::has_quantite_disponible() const {
  return _has_bit(1);
}
inline void ResourceDotations_ResourceDotation::clear_quantite_disponible() {
  quantite_disponible_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 ResourceDotations_ResourceDotation::quantite_disponible() const {
  return quantite_disponible_;
}
inline void ResourceDotations_ResourceDotation::set_quantite_disponible(::google::protobuf::int32 value) {
  _set_bit(1);
  quantite_disponible_ = value;
}

// -------------------------------------------------------------------

// ResourceDotations

// repeated .MsgsSimToClient.ResourceDotations.ResourceDotation elem = 1;
inline int ResourceDotations::elem_size() const {
  return elem_.size();
}
inline void ResourceDotations::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation >&
ResourceDotations::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation >*
ResourceDotations::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::ResourceDotations_ResourceDotation& ResourceDotations::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::ResourceDotations_ResourceDotation* ResourceDotations::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::ResourceDotations_ResourceDotation* ResourceDotations::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// EquipmentDotations_EquipmentDotation

// required .Common.EquipmentType type = 1;
inline bool EquipmentDotations_EquipmentDotation::has_type() const {
  return _has_bit(0);
}
inline void EquipmentDotations_EquipmentDotation::clear_type() {
  if (type_ != NULL) type_->::Common::EquipmentType::Clear();
  _clear_bit(0);
}
inline const ::Common::EquipmentType& EquipmentDotations_EquipmentDotation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::EquipmentType* EquipmentDotations_EquipmentDotation::mutable_type() {
  _set_bit(0);
  if (type_ == NULL) type_ = new ::Common::EquipmentType;
  return type_;
}

// required int32 nb_disponibles = 2;
inline bool EquipmentDotations_EquipmentDotation::has_nb_disponibles() const {
  return _has_bit(1);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_disponibles() {
  nb_disponibles_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_disponibles() const {
  return nb_disponibles_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_disponibles(::google::protobuf::int32 value) {
  _set_bit(1);
  nb_disponibles_ = value;
}

// required int32 nb_indisponibles = 3;
inline bool EquipmentDotations_EquipmentDotation::has_nb_indisponibles() const {
  return _has_bit(2);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_indisponibles() {
  nb_indisponibles_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_indisponibles() const {
  return nb_indisponibles_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_indisponibles(::google::protobuf::int32 value) {
  _set_bit(2);
  nb_indisponibles_ = value;
}

// required int32 nb_reparables = 4;
inline bool EquipmentDotations_EquipmentDotation::has_nb_reparables() const {
  return _has_bit(3);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_reparables() {
  nb_reparables_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_reparables() const {
  return nb_reparables_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_reparables(::google::protobuf::int32 value) {
  _set_bit(3);
  nb_reparables_ = value;
}

// required int32 nb_dans_chaine_maintenance = 5;
inline bool EquipmentDotations_EquipmentDotation::has_nb_dans_chaine_maintenance() const {
  return _has_bit(4);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_dans_chaine_maintenance() {
  nb_dans_chaine_maintenance_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_dans_chaine_maintenance() const {
  return nb_dans_chaine_maintenance_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_dans_chaine_maintenance(::google::protobuf::int32 value) {
  _set_bit(4);
  nb_dans_chaine_maintenance_ = value;
}

// required int32 nb_prisonniers = 6;
inline bool EquipmentDotations_EquipmentDotation::has_nb_prisonniers() const {
  return _has_bit(5);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_prisonniers() {
  nb_prisonniers_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_prisonniers() const {
  return nb_prisonniers_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_prisonniers(::google::protobuf::int32 value) {
  _set_bit(5);
  nb_prisonniers_ = value;
}

// -------------------------------------------------------------------

// EquipmentDotations

// repeated .MsgsSimToClient.EquipmentDotations.EquipmentDotation elem = 1;
inline int EquipmentDotations::elem_size() const {
  return elem_.size();
}
inline void EquipmentDotations::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation >&
EquipmentDotations::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation >*
EquipmentDotations::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::EquipmentDotations_EquipmentDotation& EquipmentDotations::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::EquipmentDotations_EquipmentDotation* EquipmentDotations::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::EquipmentDotations_EquipmentDotation* EquipmentDotations::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// HumanDotations_HumanDotation

// required .Common.EnumHumanRank rang = 1;
inline bool HumanDotations_HumanDotation::has_rang() const {
  return _has_bit(0);
}
inline void HumanDotations_HumanDotation::clear_rang() {
  rang_ = 0;
  _clear_bit(0);
}
inline Common::EnumHumanRank HumanDotations_HumanDotation::rang() const {
  return static_cast< Common::EnumHumanRank >(rang_);
}
inline void HumanDotations_HumanDotation::set_rang(Common::EnumHumanRank value) {
  GOOGLE_DCHECK(Common::EnumHumanRank_IsValid(value));
  _set_bit(0);
  rang_ = value;
}

// required int32 nb_total = 2;
inline bool HumanDotations_HumanDotation::has_nb_total() const {
  return _has_bit(1);
}
inline void HumanDotations_HumanDotation::clear_nb_total() {
  nb_total_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_total() const {
  return nb_total_;
}
inline void HumanDotations_HumanDotation::set_nb_total(::google::protobuf::int32 value) {
  _set_bit(1);
  nb_total_ = value;
}

// required int32 nb_operationnels = 3;
inline bool HumanDotations_HumanDotation::has_nb_operationnels() const {
  return _has_bit(2);
}
inline void HumanDotations_HumanDotation::clear_nb_operationnels() {
  nb_operationnels_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_operationnels() const {
  return nb_operationnels_;
}
inline void HumanDotations_HumanDotation::set_nb_operationnels(::google::protobuf::int32 value) {
  _set_bit(2);
  nb_operationnels_ = value;
}

// required int32 nb_morts = 4;
inline bool HumanDotations_HumanDotation::has_nb_morts() const {
  return _has_bit(3);
}
inline void HumanDotations_HumanDotation::clear_nb_morts() {
  nb_morts_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_morts() const {
  return nb_morts_;
}
inline void HumanDotations_HumanDotation::set_nb_morts(::google::protobuf::int32 value) {
  _set_bit(3);
  nb_morts_ = value;
}

// required int32 nb_blesses = 5;
inline bool HumanDotations_HumanDotation::has_nb_blesses() const {
  return _has_bit(4);
}
inline void HumanDotations_HumanDotation::clear_nb_blesses() {
  nb_blesses_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_blesses() const {
  return nb_blesses_;
}
inline void HumanDotations_HumanDotation::set_nb_blesses(::google::protobuf::int32 value) {
  _set_bit(4);
  nb_blesses_ = value;
}

// required int32 nb_blesses_mentaux = 6;
inline bool HumanDotations_HumanDotation::has_nb_blesses_mentaux() const {
  return _has_bit(5);
}
inline void HumanDotations_HumanDotation::clear_nb_blesses_mentaux() {
  nb_blesses_mentaux_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_blesses_mentaux() const {
  return nb_blesses_mentaux_;
}
inline void HumanDotations_HumanDotation::set_nb_blesses_mentaux(::google::protobuf::int32 value) {
  _set_bit(5);
  nb_blesses_mentaux_ = value;
}

// required int32 nb_contamines_nbc = 7;
inline bool HumanDotations_HumanDotation::has_nb_contamines_nbc() const {
  return _has_bit(6);
}
inline void HumanDotations_HumanDotation::clear_nb_contamines_nbc() {
  nb_contamines_nbc_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_contamines_nbc() const {
  return nb_contamines_nbc_;
}
inline void HumanDotations_HumanDotation::set_nb_contamines_nbc(::google::protobuf::int32 value) {
  _set_bit(6);
  nb_contamines_nbc_ = value;
}

// required int32 nb_dans_chaine_sante = 8;
inline bool HumanDotations_HumanDotation::has_nb_dans_chaine_sante() const {
  return _has_bit(7);
}
inline void HumanDotations_HumanDotation::clear_nb_dans_chaine_sante() {
  nb_dans_chaine_sante_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_dans_chaine_sante() const {
  return nb_dans_chaine_sante_;
}
inline void HumanDotations_HumanDotation::set_nb_dans_chaine_sante(::google::protobuf::int32 value) {
  _set_bit(7);
  nb_dans_chaine_sante_ = value;
}

// required int32 nb_utilises_pour_maintenance = 9;
inline bool HumanDotations_HumanDotation::has_nb_utilises_pour_maintenance() const {
  return _has_bit(8);
}
inline void HumanDotations_HumanDotation::clear_nb_utilises_pour_maintenance() {
  nb_utilises_pour_maintenance_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_utilises_pour_maintenance() const {
  return nb_utilises_pour_maintenance_;
}
inline void HumanDotations_HumanDotation::set_nb_utilises_pour_maintenance(::google::protobuf::int32 value) {
  _set_bit(8);
  nb_utilises_pour_maintenance_ = value;
}

// -------------------------------------------------------------------

// HumanDotations

// repeated .MsgsSimToClient.HumanDotations.HumanDotation elem = 1;
inline int HumanDotations::elem_size() const {
  return elem_.size();
}
inline void HumanDotations::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation >&
HumanDotations::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation >*
HumanDotations::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::HumanDotations_HumanDotation& HumanDotations::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::HumanDotations_HumanDotation* HumanDotations::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::HumanDotations_HumanDotation* HumanDotations::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// ContaminationState

// optional int32 percentage = 1;
inline bool ContaminationState::has_percentage() const {
  return _has_bit(0);
}
inline void ContaminationState::clear_percentage() {
  percentage_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ContaminationState::percentage() const {
  return percentage_;
}
inline void ContaminationState::set_percentage(::google::protobuf::int32 value) {
  _set_bit(0);
  percentage_ = value;
}

// optional float quantity = 2;
inline bool ContaminationState::has_quantity() const {
  return _has_bit(1);
}
inline void ContaminationState::clear_quantity() {
  quantity_ = 0;
  _clear_bit(1);
}
inline float ContaminationState::quantity() const {
  return quantity_;
}
inline void ContaminationState::set_quantity(float value) {
  _set_bit(1);
  quantity_ = value;
}

// -------------------------------------------------------------------

// NBCAgents

// repeated .Common.NBCAgentType elem = 1;
inline int NBCAgents::elem_size() const {
  return elem_.size();
}
inline void NBCAgents::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType >&
NBCAgents::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType >*
NBCAgents::mutable_elem() {
  return &elem_;
}
inline const ::Common::NBCAgentType& NBCAgents::elem(int index) const {
  return elem_.Get(index);
}
inline ::Common::NBCAgentType* NBCAgents::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::Common::NBCAgentType* NBCAgents::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// Communication

// optional bool jammed = 1;
inline bool Communication::has_jammed() const {
  return _has_bit(0);
}
inline void Communication::clear_jammed() {
  jammed_ = false;
  _clear_bit(0);
}
inline bool Communication::jammed() const {
  return jammed_;
}
inline void Communication::set_jammed(bool value) {
  _set_bit(0);
  jammed_ = value;
}

// optional .Common.KnowledgeGroupId knowledge_group = 2;
inline bool Communication::has_knowledge_group() const {
  return _has_bit(1);
}
inline void Communication::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& Communication::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* Communication::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgUnitAttributes

// required .Common.UnitId unit = 1;
inline bool MsgUnitAttributes::has_unit() const {
  return _has_bit(0);
}
inline void MsgUnitAttributes::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitAttributes::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitAttributes::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// optional .MsgsSimToClient.HumanDotations dotation_eff_personnel = 2;
inline bool MsgUnitAttributes::has_dotation_eff_personnel() const {
  return _has_bit(1);
}
inline void MsgUnitAttributes::clear_dotation_eff_personnel() {
  if (dotation_eff_personnel_ != NULL) dotation_eff_personnel_->::MsgsSimToClient::HumanDotations::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::HumanDotations& MsgUnitAttributes::dotation_eff_personnel() const {
  return dotation_eff_personnel_ != NULL ? *dotation_eff_personnel_ : *default_instance_->dotation_eff_personnel_;
}
inline ::MsgsSimToClient::HumanDotations* MsgUnitAttributes::mutable_dotation_eff_personnel() {
  _set_bit(1);
  if (dotation_eff_personnel_ == NULL) dotation_eff_personnel_ = new ::MsgsSimToClient::HumanDotations;
  return dotation_eff_personnel_;
}

// optional .MsgsSimToClient.EquipmentDotations dotation_eff_materiel = 3;
inline bool MsgUnitAttributes::has_dotation_eff_materiel() const {
  return _has_bit(2);
}
inline void MsgUnitAttributes::clear_dotation_eff_materiel() {
  if (dotation_eff_materiel_ != NULL) dotation_eff_materiel_->::MsgsSimToClient::EquipmentDotations::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::EquipmentDotations& MsgUnitAttributes::dotation_eff_materiel() const {
  return dotation_eff_materiel_ != NULL ? *dotation_eff_materiel_ : *default_instance_->dotation_eff_materiel_;
}
inline ::MsgsSimToClient::EquipmentDotations* MsgUnitAttributes::mutable_dotation_eff_materiel() {
  _set_bit(2);
  if (dotation_eff_materiel_ == NULL) dotation_eff_materiel_ = new ::MsgsSimToClient::EquipmentDotations;
  return dotation_eff_materiel_;
}

// optional .MsgsSimToClient.ResourceDotations dotation_eff_ressource = 4;
inline bool MsgUnitAttributes::has_dotation_eff_ressource() const {
  return _has_bit(3);
}
inline void MsgUnitAttributes::clear_dotation_eff_ressource() {
  if (dotation_eff_ressource_ != NULL) dotation_eff_ressource_->::MsgsSimToClient::ResourceDotations::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::ResourceDotations& MsgUnitAttributes::dotation_eff_ressource() const {
  return dotation_eff_ressource_ != NULL ? *dotation_eff_ressource_ : *default_instance_->dotation_eff_ressource_;
}
inline ::MsgsSimToClient::ResourceDotations* MsgUnitAttributes::mutable_dotation_eff_ressource() {
  _set_bit(3);
  if (dotation_eff_ressource_ == NULL) dotation_eff_ressource_ = new ::MsgsSimToClient::ResourceDotations;
  return dotation_eff_ressource_;
}

// optional .MsgsSimToClient.LentEquipments equipements_pretes = 5;
inline bool MsgUnitAttributes::has_equipements_pretes() const {
  return _has_bit(4);
}
inline void MsgUnitAttributes::clear_equipements_pretes() {
  if (equipements_pretes_ != NULL) equipements_pretes_->::MsgsSimToClient::LentEquipments::Clear();
  _clear_bit(4);
}
inline const ::MsgsSimToClient::LentEquipments& MsgUnitAttributes::equipements_pretes() const {
  return equipements_pretes_ != NULL ? *equipements_pretes_ : *default_instance_->equipements_pretes_;
}
inline ::MsgsSimToClient::LentEquipments* MsgUnitAttributes::mutable_equipements_pretes() {
  _set_bit(4);
  if (equipements_pretes_ == NULL) equipements_pretes_ = new ::MsgsSimToClient::LentEquipments;
  return equipements_pretes_;
}

// optional .MsgsSimToClient.BorrowedEquipments equipements_empruntes = 6;
inline bool MsgUnitAttributes::has_equipements_empruntes() const {
  return _has_bit(5);
}
inline void MsgUnitAttributes::clear_equipements_empruntes() {
  if (equipements_empruntes_ != NULL) equipements_empruntes_->::MsgsSimToClient::BorrowedEquipments::Clear();
  _clear_bit(5);
}
inline const ::MsgsSimToClient::BorrowedEquipments& MsgUnitAttributes::equipements_empruntes() const {
  return equipements_empruntes_ != NULL ? *equipements_empruntes_ : *default_instance_->equipements_empruntes_;
}
inline ::MsgsSimToClient::BorrowedEquipments* MsgUnitAttributes::mutable_equipements_empruntes() {
  _set_bit(5);
  if (equipements_empruntes_ == NULL) equipements_empruntes_ = new ::MsgsSimToClient::BorrowedEquipments;
  return equipements_empruntes_;
}

// optional .Common.MsgCoordLatLong position = 7;
inline bool MsgUnitAttributes::has_position() const {
  return _has_bit(6);
}
inline void MsgUnitAttributes::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(6);
}
inline const ::Common::MsgCoordLatLong& MsgUnitAttributes::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgUnitAttributes::mutable_position() {
  _set_bit(6);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// optional .Common.MsgHeading direction = 8;
inline bool MsgUnitAttributes::has_direction() const {
  return _has_bit(7);
}
inline void MsgUnitAttributes::clear_direction() {
  if (direction_ != NULL) direction_->::Common::MsgHeading::Clear();
  _clear_bit(7);
}
inline const ::Common::MsgHeading& MsgUnitAttributes::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Common::MsgHeading* MsgUnitAttributes::mutable_direction() {
  _set_bit(7);
  if (direction_ == NULL) direction_ = new ::Common::MsgHeading;
  return direction_;
}

// optional int32 hauteur = 9;
inline bool MsgUnitAttributes::has_hauteur() const {
  return _has_bit(8);
}
inline void MsgUnitAttributes::clear_hauteur() {
  hauteur_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 MsgUnitAttributes::hauteur() const {
  return hauteur_;
}
inline void MsgUnitAttributes::set_hauteur(::google::protobuf::int32 value) {
  _set_bit(8);
  hauteur_ = value;
}

// optional int32 altitude = 10;
inline bool MsgUnitAttributes::has_altitude() const {
  return _has_bit(9);
}
inline void MsgUnitAttributes::clear_altitude() {
  altitude_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 MsgUnitAttributes::altitude() const {
  return altitude_;
}
inline void MsgUnitAttributes::set_altitude(::google::protobuf::int32 value) {
  _set_bit(9);
  altitude_ = value;
}

// optional int32 vitesse = 11;
inline bool MsgUnitAttributes::has_vitesse() const {
  return _has_bit(10);
}
inline void MsgUnitAttributes::clear_vitesse() {
  vitesse_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 MsgUnitAttributes::vitesse() const {
  return vitesse_;
}
inline void MsgUnitAttributes::set_vitesse(::google::protobuf::int32 value) {
  _set_bit(10);
  vitesse_ = value;
}

// optional int32 etat_operationnel_brut = 12;
inline bool MsgUnitAttributes::has_etat_operationnel_brut() const {
  return _has_bit(11);
}
inline void MsgUnitAttributes::clear_etat_operationnel_brut() {
  etat_operationnel_brut_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 MsgUnitAttributes::etat_operationnel_brut() const {
  return etat_operationnel_brut_;
}
inline void MsgUnitAttributes::set_etat_operationnel_brut(::google::protobuf::int32 value) {
  _set_bit(11);
  etat_operationnel_brut_ = value;
}

// optional .Common.UnitIdList reinforcements = 13;
inline bool MsgUnitAttributes::has_reinforcements() const {
  return _has_bit(12);
}
inline void MsgUnitAttributes::clear_reinforcements() {
  if (reinforcements_ != NULL) reinforcements_->::Common::UnitIdList::Clear();
  _clear_bit(12);
}
inline const ::Common::UnitIdList& MsgUnitAttributes::reinforcements() const {
  return reinforcements_ != NULL ? *reinforcements_ : *default_instance_->reinforcements_;
}
inline ::Common::UnitIdList* MsgUnitAttributes::mutable_reinforcements() {
  _set_bit(12);
  if (reinforcements_ == NULL) reinforcements_ = new ::Common::UnitIdList;
  return reinforcements_;
}

// optional .Common.UnitId reinforced_unit = 14;
inline bool MsgUnitAttributes::has_reinforced_unit() const {
  return _has_bit(13);
}
inline void MsgUnitAttributes::clear_reinforced_unit() {
  if (reinforced_unit_ != NULL) reinforced_unit_->::Common::UnitId::Clear();
  _clear_bit(13);
}
inline const ::Common::UnitId& MsgUnitAttributes::reinforced_unit() const {
  return reinforced_unit_ != NULL ? *reinforced_unit_ : *default_instance_->reinforced_unit_;
}
inline ::Common::UnitId* MsgUnitAttributes::mutable_reinforced_unit() {
  _set_bit(13);
  if (reinforced_unit_ == NULL) reinforced_unit_ = new ::Common::UnitId;
  return reinforced_unit_;
}

// optional bool mort = 15;
inline bool MsgUnitAttributes::has_mort() const {
  return _has_bit(14);
}
inline void MsgUnitAttributes::clear_mort() {
  mort_ = false;
  _clear_bit(14);
}
inline bool MsgUnitAttributes::mort() const {
  return mort_;
}
inline void MsgUnitAttributes::set_mort(bool value) {
  _set_bit(14);
  mort_ = value;
}

// optional bool neutralise = 16;
inline bool MsgUnitAttributes::has_neutralise() const {
  return _has_bit(15);
}
inline void MsgUnitAttributes::clear_neutralise() {
  neutralise_ = false;
  _clear_bit(15);
}
inline bool MsgUnitAttributes::neutralise() const {
  return neutralise_;
}
inline void MsgUnitAttributes::set_neutralise(bool value) {
  _set_bit(15);
  neutralise_ = value;
}

// optional bool mode_furtif_actif = 17;
inline bool MsgUnitAttributes::has_mode_furtif_actif() const {
  return _has_bit(16);
}
inline void MsgUnitAttributes::clear_mode_furtif_actif() {
  mode_furtif_actif_ = false;
  _clear_bit(16);
}
inline bool MsgUnitAttributes::mode_furtif_actif() const {
  return mode_furtif_actif_;
}
inline void MsgUnitAttributes::set_mode_furtif_actif(bool value) {
  _set_bit(16);
  mode_furtif_actif_ = value;
}

// optional bool embarque = 18;
inline bool MsgUnitAttributes::has_embarque() const {
  return _has_bit(17);
}
inline void MsgUnitAttributes::clear_embarque() {
  embarque_ = false;
  _clear_bit(17);
}
inline bool MsgUnitAttributes::embarque() const {
  return embarque_;
}
inline void MsgUnitAttributes::set_embarque(bool value) {
  _set_bit(17);
  embarque_ = value;
}

// optional bool transporteurs_disponibles = 19;
inline bool MsgUnitAttributes::has_transporteurs_disponibles() const {
  return _has_bit(18);
}
inline void MsgUnitAttributes::clear_transporteurs_disponibles() {
  transporteurs_disponibles_ = false;
  _clear_bit(18);
}
inline bool MsgUnitAttributes::transporteurs_disponibles() const {
  return transporteurs_disponibles_;
}
inline void MsgUnitAttributes::set_transporteurs_disponibles(bool value) {
  _set_bit(18);
  transporteurs_disponibles_ = value;
}

// optional .MsgsSimToClient.MsgUnitAttributes.Posture posture_old = 20;
inline bool MsgUnitAttributes::has_posture_old() const {
  return _has_bit(19);
}
inline void MsgUnitAttributes::clear_posture_old() {
  posture_old_ = 0;
  _clear_bit(19);
}
inline ::MsgsSimToClient::MsgUnitAttributes_Posture MsgUnitAttributes::posture_old() const {
  return static_cast< ::MsgsSimToClient::MsgUnitAttributes_Posture >(posture_old_);
}
inline void MsgUnitAttributes::set_posture_old(::MsgsSimToClient::MsgUnitAttributes_Posture value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUnitAttributes_Posture_IsValid(value));
  _set_bit(19);
  posture_old_ = value;
}

// optional .MsgsSimToClient.MsgUnitAttributes.Posture posture_new = 21;
inline bool MsgUnitAttributes::has_posture_new() const {
  return _has_bit(20);
}
inline void MsgUnitAttributes::clear_posture_new() {
  posture_new_ = 0;
  _clear_bit(20);
}
inline ::MsgsSimToClient::MsgUnitAttributes_Posture MsgUnitAttributes::posture_new() const {
  return static_cast< ::MsgsSimToClient::MsgUnitAttributes_Posture >(posture_new_);
}
inline void MsgUnitAttributes::set_posture_new(::MsgsSimToClient::MsgUnitAttributes_Posture value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUnitAttributes_Posture_IsValid(value));
  _set_bit(20);
  posture_new_ = value;
}

// optional int32 posture_pourcentage = 22;
inline bool MsgUnitAttributes::has_posture_pourcentage() const {
  return _has_bit(21);
}
inline void MsgUnitAttributes::clear_posture_pourcentage() {
  posture_pourcentage_ = 0;
  _clear_bit(21);
}
inline ::google::protobuf::int32 MsgUnitAttributes::posture_pourcentage() const {
  return posture_pourcentage_;
}
inline void MsgUnitAttributes::set_posture_pourcentage(::google::protobuf::int32 value) {
  _set_bit(21);
  posture_pourcentage_ = value;
}

// optional int32 etat_installation = 23;
inline bool MsgUnitAttributes::has_etat_installation() const {
  return _has_bit(22);
}
inline void MsgUnitAttributes::clear_etat_installation() {
  etat_installation_ = 0;
  _clear_bit(22);
}
inline ::google::protobuf::int32 MsgUnitAttributes::etat_installation() const {
  return etat_installation_;
}
inline void MsgUnitAttributes::set_etat_installation(::google::protobuf::int32 value) {
  _set_bit(22);
  etat_installation_ = value;
}

// optional bool en_tenue_de_protection_nbc = 24;
inline bool MsgUnitAttributes::has_en_tenue_de_protection_nbc() const {
  return _has_bit(23);
}
inline void MsgUnitAttributes::clear_en_tenue_de_protection_nbc() {
  en_tenue_de_protection_nbc_ = false;
  _clear_bit(23);
}
inline bool MsgUnitAttributes::en_tenue_de_protection_nbc() const {
  return en_tenue_de_protection_nbc_;
}
inline void MsgUnitAttributes::set_en_tenue_de_protection_nbc(bool value) {
  _set_bit(23);
  en_tenue_de_protection_nbc_ = value;
}

// optional .MsgsSimToClient.NBCAgents contamine_par_agents_nbc = 25;
inline bool MsgUnitAttributes::has_contamine_par_agents_nbc() const {
  return _has_bit(24);
}
inline void MsgUnitAttributes::clear_contamine_par_agents_nbc() {
  if (contamine_par_agents_nbc_ != NULL) contamine_par_agents_nbc_->::MsgsSimToClient::NBCAgents::Clear();
  _clear_bit(24);
}
inline const ::MsgsSimToClient::NBCAgents& MsgUnitAttributes::contamine_par_agents_nbc() const {
  return contamine_par_agents_nbc_ != NULL ? *contamine_par_agents_nbc_ : *default_instance_->contamine_par_agents_nbc_;
}
inline ::MsgsSimToClient::NBCAgents* MsgUnitAttributes::mutable_contamine_par_agents_nbc() {
  _set_bit(24);
  if (contamine_par_agents_nbc_ == NULL) contamine_par_agents_nbc_ = new ::MsgsSimToClient::NBCAgents;
  return contamine_par_agents_nbc_;
}

// optional .MsgsSimToClient.ContaminationState etat_contamination = 26;
inline bool MsgUnitAttributes::has_etat_contamination() const {
  return _has_bit(25);
}
inline void MsgUnitAttributes::clear_etat_contamination() {
  if (etat_contamination_ != NULL) etat_contamination_->::MsgsSimToClient::ContaminationState::Clear();
  _clear_bit(25);
}
inline const ::MsgsSimToClient::ContaminationState& MsgUnitAttributes::etat_contamination() const {
  return etat_contamination_ != NULL ? *etat_contamination_ : *default_instance_->etat_contamination_;
}
inline ::MsgsSimToClient::ContaminationState* MsgUnitAttributes::mutable_etat_contamination() {
  _set_bit(25);
  if (etat_contamination_ == NULL) etat_contamination_ = new ::MsgsSimToClient::ContaminationState;
  return etat_contamination_;
}

// optional .MsgsSimToClient.Communication communications = 27;
inline bool MsgUnitAttributes::has_communications() const {
  return _has_bit(26);
}
inline void MsgUnitAttributes::clear_communications() {
  if (communications_ != NULL) communications_->::MsgsSimToClient::Communication::Clear();
  _clear_bit(26);
}
inline const ::MsgsSimToClient::Communication& MsgUnitAttributes::communications() const {
  return communications_ != NULL ? *communications_ : *default_instance_->communications_;
}
inline ::MsgsSimToClient::Communication* MsgUnitAttributes::mutable_communications() {
  _set_bit(26);
  if (communications_ == NULL) communications_ = new ::MsgsSimToClient::Communication;
  return communications_;
}

// optional bool radio_emitter_disabled = 28;
inline bool MsgUnitAttributes::has_radio_emitter_disabled() const {
  return _has_bit(27);
}
inline void MsgUnitAttributes::clear_radio_emitter_disabled() {
  radio_emitter_disabled_ = false;
  _clear_bit(27);
}
inline bool MsgUnitAttributes::radio_emitter_disabled() const {
  return radio_emitter_disabled_;
}
inline void MsgUnitAttributes::set_radio_emitter_disabled(bool value) {
  _set_bit(27);
  radio_emitter_disabled_ = value;
}

// optional bool radio_receiver_disabled = 29;
inline bool MsgUnitAttributes::has_radio_receiver_disabled() const {
  return _has_bit(28);
}
inline void MsgUnitAttributes::clear_radio_receiver_disabled() {
  radio_receiver_disabled_ = false;
  _clear_bit(28);
}
inline bool MsgUnitAttributes::radio_receiver_disabled() const {
  return radio_receiver_disabled_;
}
inline void MsgUnitAttributes::set_radio_receiver_disabled(bool value) {
  _set_bit(28);
  radio_receiver_disabled_ = value;
}

// optional bool radar_actif = 30;
inline bool MsgUnitAttributes::has_radar_actif() const {
  return _has_bit(29);
}
inline void MsgUnitAttributes::clear_radar_actif() {
  radar_actif_ = false;
  _clear_bit(29);
}
inline bool MsgUnitAttributes::radar_actif() const {
  return radar_actif_;
}
inline void MsgUnitAttributes::set_radar_actif(bool value) {
  _set_bit(29);
  radar_actif_ = value;
}

// optional .Common.UnitIdList transported_units = 31;
inline bool MsgUnitAttributes::has_transported_units() const {
  return _has_bit(30);
}
inline void MsgUnitAttributes::clear_transported_units() {
  if (transported_units_ != NULL) transported_units_->::Common::UnitIdList::Clear();
  _clear_bit(30);
}
inline const ::Common::UnitIdList& MsgUnitAttributes::transported_units() const {
  return transported_units_ != NULL ? *transported_units_ : *default_instance_->transported_units_;
}
inline ::Common::UnitIdList* MsgUnitAttributes::mutable_transported_units() {
  _set_bit(30);
  if (transported_units_ == NULL) transported_units_ = new ::Common::UnitIdList;
  return transported_units_;
}

// optional .Common.UnitId transporting_unit = 32;
inline bool MsgUnitAttributes::has_transporting_unit() const {
  return _has_bit(31);
}
inline void MsgUnitAttributes::clear_transporting_unit() {
  if (transporting_unit_ != NULL) transporting_unit_->::Common::UnitId::Clear();
  _clear_bit(31);
}
inline const ::Common::UnitId& MsgUnitAttributes::transporting_unit() const {
  return transporting_unit_ != NULL ? *transporting_unit_ : *default_instance_->transporting_unit_;
}
inline ::Common::UnitId* MsgUnitAttributes::mutable_transporting_unit() {
  _set_bit(31);
  if (transporting_unit_ == NULL) transporting_unit_ = new ::Common::UnitId;
  return transporting_unit_;
}

// optional .MsgsSimToClient.ForceRatio.Value rapport_de_force = 33;
inline bool MsgUnitAttributes::has_rapport_de_force() const {
  return _has_bit(32);
}
inline void MsgUnitAttributes::clear_rapport_de_force() {
  rapport_de_force_ = 0;
  _clear_bit(32);
}
inline ::MsgsSimToClient::ForceRatio_Value MsgUnitAttributes::rapport_de_force() const {
  return static_cast< ::MsgsSimToClient::ForceRatio_Value >(rapport_de_force_);
}
inline void MsgUnitAttributes::set_rapport_de_force(::MsgsSimToClient::ForceRatio_Value value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ForceRatio_Value_IsValid(value));
  _set_bit(32);
  rapport_de_force_ = value;
}

// optional .Common.EnumMeetingEngagementStatus combat_de_rencontre = 34;
inline bool MsgUnitAttributes::has_combat_de_rencontre() const {
  return _has_bit(33);
}
inline void MsgUnitAttributes::clear_combat_de_rencontre() {
  combat_de_rencontre_ = 0;
  _clear_bit(33);
}
inline Common::EnumMeetingEngagementStatus MsgUnitAttributes::combat_de_rencontre() const {
  return static_cast< Common::EnumMeetingEngagementStatus >(combat_de_rencontre_);
}
inline void MsgUnitAttributes::set_combat_de_rencontre(Common::EnumMeetingEngagementStatus value) {
  GOOGLE_DCHECK(Common::EnumMeetingEngagementStatus_IsValid(value));
  _set_bit(33);
  combat_de_rencontre_ = value;
}

// optional .Common.EnumOperationalStatus etat_operationnel = 35;
inline bool MsgUnitAttributes::has_etat_operationnel() const {
  return _has_bit(34);
}
inline void MsgUnitAttributes::clear_etat_operationnel() {
  etat_operationnel_ = 0;
  _clear_bit(34);
}
inline Common::EnumOperationalStatus MsgUnitAttributes::etat_operationnel() const {
  return static_cast< Common::EnumOperationalStatus >(etat_operationnel_);
}
inline void MsgUnitAttributes::set_etat_operationnel(Common::EnumOperationalStatus value) {
  GOOGLE_DCHECK(Common::EnumOperationalStatus_IsValid(value));
  _set_bit(34);
  etat_operationnel_ = value;
}

// optional .MsgsSimToClient.MsgUnitAttributes.FireAvailability disponibilite_au_tir_indirect = 36;
inline bool MsgUnitAttributes::has_disponibilite_au_tir_indirect() const {
  return _has_bit(35);
}
inline void MsgUnitAttributes::clear_disponibilite_au_tir_indirect() {
  disponibilite_au_tir_indirect_ = 0;
  _clear_bit(35);
}
inline ::MsgsSimToClient::MsgUnitAttributes_FireAvailability MsgUnitAttributes::disponibilite_au_tir_indirect() const {
  return static_cast< ::MsgsSimToClient::MsgUnitAttributes_FireAvailability >(disponibilite_au_tir_indirect_);
}
inline void MsgUnitAttributes::set_disponibilite_au_tir_indirect(::MsgsSimToClient::MsgUnitAttributes_FireAvailability value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUnitAttributes_FireAvailability_IsValid(value));
  _set_bit(35);
  disponibilite_au_tir_indirect_ = value;
}

// optional .MsgsSimToClient.RulesOfEngagement.Value roe = 37;
inline bool MsgUnitAttributes::has_roe() const {
  return _has_bit(36);
}
inline void MsgUnitAttributes::clear_roe() {
  roe_ = 0;
  _clear_bit(36);
}
inline ::MsgsSimToClient::RulesOfEngagement_Value MsgUnitAttributes::roe() const {
  return static_cast< ::MsgsSimToClient::RulesOfEngagement_Value >(roe_);
}
inline void MsgUnitAttributes::set_roe(::MsgsSimToClient::RulesOfEngagement_Value value) {
  GOOGLE_DCHECK(::MsgsSimToClient::RulesOfEngagement_Value_IsValid(value));
  _set_bit(36);
  roe_ = value;
}

// optional .MsgsSimToClient.MsgUnitAttributes.CrowdRoe roe_crowd = 38;
inline bool MsgUnitAttributes::has_roe_crowd() const {
  return _has_bit(37);
}
inline void MsgUnitAttributes::clear_roe_crowd() {
  roe_crowd_ = 0;
  _clear_bit(37);
}
inline ::MsgsSimToClient::MsgUnitAttributes_CrowdRoe MsgUnitAttributes::roe_crowd() const {
  return static_cast< ::MsgsSimToClient::MsgUnitAttributes_CrowdRoe >(roe_crowd_);
}
inline void MsgUnitAttributes::set_roe_crowd(::MsgsSimToClient::MsgUnitAttributes_CrowdRoe value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUnitAttributes_CrowdRoe_IsValid(value));
  _set_bit(37);
  roe_crowd_ = value;
}

// optional .Common.EnumUnitTiredness fatigue = 39;
inline bool MsgUnitAttributes::has_fatigue() const {
  return _has_bit(38);
}
inline void MsgUnitAttributes::clear_fatigue() {
  fatigue_ = 0;
  _clear_bit(38);
}
inline Common::EnumUnitTiredness MsgUnitAttributes::fatigue() const {
  return static_cast< Common::EnumUnitTiredness >(fatigue_);
}
inline void MsgUnitAttributes::set_fatigue(Common::EnumUnitTiredness value) {
  GOOGLE_DCHECK(Common::EnumUnitTiredness_IsValid(value));
  _set_bit(38);
  fatigue_ = value;
}

// optional .Common.EnumUnitMorale moral = 40;
inline bool MsgUnitAttributes::has_moral() const {
  return _has_bit(39);
}
inline void MsgUnitAttributes::clear_moral() {
  moral_ = 0;
  _clear_bit(39);
}
inline Common::EnumUnitMorale MsgUnitAttributes::moral() const {
  return static_cast< Common::EnumUnitMorale >(moral_);
}
inline void MsgUnitAttributes::set_moral(Common::EnumUnitMorale value) {
  GOOGLE_DCHECK(Common::EnumUnitMorale_IsValid(value));
  _set_bit(39);
  moral_ = value;
}

// optional .Common.EnumUnitExperience experience = 41;
inline bool MsgUnitAttributes::has_experience() const {
  return _has_bit(40);
}
inline void MsgUnitAttributes::clear_experience() {
  experience_ = 0;
  _clear_bit(40);
}
inline Common::EnumUnitExperience MsgUnitAttributes::experience() const {
  return static_cast< Common::EnumUnitExperience >(experience_);
}
inline void MsgUnitAttributes::set_experience(Common::EnumUnitExperience value) {
  GOOGLE_DCHECK(Common::EnumUnitExperience_IsValid(value));
  _set_bit(40);
  experience_ = value;
}

// optional .Common.UnitId surrendered_unit = 42;
inline bool MsgUnitAttributes::has_surrendered_unit() const {
  return _has_bit(41);
}
inline void MsgUnitAttributes::clear_surrendered_unit() {
  if (surrendered_unit_ != NULL) surrendered_unit_->::Common::UnitId::Clear();
  _clear_bit(41);
}
inline const ::Common::UnitId& MsgUnitAttributes::surrendered_unit() const {
  return surrendered_unit_ != NULL ? *surrendered_unit_ : *default_instance_->surrendered_unit_;
}
inline ::Common::UnitId* MsgUnitAttributes::mutable_surrendered_unit() {
  _set_bit(41);
  if (surrendered_unit_ == NULL) surrendered_unit_ = new ::Common::UnitId;
  return surrendered_unit_;
}

// optional bool prisonnier = 43;
inline bool MsgUnitAttributes::has_prisonnier() const {
  return _has_bit(42);
}
inline void MsgUnitAttributes::clear_prisonnier() {
  prisonnier_ = false;
  _clear_bit(42);
}
inline bool MsgUnitAttributes::prisonnier() const {
  return prisonnier_;
}
inline void MsgUnitAttributes::set_prisonnier(bool value) {
  _set_bit(42);
  prisonnier_ = value;
}

// optional bool refugie_pris_en_compte = 44;
inline bool MsgUnitAttributes::has_refugie_pris_en_compte() const {
  return _has_bit(43);
}
inline void MsgUnitAttributes::clear_refugie_pris_en_compte() {
  refugie_pris_en_compte_ = false;
  _clear_bit(43);
}
inline bool MsgUnitAttributes::refugie_pris_en_compte() const {
  return refugie_pris_en_compte_;
}
inline void MsgUnitAttributes::set_refugie_pris_en_compte(bool value) {
  _set_bit(43);
  refugie_pris_en_compte_ = value;
}

// -------------------------------------------------------------------

// MsgUnitPathFind

// required .Common.UnitId unit = 1;
inline bool MsgUnitPathFind::has_unit() const {
  return _has_bit(0);
}
inline void MsgUnitPathFind::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitPathFind::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitPathFind::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required .Common.MsgPath itineraire = 2;
inline bool MsgUnitPathFind::has_itineraire() const {
  return _has_bit(1);
}
inline void MsgUnitPathFind::clear_itineraire() {
  if (itineraire_ != NULL) itineraire_->::Common::MsgPath::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgPath& MsgUnitPathFind::itineraire() const {
  return itineraire_ != NULL ? *itineraire_ : *default_instance_->itineraire_;
}
inline ::Common::MsgPath* MsgUnitPathFind::mutable_itineraire() {
  _set_bit(1);
  if (itineraire_ == NULL) itineraire_ = new ::Common::MsgPath;
  return itineraire_;
}

// -------------------------------------------------------------------

// MsgUnitDestruction

// required .Common.UnitId unit = 1;
inline bool MsgUnitDestruction::has_unit() const {
  return _has_bit(0);
}
inline void MsgUnitDestruction::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitDestruction::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitDestruction::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// -------------------------------------------------------------------

// MsgUnitEnvironmentType

// required .Common.UnitId unit = 1;
inline bool MsgUnitEnvironmentType::has_unit() const {
  return _has_bit(0);
}
inline void MsgUnitEnvironmentType::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitEnvironmentType::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitEnvironmentType::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required int32 area = 2;
inline bool MsgUnitEnvironmentType::has_area() const {
  return _has_bit(1);
}
inline void MsgUnitEnvironmentType::clear_area() {
  area_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgUnitEnvironmentType::area() const {
  return area_;
}
inline void MsgUnitEnvironmentType::set_area(::google::protobuf::int32 value) {
  _set_bit(1);
  area_ = value;
}

// required int32 left = 3;
inline bool MsgUnitEnvironmentType::has_left() const {
  return _has_bit(2);
}
inline void MsgUnitEnvironmentType::clear_left() {
  left_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgUnitEnvironmentType::left() const {
  return left_;
}
inline void MsgUnitEnvironmentType::set_left(::google::protobuf::int32 value) {
  _set_bit(2);
  left_ = value;
}

// required int32 right = 4;
inline bool MsgUnitEnvironmentType::has_right() const {
  return _has_bit(3);
}
inline void MsgUnitEnvironmentType::clear_right() {
  right_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgUnitEnvironmentType::right() const {
  return right_;
}
inline void MsgUnitEnvironmentType::set_right(::google::protobuf::int32 value) {
  _set_bit(3);
  right_ = value;
}

// required int32 linear = 5;
inline bool MsgUnitEnvironmentType::has_linear() const {
  return _has_bit(4);
}
inline void MsgUnitEnvironmentType::clear_linear() {
  linear_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgUnitEnvironmentType::linear() const {
  return linear_;
}
inline void MsgUnitEnvironmentType::set_linear(::google::protobuf::int32 value) {
  _set_bit(4);
  linear_ = value;
}

// -------------------------------------------------------------------

// MsgUnitKnowledgeCreation

// required .Common.UnitKnowledgeId knowledge = 1;
inline bool MsgUnitKnowledgeCreation::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgUnitKnowledgeCreation::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::UnitKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitKnowledgeId& MsgUnitKnowledgeCreation::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::UnitKnowledgeId* MsgUnitKnowledgeCreation::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::UnitKnowledgeId;
  return knowledge_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgUnitKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgUnitKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgUnitKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgUnitKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .Common.UnitId unit = 3;
inline bool MsgUnitKnowledgeCreation::has_unit() const {
  return _has_bit(2);
}
inline void MsgUnitKnowledgeCreation::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(2);
}
inline const ::Common::UnitId& MsgUnitKnowledgeCreation::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitKnowledgeCreation::mutable_unit() {
  _set_bit(2);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required .Common.UnitType type = 4;
inline bool MsgUnitKnowledgeCreation::has_type() const {
  return _has_bit(3);
}
inline void MsgUnitKnowledgeCreation::clear_type() {
  if (type_ != NULL) type_->::Common::UnitType::Clear();
  _clear_bit(3);
}
inline const ::Common::UnitType& MsgUnitKnowledgeCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::UnitType* MsgUnitKnowledgeCreation::mutable_type() {
  _set_bit(3);
  if (type_ == NULL) type_ = new ::Common::UnitType;
  return type_;
}

// -------------------------------------------------------------------

// AutomatPerception

// required .Common.AutomatId automat = 1;
inline bool AutomatPerception::has_automat() const {
  return _has_bit(0);
}
inline void AutomatPerception::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& AutomatPerception::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* AutomatPerception::mutable_automat() {
  _set_bit(0);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// required .MsgsSimToClient.EnumUnitIdentificationLevel identification_level = 2;
inline bool AutomatPerception::has_identification_level() const {
  return _has_bit(1);
}
inline void AutomatPerception::clear_identification_level() {
  identification_level_ = 0;
  _clear_bit(1);
}
inline MsgsSimToClient::EnumUnitIdentificationLevel AutomatPerception::identification_level() const {
  return static_cast< MsgsSimToClient::EnumUnitIdentificationLevel >(identification_level_);
}
inline void AutomatPerception::set_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumUnitIdentificationLevel_IsValid(value));
  _set_bit(1);
  identification_level_ = value;
}

// -------------------------------------------------------------------

// SeqOfAutomatPerception

// repeated .MsgsSimToClient.AutomatPerception elem = 1;
inline int SeqOfAutomatPerception::elem_size() const {
  return elem_.size();
}
inline void SeqOfAutomatPerception::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception >&
SeqOfAutomatPerception::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception >*
SeqOfAutomatPerception::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::AutomatPerception& SeqOfAutomatPerception::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::AutomatPerception* SeqOfAutomatPerception::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::AutomatPerception* SeqOfAutomatPerception::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgUnitKnowledgeUpdate

// required .Common.UnitKnowledgeId knowledge = 1;
inline bool MsgUnitKnowledgeUpdate::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgUnitKnowledgeUpdate::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::UnitKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitKnowledgeId& MsgUnitKnowledgeUpdate::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::UnitKnowledgeId* MsgUnitKnowledgeUpdate::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::UnitKnowledgeId;
  return knowledge_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgUnitKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgUnitKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgUnitKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgUnitKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional int32 pertinence = 3;
inline bool MsgUnitKnowledgeUpdate::has_pertinence() const {
  return _has_bit(2);
}
inline void MsgUnitKnowledgeUpdate::clear_pertinence() {
  pertinence_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgUnitKnowledgeUpdate::pertinence() const {
  return pertinence_;
}
inline void MsgUnitKnowledgeUpdate::set_pertinence(::google::protobuf::int32 value) {
  _set_bit(2);
  pertinence_ = value;
}

// optional .MsgsSimToClient.EnumUnitIdentificationLevel identification_level = 4;
inline bool MsgUnitKnowledgeUpdate::has_identification_level() const {
  return _has_bit(3);
}
inline void MsgUnitKnowledgeUpdate::clear_identification_level() {
  identification_level_ = 0;
  _clear_bit(3);
}
inline MsgsSimToClient::EnumUnitIdentificationLevel MsgUnitKnowledgeUpdate::identification_level() const {
  return static_cast< MsgsSimToClient::EnumUnitIdentificationLevel >(identification_level_);
}
inline void MsgUnitKnowledgeUpdate::set_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumUnitIdentificationLevel_IsValid(value));
  _set_bit(3);
  identification_level_ = value;
}

// optional .MsgsSimToClient.EnumUnitIdentificationLevel max_identification_level = 5;
inline bool MsgUnitKnowledgeUpdate::has_max_identification_level() const {
  return _has_bit(4);
}
inline void MsgUnitKnowledgeUpdate::clear_max_identification_level() {
  max_identification_level_ = 0;
  _clear_bit(4);
}
inline MsgsSimToClient::EnumUnitIdentificationLevel MsgUnitKnowledgeUpdate::max_identification_level() const {
  return static_cast< MsgsSimToClient::EnumUnitIdentificationLevel >(max_identification_level_);
}
inline void MsgUnitKnowledgeUpdate::set_max_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumUnitIdentificationLevel_IsValid(value));
  _set_bit(4);
  max_identification_level_ = value;
}

// optional int32 etat_op = 6;
inline bool MsgUnitKnowledgeUpdate::has_etat_op() const {
  return _has_bit(5);
}
inline void MsgUnitKnowledgeUpdate::clear_etat_op() {
  etat_op_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgUnitKnowledgeUpdate::etat_op() const {
  return etat_op_;
}
inline void MsgUnitKnowledgeUpdate::set_etat_op(::google::protobuf::int32 value) {
  _set_bit(5);
  etat_op_ = value;
}

// optional bool mort = 7;
inline bool MsgUnitKnowledgeUpdate::has_mort() const {
  return _has_bit(6);
}
inline void MsgUnitKnowledgeUpdate::clear_mort() {
  mort_ = false;
  _clear_bit(6);
}
inline bool MsgUnitKnowledgeUpdate::mort() const {
  return mort_;
}
inline void MsgUnitKnowledgeUpdate::set_mort(bool value) {
  _set_bit(6);
  mort_ = value;
}

// optional .Common.MsgCoordLatLong position = 8;
inline bool MsgUnitKnowledgeUpdate::has_position() const {
  return _has_bit(7);
}
inline void MsgUnitKnowledgeUpdate::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(7);
}
inline const ::Common::MsgCoordLatLong& MsgUnitKnowledgeUpdate::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgUnitKnowledgeUpdate::mutable_position() {
  _set_bit(7);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// optional .Common.MsgHeading direction = 9;
inline bool MsgUnitKnowledgeUpdate::has_direction() const {
  return _has_bit(8);
}
inline void MsgUnitKnowledgeUpdate::clear_direction() {
  if (direction_ != NULL) direction_->::Common::MsgHeading::Clear();
  _clear_bit(8);
}
inline const ::Common::MsgHeading& MsgUnitKnowledgeUpdate::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Common::MsgHeading* MsgUnitKnowledgeUpdate::mutable_direction() {
  _set_bit(8);
  if (direction_ == NULL) direction_ = new ::Common::MsgHeading;
  return direction_;
}

// optional int32 speed = 10;
inline bool MsgUnitKnowledgeUpdate::has_speed() const {
  return _has_bit(9);
}
inline void MsgUnitKnowledgeUpdate::clear_speed() {
  speed_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 MsgUnitKnowledgeUpdate::speed() const {
  return speed_;
}
inline void MsgUnitKnowledgeUpdate::set_speed(::google::protobuf::int32 value) {
  _set_bit(9);
  speed_ = value;
}

// optional .Common.PartyId party = 11;
inline bool MsgUnitKnowledgeUpdate::has_party() const {
  return _has_bit(10);
}
inline void MsgUnitKnowledgeUpdate::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(10);
}
inline const ::Common::PartyId& MsgUnitKnowledgeUpdate::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgUnitKnowledgeUpdate::mutable_party() {
  _set_bit(10);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional bool nature_pc = 12;
inline bool MsgUnitKnowledgeUpdate::has_nature_pc() const {
  return _has_bit(11);
}
inline void MsgUnitKnowledgeUpdate::clear_nature_pc() {
  nature_pc_ = false;
  _clear_bit(11);
}
inline bool MsgUnitKnowledgeUpdate::nature_pc() const {
  return nature_pc_;
}
inline void MsgUnitKnowledgeUpdate::set_nature_pc(bool value) {
  _set_bit(11);
  nature_pc_ = value;
}

// optional .MsgsSimToClient.SeqOfAutomatPerception perception_par_compagnie = 13;
inline bool MsgUnitKnowledgeUpdate::has_perception_par_compagnie() const {
  return _has_bit(12);
}
inline void MsgUnitKnowledgeUpdate::clear_perception_par_compagnie() {
  if (perception_par_compagnie_ != NULL) perception_par_compagnie_->::MsgsSimToClient::SeqOfAutomatPerception::Clear();
  _clear_bit(12);
}
inline const ::MsgsSimToClient::SeqOfAutomatPerception& MsgUnitKnowledgeUpdate::perception_par_compagnie() const {
  return perception_par_compagnie_ != NULL ? *perception_par_compagnie_ : *default_instance_->perception_par_compagnie_;
}
inline ::MsgsSimToClient::SeqOfAutomatPerception* MsgUnitKnowledgeUpdate::mutable_perception_par_compagnie() {
  _set_bit(12);
  if (perception_par_compagnie_ == NULL) perception_par_compagnie_ = new ::MsgsSimToClient::SeqOfAutomatPerception;
  return perception_par_compagnie_;
}

// optional .Common.UnitId surrendered_unit = 14;
inline bool MsgUnitKnowledgeUpdate::has_surrendered_unit() const {
  return _has_bit(13);
}
inline void MsgUnitKnowledgeUpdate::clear_surrendered_unit() {
  if (surrendered_unit_ != NULL) surrendered_unit_->::Common::UnitId::Clear();
  _clear_bit(13);
}
inline const ::Common::UnitId& MsgUnitKnowledgeUpdate::surrendered_unit() const {
  return surrendered_unit_ != NULL ? *surrendered_unit_ : *default_instance_->surrendered_unit_;
}
inline ::Common::UnitId* MsgUnitKnowledgeUpdate::mutable_surrendered_unit() {
  _set_bit(13);
  if (surrendered_unit_ == NULL) surrendered_unit_ = new ::Common::UnitId;
  return surrendered_unit_;
}

// optional bool prisonnier = 15;
inline bool MsgUnitKnowledgeUpdate::has_prisonnier() const {
  return _has_bit(14);
}
inline void MsgUnitKnowledgeUpdate::clear_prisonnier() {
  prisonnier_ = false;
  _clear_bit(14);
}
inline bool MsgUnitKnowledgeUpdate::prisonnier() const {
  return prisonnier_;
}
inline void MsgUnitKnowledgeUpdate::set_prisonnier(bool value) {
  _set_bit(14);
  prisonnier_ = value;
}

// optional bool refugie_pris_en_compte = 16;
inline bool MsgUnitKnowledgeUpdate::has_refugie_pris_en_compte() const {
  return _has_bit(15);
}
inline void MsgUnitKnowledgeUpdate::clear_refugie_pris_en_compte() {
  refugie_pris_en_compte_ = false;
  _clear_bit(15);
}
inline bool MsgUnitKnowledgeUpdate::refugie_pris_en_compte() const {
  return refugie_pris_en_compte_;
}
inline void MsgUnitKnowledgeUpdate::set_refugie_pris_en_compte(bool value) {
  _set_bit(15);
  refugie_pris_en_compte_ = value;
}

// -------------------------------------------------------------------

// MsgUnitKnowledgeDestruction

// required .Common.UnitKnowledgeId knowledge = 1;
inline bool MsgUnitKnowledgeDestruction::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgUnitKnowledgeDestruction::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::UnitKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitKnowledgeId& MsgUnitKnowledgeDestruction::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::UnitKnowledgeId* MsgUnitKnowledgeDestruction::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::UnitKnowledgeId;
  return knowledge_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgUnitKnowledgeDestruction::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgUnitKnowledgeDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgUnitKnowledgeDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgUnitKnowledgeDestruction::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// UnitFireTarget

// optional .Common.UnitId unit = 1;
inline bool UnitFireTarget::has_unit() const {
  return _has_bit(0);
}
inline void UnitFireTarget::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& UnitFireTarget::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* UnitFireTarget::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// optional .Common.CrowdId crowd = 2;
inline bool UnitFireTarget::has_crowd() const {
  return _has_bit(1);
}
inline void UnitFireTarget::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& UnitFireTarget::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* UnitFireTarget::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// optional .Common.MsgCoordLatLong position = 3;
inline bool UnitFireTarget::has_position() const {
  return _has_bit(2);
}
inline void UnitFireTarget::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgCoordLatLong& UnitFireTarget::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* UnitFireTarget::mutable_position() {
  _set_bit(2);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// -------------------------------------------------------------------

// MsgStartUnitFire

// required .Common.FireId fire = 1;
inline bool MsgStartUnitFire::has_fire() const {
  return _has_bit(0);
}
inline void MsgStartUnitFire::clear_fire() {
  if (fire_ != NULL) fire_->::Common::FireId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireId& MsgStartUnitFire::fire() const {
  return fire_ != NULL ? *fire_ : *default_instance_->fire_;
}
inline ::Common::FireId* MsgStartUnitFire::mutable_fire() {
  _set_bit(0);
  if (fire_ == NULL) fire_ = new ::Common::FireId;
  return fire_;
}

// required .Common.UnitId firing_unit = 2;
inline bool MsgStartUnitFire::has_firing_unit() const {
  return _has_bit(1);
}
inline void MsgStartUnitFire::clear_firing_unit() {
  if (firing_unit_ != NULL) firing_unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgStartUnitFire::firing_unit() const {
  return firing_unit_ != NULL ? *firing_unit_ : *default_instance_->firing_unit_;
}
inline ::Common::UnitId* MsgStartUnitFire::mutable_firing_unit() {
  _set_bit(1);
  if (firing_unit_ == NULL) firing_unit_ = new ::Common::UnitId;
  return firing_unit_;
}

// required .MsgsSimToClient.UnitFireTarget target = 3;
inline bool MsgStartUnitFire::has_target() const {
  return _has_bit(2);
}
inline void MsgStartUnitFire::clear_target() {
  if (target_ != NULL) target_->::MsgsSimToClient::UnitFireTarget::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::UnitFireTarget& MsgStartUnitFire::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::MsgsSimToClient::UnitFireTarget* MsgStartUnitFire::mutable_target() {
  _set_bit(2);
  if (target_ == NULL) target_ = new ::MsgsSimToClient::UnitFireTarget;
  return target_;
}

// required .Common.UnitFireType type = 4;
inline bool MsgStartUnitFire::has_type() const {
  return _has_bit(3);
}
inline void MsgStartUnitFire::clear_type() {
  type_ = 0;
  _clear_bit(3);
}
inline Common::UnitFireType MsgStartUnitFire::type() const {
  return static_cast< Common::UnitFireType >(type_);
}
inline void MsgStartUnitFire::set_type(Common::UnitFireType value) {
  GOOGLE_DCHECK(Common::UnitFireType_IsValid(value));
  _set_bit(3);
  type_ = value;
}

// optional .Common.ResourceType ammunition = 5;
inline bool MsgStartUnitFire::has_ammunition() const {
  return _has_bit(4);
}
inline void MsgStartUnitFire::clear_ammunition() {
  if (ammunition_ != NULL) ammunition_->::Common::ResourceType::Clear();
  _clear_bit(4);
}
inline const ::Common::ResourceType& MsgStartUnitFire::ammunition() const {
  return ammunition_ != NULL ? *ammunition_ : *default_instance_->ammunition_;
}
inline ::Common::ResourceType* MsgStartUnitFire::mutable_ammunition() {
  _set_bit(4);
  if (ammunition_ == NULL) ammunition_ = new ::Common::ResourceType;
  return ammunition_;
}

// -------------------------------------------------------------------

// UnitHumanFireDamage

// required .Common.EnumHumanRank rank = 1;
inline bool UnitHumanFireDamage::has_rank() const {
  return _has_bit(0);
}
inline void UnitHumanFireDamage::clear_rank() {
  rank_ = 0;
  _clear_bit(0);
}
inline Common::EnumHumanRank UnitHumanFireDamage::rank() const {
  return static_cast< Common::EnumHumanRank >(rank_);
}
inline void UnitHumanFireDamage::set_rank(Common::EnumHumanRank value) {
  GOOGLE_DCHECK(Common::EnumHumanRank_IsValid(value));
  _set_bit(0);
  rank_ = value;
}

// required int32 alive_nbr = 2;
inline bool UnitHumanFireDamage::has_alive_nbr() const {
  return _has_bit(1);
}
inline void UnitHumanFireDamage::clear_alive_nbr() {
  alive_nbr_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::alive_nbr() const {
  return alive_nbr_;
}
inline void UnitHumanFireDamage::set_alive_nbr(::google::protobuf::int32 value) {
  _set_bit(1);
  alive_nbr_ = value;
}

// required int32 dead_nbr = 3;
inline bool UnitHumanFireDamage::has_dead_nbr() const {
  return _has_bit(2);
}
inline void UnitHumanFireDamage::clear_dead_nbr() {
  dead_nbr_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::dead_nbr() const {
  return dead_nbr_;
}
inline void UnitHumanFireDamage::set_dead_nbr(::google::protobuf::int32 value) {
  _set_bit(2);
  dead_nbr_ = value;
}

// required int32 wounded_u1_nbr = 4;
inline bool UnitHumanFireDamage::has_wounded_u1_nbr() const {
  return _has_bit(3);
}
inline void UnitHumanFireDamage::clear_wounded_u1_nbr() {
  wounded_u1_nbr_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::wounded_u1_nbr() const {
  return wounded_u1_nbr_;
}
inline void UnitHumanFireDamage::set_wounded_u1_nbr(::google::protobuf::int32 value) {
  _set_bit(3);
  wounded_u1_nbr_ = value;
}

// required int32 wounded_u2_nbr = 5;
inline bool UnitHumanFireDamage::has_wounded_u2_nbr() const {
  return _has_bit(4);
}
inline void UnitHumanFireDamage::clear_wounded_u2_nbr() {
  wounded_u2_nbr_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::wounded_u2_nbr() const {
  return wounded_u2_nbr_;
}
inline void UnitHumanFireDamage::set_wounded_u2_nbr(::google::protobuf::int32 value) {
  _set_bit(4);
  wounded_u2_nbr_ = value;
}

// required int32 wounded_u3_nbr = 6;
inline bool UnitHumanFireDamage::has_wounded_u3_nbr() const {
  return _has_bit(5);
}
inline void UnitHumanFireDamage::clear_wounded_u3_nbr() {
  wounded_u3_nbr_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::wounded_u3_nbr() const {
  return wounded_u3_nbr_;
}
inline void UnitHumanFireDamage::set_wounded_u3_nbr(::google::protobuf::int32 value) {
  _set_bit(5);
  wounded_u3_nbr_ = value;
}

// required int32 wounded_ue_nbr = 7;
inline bool UnitHumanFireDamage::has_wounded_ue_nbr() const {
  return _has_bit(6);
}
inline void UnitHumanFireDamage::clear_wounded_ue_nbr() {
  wounded_ue_nbr_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::wounded_ue_nbr() const {
  return wounded_ue_nbr_;
}
inline void UnitHumanFireDamage::set_wounded_ue_nbr(::google::protobuf::int32 value) {
  _set_bit(6);
  wounded_ue_nbr_ = value;
}

// -------------------------------------------------------------------

// SeqOfUnitHumanFireDamage

// repeated .MsgsSimToClient.UnitHumanFireDamage elem = 1;
inline int SeqOfUnitHumanFireDamage::elem_size() const {
  return elem_.size();
}
inline void SeqOfUnitHumanFireDamage::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage >&
SeqOfUnitHumanFireDamage::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage >*
SeqOfUnitHumanFireDamage::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::UnitHumanFireDamage& SeqOfUnitHumanFireDamage::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::UnitHumanFireDamage* SeqOfUnitHumanFireDamage::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::UnitHumanFireDamage* SeqOfUnitHumanFireDamage::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgUnitEquipmentFireDamage

// required .Common.EquipmentType equipement_type = 1;
inline bool MsgUnitEquipmentFireDamage::has_equipement_type() const {
  return _has_bit(0);
}
inline void MsgUnitEquipmentFireDamage::clear_equipement_type() {
  if (equipement_type_ != NULL) equipement_type_->::Common::EquipmentType::Clear();
  _clear_bit(0);
}
inline const ::Common::EquipmentType& MsgUnitEquipmentFireDamage::equipement_type() const {
  return equipement_type_ != NULL ? *equipement_type_ : *default_instance_->equipement_type_;
}
inline ::Common::EquipmentType* MsgUnitEquipmentFireDamage::mutable_equipement_type() {
  _set_bit(0);
  if (equipement_type_ == NULL) equipement_type_ = new ::Common::EquipmentType;
  return equipement_type_;
}

// required uint32 available_nbr = 2;
inline bool MsgUnitEquipmentFireDamage::has_available_nbr() const {
  return _has_bit(1);
}
inline void MsgUnitEquipmentFireDamage::clear_available_nbr() {
  available_nbr_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 MsgUnitEquipmentFireDamage::available_nbr() const {
  return available_nbr_;
}
inline void MsgUnitEquipmentFireDamage::set_available_nbr(::google::protobuf::uint32 value) {
  _set_bit(1);
  available_nbr_ = value;
}

// required uint32 unavailable_nbr = 3;
inline bool MsgUnitEquipmentFireDamage::has_unavailable_nbr() const {
  return _has_bit(2);
}
inline void MsgUnitEquipmentFireDamage::clear_unavailable_nbr() {
  unavailable_nbr_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 MsgUnitEquipmentFireDamage::unavailable_nbr() const {
  return unavailable_nbr_;
}
inline void MsgUnitEquipmentFireDamage::set_unavailable_nbr(::google::protobuf::uint32 value) {
  _set_bit(2);
  unavailable_nbr_ = value;
}

// required uint32 repairable_nbr = 4;
inline bool MsgUnitEquipmentFireDamage::has_repairable_nbr() const {
  return _has_bit(3);
}
inline void MsgUnitEquipmentFireDamage::clear_repairable_nbr() {
  repairable_nbr_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 MsgUnitEquipmentFireDamage::repairable_nbr() const {
  return repairable_nbr_;
}
inline void MsgUnitEquipmentFireDamage::set_repairable_nbr(::google::protobuf::uint32 value) {
  _set_bit(3);
  repairable_nbr_ = value;
}

// -------------------------------------------------------------------

// SeqOfUnitEquipmentFireDamage

// repeated .MsgsSimToClient.MsgUnitEquipmentFireDamage elem = 1;
inline int SeqOfUnitEquipmentFireDamage::elem_size() const {
  return elem_.size();
}
inline void SeqOfUnitEquipmentFireDamage::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage >&
SeqOfUnitEquipmentFireDamage::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage >*
SeqOfUnitEquipmentFireDamage::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgUnitEquipmentFireDamage& SeqOfUnitEquipmentFireDamage::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgUnitEquipmentFireDamage* SeqOfUnitEquipmentFireDamage::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgUnitEquipmentFireDamage* SeqOfUnitEquipmentFireDamage::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgUnitFireDamages

// required .Common.UnitId target = 1;
inline bool MsgUnitFireDamages::has_target() const {
  return _has_bit(0);
}
inline void MsgUnitFireDamages::clear_target() {
  if (target_ != NULL) target_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitFireDamages::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::Common::UnitId* MsgUnitFireDamages::mutable_target() {
  _set_bit(0);
  if (target_ == NULL) target_ = new ::Common::UnitId;
  return target_;
}

// required .MsgsSimToClient.SeqOfUnitHumanFireDamage humans = 2;
inline bool MsgUnitFireDamages::has_humans() const {
  return _has_bit(1);
}
inline void MsgUnitFireDamages::clear_humans() {
  if (humans_ != NULL) humans_->::MsgsSimToClient::SeqOfUnitHumanFireDamage::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::SeqOfUnitHumanFireDamage& MsgUnitFireDamages::humans() const {
  return humans_ != NULL ? *humans_ : *default_instance_->humans_;
}
inline ::MsgsSimToClient::SeqOfUnitHumanFireDamage* MsgUnitFireDamages::mutable_humans() {
  _set_bit(1);
  if (humans_ == NULL) humans_ = new ::MsgsSimToClient::SeqOfUnitHumanFireDamage;
  return humans_;
}

// required .MsgsSimToClient.SeqOfUnitEquipmentFireDamage equipments = 3;
inline bool MsgUnitFireDamages::has_equipments() const {
  return _has_bit(2);
}
inline void MsgUnitFireDamages::clear_equipments() {
  if (equipments_ != NULL) equipments_->::MsgsSimToClient::SeqOfUnitEquipmentFireDamage::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage& MsgUnitFireDamages::equipments() const {
  return equipments_ != NULL ? *equipments_ : *default_instance_->equipments_;
}
inline ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage* MsgUnitFireDamages::mutable_equipments() {
  _set_bit(2);
  if (equipments_ == NULL) equipments_ = new ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage;
  return equipments_;
}

// -------------------------------------------------------------------

// MsgUnitsFireDamages

// repeated .MsgsSimToClient.MsgUnitFireDamages elem = 1;
inline int MsgUnitsFireDamages::elem_size() const {
  return elem_.size();
}
inline void MsgUnitsFireDamages::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages >&
MsgUnitsFireDamages::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages >*
MsgUnitsFireDamages::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgUnitFireDamages& MsgUnitsFireDamages::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgUnitFireDamages* MsgUnitsFireDamages::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgUnitFireDamages* MsgUnitsFireDamages::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgCrowdFireDamages

// required .Common.CrowdId target = 1;
inline bool MsgCrowdFireDamages::has_target() const {
  return _has_bit(0);
}
inline void MsgCrowdFireDamages::clear_target() {
  if (target_ != NULL) target_->::Common::CrowdId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdId& MsgCrowdFireDamages::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::Common::CrowdId* MsgCrowdFireDamages::mutable_target() {
  _set_bit(0);
  if (target_ == NULL) target_ = new ::Common::CrowdId;
  return target_;
}

// required int32 dead_nbr = 2;
inline bool MsgCrowdFireDamages::has_dead_nbr() const {
  return _has_bit(1);
}
inline void MsgCrowdFireDamages::clear_dead_nbr() {
  dead_nbr_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgCrowdFireDamages::dead_nbr() const {
  return dead_nbr_;
}
inline void MsgCrowdFireDamages::set_dead_nbr(::google::protobuf::int32 value) {
  _set_bit(1);
  dead_nbr_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdsFireDamages

// repeated .MsgsSimToClient.MsgCrowdFireDamages elem = 1;
inline int MsgCrowdsFireDamages::elem_size() const {
  return elem_.size();
}
inline void MsgCrowdsFireDamages::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgCrowdFireDamages >&
MsgCrowdsFireDamages::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgCrowdFireDamages >*
MsgCrowdsFireDamages::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgCrowdFireDamages& MsgCrowdsFireDamages::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgCrowdFireDamages* MsgCrowdsFireDamages::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgCrowdFireDamages* MsgCrowdsFireDamages::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgStopUnitFire

// required .Common.FireId fire = 1;
inline bool MsgStopUnitFire::has_fire() const {
  return _has_bit(0);
}
inline void MsgStopUnitFire::clear_fire() {
  if (fire_ != NULL) fire_->::Common::FireId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireId& MsgStopUnitFire::fire() const {
  return fire_ != NULL ? *fire_ : *default_instance_->fire_;
}
inline ::Common::FireId* MsgStopUnitFire::mutable_fire() {
  _set_bit(0);
  if (fire_ == NULL) fire_ = new ::Common::FireId;
  return fire_;
}

// optional .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
inline bool MsgStopUnitFire::has_units_damages() const {
  return _has_bit(1);
}
inline void MsgStopUnitFire::clear_units_damages() {
  if (units_damages_ != NULL) units_damages_->::MsgsSimToClient::MsgUnitsFireDamages::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgUnitsFireDamages& MsgStopUnitFire::units_damages() const {
  return units_damages_ != NULL ? *units_damages_ : *default_instance_->units_damages_;
}
inline ::MsgsSimToClient::MsgUnitsFireDamages* MsgStopUnitFire::mutable_units_damages() {
  _set_bit(1);
  if (units_damages_ == NULL) units_damages_ = new ::MsgsSimToClient::MsgUnitsFireDamages;
  return units_damages_;
}

// optional .MsgsSimToClient.MsgCrowdsFireDamages crowds_damages = 3;
inline bool MsgStopUnitFire::has_crowds_damages() const {
  return _has_bit(2);
}
inline void MsgStopUnitFire::clear_crowds_damages() {
  if (crowds_damages_ != NULL) crowds_damages_->::MsgsSimToClient::MsgCrowdsFireDamages::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgCrowdsFireDamages& MsgStopUnitFire::crowds_damages() const {
  return crowds_damages_ != NULL ? *crowds_damages_ : *default_instance_->crowds_damages_;
}
inline ::MsgsSimToClient::MsgCrowdsFireDamages* MsgStopUnitFire::mutable_crowds_damages() {
  _set_bit(2);
  if (crowds_damages_ == NULL) crowds_damages_ = new ::MsgsSimToClient::MsgCrowdsFireDamages;
  return crowds_damages_;
}

// -------------------------------------------------------------------

// MsgStartCrowdFire

// required .Common.FireId fire = 1;
inline bool MsgStartCrowdFire::has_fire() const {
  return _has_bit(0);
}
inline void MsgStartCrowdFire::clear_fire() {
  if (fire_ != NULL) fire_->::Common::FireId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireId& MsgStartCrowdFire::fire() const {
  return fire_ != NULL ? *fire_ : *default_instance_->fire_;
}
inline ::Common::FireId* MsgStartCrowdFire::mutable_fire() {
  _set_bit(0);
  if (fire_ == NULL) fire_ = new ::Common::FireId;
  return fire_;
}

// required .Common.CrowdId firing_crowd = 2;
inline bool MsgStartCrowdFire::has_firing_crowd() const {
  return _has_bit(1);
}
inline void MsgStartCrowdFire::clear_firing_crowd() {
  if (firing_crowd_ != NULL) firing_crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgStartCrowdFire::firing_crowd() const {
  return firing_crowd_ != NULL ? *firing_crowd_ : *default_instance_->firing_crowd_;
}
inline ::Common::CrowdId* MsgStartCrowdFire::mutable_firing_crowd() {
  _set_bit(1);
  if (firing_crowd_ == NULL) firing_crowd_ = new ::Common::CrowdId;
  return firing_crowd_;
}

// -------------------------------------------------------------------

// MsgStopCrowdFire

// required .Common.FireId fire = 1;
inline bool MsgStopCrowdFire::has_fire() const {
  return _has_bit(0);
}
inline void MsgStopCrowdFire::clear_fire() {
  if (fire_ != NULL) fire_->::Common::FireId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireId& MsgStopCrowdFire::fire() const {
  return fire_ != NULL ? *fire_ : *default_instance_->fire_;
}
inline ::Common::FireId* MsgStopCrowdFire::mutable_fire() {
  _set_bit(0);
  if (fire_ == NULL) fire_ = new ::Common::FireId;
  return fire_;
}

// required .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
inline bool MsgStopCrowdFire::has_units_damages() const {
  return _has_bit(1);
}
inline void MsgStopCrowdFire::clear_units_damages() {
  if (units_damages_ != NULL) units_damages_->::MsgsSimToClient::MsgUnitsFireDamages::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgUnitsFireDamages& MsgStopCrowdFire::units_damages() const {
  return units_damages_ != NULL ? *units_damages_ : *default_instance_->units_damages_;
}
inline ::MsgsSimToClient::MsgUnitsFireDamages* MsgStopCrowdFire::mutable_units_damages() {
  _set_bit(1);
  if (units_damages_ == NULL) units_damages_ = new ::MsgsSimToClient::MsgUnitsFireDamages;
  return units_damages_;
}

// -------------------------------------------------------------------

// MsgExplosion

// required .Common.ObjectId object = 1;
inline bool MsgExplosion::has_object() const {
  return _has_bit(0);
}
inline void MsgExplosion::clear_object() {
  if (object_ != NULL) object_->::Common::ObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectId& MsgExplosion::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Common::ObjectId* MsgExplosion::mutable_object() {
  _set_bit(0);
  if (object_ == NULL) object_ = new ::Common::ObjectId;
  return object_;
}

// optional .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
inline bool MsgExplosion::has_units_damages() const {
  return _has_bit(1);
}
inline void MsgExplosion::clear_units_damages() {
  if (units_damages_ != NULL) units_damages_->::MsgsSimToClient::MsgUnitsFireDamages::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgUnitsFireDamages& MsgExplosion::units_damages() const {
  return units_damages_ != NULL ? *units_damages_ : *default_instance_->units_damages_;
}
inline ::MsgsSimToClient::MsgUnitsFireDamages* MsgExplosion::mutable_units_damages() {
  _set_bit(1);
  if (units_damages_ == NULL) units_damages_ = new ::MsgsSimToClient::MsgUnitsFireDamages;
  return units_damages_;
}

// optional .MsgsSimToClient.MsgCrowdsFireDamages crowds_damages = 3;
inline bool MsgExplosion::has_crowds_damages() const {
  return _has_bit(2);
}
inline void MsgExplosion::clear_crowds_damages() {
  if (crowds_damages_ != NULL) crowds_damages_->::MsgsSimToClient::MsgCrowdsFireDamages::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgCrowdsFireDamages& MsgExplosion::crowds_damages() const {
  return crowds_damages_ != NULL ? *crowds_damages_ : *default_instance_->crowds_damages_;
}
inline ::MsgsSimToClient::MsgCrowdsFireDamages* MsgExplosion::mutable_crowds_damages() {
  _set_bit(2);
  if (crowds_damages_ == NULL) crowds_damages_ = new ::MsgsSimToClient::MsgCrowdsFireDamages;
  return crowds_damages_;
}

// -------------------------------------------------------------------

// MsgStartFireEffect

// required .Common.FireEffectId fire_effect = 1;
inline bool MsgStartFireEffect::has_fire_effect() const {
  return _has_bit(0);
}
inline void MsgStartFireEffect::clear_fire_effect() {
  if (fire_effect_ != NULL) fire_effect_->::Common::FireEffectId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireEffectId& MsgStartFireEffect::fire_effect() const {
  return fire_effect_ != NULL ? *fire_effect_ : *default_instance_->fire_effect_;
}
inline ::Common::FireEffectId* MsgStartFireEffect::mutable_fire_effect() {
  _set_bit(0);
  if (fire_effect_ == NULL) fire_effect_ = new ::Common::FireEffectId;
  return fire_effect_;
}

// required .Common.MsgLocation location = 2;
inline bool MsgStartFireEffect::has_location() const {
  return _has_bit(1);
}
inline void MsgStartFireEffect::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgLocation& MsgStartFireEffect::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgStartFireEffect::mutable_location() {
  _set_bit(1);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// required .Common.EnumFireEffectType type = 3;
inline bool MsgStartFireEffect::has_type() const {
  return _has_bit(2);
}
inline void MsgStartFireEffect::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline Common::EnumFireEffectType MsgStartFireEffect::type() const {
  return static_cast< Common::EnumFireEffectType >(type_);
}
inline void MsgStartFireEffect::set_type(Common::EnumFireEffectType value) {
  GOOGLE_DCHECK(Common::EnumFireEffectType_IsValid(value));
  _set_bit(2);
  type_ = value;
}

// -------------------------------------------------------------------

// MsgStopFireEffect

// required .Common.FireEffectId fire_effect = 1;
inline bool MsgStopFireEffect::has_fire_effect() const {
  return _has_bit(0);
}
inline void MsgStopFireEffect::clear_fire_effect() {
  if (fire_effect_ != NULL) fire_effect_->::Common::FireEffectId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireEffectId& MsgStopFireEffect::fire_effect() const {
  return fire_effect_ != NULL ? *fire_effect_ : *default_instance_->fire_effect_;
}
inline ::Common::FireEffectId* MsgStopFireEffect::mutable_fire_effect() {
  _set_bit(0);
  if (fire_effect_ == NULL) fire_effect_ = new ::Common::FireEffectId;
  return fire_effect_;
}

// -------------------------------------------------------------------

// MsgReport

// required .Common.ReportId report = 1;
inline bool MsgReport::has_report() const {
  return _has_bit(0);
}
inline void MsgReport::clear_report() {
  if (report_ != NULL) report_->::Common::ReportId::Clear();
  _clear_bit(0);
}
inline const ::Common::ReportId& MsgReport::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::Common::ReportId* MsgReport::mutable_report() {
  _set_bit(0);
  if (report_ == NULL) report_ = new ::Common::ReportId;
  return report_;
}

// required .Common.Tasker source = 2;
inline bool MsgReport::has_source() const {
  return _has_bit(1);
}
inline void MsgReport::clear_source() {
  if (source_ != NULL) source_->::Common::Tasker::Clear();
  _clear_bit(1);
}
inline const ::Common::Tasker& MsgReport::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Common::Tasker* MsgReport::mutable_source() {
  _set_bit(1);
  if (source_ == NULL) source_ = new ::Common::Tasker;
  return source_;
}

// required .Common.ReportType type = 3;
inline bool MsgReport::has_type() const {
  return _has_bit(2);
}
inline void MsgReport::clear_type() {
  if (type_ != NULL) type_->::Common::ReportType::Clear();
  _clear_bit(2);
}
inline const ::Common::ReportType& MsgReport::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::ReportType* MsgReport::mutable_type() {
  _set_bit(2);
  if (type_ == NULL) type_ = new ::Common::ReportType;
  return type_;
}

// required .MsgsSimToClient.EnumReportType category = 4;
inline bool MsgReport::has_category() const {
  return _has_bit(3);
}
inline void MsgReport::clear_category() {
  category_ = 0;
  _clear_bit(3);
}
inline MsgsSimToClient::EnumReportType MsgReport::category() const {
  return static_cast< MsgsSimToClient::EnumReportType >(category_);
}
inline void MsgReport::set_category(MsgsSimToClient::EnumReportType value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumReportType_IsValid(value));
  _set_bit(3);
  category_ = value;
}

// required .Common.MsgDateTime time = 5;
inline bool MsgReport::has_time() const {
  return _has_bit(4);
}
inline void MsgReport::clear_time() {
  if (time_ != NULL) time_->::Common::MsgDateTime::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgDateTime& MsgReport::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::Common::MsgDateTime* MsgReport::mutable_time() {
  _set_bit(4);
  if (time_ == NULL) time_ = new ::Common::MsgDateTime;
  return time_;
}

// optional .Common.MsgMissionParameters parameters = 6;
inline bool MsgReport::has_parameters() const {
  return _has_bit(5);
}
inline void MsgReport::clear_parameters() {
  if (parameters_ != NULL) parameters_->::Common::MsgMissionParameters::Clear();
  _clear_bit(5);
}
inline const ::Common::MsgMissionParameters& MsgReport::parameters() const {
  return parameters_ != NULL ? *parameters_ : *default_instance_->parameters_;
}
inline ::Common::MsgMissionParameters* MsgReport::mutable_parameters() {
  _set_bit(5);
  if (parameters_ == NULL) parameters_ = new ::Common::MsgMissionParameters;
  return parameters_;
}

// -------------------------------------------------------------------

// MsgInvalidateReport

// required .Common.ReportId report = 1;
inline bool MsgInvalidateReport::has_report() const {
  return _has_bit(0);
}
inline void MsgInvalidateReport::clear_report() {
  if (report_ != NULL) report_->::Common::ReportId::Clear();
  _clear_bit(0);
}
inline const ::Common::ReportId& MsgInvalidateReport::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::Common::ReportId* MsgInvalidateReport::mutable_report() {
  _set_bit(0);
  if (report_ == NULL) report_ = new ::Common::ReportId;
  return report_;
}

// required .Common.Tasker source = 2;
inline bool MsgInvalidateReport::has_source() const {
  return _has_bit(1);
}
inline void MsgInvalidateReport::clear_source() {
  if (source_ != NULL) source_->::Common::Tasker::Clear();
  _clear_bit(1);
}
inline const ::Common::Tasker& MsgInvalidateReport::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Common::Tasker* MsgInvalidateReport::mutable_source() {
  _set_bit(1);
  if (source_ == NULL) source_ = new ::Common::Tasker;
  return source_;
}

// -------------------------------------------------------------------

// MsgTrace

// required .Common.Tasker source = 1;
inline bool MsgTrace::has_source() const {
  return _has_bit(0);
}
inline void MsgTrace::clear_source() {
  if (source_ != NULL) source_->::Common::Tasker::Clear();
  _clear_bit(0);
}
inline const ::Common::Tasker& MsgTrace::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Common::Tasker* MsgTrace::mutable_source() {
  _set_bit(0);
  if (source_ == NULL) source_ = new ::Common::Tasker;
  return source_;
}

// required string message = 2;
inline bool MsgTrace::has_message() const {
  return _has_bit(1);
}
inline void MsgTrace::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgTrace::message() const {
  return *message_;
}
inline void MsgTrace::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void MsgTrace::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void MsgTrace::set_message(const char* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgTrace::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// MsgDecisionalState

// required .Common.Tasker source = 1;
inline bool MsgDecisionalState::has_source() const {
  return _has_bit(0);
}
inline void MsgDecisionalState::clear_source() {
  if (source_ != NULL) source_->::Common::Tasker::Clear();
  _clear_bit(0);
}
inline const ::Common::Tasker& MsgDecisionalState::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Common::Tasker* MsgDecisionalState::mutable_source() {
  _set_bit(0);
  if (source_ == NULL) source_ = new ::Common::Tasker;
  return source_;
}

// required string key = 2;
inline bool MsgDecisionalState::has_key() const {
  return _has_bit(1);
}
inline void MsgDecisionalState::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgDecisionalState::key() const {
  return *key_;
}
inline void MsgDecisionalState::set_key(const ::std::string& value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MsgDecisionalState::set_key(const char* value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MsgDecisionalState::set_key(const char* value, size_t size) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgDecisionalState::mutable_key() {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required string value = 3;
inline bool MsgDecisionalState::has_value() const {
  return _has_bit(2);
}
inline void MsgDecisionalState::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgDecisionalState::value() const {
  return *value_;
}
inline void MsgDecisionalState::set_value(const ::std::string& value) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void MsgDecisionalState::set_value(const char* value) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void MsgDecisionalState::set_value(const char* value, size_t size) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgDecisionalState::mutable_value() {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// MsgDebugPoints

// required .Common.Tasker source = 1;
inline bool MsgDebugPoints::has_source() const {
  return _has_bit(0);
}
inline void MsgDebugPoints::clear_source() {
  if (source_ != NULL) source_->::Common::Tasker::Clear();
  _clear_bit(0);
}
inline const ::Common::Tasker& MsgDebugPoints::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Common::Tasker* MsgDebugPoints::mutable_source() {
  _set_bit(0);
  if (source_ == NULL) source_ = new ::Common::Tasker;
  return source_;
}

// required .Common.MsgCoordLatLongList coordinates = 2;
inline bool MsgDebugPoints::has_coordinates() const {
  return _has_bit(1);
}
inline void MsgDebugPoints::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::Common::MsgCoordLatLongList::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgCoordLatLongList& MsgDebugPoints::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::Common::MsgCoordLatLongList* MsgDebugPoints::mutable_coordinates() {
  _set_bit(1);
  if (coordinates_ == NULL) coordinates_ = new ::Common::MsgCoordLatLongList;
  return coordinates_;
}

// -------------------------------------------------------------------

// SeqOfHeading

// repeated .Common.MsgHeading elem = 1;
inline int SeqOfHeading::elem_size() const {
  return elem_.size();
}
inline void SeqOfHeading::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading >&
SeqOfHeading::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading >*
SeqOfHeading::mutable_elem() {
  return &elem_;
}
inline const ::Common::MsgHeading& SeqOfHeading::elem(int index) const {
  return elem_.Get(index);
}
inline ::Common::MsgHeading* SeqOfHeading::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::Common::MsgHeading* SeqOfHeading::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgVisionCone

// required .Common.MsgCoordLatLong origin = 1;
inline bool MsgVisionCone::has_origin() const {
  return _has_bit(0);
}
inline void MsgVisionCone::clear_origin() {
  if (origin_ != NULL) origin_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(0);
}
inline const ::Common::MsgCoordLatLong& MsgVisionCone::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::Common::MsgCoordLatLong* MsgVisionCone::mutable_origin() {
  _set_bit(0);
  if (origin_ == NULL) origin_ = new ::Common::MsgCoordLatLong;
  return origin_;
}

// required int32 height = 2;
inline bool MsgVisionCone::has_height() const {
  return _has_bit(1);
}
inline void MsgVisionCone::clear_height() {
  height_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgVisionCone::height() const {
  return height_;
}
inline void MsgVisionCone::set_height(::google::protobuf::int32 value) {
  _set_bit(1);
  height_ = value;
}

// required string sensor = 3;
inline bool MsgVisionCone::has_sensor() const {
  return _has_bit(2);
}
inline void MsgVisionCone::clear_sensor() {
  if (sensor_ != &_default_sensor_) {
    sensor_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgVisionCone::sensor() const {
  return *sensor_;
}
inline void MsgVisionCone::set_sensor(const ::std::string& value) {
  _set_bit(2);
  if (sensor_ == &_default_sensor_) {
    sensor_ = new ::std::string;
  }
  sensor_->assign(value);
}
inline void MsgVisionCone::set_sensor(const char* value) {
  _set_bit(2);
  if (sensor_ == &_default_sensor_) {
    sensor_ = new ::std::string;
  }
  sensor_->assign(value);
}
inline void MsgVisionCone::set_sensor(const char* value, size_t size) {
  _set_bit(2);
  if (sensor_ == &_default_sensor_) {
    sensor_ = new ::std::string;
  }
  sensor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgVisionCone::mutable_sensor() {
  _set_bit(2);
  if (sensor_ == &_default_sensor_) {
    sensor_ = new ::std::string;
  }
  return sensor_;
}

// required .MsgsSimToClient.SeqOfHeading directions = 4;
inline bool MsgVisionCone::has_directions() const {
  return _has_bit(3);
}
inline void MsgVisionCone::clear_directions() {
  if (directions_ != NULL) directions_->::MsgsSimToClient::SeqOfHeading::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::SeqOfHeading& MsgVisionCone::directions() const {
  return directions_ != NULL ? *directions_ : *default_instance_->directions_;
}
inline ::MsgsSimToClient::SeqOfHeading* MsgVisionCone::mutable_directions() {
  _set_bit(3);
  if (directions_ == NULL) directions_ = new ::MsgsSimToClient::SeqOfHeading;
  return directions_;
}

// -------------------------------------------------------------------

// SeqOfVisionCone

// repeated .MsgsSimToClient.MsgVisionCone elem = 1;
inline int SeqOfVisionCone::elem_size() const {
  return elem_.size();
}
inline void SeqOfVisionCone::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone >&
SeqOfVisionCone::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone >*
SeqOfVisionCone::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgVisionCone& SeqOfVisionCone::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgVisionCone* SeqOfVisionCone::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgVisionCone* SeqOfVisionCone::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgUnitVisionCones

// required .Common.UnitId unit = 1;
inline bool MsgUnitVisionCones::has_unit() const {
  return _has_bit(0);
}
inline void MsgUnitVisionCones::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitVisionCones::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitVisionCones::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required .MsgsSimToClient.SeqOfVisionCone cones = 2;
inline bool MsgUnitVisionCones::has_cones() const {
  return _has_bit(1);
}
inline void MsgUnitVisionCones::clear_cones() {
  if (cones_ != NULL) cones_->::MsgsSimToClient::SeqOfVisionCone::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::SeqOfVisionCone& MsgUnitVisionCones::cones() const {
  return cones_ != NULL ? *cones_ : *default_instance_->cones_;
}
inline ::MsgsSimToClient::SeqOfVisionCone* MsgUnitVisionCones::mutable_cones() {
  _set_bit(1);
  if (cones_ == NULL) cones_ = new ::MsgsSimToClient::SeqOfVisionCone;
  return cones_;
}

// required float elongation = 3;
inline bool MsgUnitVisionCones::has_elongation() const {
  return _has_bit(2);
}
inline void MsgUnitVisionCones::clear_elongation() {
  elongation_ = 0;
  _clear_bit(2);
}
inline float MsgUnitVisionCones::elongation() const {
  return elongation_;
}
inline void MsgUnitVisionCones::set_elongation(float value) {
  _set_bit(2);
  elongation_ = value;
}

// -------------------------------------------------------------------

// MsgUnitDetection

// required .Common.UnitId observer = 1;
inline bool MsgUnitDetection::has_observer() const {
  return _has_bit(0);
}
inline void MsgUnitDetection::clear_observer() {
  if (observer_ != NULL) observer_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitDetection::observer() const {
  return observer_ != NULL ? *observer_ : *default_instance_->observer_;
}
inline ::Common::UnitId* MsgUnitDetection::mutable_observer() {
  _set_bit(0);
  if (observer_ == NULL) observer_ = new ::Common::UnitId;
  return observer_;
}

// required .Common.UnitId detected_unit = 2;
inline bool MsgUnitDetection::has_detected_unit() const {
  return _has_bit(1);
}
inline void MsgUnitDetection::clear_detected_unit() {
  if (detected_unit_ != NULL) detected_unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgUnitDetection::detected_unit() const {
  return detected_unit_ != NULL ? *detected_unit_ : *default_instance_->detected_unit_;
}
inline ::Common::UnitId* MsgUnitDetection::mutable_detected_unit() {
  _set_bit(1);
  if (detected_unit_ == NULL) detected_unit_ = new ::Common::UnitId;
  return detected_unit_;
}

// required .Common.EnumUnitVisibility current_visibility = 3;
inline bool MsgUnitDetection::has_current_visibility() const {
  return _has_bit(2);
}
inline void MsgUnitDetection::clear_current_visibility() {
  current_visibility_ = 0;
  _clear_bit(2);
}
inline Common::EnumUnitVisibility MsgUnitDetection::current_visibility() const {
  return static_cast< Common::EnumUnitVisibility >(current_visibility_);
}
inline void MsgUnitDetection::set_current_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(2);
  current_visibility_ = value;
}

// required .Common.EnumUnitVisibility max_visibility = 4;
inline bool MsgUnitDetection::has_max_visibility() const {
  return _has_bit(3);
}
inline void MsgUnitDetection::clear_max_visibility() {
  max_visibility_ = 0;
  _clear_bit(3);
}
inline Common::EnumUnitVisibility MsgUnitDetection::max_visibility() const {
  return static_cast< Common::EnumUnitVisibility >(max_visibility_);
}
inline void MsgUnitDetection::set_max_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(3);
  max_visibility_ = value;
}

// -------------------------------------------------------------------

// MsgObjectDetection

// required .Common.UnitId observer = 1;
inline bool MsgObjectDetection::has_observer() const {
  return _has_bit(0);
}
inline void MsgObjectDetection::clear_observer() {
  if (observer_ != NULL) observer_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgObjectDetection::observer() const {
  return observer_ != NULL ? *observer_ : *default_instance_->observer_;
}
inline ::Common::UnitId* MsgObjectDetection::mutable_observer() {
  _set_bit(0);
  if (observer_ == NULL) observer_ = new ::Common::UnitId;
  return observer_;
}

// required .Common.ObjectId detected_object = 2;
inline bool MsgObjectDetection::has_detected_object() const {
  return _has_bit(1);
}
inline void MsgObjectDetection::clear_detected_object() {
  if (detected_object_ != NULL) detected_object_->::Common::ObjectId::Clear();
  _clear_bit(1);
}
inline const ::Common::ObjectId& MsgObjectDetection::detected_object() const {
  return detected_object_ != NULL ? *detected_object_ : *default_instance_->detected_object_;
}
inline ::Common::ObjectId* MsgObjectDetection::mutable_detected_object() {
  _set_bit(1);
  if (detected_object_ == NULL) detected_object_ = new ::Common::ObjectId;
  return detected_object_;
}

// required .Common.EnumUnitVisibility visibility = 3;
inline bool MsgObjectDetection::has_visibility() const {
  return _has_bit(2);
}
inline void MsgObjectDetection::clear_visibility() {
  visibility_ = 0;
  _clear_bit(2);
}
inline Common::EnumUnitVisibility MsgObjectDetection::visibility() const {
  return static_cast< Common::EnumUnitVisibility >(visibility_);
}
inline void MsgObjectDetection::set_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(2);
  visibility_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdConcentrationDetection

// required .Common.UnitId observer = 1;
inline bool MsgCrowdConcentrationDetection::has_observer() const {
  return _has_bit(0);
}
inline void MsgCrowdConcentrationDetection::clear_observer() {
  if (observer_ != NULL) observer_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgCrowdConcentrationDetection::observer() const {
  return observer_ != NULL ? *observer_ : *default_instance_->observer_;
}
inline ::Common::UnitId* MsgCrowdConcentrationDetection::mutable_observer() {
  _set_bit(0);
  if (observer_ == NULL) observer_ = new ::Common::UnitId;
  return observer_;
}

// required .Common.CrowdId detected_crowd = 2;
inline bool MsgCrowdConcentrationDetection::has_detected_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdConcentrationDetection::clear_detected_crowd() {
  if (detected_crowd_ != NULL) detected_crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgCrowdConcentrationDetection::detected_crowd() const {
  return detected_crowd_ != NULL ? *detected_crowd_ : *default_instance_->detected_crowd_;
}
inline ::Common::CrowdId* MsgCrowdConcentrationDetection::mutable_detected_crowd() {
  _set_bit(1);
  if (detected_crowd_ == NULL) detected_crowd_ = new ::Common::CrowdId;
  return detected_crowd_;
}

// required .Common.CrowdConcentrationId detected_concentration = 3;
inline bool MsgCrowdConcentrationDetection::has_detected_concentration() const {
  return _has_bit(2);
}
inline void MsgCrowdConcentrationDetection::clear_detected_concentration() {
  if (detected_concentration_ != NULL) detected_concentration_->::Common::CrowdConcentrationId::Clear();
  _clear_bit(2);
}
inline const ::Common::CrowdConcentrationId& MsgCrowdConcentrationDetection::detected_concentration() const {
  return detected_concentration_ != NULL ? *detected_concentration_ : *default_instance_->detected_concentration_;
}
inline ::Common::CrowdConcentrationId* MsgCrowdConcentrationDetection::mutable_detected_concentration() {
  _set_bit(2);
  if (detected_concentration_ == NULL) detected_concentration_ = new ::Common::CrowdConcentrationId;
  return detected_concentration_;
}

// required .Common.EnumUnitVisibility visibility = 4;
inline bool MsgCrowdConcentrationDetection::has_visibility() const {
  return _has_bit(3);
}
inline void MsgCrowdConcentrationDetection::clear_visibility() {
  visibility_ = 0;
  _clear_bit(3);
}
inline Common::EnumUnitVisibility MsgCrowdConcentrationDetection::visibility() const {
  return static_cast< Common::EnumUnitVisibility >(visibility_);
}
inline void MsgCrowdConcentrationDetection::set_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(3);
  visibility_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdFlowDetection

// required .Common.UnitId observer = 1;
inline bool MsgCrowdFlowDetection::has_observer() const {
  return _has_bit(0);
}
inline void MsgCrowdFlowDetection::clear_observer() {
  if (observer_ != NULL) observer_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgCrowdFlowDetection::observer() const {
  return observer_ != NULL ? *observer_ : *default_instance_->observer_;
}
inline ::Common::UnitId* MsgCrowdFlowDetection::mutable_observer() {
  _set_bit(0);
  if (observer_ == NULL) observer_ = new ::Common::UnitId;
  return observer_;
}

// required .Common.CrowdId detected_crowd = 2;
inline bool MsgCrowdFlowDetection::has_detected_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdFlowDetection::clear_detected_crowd() {
  if (detected_crowd_ != NULL) detected_crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgCrowdFlowDetection::detected_crowd() const {
  return detected_crowd_ != NULL ? *detected_crowd_ : *default_instance_->detected_crowd_;
}
inline ::Common::CrowdId* MsgCrowdFlowDetection::mutable_detected_crowd() {
  _set_bit(1);
  if (detected_crowd_ == NULL) detected_crowd_ = new ::Common::CrowdId;
  return detected_crowd_;
}

// required .Common.CrowdFlowId detected_flow = 3;
inline bool MsgCrowdFlowDetection::has_detected_flow() const {
  return _has_bit(2);
}
inline void MsgCrowdFlowDetection::clear_detected_flow() {
  if (detected_flow_ != NULL) detected_flow_->::Common::CrowdFlowId::Clear();
  _clear_bit(2);
}
inline const ::Common::CrowdFlowId& MsgCrowdFlowDetection::detected_flow() const {
  return detected_flow_ != NULL ? *detected_flow_ : *default_instance_->detected_flow_;
}
inline ::Common::CrowdFlowId* MsgCrowdFlowDetection::mutable_detected_flow() {
  _set_bit(2);
  if (detected_flow_ == NULL) detected_flow_ = new ::Common::CrowdFlowId;
  return detected_flow_;
}

// required .Common.MsgPath visible_flow = 4;
inline bool MsgCrowdFlowDetection::has_visible_flow() const {
  return _has_bit(3);
}
inline void MsgCrowdFlowDetection::clear_visible_flow() {
  if (visible_flow_ != NULL) visible_flow_->::Common::MsgPath::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgPath& MsgCrowdFlowDetection::visible_flow() const {
  return visible_flow_ != NULL ? *visible_flow_ : *default_instance_->visible_flow_;
}
inline ::Common::MsgPath* MsgCrowdFlowDetection::mutable_visible_flow() {
  _set_bit(3);
  if (visible_flow_ == NULL) visible_flow_ = new ::Common::MsgPath;
  return visible_flow_;
}

// -------------------------------------------------------------------

// MsgObjectCreation

// required .Common.ObjectId object = 1;
inline bool MsgObjectCreation::has_object() const {
  return _has_bit(0);
}
inline void MsgObjectCreation::clear_object() {
  if (object_ != NULL) object_->::Common::ObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectId& MsgObjectCreation::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Common::ObjectId* MsgObjectCreation::mutable_object() {
  _set_bit(0);
  if (object_ == NULL) object_ = new ::Common::ObjectId;
  return object_;
}

// required .Common.ObjectType type = 2;
inline bool MsgObjectCreation::has_type() const {
  return _has_bit(1);
}
inline void MsgObjectCreation::clear_type() {
  if (type_ != NULL) type_->::Common::ObjectType::Clear();
  _clear_bit(1);
}
inline const ::Common::ObjectType& MsgObjectCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::ObjectType* MsgObjectCreation::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::ObjectType;
  return type_;
}

// required string name = 3;
inline bool MsgObjectCreation::has_name() const {
  return _has_bit(2);
}
inline void MsgObjectCreation::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgObjectCreation::name() const {
  return *name_;
}
inline void MsgObjectCreation::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgObjectCreation::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgObjectCreation::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgObjectCreation::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .Common.PartyId party = 4;
inline bool MsgObjectCreation::has_party() const {
  return _has_bit(3);
}
inline void MsgObjectCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(3);
}
inline const ::Common::PartyId& MsgObjectCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgObjectCreation::mutable_party() {
  _set_bit(3);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required .Common.MsgLocation location = 5;
inline bool MsgObjectCreation::has_location() const {
  return _has_bit(4);
}
inline void MsgObjectCreation::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgLocation& MsgObjectCreation::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgObjectCreation::mutable_location() {
  _set_bit(4);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// required .Common.ObjectAttributes attributes = 6;
inline bool MsgObjectCreation::has_attributes() const {
  return _has_bit(5);
}
inline void MsgObjectCreation::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::ObjectAttributes::Clear();
  _clear_bit(5);
}
inline const ::Common::ObjectAttributes& MsgObjectCreation::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::ObjectAttributes* MsgObjectCreation::mutable_attributes() {
  _set_bit(5);
  if (attributes_ == NULL) attributes_ = new ::Common::ObjectAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgObjectDestruction

// required .Common.ObjectId object = 1;
inline bool MsgObjectDestruction::has_object() const {
  return _has_bit(0);
}
inline void MsgObjectDestruction::clear_object() {
  if (object_ != NULL) object_->::Common::ObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectId& MsgObjectDestruction::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Common::ObjectId* MsgObjectDestruction::mutable_object() {
  _set_bit(0);
  if (object_ == NULL) object_ = new ::Common::ObjectId;
  return object_;
}

// -------------------------------------------------------------------

// MsgObjectUpdate

// required .Common.ObjectId object = 1;
inline bool MsgObjectUpdate::has_object() const {
  return _has_bit(0);
}
inline void MsgObjectUpdate::clear_object() {
  if (object_ != NULL) object_->::Common::ObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectId& MsgObjectUpdate::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Common::ObjectId* MsgObjectUpdate::mutable_object() {
  _set_bit(0);
  if (object_ == NULL) object_ = new ::Common::ObjectId;
  return object_;
}

// optional .Common.MsgLocation location = 2;
inline bool MsgObjectUpdate::has_location() const {
  return _has_bit(1);
}
inline void MsgObjectUpdate::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgLocation& MsgObjectUpdate::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgObjectUpdate::mutable_location() {
  _set_bit(1);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// required .Common.ObjectAttributes attributes = 3;
inline bool MsgObjectUpdate::has_attributes() const {
  return _has_bit(2);
}
inline void MsgObjectUpdate::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::ObjectAttributes::Clear();
  _clear_bit(2);
}
inline const ::Common::ObjectAttributes& MsgObjectUpdate::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::ObjectAttributes* MsgObjectUpdate::mutable_attributes() {
  _set_bit(2);
  if (attributes_ == NULL) attributes_ = new ::Common::ObjectAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgObjectKnowledgeCreation

// required .Common.ObjectKnowledgeId knowledge = 1;
inline bool MsgObjectKnowledgeCreation::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgObjectKnowledgeCreation::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::ObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectKnowledgeId& MsgObjectKnowledgeCreation::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::ObjectKnowledgeId* MsgObjectKnowledgeCreation::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::ObjectKnowledgeId;
  return knowledge_;
}

// required .Common.PartyId party = 2;
inline bool MsgObjectKnowledgeCreation::has_party() const {
  return _has_bit(1);
}
inline void MsgObjectKnowledgeCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgObjectKnowledgeCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgObjectKnowledgeCreation::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required .Common.ObjectId object = 3;
inline bool MsgObjectKnowledgeCreation::has_object() const {
  return _has_bit(2);
}
inline void MsgObjectKnowledgeCreation::clear_object() {
  if (object_ != NULL) object_->::Common::ObjectId::Clear();
  _clear_bit(2);
}
inline const ::Common::ObjectId& MsgObjectKnowledgeCreation::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Common::ObjectId* MsgObjectKnowledgeCreation::mutable_object() {
  _set_bit(2);
  if (object_ == NULL) object_ = new ::Common::ObjectId;
  return object_;
}

// required .Common.ObjectType type = 4;
inline bool MsgObjectKnowledgeCreation::has_type() const {
  return _has_bit(3);
}
inline void MsgObjectKnowledgeCreation::clear_type() {
  if (type_ != NULL) type_->::Common::ObjectType::Clear();
  _clear_bit(3);
}
inline const ::Common::ObjectType& MsgObjectKnowledgeCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::ObjectType* MsgObjectKnowledgeCreation::mutable_type() {
  _set_bit(3);
  if (type_ == NULL) type_ = new ::Common::ObjectType;
  return type_;
}

// required .Common.ObjectAttributes attributes = 5;
inline bool MsgObjectKnowledgeCreation::has_attributes() const {
  return _has_bit(4);
}
inline void MsgObjectKnowledgeCreation::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::ObjectAttributes::Clear();
  _clear_bit(4);
}
inline const ::Common::ObjectAttributes& MsgObjectKnowledgeCreation::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::ObjectAttributes* MsgObjectKnowledgeCreation::mutable_attributes() {
  _set_bit(4);
  if (attributes_ == NULL) attributes_ = new ::Common::ObjectAttributes;
  return attributes_;
}

// optional .Common.KnowledgeGroupId knowledge_group = 6;
inline bool MsgObjectKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(5);
}
inline void MsgObjectKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(5);
}
inline const ::Common::KnowledgeGroupId& MsgObjectKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgObjectKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(5);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgObjectKnowledgeUpdate

// required .Common.ObjectKnowledgeId knowledge = 1;
inline bool MsgObjectKnowledgeUpdate::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgObjectKnowledgeUpdate::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::ObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectKnowledgeId& MsgObjectKnowledgeUpdate::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::ObjectKnowledgeId* MsgObjectKnowledgeUpdate::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::ObjectKnowledgeId;
  return knowledge_;
}

// required .Common.PartyId party = 2;
inline bool MsgObjectKnowledgeUpdate::has_party() const {
  return _has_bit(1);
}
inline void MsgObjectKnowledgeUpdate::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgObjectKnowledgeUpdate::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgObjectKnowledgeUpdate::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.ObjectId object = 3;
inline bool MsgObjectKnowledgeUpdate::has_object() const {
  return _has_bit(2);
}
inline void MsgObjectKnowledgeUpdate::clear_object() {
  if (object_ != NULL) object_->::Common::ObjectId::Clear();
  _clear_bit(2);
}
inline const ::Common::ObjectId& MsgObjectKnowledgeUpdate::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Common::ObjectId* MsgObjectKnowledgeUpdate::mutable_object() {
  _set_bit(2);
  if (object_ == NULL) object_ = new ::Common::ObjectId;
  return object_;
}

// optional int32 relevance = 4;
inline bool MsgObjectKnowledgeUpdate::has_relevance() const {
  return _has_bit(3);
}
inline void MsgObjectKnowledgeUpdate::clear_relevance() {
  relevance_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgObjectKnowledgeUpdate::relevance() const {
  return relevance_;
}
inline void MsgObjectKnowledgeUpdate::set_relevance(::google::protobuf::int32 value) {
  _set_bit(3);
  relevance_ = value;
}

// optional .Common.MsgLocation location = 5;
inline bool MsgObjectKnowledgeUpdate::has_location() const {
  return _has_bit(4);
}
inline void MsgObjectKnowledgeUpdate::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgLocation& MsgObjectKnowledgeUpdate::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgObjectKnowledgeUpdate::mutable_location() {
  _set_bit(4);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// optional .Common.ObjectAttributes attributes = 6;
inline bool MsgObjectKnowledgeUpdate::has_attributes() const {
  return _has_bit(5);
}
inline void MsgObjectKnowledgeUpdate::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::ObjectAttributes::Clear();
  _clear_bit(5);
}
inline const ::Common::ObjectAttributes& MsgObjectKnowledgeUpdate::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::ObjectAttributes* MsgObjectKnowledgeUpdate::mutable_attributes() {
  _set_bit(5);
  if (attributes_ == NULL) attributes_ = new ::Common::ObjectAttributes;
  return attributes_;
}

// optional bool perceived = 7;
inline bool MsgObjectKnowledgeUpdate::has_perceived() const {
  return _has_bit(6);
}
inline void MsgObjectKnowledgeUpdate::clear_perceived() {
  perceived_ = false;
  _clear_bit(6);
}
inline bool MsgObjectKnowledgeUpdate::perceived() const {
  return perceived_;
}
inline void MsgObjectKnowledgeUpdate::set_perceived(bool value) {
  _set_bit(6);
  perceived_ = value;
}

// optional .Common.AutomatIdList perceiving_automats = 8;
inline bool MsgObjectKnowledgeUpdate::has_perceiving_automats() const {
  return _has_bit(7);
}
inline void MsgObjectKnowledgeUpdate::clear_perceiving_automats() {
  if (perceiving_automats_ != NULL) perceiving_automats_->::Common::AutomatIdList::Clear();
  _clear_bit(7);
}
inline const ::Common::AutomatIdList& MsgObjectKnowledgeUpdate::perceiving_automats() const {
  return perceiving_automats_ != NULL ? *perceiving_automats_ : *default_instance_->perceiving_automats_;
}
inline ::Common::AutomatIdList* MsgObjectKnowledgeUpdate::mutable_perceiving_automats() {
  _set_bit(7);
  if (perceiving_automats_ == NULL) perceiving_automats_ = new ::Common::AutomatIdList;
  return perceiving_automats_;
}

// optional .Common.KnowledgeGroupId knowledge_group = 9;
inline bool MsgObjectKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(8);
}
inline void MsgObjectKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(8);
}
inline const ::Common::KnowledgeGroupId& MsgObjectKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgObjectKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(8);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgObjectKnowledgeDestruction

// required .Common.ObjectKnowledgeId knowledge = 1;
inline bool MsgObjectKnowledgeDestruction::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgObjectKnowledgeDestruction::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::ObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectKnowledgeId& MsgObjectKnowledgeDestruction::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::ObjectKnowledgeId* MsgObjectKnowledgeDestruction::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::ObjectKnowledgeId;
  return knowledge_;
}

// required .Common.PartyId party = 2;
inline bool MsgObjectKnowledgeDestruction::has_party() const {
  return _has_bit(1);
}
inline void MsgObjectKnowledgeDestruction::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgObjectKnowledgeDestruction::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgObjectKnowledgeDestruction::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgUrbanKnowledgeCreation

// required .Common.UrbanObjectKnowledgeId knowledge = 1;
inline bool MsgUrbanKnowledgeCreation::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgUrbanKnowledgeCreation::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::UrbanObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UrbanObjectKnowledgeId& MsgUrbanKnowledgeCreation::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::UrbanObjectKnowledgeId* MsgUrbanKnowledgeCreation::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::UrbanObjectKnowledgeId;
  return knowledge_;
}

// required .Common.PartyId party = 2;
inline bool MsgUrbanKnowledgeCreation::has_party() const {
  return _has_bit(1);
}
inline void MsgUrbanKnowledgeCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgUrbanKnowledgeCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgUrbanKnowledgeCreation::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required .Common.UrbanObjectId urban_block = 3;
inline bool MsgUrbanKnowledgeCreation::has_urban_block() const {
  return _has_bit(2);
}
inline void MsgUrbanKnowledgeCreation::clear_urban_block() {
  if (urban_block_ != NULL) urban_block_->::Common::UrbanObjectId::Clear();
  _clear_bit(2);
}
inline const ::Common::UrbanObjectId& MsgUrbanKnowledgeCreation::urban_block() const {
  return urban_block_ != NULL ? *urban_block_ : *default_instance_->urban_block_;
}
inline ::Common::UrbanObjectId* MsgUrbanKnowledgeCreation::mutable_urban_block() {
  _set_bit(2);
  if (urban_block_ == NULL) urban_block_ = new ::Common::UrbanObjectId;
  return urban_block_;
}

// -------------------------------------------------------------------

// MsgUrbanKnowledgeUpdate

// required .Common.UrbanObjectKnowledgeId knowledge = 1;
inline bool MsgUrbanKnowledgeUpdate::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgUrbanKnowledgeUpdate::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::UrbanObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UrbanObjectKnowledgeId& MsgUrbanKnowledgeUpdate::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::UrbanObjectKnowledgeId* MsgUrbanKnowledgeUpdate::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::UrbanObjectKnowledgeId;
  return knowledge_;
}

// required .Common.PartyId party = 2;
inline bool MsgUrbanKnowledgeUpdate::has_party() const {
  return _has_bit(1);
}
inline void MsgUrbanKnowledgeUpdate::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgUrbanKnowledgeUpdate::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgUrbanKnowledgeUpdate::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required .Common.UrbanObjectId urban_block = 3;
inline bool MsgUrbanKnowledgeUpdate::has_urban_block() const {
  return _has_bit(2);
}
inline void MsgUrbanKnowledgeUpdate::clear_urban_block() {
  if (urban_block_ != NULL) urban_block_->::Common::UrbanObjectId::Clear();
  _clear_bit(2);
}
inline const ::Common::UrbanObjectId& MsgUrbanKnowledgeUpdate::urban_block() const {
  return urban_block_ != NULL ? *urban_block_ : *default_instance_->urban_block_;
}
inline ::Common::UrbanObjectId* MsgUrbanKnowledgeUpdate::mutable_urban_block() {
  _set_bit(2);
  if (urban_block_ == NULL) urban_block_ = new ::Common::UrbanObjectId;
  return urban_block_;
}

// optional int32 progress = 4;
inline bool MsgUrbanKnowledgeUpdate::has_progress() const {
  return _has_bit(3);
}
inline void MsgUrbanKnowledgeUpdate::clear_progress() {
  progress_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgUrbanKnowledgeUpdate::progress() const {
  return progress_;
}
inline void MsgUrbanKnowledgeUpdate::set_progress(::google::protobuf::int32 value) {
  _set_bit(3);
  progress_ = value;
}

// optional int32 max_progress = 5;
inline bool MsgUrbanKnowledgeUpdate::has_max_progress() const {
  return _has_bit(4);
}
inline void MsgUrbanKnowledgeUpdate::clear_max_progress() {
  max_progress_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgUrbanKnowledgeUpdate::max_progress() const {
  return max_progress_;
}
inline void MsgUrbanKnowledgeUpdate::set_max_progress(::google::protobuf::int32 value) {
  _set_bit(4);
  max_progress_ = value;
}

// optional bool perceived = 6;
inline bool MsgUrbanKnowledgeUpdate::has_perceived() const {
  return _has_bit(5);
}
inline void MsgUrbanKnowledgeUpdate::clear_perceived() {
  perceived_ = false;
  _clear_bit(5);
}
inline bool MsgUrbanKnowledgeUpdate::perceived() const {
  return perceived_;
}
inline void MsgUrbanKnowledgeUpdate::set_perceived(bool value) {
  _set_bit(5);
  perceived_ = value;
}

// optional .Common.AutomatIdList automat_perceptions = 7;
inline bool MsgUrbanKnowledgeUpdate::has_automat_perceptions() const {
  return _has_bit(6);
}
inline void MsgUrbanKnowledgeUpdate::clear_automat_perceptions() {
  if (automat_perceptions_ != NULL) automat_perceptions_->::Common::AutomatIdList::Clear();
  _clear_bit(6);
}
inline const ::Common::AutomatIdList& MsgUrbanKnowledgeUpdate::automat_perceptions() const {
  return automat_perceptions_ != NULL ? *automat_perceptions_ : *default_instance_->automat_perceptions_;
}
inline ::Common::AutomatIdList* MsgUrbanKnowledgeUpdate::mutable_automat_perceptions() {
  _set_bit(6);
  if (automat_perceptions_ == NULL) automat_perceptions_ = new ::Common::AutomatIdList;
  return automat_perceptions_;
}

// -------------------------------------------------------------------

// MsgUrbanKnowledgeDestruction

// required .Common.UrbanObjectKnowledgeId knowledge = 1;
inline bool MsgUrbanKnowledgeDestruction::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgUrbanKnowledgeDestruction::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::UrbanObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UrbanObjectKnowledgeId& MsgUrbanKnowledgeDestruction::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::UrbanObjectKnowledgeId* MsgUrbanKnowledgeDestruction::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::UrbanObjectKnowledgeId;
  return knowledge_;
}

// required .Common.PartyId party = 2;
inline bool MsgUrbanKnowledgeDestruction::has_party() const {
  return _has_bit(1);
}
inline void MsgUrbanKnowledgeDestruction::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgUrbanKnowledgeDestruction::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgUrbanKnowledgeDestruction::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgLogMedicalHandlingCreation

// required .Common.MedicalRequestId request = 1;
inline bool MsgLogMedicalHandlingCreation::has_request() const {
  return _has_bit(0);
}
inline void MsgLogMedicalHandlingCreation::clear_request() {
  if (request_ != NULL) request_->::Common::MedicalRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MedicalRequestId& MsgLogMedicalHandlingCreation::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::MedicalRequestId* MsgLogMedicalHandlingCreation::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::MedicalRequestId;
  return request_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMedicalHandlingCreation::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMedicalHandlingCreation::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMedicalHandlingCreation::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMedicalHandlingCreation::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required int32 tick_creation = 3;
inline bool MsgLogMedicalHandlingCreation::has_tick_creation() const {
  return _has_bit(2);
}
inline void MsgLogMedicalHandlingCreation::clear_tick_creation() {
  tick_creation_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogMedicalHandlingCreation::tick_creation() const {
  return tick_creation_;
}
inline void MsgLogMedicalHandlingCreation::set_tick_creation(::google::protobuf::int32 value) {
  _set_bit(2);
  tick_creation_ = value;
}

// required .Common.EnumHumanRank rang = 4;
inline bool MsgLogMedicalHandlingCreation::has_rang() const {
  return _has_bit(3);
}
inline void MsgLogMedicalHandlingCreation::clear_rang() {
  rang_ = 0;
  _clear_bit(3);
}
inline Common::EnumHumanRank MsgLogMedicalHandlingCreation::rang() const {
  return static_cast< Common::EnumHumanRank >(rang_);
}
inline void MsgLogMedicalHandlingCreation::set_rang(Common::EnumHumanRank value) {
  GOOGLE_DCHECK(Common::EnumHumanRank_IsValid(value));
  _set_bit(3);
  rang_ = value;
}

// required .Common.EnumHumanWound blessure = 5;
inline bool MsgLogMedicalHandlingCreation::has_blessure() const {
  return _has_bit(4);
}
inline void MsgLogMedicalHandlingCreation::clear_blessure() {
  blessure_ = 0;
  _clear_bit(4);
}
inline Common::EnumHumanWound MsgLogMedicalHandlingCreation::blessure() const {
  return static_cast< Common::EnumHumanWound >(blessure_);
}
inline void MsgLogMedicalHandlingCreation::set_blessure(Common::EnumHumanWound value) {
  GOOGLE_DCHECK(Common::EnumHumanWound_IsValid(value));
  _set_bit(4);
  blessure_ = value;
}

// optional bool blesse_mental = 6;
inline bool MsgLogMedicalHandlingCreation::has_blesse_mental() const {
  return _has_bit(5);
}
inline void MsgLogMedicalHandlingCreation::clear_blesse_mental() {
  blesse_mental_ = false;
  _clear_bit(5);
}
inline bool MsgLogMedicalHandlingCreation::blesse_mental() const {
  return blesse_mental_;
}
inline void MsgLogMedicalHandlingCreation::set_blesse_mental(bool value) {
  _set_bit(5);
  blesse_mental_ = value;
}

// optional bool contamine_nbc = 7;
inline bool MsgLogMedicalHandlingCreation::has_contamine_nbc() const {
  return _has_bit(6);
}
inline void MsgLogMedicalHandlingCreation::clear_contamine_nbc() {
  contamine_nbc_ = false;
  _clear_bit(6);
}
inline bool MsgLogMedicalHandlingCreation::contamine_nbc() const {
  return contamine_nbc_;
}
inline void MsgLogMedicalHandlingCreation::set_contamine_nbc(bool value) {
  _set_bit(6);
  contamine_nbc_ = value;
}

// -------------------------------------------------------------------

// MsgLogMedicalHandlingUpdate

// required .Common.MedicalRequestId request = 1;
inline bool MsgLogMedicalHandlingUpdate::has_request() const {
  return _has_bit(0);
}
inline void MsgLogMedicalHandlingUpdate::clear_request() {
  if (request_ != NULL) request_->::Common::MedicalRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MedicalRequestId& MsgLogMedicalHandlingUpdate::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::MedicalRequestId* MsgLogMedicalHandlingUpdate::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::MedicalRequestId;
  return request_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMedicalHandlingUpdate::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMedicalHandlingUpdate::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMedicalHandlingUpdate::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMedicalHandlingUpdate::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// optional .Common.UnitId provider = 3;
inline bool MsgLogMedicalHandlingUpdate::has_provider() const {
  return _has_bit(2);
}
inline void MsgLogMedicalHandlingUpdate::clear_provider() {
  if (provider_ != NULL) provider_->::Common::UnitId::Clear();
  _clear_bit(2);
}
inline const ::Common::UnitId& MsgLogMedicalHandlingUpdate::provider() const {
  return provider_ != NULL ? *provider_ : *default_instance_->provider_;
}
inline ::Common::UnitId* MsgLogMedicalHandlingUpdate::mutable_provider() {
  _set_bit(2);
  if (provider_ == NULL) provider_ = new ::Common::UnitId;
  return provider_;
}

// optional .Common.EnumHumanWound blessure = 4;
inline bool MsgLogMedicalHandlingUpdate::has_blessure() const {
  return _has_bit(3);
}
inline void MsgLogMedicalHandlingUpdate::clear_blessure() {
  blessure_ = 0;
  _clear_bit(3);
}
inline Common::EnumHumanWound MsgLogMedicalHandlingUpdate::blessure() const {
  return static_cast< Common::EnumHumanWound >(blessure_);
}
inline void MsgLogMedicalHandlingUpdate::set_blessure(Common::EnumHumanWound value) {
  GOOGLE_DCHECK(Common::EnumHumanWound_IsValid(value));
  _set_bit(3);
  blessure_ = value;
}

// optional bool blesse_mental = 5;
inline bool MsgLogMedicalHandlingUpdate::has_blesse_mental() const {
  return _has_bit(4);
}
inline void MsgLogMedicalHandlingUpdate::clear_blesse_mental() {
  blesse_mental_ = false;
  _clear_bit(4);
}
inline bool MsgLogMedicalHandlingUpdate::blesse_mental() const {
  return blesse_mental_;
}
inline void MsgLogMedicalHandlingUpdate::set_blesse_mental(bool value) {
  _set_bit(4);
  blesse_mental_ = value;
}

// optional bool contamine_nbc = 6;
inline bool MsgLogMedicalHandlingUpdate::has_contamine_nbc() const {
  return _has_bit(5);
}
inline void MsgLogMedicalHandlingUpdate::clear_contamine_nbc() {
  contamine_nbc_ = false;
  _clear_bit(5);
}
inline bool MsgLogMedicalHandlingUpdate::contamine_nbc() const {
  return contamine_nbc_;
}
inline void MsgLogMedicalHandlingUpdate::set_contamine_nbc(bool value) {
  _set_bit(5);
  contamine_nbc_ = value;
}

// optional .Common.EnumLogMedicalHandlingStatus etat = 7;
inline bool MsgLogMedicalHandlingUpdate::has_etat() const {
  return _has_bit(6);
}
inline void MsgLogMedicalHandlingUpdate::clear_etat() {
  etat_ = 0;
  _clear_bit(6);
}
inline Common::EnumLogMedicalHandlingStatus MsgLogMedicalHandlingUpdate::etat() const {
  return static_cast< Common::EnumLogMedicalHandlingStatus >(etat_);
}
inline void MsgLogMedicalHandlingUpdate::set_etat(Common::EnumLogMedicalHandlingStatus value) {
  GOOGLE_DCHECK(Common::EnumLogMedicalHandlingStatus_IsValid(value));
  _set_bit(6);
  etat_ = value;
}

// optional bool diagnostique_effectue = 8;
inline bool MsgLogMedicalHandlingUpdate::has_diagnostique_effectue() const {
  return _has_bit(7);
}
inline void MsgLogMedicalHandlingUpdate::clear_diagnostique_effectue() {
  diagnostique_effectue_ = false;
  _clear_bit(7);
}
inline bool MsgLogMedicalHandlingUpdate::diagnostique_effectue() const {
  return diagnostique_effectue_;
}
inline void MsgLogMedicalHandlingUpdate::set_diagnostique_effectue(bool value) {
  _set_bit(7);
  diagnostique_effectue_ = value;
}

// -------------------------------------------------------------------

// MsgLogMedicalHandlingDestruction

// required .Common.MedicalRequestId request = 1;
inline bool MsgLogMedicalHandlingDestruction::has_request() const {
  return _has_bit(0);
}
inline void MsgLogMedicalHandlingDestruction::clear_request() {
  if (request_ != NULL) request_->::Common::MedicalRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MedicalRequestId& MsgLogMedicalHandlingDestruction::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::MedicalRequestId* MsgLogMedicalHandlingDestruction::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::MedicalRequestId;
  return request_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMedicalHandlingDestruction::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMedicalHandlingDestruction::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMedicalHandlingDestruction::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMedicalHandlingDestruction::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// -------------------------------------------------------------------

// MsgLogMedicalEquipmentAvailability

// required .Common.EquipmentType equipment_type = 1;
inline bool MsgLogMedicalEquipmentAvailability::has_equipment_type() const {
  return _has_bit(0);
}
inline void MsgLogMedicalEquipmentAvailability::clear_equipment_type() {
  if (equipment_type_ != NULL) equipment_type_->::Common::EquipmentType::Clear();
  _clear_bit(0);
}
inline const ::Common::EquipmentType& MsgLogMedicalEquipmentAvailability::equipment_type() const {
  return equipment_type_ != NULL ? *equipment_type_ : *default_instance_->equipment_type_;
}
inline ::Common::EquipmentType* MsgLogMedicalEquipmentAvailability::mutable_equipment_type() {
  _set_bit(0);
  if (equipment_type_ == NULL) equipment_type_ = new ::Common::EquipmentType;
  return equipment_type_;
}

// required int32 nbr_total = 2;
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_total() const {
  return _has_bit(1);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_total() {
  nbr_total_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_total() const {
  return nbr_total_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_total(::google::protobuf::int32 value) {
  _set_bit(1);
  nbr_total_ = value;
}

// required int32 nbr_disponibles = 3;
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_disponibles() const {
  return _has_bit(2);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_disponibles() {
  nbr_disponibles_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_disponibles() const {
  return nbr_disponibles_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_disponibles(::google::protobuf::int32 value) {
  _set_bit(2);
  nbr_disponibles_ = value;
}

// required int32 nbr_au_travail = 4;
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_au_travail() const {
  return _has_bit(3);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_au_travail() {
  nbr_au_travail_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_au_travail() const {
  return nbr_au_travail_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_au_travail(::google::protobuf::int32 value) {
  _set_bit(3);
  nbr_au_travail_ = value;
}

// optional int32 nbr_pretes = 5;
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_pretes() const {
  return _has_bit(4);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_pretes() {
  nbr_pretes_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_pretes() const {
  return nbr_pretes_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_pretes(::google::protobuf::int32 value) {
  _set_bit(4);
  nbr_pretes_ = value;
}

// optional int32 nbr_au_repos = 6;
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_au_repos() const {
  return _has_bit(5);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_au_repos() {
  nbr_au_repos_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_au_repos() const {
  return nbr_au_repos_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_au_repos(::google::protobuf::int32 value) {
  _set_bit(5);
  nbr_au_repos_ = value;
}

// -------------------------------------------------------------------

// SeqOfLogMedicalEquipmentAvailability

// repeated .MsgsSimToClient.MsgLogMedicalEquipmentAvailability elem = 1;
inline int SeqOfLogMedicalEquipmentAvailability::elem_size() const {
  return elem_.size();
}
inline void SeqOfLogMedicalEquipmentAvailability::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability >&
SeqOfLogMedicalEquipmentAvailability::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability >*
SeqOfLogMedicalEquipmentAvailability::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability& SeqOfLogMedicalEquipmentAvailability::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability* SeqOfLogMedicalEquipmentAvailability::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability* SeqOfLogMedicalEquipmentAvailability::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgLogMedicalState

// required .Common.UnitId unit = 1;
inline bool MsgLogMedicalState::has_unit() const {
  return _has_bit(0);
}
inline void MsgLogMedicalState::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgLogMedicalState::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMedicalState::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// optional bool chaine_activee = 2;
inline bool MsgLogMedicalState::has_chaine_activee() const {
  return _has_bit(1);
}
inline void MsgLogMedicalState::clear_chaine_activee() {
  chaine_activee_ = false;
  _clear_bit(1);
}
inline bool MsgLogMedicalState::chaine_activee() const {
  return chaine_activee_;
}
inline void MsgLogMedicalState::set_chaine_activee(bool value) {
  _set_bit(1);
  chaine_activee_ = value;
}

// optional .Common.MsgLogMedicalPriorities priorites = 3;
inline bool MsgLogMedicalState::has_priorites() const {
  return _has_bit(2);
}
inline void MsgLogMedicalState::clear_priorites() {
  if (priorites_ != NULL) priorites_->::Common::MsgLogMedicalPriorities::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgLogMedicalPriorities& MsgLogMedicalState::priorites() const {
  return priorites_ != NULL ? *priorites_ : *default_instance_->priorites_;
}
inline ::Common::MsgLogMedicalPriorities* MsgLogMedicalState::mutable_priorites() {
  _set_bit(2);
  if (priorites_ == NULL) priorites_ = new ::Common::MsgLogMedicalPriorities;
  return priorites_;
}

// optional .Common.AutomatIdList tactical_priorities = 4;
inline bool MsgLogMedicalState::has_tactical_priorities() const {
  return _has_bit(3);
}
inline void MsgLogMedicalState::clear_tactical_priorities() {
  if (tactical_priorities_ != NULL) tactical_priorities_->::Common::AutomatIdList::Clear();
  _clear_bit(3);
}
inline const ::Common::AutomatIdList& MsgLogMedicalState::tactical_priorities() const {
  return tactical_priorities_ != NULL ? *tactical_priorities_ : *default_instance_->tactical_priorities_;
}
inline ::Common::AutomatIdList* MsgLogMedicalState::mutable_tactical_priorities() {
  _set_bit(3);
  if (tactical_priorities_ == NULL) tactical_priorities_ = new ::Common::AutomatIdList;
  return tactical_priorities_;
}

// optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_releve = 5;
inline bool MsgLogMedicalState::has_disponibilites_ambulances_releve() const {
  return _has_bit(4);
}
inline void MsgLogMedicalState::clear_disponibilites_ambulances_releve() {
  if (disponibilites_ambulances_releve_ != NULL) disponibilites_ambulances_releve_->::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability::Clear();
  _clear_bit(4);
}
inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& MsgLogMedicalState::disponibilites_ambulances_releve() const {
  return disponibilites_ambulances_releve_ != NULL ? *disponibilites_ambulances_releve_ : *default_instance_->disponibilites_ambulances_releve_;
}
inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* MsgLogMedicalState::mutable_disponibilites_ambulances_releve() {
  _set_bit(4);
  if (disponibilites_ambulances_releve_ == NULL) disponibilites_ambulances_releve_ = new ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability;
  return disponibilites_ambulances_releve_;
}

// optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_ramassage = 6;
inline bool MsgLogMedicalState::has_disponibilites_ambulances_ramassage() const {
  return _has_bit(5);
}
inline void MsgLogMedicalState::clear_disponibilites_ambulances_ramassage() {
  if (disponibilites_ambulances_ramassage_ != NULL) disponibilites_ambulances_ramassage_->::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability::Clear();
  _clear_bit(5);
}
inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& MsgLogMedicalState::disponibilites_ambulances_ramassage() const {
  return disponibilites_ambulances_ramassage_ != NULL ? *disponibilites_ambulances_ramassage_ : *default_instance_->disponibilites_ambulances_ramassage_;
}
inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* MsgLogMedicalState::mutable_disponibilites_ambulances_ramassage() {
  _set_bit(5);
  if (disponibilites_ambulances_ramassage_ == NULL) disponibilites_ambulances_ramassage_ = new ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability;
  return disponibilites_ambulances_ramassage_;
}

// optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_medecins = 7;
inline bool MsgLogMedicalState::has_disponibilites_medecins() const {
  return _has_bit(6);
}
inline void MsgLogMedicalState::clear_disponibilites_medecins() {
  if (disponibilites_medecins_ != NULL) disponibilites_medecins_->::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability::Clear();
  _clear_bit(6);
}
inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& MsgLogMedicalState::disponibilites_medecins() const {
  return disponibilites_medecins_ != NULL ? *disponibilites_medecins_ : *default_instance_->disponibilites_medecins_;
}
inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* MsgLogMedicalState::mutable_disponibilites_medecins() {
  _set_bit(6);
  if (disponibilites_medecins_ == NULL) disponibilites_medecins_ = new ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability;
  return disponibilites_medecins_;
}

// -------------------------------------------------------------------

// MsgLogMaintenanceHandlingCreation

// required .Common.MaintenanceRequestId request = 1;
inline bool MsgLogMaintenanceHandlingCreation::has_request() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceHandlingCreation::clear_request() {
  if (request_ != NULL) request_->::Common::MaintenanceRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MaintenanceRequestId& MsgLogMaintenanceHandlingCreation::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::MaintenanceRequestId* MsgLogMaintenanceHandlingCreation::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::MaintenanceRequestId;
  return request_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMaintenanceHandlingCreation::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceHandlingCreation::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMaintenanceHandlingCreation::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMaintenanceHandlingCreation::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required int32 tick_creation = 3;
inline bool MsgLogMaintenanceHandlingCreation::has_tick_creation() const {
  return _has_bit(2);
}
inline void MsgLogMaintenanceHandlingCreation::clear_tick_creation() {
  tick_creation_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogMaintenanceHandlingCreation::tick_creation() const {
  return tick_creation_;
}
inline void MsgLogMaintenanceHandlingCreation::set_tick_creation(::google::protobuf::int32 value) {
  _set_bit(2);
  tick_creation_ = value;
}

// required .Common.EquipmentType equipement = 4;
inline bool MsgLogMaintenanceHandlingCreation::has_equipement() const {
  return _has_bit(3);
}
inline void MsgLogMaintenanceHandlingCreation::clear_equipement() {
  if (equipement_ != NULL) equipement_->::Common::EquipmentType::Clear();
  _clear_bit(3);
}
inline const ::Common::EquipmentType& MsgLogMaintenanceHandlingCreation::equipement() const {
  return equipement_ != NULL ? *equipement_ : *default_instance_->equipement_;
}
inline ::Common::EquipmentType* MsgLogMaintenanceHandlingCreation::mutable_equipement() {
  _set_bit(3);
  if (equipement_ == NULL) equipement_ = new ::Common::EquipmentType;
  return equipement_;
}

// required .Common.BreakdownType breakdown = 5;
inline bool MsgLogMaintenanceHandlingCreation::has_breakdown() const {
  return _has_bit(4);
}
inline void MsgLogMaintenanceHandlingCreation::clear_breakdown() {
  if (breakdown_ != NULL) breakdown_->::Common::BreakdownType::Clear();
  _clear_bit(4);
}
inline const ::Common::BreakdownType& MsgLogMaintenanceHandlingCreation::breakdown() const {
  return breakdown_ != NULL ? *breakdown_ : *default_instance_->breakdown_;
}
inline ::Common::BreakdownType* MsgLogMaintenanceHandlingCreation::mutable_breakdown() {
  _set_bit(4);
  if (breakdown_ == NULL) breakdown_ = new ::Common::BreakdownType;
  return breakdown_;
}

// -------------------------------------------------------------------

// MsgLogMaintenanceHandlingUpdate

// required .Common.MaintenanceRequestId request = 1;
inline bool MsgLogMaintenanceHandlingUpdate::has_request() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_request() {
  if (request_ != NULL) request_->::Common::MaintenanceRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MaintenanceRequestId& MsgLogMaintenanceHandlingUpdate::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::MaintenanceRequestId* MsgLogMaintenanceHandlingUpdate::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::MaintenanceRequestId;
  return request_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMaintenanceHandlingUpdate::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMaintenanceHandlingUpdate::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMaintenanceHandlingUpdate::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required .Common.UnitId provider = 3;
inline bool MsgLogMaintenanceHandlingUpdate::has_provider() const {
  return _has_bit(2);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_provider() {
  if (provider_ != NULL) provider_->::Common::UnitId::Clear();
  _clear_bit(2);
}
inline const ::Common::UnitId& MsgLogMaintenanceHandlingUpdate::provider() const {
  return provider_ != NULL ? *provider_ : *default_instance_->provider_;
}
inline ::Common::UnitId* MsgLogMaintenanceHandlingUpdate::mutable_provider() {
  _set_bit(2);
  if (provider_ == NULL) provider_ = new ::Common::UnitId;
  return provider_;
}

// optional .Common.EnumLogMaintenanceHandlingStatus etat = 4;
inline bool MsgLogMaintenanceHandlingUpdate::has_etat() const {
  return _has_bit(3);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_etat() {
  etat_ = 0;
  _clear_bit(3);
}
inline Common::EnumLogMaintenanceHandlingStatus MsgLogMaintenanceHandlingUpdate::etat() const {
  return static_cast< Common::EnumLogMaintenanceHandlingStatus >(etat_);
}
inline void MsgLogMaintenanceHandlingUpdate::set_etat(Common::EnumLogMaintenanceHandlingStatus value) {
  GOOGLE_DCHECK(Common::EnumLogMaintenanceHandlingStatus_IsValid(value));
  _set_bit(3);
  etat_ = value;
}

// optional bool diagnostique_effectue = 5;
inline bool MsgLogMaintenanceHandlingUpdate::has_diagnostique_effectue() const {
  return _has_bit(4);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_diagnostique_effectue() {
  diagnostique_effectue_ = false;
  _clear_bit(4);
}
inline bool MsgLogMaintenanceHandlingUpdate::diagnostique_effectue() const {
  return diagnostique_effectue_;
}
inline void MsgLogMaintenanceHandlingUpdate::set_diagnostique_effectue(bool value) {
  _set_bit(4);
  diagnostique_effectue_ = value;
}

// -------------------------------------------------------------------

// MsgLogMaintenanceHandlingDestruction

// required .Common.MaintenanceRequestId request = 1;
inline bool MsgLogMaintenanceHandlingDestruction::has_request() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceHandlingDestruction::clear_request() {
  if (request_ != NULL) request_->::Common::MaintenanceRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MaintenanceRequestId& MsgLogMaintenanceHandlingDestruction::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::MaintenanceRequestId* MsgLogMaintenanceHandlingDestruction::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::MaintenanceRequestId;
  return request_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMaintenanceHandlingDestruction::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceHandlingDestruction::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMaintenanceHandlingDestruction::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMaintenanceHandlingDestruction::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// -------------------------------------------------------------------

// MsgLogMaintenanceEquipmentAvailability

// required .Common.EquipmentType equipment_type = 1;
inline bool MsgLogMaintenanceEquipmentAvailability::has_equipment_type() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_equipment_type() {
  if (equipment_type_ != NULL) equipment_type_->::Common::EquipmentType::Clear();
  _clear_bit(0);
}
inline const ::Common::EquipmentType& MsgLogMaintenanceEquipmentAvailability::equipment_type() const {
  return equipment_type_ != NULL ? *equipment_type_ : *default_instance_->equipment_type_;
}
inline ::Common::EquipmentType* MsgLogMaintenanceEquipmentAvailability::mutable_equipment_type() {
  _set_bit(0);
  if (equipment_type_ == NULL) equipment_type_ = new ::Common::EquipmentType;
  return equipment_type_;
}

// required int32 nbr_total = 2;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_total() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_total() {
  nbr_total_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_total() const {
  return nbr_total_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_total(::google::protobuf::int32 value) {
  _set_bit(1);
  nbr_total_ = value;
}

// required int32 nbr_disponibles = 3;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_disponibles() const {
  return _has_bit(2);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_disponibles() {
  nbr_disponibles_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_disponibles() const {
  return nbr_disponibles_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_disponibles(::google::protobuf::int32 value) {
  _set_bit(2);
  nbr_disponibles_ = value;
}

// required int32 nbr_au_travail = 4;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_au_travail() const {
  return _has_bit(3);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_au_travail() {
  nbr_au_travail_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_au_travail() const {
  return nbr_au_travail_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_au_travail(::google::protobuf::int32 value) {
  _set_bit(3);
  nbr_au_travail_ = value;
}

// optional int32 nbr_pretes = 5;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_pretes() const {
  return _has_bit(4);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_pretes() {
  nbr_pretes_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_pretes() const {
  return nbr_pretes_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_pretes(::google::protobuf::int32 value) {
  _set_bit(4);
  nbr_pretes_ = value;
}

// optional int32 nbr_au_repos = 6;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_au_repos() const {
  return _has_bit(5);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_au_repos() {
  nbr_au_repos_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_au_repos() const {
  return nbr_au_repos_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_au_repos(::google::protobuf::int32 value) {
  _set_bit(5);
  nbr_au_repos_ = value;
}

// -------------------------------------------------------------------

// SeqOfLogMaintenanceEquipmentAvailability

// repeated .MsgsSimToClient.MsgLogMaintenanceEquipmentAvailability elem = 1;
inline int SeqOfLogMaintenanceEquipmentAvailability::elem_size() const {
  return elem_.size();
}
inline void SeqOfLogMaintenanceEquipmentAvailability::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability >&
SeqOfLogMaintenanceEquipmentAvailability::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability >*
SeqOfLogMaintenanceEquipmentAvailability::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability& SeqOfLogMaintenanceEquipmentAvailability::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability* SeqOfLogMaintenanceEquipmentAvailability::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability* SeqOfLogMaintenanceEquipmentAvailability::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgLogMaintenanceState

// required .Common.UnitId unit = 1;
inline bool MsgLogMaintenanceState::has_unit() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceState::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgLogMaintenanceState::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMaintenanceState::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// optional bool chaine_activee = 2;
inline bool MsgLogMaintenanceState::has_chaine_activee() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceState::clear_chaine_activee() {
  chaine_activee_ = false;
  _clear_bit(1);
}
inline bool MsgLogMaintenanceState::chaine_activee() const {
  return chaine_activee_;
}
inline void MsgLogMaintenanceState::set_chaine_activee(bool value) {
  _set_bit(1);
  chaine_activee_ = value;
}

// optional .Common.EnumLogMaintenanceRegimeTravail regime_travail = 3;
inline bool MsgLogMaintenanceState::has_regime_travail() const {
  return _has_bit(2);
}
inline void MsgLogMaintenanceState::clear_regime_travail() {
  regime_travail_ = 0;
  _clear_bit(2);
}
inline Common::EnumLogMaintenanceRegimeTravail MsgLogMaintenanceState::regime_travail() const {
  return static_cast< Common::EnumLogMaintenanceRegimeTravail >(regime_travail_);
}
inline void MsgLogMaintenanceState::set_regime_travail(Common::EnumLogMaintenanceRegimeTravail value) {
  GOOGLE_DCHECK(Common::EnumLogMaintenanceRegimeTravail_IsValid(value));
  _set_bit(2);
  regime_travail_ = value;
}

// optional .Common.MsgLogMaintenancePriorities priorites = 4;
inline bool MsgLogMaintenanceState::has_priorites() const {
  return _has_bit(3);
}
inline void MsgLogMaintenanceState::clear_priorites() {
  if (priorites_ != NULL) priorites_->::Common::MsgLogMaintenancePriorities::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgLogMaintenancePriorities& MsgLogMaintenanceState::priorites() const {
  return priorites_ != NULL ? *priorites_ : *default_instance_->priorites_;
}
inline ::Common::MsgLogMaintenancePriorities* MsgLogMaintenanceState::mutable_priorites() {
  _set_bit(3);
  if (priorites_ == NULL) priorites_ = new ::Common::MsgLogMaintenancePriorities;
  return priorites_;
}

// optional .Common.AutomatIdList priorites_tactiques = 5;
inline bool MsgLogMaintenanceState::has_priorites_tactiques() const {
  return _has_bit(4);
}
inline void MsgLogMaintenanceState::clear_priorites_tactiques() {
  if (priorites_tactiques_ != NULL) priorites_tactiques_->::Common::AutomatIdList::Clear();
  _clear_bit(4);
}
inline const ::Common::AutomatIdList& MsgLogMaintenanceState::priorites_tactiques() const {
  return priorites_tactiques_ != NULL ? *priorites_tactiques_ : *default_instance_->priorites_tactiques_;
}
inline ::Common::AutomatIdList* MsgLogMaintenanceState::mutable_priorites_tactiques() {
  _set_bit(4);
  if (priorites_tactiques_ == NULL) priorites_tactiques_ = new ::Common::AutomatIdList;
  return priorites_tactiques_;
}

// optional .MsgsSimToClient.SeqOfLogMaintenanceEquipmentAvailability disponibilites_remorqueurs = 6;
inline bool MsgLogMaintenanceState::has_disponibilites_remorqueurs() const {
  return _has_bit(5);
}
inline void MsgLogMaintenanceState::clear_disponibilites_remorqueurs() {
  if (disponibilites_remorqueurs_ != NULL) disponibilites_remorqueurs_->::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability::Clear();
  _clear_bit(5);
}
inline const ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability& MsgLogMaintenanceState::disponibilites_remorqueurs() const {
  return disponibilites_remorqueurs_ != NULL ? *disponibilites_remorqueurs_ : *default_instance_->disponibilites_remorqueurs_;
}
inline ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* MsgLogMaintenanceState::mutable_disponibilites_remorqueurs() {
  _set_bit(5);
  if (disponibilites_remorqueurs_ == NULL) disponibilites_remorqueurs_ = new ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability;
  return disponibilites_remorqueurs_;
}

// optional .MsgsSimToClient.SeqOfLogMaintenanceEquipmentAvailability disponibilites_reparateurs = 7;
inline bool MsgLogMaintenanceState::has_disponibilites_reparateurs() const {
  return _has_bit(6);
}
inline void MsgLogMaintenanceState::clear_disponibilites_reparateurs() {
  if (disponibilites_reparateurs_ != NULL) disponibilites_reparateurs_->::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability::Clear();
  _clear_bit(6);
}
inline const ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability& MsgLogMaintenanceState::disponibilites_reparateurs() const {
  return disponibilites_reparateurs_ != NULL ? *disponibilites_reparateurs_ : *default_instance_->disponibilites_reparateurs_;
}
inline ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* MsgLogMaintenanceState::mutable_disponibilites_reparateurs() {
  _set_bit(6);
  if (disponibilites_reparateurs_ == NULL) disponibilites_reparateurs_ = new ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability;
  return disponibilites_reparateurs_;
}

// -------------------------------------------------------------------

// MsgLogSupplyHandlingCreation

// optional .Common.SupplyRequestId request = 1;
inline bool MsgLogSupplyHandlingCreation::has_request() const {
  return _has_bit(0);
}
inline void MsgLogSupplyHandlingCreation::clear_request() {
  if (request_ != NULL) request_->::Common::SupplyRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::SupplyRequestId& MsgLogSupplyHandlingCreation::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::SupplyRequestId* MsgLogSupplyHandlingCreation::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::SupplyRequestId;
  return request_;
}

// optional .Common.AutomatId consumer = 2;
inline bool MsgLogSupplyHandlingCreation::has_consumer() const {
  return _has_bit(1);
}
inline void MsgLogSupplyHandlingCreation::clear_consumer() {
  if (consumer_ != NULL) consumer_->::Common::AutomatId::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingCreation::consumer() const {
  return consumer_ != NULL ? *consumer_ : *default_instance_->consumer_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingCreation::mutable_consumer() {
  _set_bit(1);
  if (consumer_ == NULL) consumer_ = new ::Common::AutomatId;
  return consumer_;
}

// optional int32 tick_creation = 3;
inline bool MsgLogSupplyHandlingCreation::has_tick_creation() const {
  return _has_bit(2);
}
inline void MsgLogSupplyHandlingCreation::clear_tick_creation() {
  tick_creation_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogSupplyHandlingCreation::tick_creation() const {
  return tick_creation_;
}
inline void MsgLogSupplyHandlingCreation::set_tick_creation(::google::protobuf::int32 value) {
  _set_bit(2);
  tick_creation_ = value;
}

// optional .MsgsSimToClient.SeqOfDotationQuery dotations = 4;
inline bool MsgLogSupplyHandlingCreation::has_dotations() const {
  return _has_bit(3);
}
inline void MsgLogSupplyHandlingCreation::clear_dotations() {
  if (dotations_ != NULL) dotations_->::MsgsSimToClient::SeqOfDotationQuery::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::SeqOfDotationQuery& MsgLogSupplyHandlingCreation::dotations() const {
  return dotations_ != NULL ? *dotations_ : *default_instance_->dotations_;
}
inline ::MsgsSimToClient::SeqOfDotationQuery* MsgLogSupplyHandlingCreation::mutable_dotations() {
  _set_bit(3);
  if (dotations_ == NULL) dotations_ = new ::MsgsSimToClient::SeqOfDotationQuery;
  return dotations_;
}

// -------------------------------------------------------------------

// MsgDotationQuery

// optional .Common.ResourceType resource = 1;
inline bool MsgDotationQuery::has_resource() const {
  return _has_bit(0);
}
inline void MsgDotationQuery::clear_resource() {
  if (resource_ != NULL) resource_->::Common::ResourceType::Clear();
  _clear_bit(0);
}
inline const ::Common::ResourceType& MsgDotationQuery::resource() const {
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::Common::ResourceType* MsgDotationQuery::mutable_resource() {
  _set_bit(0);
  if (resource_ == NULL) resource_ = new ::Common::ResourceType;
  return resource_;
}

// optional int32 quantite_demandee = 2;
inline bool MsgDotationQuery::has_quantite_demandee() const {
  return _has_bit(1);
}
inline void MsgDotationQuery::clear_quantite_demandee() {
  quantite_demandee_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgDotationQuery::quantite_demandee() const {
  return quantite_demandee_;
}
inline void MsgDotationQuery::set_quantite_demandee(::google::protobuf::int32 value) {
  _set_bit(1);
  quantite_demandee_ = value;
}

// optional int32 quantite_accordee = 3;
inline bool MsgDotationQuery::has_quantite_accordee() const {
  return _has_bit(2);
}
inline void MsgDotationQuery::clear_quantite_accordee() {
  quantite_accordee_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgDotationQuery::quantite_accordee() const {
  return quantite_accordee_;
}
inline void MsgDotationQuery::set_quantite_accordee(::google::protobuf::int32 value) {
  _set_bit(2);
  quantite_accordee_ = value;
}

// optional int32 quantite_en_transit = 4;
inline bool MsgDotationQuery::has_quantite_en_transit() const {
  return _has_bit(3);
}
inline void MsgDotationQuery::clear_quantite_en_transit() {
  quantite_en_transit_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgDotationQuery::quantite_en_transit() const {
  return quantite_en_transit_;
}
inline void MsgDotationQuery::set_quantite_en_transit(::google::protobuf::int32 value) {
  _set_bit(3);
  quantite_en_transit_ = value;
}

// -------------------------------------------------------------------

// SeqOfDotationQuery

// repeated .MsgsSimToClient.MsgDotationQuery elem = 1;
inline int SeqOfDotationQuery::elem_size() const {
  return elem_.size();
}
inline void SeqOfDotationQuery::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery >&
SeqOfDotationQuery::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery >*
SeqOfDotationQuery::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgDotationQuery& SeqOfDotationQuery::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgDotationQuery* SeqOfDotationQuery::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgDotationQuery* SeqOfDotationQuery::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgLogSupplyHandlingUpdate

// optional .Common.SupplyRequestId request = 1;
inline bool MsgLogSupplyHandlingUpdate::has_request() const {
  return _has_bit(0);
}
inline void MsgLogSupplyHandlingUpdate::clear_request() {
  if (request_ != NULL) request_->::Common::SupplyRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::SupplyRequestId& MsgLogSupplyHandlingUpdate::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::SupplyRequestId* MsgLogSupplyHandlingUpdate::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::SupplyRequestId;
  return request_;
}

// optional .Common.AutomatId consumer = 2;
inline bool MsgLogSupplyHandlingUpdate::has_consumer() const {
  return _has_bit(1);
}
inline void MsgLogSupplyHandlingUpdate::clear_consumer() {
  if (consumer_ != NULL) consumer_->::Common::AutomatId::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingUpdate::consumer() const {
  return consumer_ != NULL ? *consumer_ : *default_instance_->consumer_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingUpdate::mutable_consumer() {
  _set_bit(1);
  if (consumer_ == NULL) consumer_ = new ::Common::AutomatId;
  return consumer_;
}

// optional .Common.AutomatId supplier = 3;
inline bool MsgLogSupplyHandlingUpdate::has_supplier() const {
  return _has_bit(2);
}
inline void MsgLogSupplyHandlingUpdate::clear_supplier() {
  if (supplier_ != NULL) supplier_->::Common::AutomatId::Clear();
  _clear_bit(2);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingUpdate::supplier() const {
  return supplier_ != NULL ? *supplier_ : *default_instance_->supplier_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingUpdate::mutable_supplier() {
  _set_bit(2);
  if (supplier_ == NULL) supplier_ = new ::Common::AutomatId;
  return supplier_;
}

// optional .Common.AutomatId convoy_provider = 4;
inline bool MsgLogSupplyHandlingUpdate::has_convoy_provider() const {
  return _has_bit(3);
}
inline void MsgLogSupplyHandlingUpdate::clear_convoy_provider() {
  if (convoy_provider_ != NULL) convoy_provider_->::Common::AutomatId::Clear();
  _clear_bit(3);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingUpdate::convoy_provider() const {
  return convoy_provider_ != NULL ? *convoy_provider_ : *default_instance_->convoy_provider_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingUpdate::mutable_convoy_provider() {
  _set_bit(3);
  if (convoy_provider_ == NULL) convoy_provider_ = new ::Common::AutomatId;
  return convoy_provider_;
}

// optional .Common.UnitId convoying_unit = 5;
inline bool MsgLogSupplyHandlingUpdate::has_convoying_unit() const {
  return _has_bit(4);
}
inline void MsgLogSupplyHandlingUpdate::clear_convoying_unit() {
  if (convoying_unit_ != NULL) convoying_unit_->::Common::UnitId::Clear();
  _clear_bit(4);
}
inline const ::Common::UnitId& MsgLogSupplyHandlingUpdate::convoying_unit() const {
  return convoying_unit_ != NULL ? *convoying_unit_ : *default_instance_->convoying_unit_;
}
inline ::Common::UnitId* MsgLogSupplyHandlingUpdate::mutable_convoying_unit() {
  _set_bit(4);
  if (convoying_unit_ == NULL) convoying_unit_ = new ::Common::UnitId;
  return convoying_unit_;
}

// optional .MsgsSimToClient.EnumLogSupplyHandlingStatus etat = 6;
inline bool MsgLogSupplyHandlingUpdate::has_etat() const {
  return _has_bit(5);
}
inline void MsgLogSupplyHandlingUpdate::clear_etat() {
  etat_ = 1;
  _clear_bit(5);
}
inline MsgsSimToClient::EnumLogSupplyHandlingStatus MsgLogSupplyHandlingUpdate::etat() const {
  return static_cast< MsgsSimToClient::EnumLogSupplyHandlingStatus >(etat_);
}
inline void MsgLogSupplyHandlingUpdate::set_etat(MsgsSimToClient::EnumLogSupplyHandlingStatus value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumLogSupplyHandlingStatus_IsValid(value));
  _set_bit(5);
  etat_ = value;
}

// optional .MsgsSimToClient.SeqOfDotationQuery dotations = 7;
inline bool MsgLogSupplyHandlingUpdate::has_dotations() const {
  return _has_bit(6);
}
inline void MsgLogSupplyHandlingUpdate::clear_dotations() {
  if (dotations_ != NULL) dotations_->::MsgsSimToClient::SeqOfDotationQuery::Clear();
  _clear_bit(6);
}
inline const ::MsgsSimToClient::SeqOfDotationQuery& MsgLogSupplyHandlingUpdate::dotations() const {
  return dotations_ != NULL ? *dotations_ : *default_instance_->dotations_;
}
inline ::MsgsSimToClient::SeqOfDotationQuery* MsgLogSupplyHandlingUpdate::mutable_dotations() {
  _set_bit(6);
  if (dotations_ == NULL) dotations_ = new ::MsgsSimToClient::SeqOfDotationQuery;
  return dotations_;
}

// -------------------------------------------------------------------

// MsgLogSupplyHandlingDestruction

// required .Common.SupplyRequestId request = 1;
inline bool MsgLogSupplyHandlingDestruction::has_request() const {
  return _has_bit(0);
}
inline void MsgLogSupplyHandlingDestruction::clear_request() {
  if (request_ != NULL) request_->::Common::SupplyRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::SupplyRequestId& MsgLogSupplyHandlingDestruction::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::Common::SupplyRequestId* MsgLogSupplyHandlingDestruction::mutable_request() {
  _set_bit(0);
  if (request_ == NULL) request_ = new ::Common::SupplyRequestId;
  return request_;
}

// required .Common.AutomatId consumer = 2;
inline bool MsgLogSupplyHandlingDestruction::has_consumer() const {
  return _has_bit(1);
}
inline void MsgLogSupplyHandlingDestruction::clear_consumer() {
  if (consumer_ != NULL) consumer_->::Common::AutomatId::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingDestruction::consumer() const {
  return consumer_ != NULL ? *consumer_ : *default_instance_->consumer_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingDestruction::mutable_consumer() {
  _set_bit(1);
  if (consumer_ == NULL) consumer_ = new ::Common::AutomatId;
  return consumer_;
}

// -------------------------------------------------------------------

// MsgLogSupplyEquimentAvailability

// optional .Common.EquipmentType equipment = 1;
inline bool MsgLogSupplyEquimentAvailability::has_equipment() const {
  return _has_bit(0);
}
inline void MsgLogSupplyEquimentAvailability::clear_equipment() {
  if (equipment_ != NULL) equipment_->::Common::EquipmentType::Clear();
  _clear_bit(0);
}
inline const ::Common::EquipmentType& MsgLogSupplyEquimentAvailability::equipment() const {
  return equipment_ != NULL ? *equipment_ : *default_instance_->equipment_;
}
inline ::Common::EquipmentType* MsgLogSupplyEquimentAvailability::mutable_equipment() {
  _set_bit(0);
  if (equipment_ == NULL) equipment_ = new ::Common::EquipmentType;
  return equipment_;
}

// optional int32 nbr_total = 2;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_total() const {
  return _has_bit(1);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_total() {
  nbr_total_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_total() const {
  return nbr_total_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_total(::google::protobuf::int32 value) {
  _set_bit(1);
  nbr_total_ = value;
}

// optional int32 nbr_disponibles = 3;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_disponibles() const {
  return _has_bit(2);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_disponibles() {
  nbr_disponibles_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_disponibles() const {
  return nbr_disponibles_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_disponibles(::google::protobuf::int32 value) {
  _set_bit(2);
  nbr_disponibles_ = value;
}

// optional int32 nbr_au_travail = 4;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_au_travail() const {
  return _has_bit(3);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_au_travail() {
  nbr_au_travail_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_au_travail() const {
  return nbr_au_travail_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_au_travail(::google::protobuf::int32 value) {
  _set_bit(3);
  nbr_au_travail_ = value;
}

// optional int32 nbr_pretes = 5;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_pretes() const {
  return _has_bit(4);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_pretes() {
  nbr_pretes_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_pretes() const {
  return nbr_pretes_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_pretes(::google::protobuf::int32 value) {
  _set_bit(4);
  nbr_pretes_ = value;
}

// optional int32 nbr_au_repos = 6;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_au_repos() const {
  return _has_bit(5);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_au_repos() {
  nbr_au_repos_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_au_repos() const {
  return nbr_au_repos_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_au_repos(::google::protobuf::int32 value) {
  _set_bit(5);
  nbr_au_repos_ = value;
}

// -------------------------------------------------------------------

// SeqOfLogSupplyEquimentAvailability

// repeated .MsgsSimToClient.MsgLogSupplyEquimentAvailability elem = 1;
inline int SeqOfLogSupplyEquimentAvailability::elem_size() const {
  return elem_.size();
}
inline void SeqOfLogSupplyEquimentAvailability::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability >&
SeqOfLogSupplyEquimentAvailability::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability >*
SeqOfLogSupplyEquimentAvailability::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgLogSupplyEquimentAvailability& SeqOfLogSupplyEquimentAvailability::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgLogSupplyEquimentAvailability* SeqOfLogSupplyEquimentAvailability::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgLogSupplyEquimentAvailability* SeqOfLogSupplyEquimentAvailability::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgLogSupplyState

// optional .Common.UnitId unit = 1;
inline bool MsgLogSupplyState::has_unit() const {
  return _has_bit(0);
}
inline void MsgLogSupplyState::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgLogSupplyState::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogSupplyState::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// optional bool chaine_activee = 2;
inline bool MsgLogSupplyState::has_chaine_activee() const {
  return _has_bit(1);
}
inline void MsgLogSupplyState::clear_chaine_activee() {
  chaine_activee_ = false;
  _clear_bit(1);
}
inline bool MsgLogSupplyState::chaine_activee() const {
  return chaine_activee_;
}
inline void MsgLogSupplyState::set_chaine_activee(bool value) {
  _set_bit(1);
  chaine_activee_ = value;
}

// optional .Common.SeqOfDotationStock stocks = 3;
inline bool MsgLogSupplyState::has_stocks() const {
  return _has_bit(2);
}
inline void MsgLogSupplyState::clear_stocks() {
  if (stocks_ != NULL) stocks_->::Common::SeqOfDotationStock::Clear();
  _clear_bit(2);
}
inline const ::Common::SeqOfDotationStock& MsgLogSupplyState::stocks() const {
  return stocks_ != NULL ? *stocks_ : *default_instance_->stocks_;
}
inline ::Common::SeqOfDotationStock* MsgLogSupplyState::mutable_stocks() {
  _set_bit(2);
  if (stocks_ == NULL) stocks_ = new ::Common::SeqOfDotationStock;
  return stocks_;
}

// optional .MsgsSimToClient.SeqOfLogSupplyEquimentAvailability disponibilites_transporteurs_convois = 4;
inline bool MsgLogSupplyState::has_disponibilites_transporteurs_convois() const {
  return _has_bit(3);
}
inline void MsgLogSupplyState::clear_disponibilites_transporteurs_convois() {
  if (disponibilites_transporteurs_convois_ != NULL) disponibilites_transporteurs_convois_->::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability& MsgLogSupplyState::disponibilites_transporteurs_convois() const {
  return disponibilites_transporteurs_convois_ != NULL ? *disponibilites_transporteurs_convois_ : *default_instance_->disponibilites_transporteurs_convois_;
}
inline ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability* MsgLogSupplyState::mutable_disponibilites_transporteurs_convois() {
  _set_bit(3);
  if (disponibilites_transporteurs_convois_ == NULL) disponibilites_transporteurs_convois_ = new ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability;
  return disponibilites_transporteurs_convois_;
}

// -------------------------------------------------------------------

// MsgLogSupplyQuotas

// required .Common.AutomatId automat = 1;
inline bool MsgLogSupplyQuotas::has_automat() const {
  return _has_bit(0);
}
inline void MsgLogSupplyQuotas::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgLogSupplyQuotas::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* MsgLogSupplyQuotas::mutable_automat() {
  _set_bit(0);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// required .Common.SeqOfDotationQuota quotas = 2;
inline bool MsgLogSupplyQuotas::has_quotas() const {
  return _has_bit(1);
}
inline void MsgLogSupplyQuotas::clear_quotas() {
  if (quotas_ != NULL) quotas_->::Common::SeqOfDotationQuota::Clear();
  _clear_bit(1);
}
inline const ::Common::SeqOfDotationQuota& MsgLogSupplyQuotas::quotas() const {
  return quotas_ != NULL ? *quotas_ : *default_instance_->quotas_;
}
inline ::Common::SeqOfDotationQuota* MsgLogSupplyQuotas::mutable_quotas() {
  _set_bit(1);
  if (quotas_ == NULL) quotas_ = new ::Common::SeqOfDotationQuota;
  return quotas_;
}

// -------------------------------------------------------------------

// MsgCrowdCreation

// required .Common.CrowdId crowd = 1;
inline bool MsgCrowdCreation::has_crowd() const {
  return _has_bit(0);
}
inline void MsgCrowdCreation::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdId& MsgCrowdCreation::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdCreation::mutable_crowd() {
  _set_bit(0);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// required .Common.CrowdType type = 2;
inline bool MsgCrowdCreation::has_type() const {
  return _has_bit(1);
}
inline void MsgCrowdCreation::clear_type() {
  if (type_ != NULL) type_->::Common::CrowdType::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdType& MsgCrowdCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::CrowdType* MsgCrowdCreation::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::CrowdType;
  return type_;
}

// optional string nom = 3;
inline bool MsgCrowdCreation::has_nom() const {
  return _has_bit(2);
}
inline void MsgCrowdCreation::clear_nom() {
  if (nom_ != &_default_nom_) {
    nom_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgCrowdCreation::nom() const {
  return *nom_;
}
inline void MsgCrowdCreation::set_nom(const ::std::string& value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgCrowdCreation::set_nom(const char* value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgCrowdCreation::set_nom(const char* value, size_t size) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgCrowdCreation::mutable_nom() {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  return nom_;
}

// required .Common.PartyId party = 4;
inline bool MsgCrowdCreation::has_party() const {
  return _has_bit(3);
}
inline void MsgCrowdCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(3);
}
inline const ::Common::PartyId& MsgCrowdCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgCrowdCreation::mutable_party() {
  _set_bit(3);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgCrowdUpdate

// required .Common.CrowdId crowd = 1;
inline bool MsgCrowdUpdate::has_crowd() const {
  return _has_bit(0);
}
inline void MsgCrowdUpdate::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdId& MsgCrowdUpdate::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdUpdate::mutable_crowd() {
  _set_bit(0);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// optional int32 etat_domination = 2;
inline bool MsgCrowdUpdate::has_etat_domination() const {
  return _has_bit(1);
}
inline void MsgCrowdUpdate::clear_etat_domination() {
  etat_domination_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgCrowdUpdate::etat_domination() const {
  return etat_domination_;
}
inline void MsgCrowdUpdate::set_etat_domination(::google::protobuf::int32 value) {
  _set_bit(1);
  etat_domination_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdConcentrationCreation

// required .Common.CrowdConcentrationId concentration = 1;
inline bool MsgCrowdConcentrationCreation::has_concentration() const {
  return _has_bit(0);
}
inline void MsgCrowdConcentrationCreation::clear_concentration() {
  if (concentration_ != NULL) concentration_->::Common::CrowdConcentrationId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdConcentrationId& MsgCrowdConcentrationCreation::concentration() const {
  return concentration_ != NULL ? *concentration_ : *default_instance_->concentration_;
}
inline ::Common::CrowdConcentrationId* MsgCrowdConcentrationCreation::mutable_concentration() {
  _set_bit(0);
  if (concentration_ == NULL) concentration_ = new ::Common::CrowdConcentrationId;
  return concentration_;
}

// required .Common.CrowdId crowd = 2;
inline bool MsgCrowdConcentrationCreation::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdConcentrationCreation::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgCrowdConcentrationCreation::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdConcentrationCreation::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// required .Common.MsgCoordLatLong position = 3;
inline bool MsgCrowdConcentrationCreation::has_position() const {
  return _has_bit(2);
}
inline void MsgCrowdConcentrationCreation::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgCoordLatLong& MsgCrowdConcentrationCreation::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgCrowdConcentrationCreation::mutable_position() {
  _set_bit(2);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// -------------------------------------------------------------------

// MsgCrowdConcentrationDestruction

// required .Common.CrowdConcentrationId concentration = 1;
inline bool MsgCrowdConcentrationDestruction::has_concentration() const {
  return _has_bit(0);
}
inline void MsgCrowdConcentrationDestruction::clear_concentration() {
  if (concentration_ != NULL) concentration_->::Common::CrowdConcentrationId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdConcentrationId& MsgCrowdConcentrationDestruction::concentration() const {
  return concentration_ != NULL ? *concentration_ : *default_instance_->concentration_;
}
inline ::Common::CrowdConcentrationId* MsgCrowdConcentrationDestruction::mutable_concentration() {
  _set_bit(0);
  if (concentration_ == NULL) concentration_ = new ::Common::CrowdConcentrationId;
  return concentration_;
}

// required .Common.CrowdId crowd = 2;
inline bool MsgCrowdConcentrationDestruction::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdConcentrationDestruction::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgCrowdConcentrationDestruction::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdConcentrationDestruction::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// -------------------------------------------------------------------

// MsgCrowdConcentrationUpdate

// required .Common.CrowdConcentrationId concentration = 1;
inline bool MsgCrowdConcentrationUpdate::has_concentration() const {
  return _has_bit(0);
}
inline void MsgCrowdConcentrationUpdate::clear_concentration() {
  if (concentration_ != NULL) concentration_->::Common::CrowdConcentrationId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdConcentrationId& MsgCrowdConcentrationUpdate::concentration() const {
  return concentration_ != NULL ? *concentration_ : *default_instance_->concentration_;
}
inline ::Common::CrowdConcentrationId* MsgCrowdConcentrationUpdate::mutable_concentration() {
  _set_bit(0);
  if (concentration_ == NULL) concentration_ = new ::Common::CrowdConcentrationId;
  return concentration_;
}

// required .Common.CrowdId crowd = 2;
inline bool MsgCrowdConcentrationUpdate::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdConcentrationUpdate::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgCrowdConcentrationUpdate::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdConcentrationUpdate::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// optional int32 nb_humains_vivants = 3;
inline bool MsgCrowdConcentrationUpdate::has_nb_humains_vivants() const {
  return _has_bit(2);
}
inline void MsgCrowdConcentrationUpdate::clear_nb_humains_vivants() {
  nb_humains_vivants_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgCrowdConcentrationUpdate::nb_humains_vivants() const {
  return nb_humains_vivants_;
}
inline void MsgCrowdConcentrationUpdate::set_nb_humains_vivants(::google::protobuf::int32 value) {
  _set_bit(2);
  nb_humains_vivants_ = value;
}

// optional int32 nb_humains_morts = 4;
inline bool MsgCrowdConcentrationUpdate::has_nb_humains_morts() const {
  return _has_bit(3);
}
inline void MsgCrowdConcentrationUpdate::clear_nb_humains_morts() {
  nb_humains_morts_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgCrowdConcentrationUpdate::nb_humains_morts() const {
  return nb_humains_morts_;
}
inline void MsgCrowdConcentrationUpdate::set_nb_humains_morts(::google::protobuf::int32 value) {
  _set_bit(3);
  nb_humains_morts_ = value;
}

// optional .Common.EnumCrowdAttitude attitude = 5;
inline bool MsgCrowdConcentrationUpdate::has_attitude() const {
  return _has_bit(4);
}
inline void MsgCrowdConcentrationUpdate::clear_attitude() {
  attitude_ = 0;
  _clear_bit(4);
}
inline Common::EnumCrowdAttitude MsgCrowdConcentrationUpdate::attitude() const {
  return static_cast< Common::EnumCrowdAttitude >(attitude_);
}
inline void MsgCrowdConcentrationUpdate::set_attitude(Common::EnumCrowdAttitude value) {
  GOOGLE_DCHECK(Common::EnumCrowdAttitude_IsValid(value));
  _set_bit(4);
  attitude_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdFlowCreation

// required .Common.CrowdFlowId flow = 1;
inline bool MsgCrowdFlowCreation::has_flow() const {
  return _has_bit(0);
}
inline void MsgCrowdFlowCreation::clear_flow() {
  if (flow_ != NULL) flow_->::Common::CrowdFlowId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdFlowId& MsgCrowdFlowCreation::flow() const {
  return flow_ != NULL ? *flow_ : *default_instance_->flow_;
}
inline ::Common::CrowdFlowId* MsgCrowdFlowCreation::mutable_flow() {
  _set_bit(0);
  if (flow_ == NULL) flow_ = new ::Common::CrowdFlowId;
  return flow_;
}

// required .Common.CrowdId crowd = 2;
inline bool MsgCrowdFlowCreation::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdFlowCreation::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgCrowdFlowCreation::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdFlowCreation::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// -------------------------------------------------------------------

// MsgCrowdFlowDestruction

// required .Common.CrowdFlowId flow = 1;
inline bool MsgCrowdFlowDestruction::has_flow() const {
  return _has_bit(0);
}
inline void MsgCrowdFlowDestruction::clear_flow() {
  if (flow_ != NULL) flow_->::Common::CrowdFlowId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdFlowId& MsgCrowdFlowDestruction::flow() const {
  return flow_ != NULL ? *flow_ : *default_instance_->flow_;
}
inline ::Common::CrowdFlowId* MsgCrowdFlowDestruction::mutable_flow() {
  _set_bit(0);
  if (flow_ == NULL) flow_ = new ::Common::CrowdFlowId;
  return flow_;
}

// required .Common.CrowdId crowd = 2;
inline bool MsgCrowdFlowDestruction::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdFlowDestruction::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgCrowdFlowDestruction::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdFlowDestruction::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// -------------------------------------------------------------------

// MsgCrowdFlowUpdate

// required .Common.CrowdFlowId flow = 1;
inline bool MsgCrowdFlowUpdate::has_flow() const {
  return _has_bit(0);
}
inline void MsgCrowdFlowUpdate::clear_flow() {
  if (flow_ != NULL) flow_->::Common::CrowdFlowId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdFlowId& MsgCrowdFlowUpdate::flow() const {
  return flow_ != NULL ? *flow_ : *default_instance_->flow_;
}
inline ::Common::CrowdFlowId* MsgCrowdFlowUpdate::mutable_flow() {
  _set_bit(0);
  if (flow_ == NULL) flow_ = new ::Common::CrowdFlowId;
  return flow_;
}

// required .Common.CrowdId crowd = 2;
inline bool MsgCrowdFlowUpdate::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdFlowUpdate::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdId& MsgCrowdFlowUpdate::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdFlowUpdate::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// optional .Common.MsgPath itineraire = 3;
inline bool MsgCrowdFlowUpdate::has_itineraire() const {
  return _has_bit(2);
}
inline void MsgCrowdFlowUpdate::clear_itineraire() {
  if (itineraire_ != NULL) itineraire_->::Common::MsgPath::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgPath& MsgCrowdFlowUpdate::itineraire() const {
  return itineraire_ != NULL ? *itineraire_ : *default_instance_->itineraire_;
}
inline ::Common::MsgPath* MsgCrowdFlowUpdate::mutable_itineraire() {
  _set_bit(2);
  if (itineraire_ == NULL) itineraire_ = new ::Common::MsgPath;
  return itineraire_;
}

// optional .Common.MsgPath parts = 4;
inline bool MsgCrowdFlowUpdate::has_parts() const {
  return _has_bit(3);
}
inline void MsgCrowdFlowUpdate::clear_parts() {
  if (parts_ != NULL) parts_->::Common::MsgPath::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgPath& MsgCrowdFlowUpdate::parts() const {
  return parts_ != NULL ? *parts_ : *default_instance_->parts_;
}
inline ::Common::MsgPath* MsgCrowdFlowUpdate::mutable_parts() {
  _set_bit(3);
  if (parts_ == NULL) parts_ = new ::Common::MsgPath;
  return parts_;
}

// optional .Common.MsgHeading direction = 5;
inline bool MsgCrowdFlowUpdate::has_direction() const {
  return _has_bit(4);
}
inline void MsgCrowdFlowUpdate::clear_direction() {
  if (direction_ != NULL) direction_->::Common::MsgHeading::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgHeading& MsgCrowdFlowUpdate::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Common::MsgHeading* MsgCrowdFlowUpdate::mutable_direction() {
  _set_bit(4);
  if (direction_ == NULL) direction_ = new ::Common::MsgHeading;
  return direction_;
}

// optional int32 vitesse = 6;
inline bool MsgCrowdFlowUpdate::has_vitesse() const {
  return _has_bit(5);
}
inline void MsgCrowdFlowUpdate::clear_vitesse() {
  vitesse_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgCrowdFlowUpdate::vitesse() const {
  return vitesse_;
}
inline void MsgCrowdFlowUpdate::set_vitesse(::google::protobuf::int32 value) {
  _set_bit(5);
  vitesse_ = value;
}

// optional int32 nb_humains_vivants = 7;
inline bool MsgCrowdFlowUpdate::has_nb_humains_vivants() const {
  return _has_bit(6);
}
inline void MsgCrowdFlowUpdate::clear_nb_humains_vivants() {
  nb_humains_vivants_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 MsgCrowdFlowUpdate::nb_humains_vivants() const {
  return nb_humains_vivants_;
}
inline void MsgCrowdFlowUpdate::set_nb_humains_vivants(::google::protobuf::int32 value) {
  _set_bit(6);
  nb_humains_vivants_ = value;
}

// optional int32 nb_humains_morts = 8;
inline bool MsgCrowdFlowUpdate::has_nb_humains_morts() const {
  return _has_bit(7);
}
inline void MsgCrowdFlowUpdate::clear_nb_humains_morts() {
  nb_humains_morts_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MsgCrowdFlowUpdate::nb_humains_morts() const {
  return nb_humains_morts_;
}
inline void MsgCrowdFlowUpdate::set_nb_humains_morts(::google::protobuf::int32 value) {
  _set_bit(7);
  nb_humains_morts_ = value;
}

// optional .Common.EnumCrowdAttitude attitude = 9;
inline bool MsgCrowdFlowUpdate::has_attitude() const {
  return _has_bit(8);
}
inline void MsgCrowdFlowUpdate::clear_attitude() {
  attitude_ = 0;
  _clear_bit(8);
}
inline Common::EnumCrowdAttitude MsgCrowdFlowUpdate::attitude() const {
  return static_cast< Common::EnumCrowdAttitude >(attitude_);
}
inline void MsgCrowdFlowUpdate::set_attitude(Common::EnumCrowdAttitude value) {
  GOOGLE_DCHECK(Common::EnumCrowdAttitude_IsValid(value));
  _set_bit(8);
  attitude_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdKnowledgeCreation

// required .Common.CrowdKnowledgeId knowledge = 1;
inline bool MsgCrowdKnowledgeCreation::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdKnowledgeCreation::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdKnowledgeCreation::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdKnowledgeCreation::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdKnowledgeId;
  return knowledge_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgCrowdKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgCrowdKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional .Common.CrowdId crowd = 3;
inline bool MsgCrowdKnowledgeCreation::has_crowd() const {
  return _has_bit(2);
}
inline void MsgCrowdKnowledgeCreation::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdId::Clear();
  _clear_bit(2);
}
inline const ::Common::CrowdId& MsgCrowdKnowledgeCreation::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdId* MsgCrowdKnowledgeCreation::mutable_crowd() {
  _set_bit(2);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdId;
  return crowd_;
}

// optional .Common.PartyId party = 4;
inline bool MsgCrowdKnowledgeCreation::has_party() const {
  return _has_bit(3);
}
inline void MsgCrowdKnowledgeCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(3);
}
inline const ::Common::PartyId& MsgCrowdKnowledgeCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgCrowdKnowledgeCreation::mutable_party() {
  _set_bit(3);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgCrowdKnowledgeUpdate

// required .Common.CrowdKnowledgeId knowledge = 1;
inline bool MsgCrowdKnowledgeUpdate::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdKnowledgeUpdate::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdKnowledgeUpdate::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdKnowledgeUpdate::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdKnowledgeId;
  return knowledge_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgCrowdKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgCrowdKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional int32 etat_domination = 3;
inline bool MsgCrowdKnowledgeUpdate::has_etat_domination() const {
  return _has_bit(2);
}
inline void MsgCrowdKnowledgeUpdate::clear_etat_domination() {
  etat_domination_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgCrowdKnowledgeUpdate::etat_domination() const {
  return etat_domination_;
}
inline void MsgCrowdKnowledgeUpdate::set_etat_domination(::google::protobuf::int32 value) {
  _set_bit(2);
  etat_domination_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdKnowledgeDestruction

// required .Common.CrowdKnowledgeId knowledge = 1;
inline bool MsgCrowdKnowledgeDestruction::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdKnowledgeDestruction::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdKnowledgeDestruction::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdKnowledgeDestruction::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdKnowledgeId;
  return knowledge_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgCrowdKnowledgeDestruction::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgCrowdKnowledgeDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdKnowledgeDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdKnowledgeDestruction::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgCrowdConcentrationKnowledgeCreation

// required .Common.CrowdConcentrationKnowledgeId knowledge = 1;
inline bool MsgCrowdConcentrationKnowledgeCreation::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdConcentrationKnowledgeCreation::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdConcentrationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdConcentrationKnowledgeId& MsgCrowdConcentrationKnowledgeCreation::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdConcentrationKnowledgeId* MsgCrowdConcentrationKnowledgeCreation::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdConcentrationKnowledgeId;
  return knowledge_;
}

// required .Common.CrowdKnowledgeId crowd = 2;
inline bool MsgCrowdConcentrationKnowledgeCreation::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdConcentrationKnowledgeCreation::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdConcentrationKnowledgeCreation::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdConcentrationKnowledgeCreation::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdKnowledgeId;
  return crowd_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgCrowdConcentrationKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgCrowdConcentrationKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdConcentrationKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdConcentrationKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .Common.CrowdConcentrationId concentration = 4;
inline bool MsgCrowdConcentrationKnowledgeCreation::has_concentration() const {
  return _has_bit(3);
}
inline void MsgCrowdConcentrationKnowledgeCreation::clear_concentration() {
  if (concentration_ != NULL) concentration_->::Common::CrowdConcentrationId::Clear();
  _clear_bit(3);
}
inline const ::Common::CrowdConcentrationId& MsgCrowdConcentrationKnowledgeCreation::concentration() const {
  return concentration_ != NULL ? *concentration_ : *default_instance_->concentration_;
}
inline ::Common::CrowdConcentrationId* MsgCrowdConcentrationKnowledgeCreation::mutable_concentration() {
  _set_bit(3);
  if (concentration_ == NULL) concentration_ = new ::Common::CrowdConcentrationId;
  return concentration_;
}

// optional .Common.MsgCoordLatLong position = 5;
inline bool MsgCrowdConcentrationKnowledgeCreation::has_position() const {
  return _has_bit(4);
}
inline void MsgCrowdConcentrationKnowledgeCreation::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgCoordLatLong& MsgCrowdConcentrationKnowledgeCreation::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgCrowdConcentrationKnowledgeCreation::mutable_position() {
  _set_bit(4);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// -------------------------------------------------------------------

// MsgCrowdConcentrationKnowledgeUpdate

// required .Common.CrowdConcentrationKnowledgeId knowledge = 1;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdConcentrationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdConcentrationKnowledgeId& MsgCrowdConcentrationKnowledgeUpdate::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdConcentrationKnowledgeId* MsgCrowdConcentrationKnowledgeUpdate::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdConcentrationKnowledgeId;
  return knowledge_;
}

// required .Common.CrowdKnowledgeId crowd = 2;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdConcentrationKnowledgeUpdate::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdConcentrationKnowledgeUpdate::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdKnowledgeId;
  return crowd_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdConcentrationKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdConcentrationKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional .Common.CrowdConcentrationId concentration = 4;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_concentration() const {
  return _has_bit(3);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_concentration() {
  if (concentration_ != NULL) concentration_->::Common::CrowdConcentrationId::Clear();
  _clear_bit(3);
}
inline const ::Common::CrowdConcentrationId& MsgCrowdConcentrationKnowledgeUpdate::concentration() const {
  return concentration_ != NULL ? *concentration_ : *default_instance_->concentration_;
}
inline ::Common::CrowdConcentrationId* MsgCrowdConcentrationKnowledgeUpdate::mutable_concentration() {
  _set_bit(3);
  if (concentration_ == NULL) concentration_ = new ::Common::CrowdConcentrationId;
  return concentration_;
}

// optional int32 nb_humains_vivants = 5;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_nb_humains_vivants() const {
  return _has_bit(4);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_nb_humains_vivants() {
  nb_humains_vivants_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgCrowdConcentrationKnowledgeUpdate::nb_humains_vivants() const {
  return nb_humains_vivants_;
}
inline void MsgCrowdConcentrationKnowledgeUpdate::set_nb_humains_vivants(::google::protobuf::int32 value) {
  _set_bit(4);
  nb_humains_vivants_ = value;
}

// optional int32 nb_humains_morts = 6;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_nb_humains_morts() const {
  return _has_bit(5);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_nb_humains_morts() {
  nb_humains_morts_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgCrowdConcentrationKnowledgeUpdate::nb_humains_morts() const {
  return nb_humains_morts_;
}
inline void MsgCrowdConcentrationKnowledgeUpdate::set_nb_humains_morts(::google::protobuf::int32 value) {
  _set_bit(5);
  nb_humains_morts_ = value;
}

// optional .Common.EnumCrowdAttitude attitude = 7;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_attitude() const {
  return _has_bit(6);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_attitude() {
  attitude_ = 0;
  _clear_bit(6);
}
inline Common::EnumCrowdAttitude MsgCrowdConcentrationKnowledgeUpdate::attitude() const {
  return static_cast< Common::EnumCrowdAttitude >(attitude_);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::set_attitude(Common::EnumCrowdAttitude value) {
  GOOGLE_DCHECK(Common::EnumCrowdAttitude_IsValid(value));
  _set_bit(6);
  attitude_ = value;
}

// optional int32 pertinence = 8;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_pertinence() const {
  return _has_bit(7);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_pertinence() {
  pertinence_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MsgCrowdConcentrationKnowledgeUpdate::pertinence() const {
  return pertinence_;
}
inline void MsgCrowdConcentrationKnowledgeUpdate::set_pertinence(::google::protobuf::int32 value) {
  _set_bit(7);
  pertinence_ = value;
}

// optional bool est_percu = 9;
inline bool MsgCrowdConcentrationKnowledgeUpdate::has_est_percu() const {
  return _has_bit(8);
}
inline void MsgCrowdConcentrationKnowledgeUpdate::clear_est_percu() {
  est_percu_ = false;
  _clear_bit(8);
}
inline bool MsgCrowdConcentrationKnowledgeUpdate::est_percu() const {
  return est_percu_;
}
inline void MsgCrowdConcentrationKnowledgeUpdate::set_est_percu(bool value) {
  _set_bit(8);
  est_percu_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdConcentrationKnowledgeDestruction

// required .Common.CrowdConcentrationKnowledgeId knowledge = 1;
inline bool MsgCrowdConcentrationKnowledgeDestruction::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdConcentrationKnowledgeDestruction::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdConcentrationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdConcentrationKnowledgeId& MsgCrowdConcentrationKnowledgeDestruction::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdConcentrationKnowledgeId* MsgCrowdConcentrationKnowledgeDestruction::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdConcentrationKnowledgeId;
  return knowledge_;
}

// required .Common.CrowdKnowledgeId crowd = 2;
inline bool MsgCrowdConcentrationKnowledgeDestruction::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdConcentrationKnowledgeDestruction::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdConcentrationKnowledgeDestruction::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdConcentrationKnowledgeDestruction::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdKnowledgeId;
  return crowd_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgCrowdConcentrationKnowledgeDestruction::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgCrowdConcentrationKnowledgeDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdConcentrationKnowledgeDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdConcentrationKnowledgeDestruction::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgCrowdFlowKnowledgeCreation

// required .Common.CrowdFlowKnowledgeId knowledge = 1;
inline bool MsgCrowdFlowKnowledgeCreation::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdFlowKnowledgeCreation::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdFlowKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdFlowKnowledgeId& MsgCrowdFlowKnowledgeCreation::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdFlowKnowledgeId* MsgCrowdFlowKnowledgeCreation::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdFlowKnowledgeId;
  return knowledge_;
}

// required .Common.CrowdKnowledgeId crowd = 2;
inline bool MsgCrowdFlowKnowledgeCreation::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdFlowKnowledgeCreation::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdFlowKnowledgeCreation::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdFlowKnowledgeCreation::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdKnowledgeId;
  return crowd_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgCrowdFlowKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgCrowdFlowKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdFlowKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdFlowKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .Common.CrowdFlowId flow = 4;
inline bool MsgCrowdFlowKnowledgeCreation::has_flow() const {
  return _has_bit(3);
}
inline void MsgCrowdFlowKnowledgeCreation::clear_flow() {
  if (flow_ != NULL) flow_->::Common::CrowdFlowId::Clear();
  _clear_bit(3);
}
inline const ::Common::CrowdFlowId& MsgCrowdFlowKnowledgeCreation::flow() const {
  return flow_ != NULL ? *flow_ : *default_instance_->flow_;
}
inline ::Common::CrowdFlowId* MsgCrowdFlowKnowledgeCreation::mutable_flow() {
  _set_bit(3);
  if (flow_ == NULL) flow_ = new ::Common::CrowdFlowId;
  return flow_;
}

// -------------------------------------------------------------------

// MsgFlowPart

// required .Common.MsgPath forme = 1;
inline bool MsgFlowPart::has_forme() const {
  return _has_bit(0);
}
inline void MsgFlowPart::clear_forme() {
  if (forme_ != NULL) forme_->::Common::MsgPath::Clear();
  _clear_bit(0);
}
inline const ::Common::MsgPath& MsgFlowPart::forme() const {
  return forme_ != NULL ? *forme_ : *default_instance_->forme_;
}
inline ::Common::MsgPath* MsgFlowPart::mutable_forme() {
  _set_bit(0);
  if (forme_ == NULL) forme_ = new ::Common::MsgPath;
  return forme_;
}

// required int32 pertinence = 2;
inline bool MsgFlowPart::has_pertinence() const {
  return _has_bit(1);
}
inline void MsgFlowPart::clear_pertinence() {
  pertinence_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgFlowPart::pertinence() const {
  return pertinence_;
}
inline void MsgFlowPart::set_pertinence(::google::protobuf::int32 value) {
  _set_bit(1);
  pertinence_ = value;
}

// -------------------------------------------------------------------

// SeqOfFlowPart

// repeated .MsgsSimToClient.MsgFlowPart elem = 1;
inline int SeqOfFlowPart::elem_size() const {
  return elem_.size();
}
inline void SeqOfFlowPart::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart >&
SeqOfFlowPart::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart >*
SeqOfFlowPart::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgFlowPart& SeqOfFlowPart::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgFlowPart* SeqOfFlowPart::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgFlowPart* SeqOfFlowPart::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgCrowdFlowKnowledgeUpdate

// required .Common.CrowdFlowKnowledgeId knowledge = 1;
inline bool MsgCrowdFlowKnowledgeUpdate::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdFlowKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdFlowKnowledgeId& MsgCrowdFlowKnowledgeUpdate::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdFlowKnowledgeId* MsgCrowdFlowKnowledgeUpdate::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdFlowKnowledgeId;
  return knowledge_;
}

// required .Common.CrowdKnowledgeId crowd = 2;
inline bool MsgCrowdFlowKnowledgeUpdate::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdFlowKnowledgeUpdate::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdFlowKnowledgeUpdate::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdKnowledgeId;
  return crowd_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgCrowdFlowKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdFlowKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdFlowKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional .Common.CrowdFlowId flow = 4;
inline bool MsgCrowdFlowKnowledgeUpdate::has_flow() const {
  return _has_bit(3);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_flow() {
  if (flow_ != NULL) flow_->::Common::CrowdFlowId::Clear();
  _clear_bit(3);
}
inline const ::Common::CrowdFlowId& MsgCrowdFlowKnowledgeUpdate::flow() const {
  return flow_ != NULL ? *flow_ : *default_instance_->flow_;
}
inline ::Common::CrowdFlowId* MsgCrowdFlowKnowledgeUpdate::mutable_flow() {
  _set_bit(3);
  if (flow_ == NULL) flow_ = new ::Common::CrowdFlowId;
  return flow_;
}

// optional .MsgsSimToClient.SeqOfFlowPart portions_flux = 5;
inline bool MsgCrowdFlowKnowledgeUpdate::has_portions_flux() const {
  return _has_bit(4);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_portions_flux() {
  if (portions_flux_ != NULL) portions_flux_->::MsgsSimToClient::SeqOfFlowPart::Clear();
  _clear_bit(4);
}
inline const ::MsgsSimToClient::SeqOfFlowPart& MsgCrowdFlowKnowledgeUpdate::portions_flux() const {
  return portions_flux_ != NULL ? *portions_flux_ : *default_instance_->portions_flux_;
}
inline ::MsgsSimToClient::SeqOfFlowPart* MsgCrowdFlowKnowledgeUpdate::mutable_portions_flux() {
  _set_bit(4);
  if (portions_flux_ == NULL) portions_flux_ = new ::MsgsSimToClient::SeqOfFlowPart;
  return portions_flux_;
}

// optional .Common.MsgHeading direction = 6;
inline bool MsgCrowdFlowKnowledgeUpdate::has_direction() const {
  return _has_bit(5);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_direction() {
  if (direction_ != NULL) direction_->::Common::MsgHeading::Clear();
  _clear_bit(5);
}
inline const ::Common::MsgHeading& MsgCrowdFlowKnowledgeUpdate::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Common::MsgHeading* MsgCrowdFlowKnowledgeUpdate::mutable_direction() {
  _set_bit(5);
  if (direction_ == NULL) direction_ = new ::Common::MsgHeading;
  return direction_;
}

// optional int32 vitesse = 7;
inline bool MsgCrowdFlowKnowledgeUpdate::has_vitesse() const {
  return _has_bit(6);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_vitesse() {
  vitesse_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 MsgCrowdFlowKnowledgeUpdate::vitesse() const {
  return vitesse_;
}
inline void MsgCrowdFlowKnowledgeUpdate::set_vitesse(::google::protobuf::int32 value) {
  _set_bit(6);
  vitesse_ = value;
}

// optional int32 nb_humains_vivants = 8;
inline bool MsgCrowdFlowKnowledgeUpdate::has_nb_humains_vivants() const {
  return _has_bit(7);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_nb_humains_vivants() {
  nb_humains_vivants_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MsgCrowdFlowKnowledgeUpdate::nb_humains_vivants() const {
  return nb_humains_vivants_;
}
inline void MsgCrowdFlowKnowledgeUpdate::set_nb_humains_vivants(::google::protobuf::int32 value) {
  _set_bit(7);
  nb_humains_vivants_ = value;
}

// optional int32 nb_humains_morts = 9;
inline bool MsgCrowdFlowKnowledgeUpdate::has_nb_humains_morts() const {
  return _has_bit(8);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_nb_humains_morts() {
  nb_humains_morts_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 MsgCrowdFlowKnowledgeUpdate::nb_humains_morts() const {
  return nb_humains_morts_;
}
inline void MsgCrowdFlowKnowledgeUpdate::set_nb_humains_morts(::google::protobuf::int32 value) {
  _set_bit(8);
  nb_humains_morts_ = value;
}

// optional .Common.EnumCrowdAttitude attitude = 10;
inline bool MsgCrowdFlowKnowledgeUpdate::has_attitude() const {
  return _has_bit(9);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_attitude() {
  attitude_ = 0;
  _clear_bit(9);
}
inline Common::EnumCrowdAttitude MsgCrowdFlowKnowledgeUpdate::attitude() const {
  return static_cast< Common::EnumCrowdAttitude >(attitude_);
}
inline void MsgCrowdFlowKnowledgeUpdate::set_attitude(Common::EnumCrowdAttitude value) {
  GOOGLE_DCHECK(Common::EnumCrowdAttitude_IsValid(value));
  _set_bit(9);
  attitude_ = value;
}

// optional bool est_percu = 11;
inline bool MsgCrowdFlowKnowledgeUpdate::has_est_percu() const {
  return _has_bit(10);
}
inline void MsgCrowdFlowKnowledgeUpdate::clear_est_percu() {
  est_percu_ = false;
  _clear_bit(10);
}
inline bool MsgCrowdFlowKnowledgeUpdate::est_percu() const {
  return est_percu_;
}
inline void MsgCrowdFlowKnowledgeUpdate::set_est_percu(bool value) {
  _set_bit(10);
  est_percu_ = value;
}

// -------------------------------------------------------------------

// MsgCrowdFlowKnowledgeDestruction

// required .Common.CrowdFlowKnowledgeId knowledge = 1;
inline bool MsgCrowdFlowKnowledgeDestruction::has_knowledge() const {
  return _has_bit(0);
}
inline void MsgCrowdFlowKnowledgeDestruction::clear_knowledge() {
  if (knowledge_ != NULL) knowledge_->::Common::CrowdFlowKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::CrowdFlowKnowledgeId& MsgCrowdFlowKnowledgeDestruction::knowledge() const {
  return knowledge_ != NULL ? *knowledge_ : *default_instance_->knowledge_;
}
inline ::Common::CrowdFlowKnowledgeId* MsgCrowdFlowKnowledgeDestruction::mutable_knowledge() {
  _set_bit(0);
  if (knowledge_ == NULL) knowledge_ = new ::Common::CrowdFlowKnowledgeId;
  return knowledge_;
}

// required .Common.CrowdKnowledgeId crowd = 2;
inline bool MsgCrowdFlowKnowledgeDestruction::has_crowd() const {
  return _has_bit(1);
}
inline void MsgCrowdFlowKnowledgeDestruction::clear_crowd() {
  if (crowd_ != NULL) crowd_->::Common::CrowdKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::CrowdKnowledgeId& MsgCrowdFlowKnowledgeDestruction::crowd() const {
  return crowd_ != NULL ? *crowd_ : *default_instance_->crowd_;
}
inline ::Common::CrowdKnowledgeId* MsgCrowdFlowKnowledgeDestruction::mutable_crowd() {
  _set_bit(1);
  if (crowd_ == NULL) crowd_ = new ::Common::CrowdKnowledgeId;
  return crowd_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgCrowdFlowKnowledgeDestruction::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgCrowdFlowKnowledgeDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgCrowdFlowKnowledgeDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgCrowdFlowKnowledgeDestruction::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgFolkCreation_profiles

// repeated string elem = 1;
inline int MsgFolkCreation_profiles::elem_size() const {
  return elem_.size();
}
inline void MsgFolkCreation_profiles::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MsgFolkCreation_profiles::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MsgFolkCreation_profiles::mutable_elem() {
  return &elem_;
}
inline const ::std::string& MsgFolkCreation_profiles::elem(int index) const {
  return elem_.Get(index);
}
inline ::std::string* MsgFolkCreation_profiles::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline void MsgFolkCreation_profiles::set_elem(int index, const ::std::string& value) {
  elem_.Mutable(index)->assign(value);
}
inline void MsgFolkCreation_profiles::set_elem(int index, const char* value) {
  elem_.Mutable(index)->assign(value);
}
inline void MsgFolkCreation_profiles::set_elem(int index, const char* value, size_t size) {
  elem_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgFolkCreation_profiles::add_elem() {
  return elem_.Add();
}
inline void MsgFolkCreation_profiles::add_elem(const ::std::string& value) {
  elem_.Add()->assign(value);
}
inline void MsgFolkCreation_profiles::add_elem(const char* value) {
  elem_.Add()->assign(value);
}
inline void MsgFolkCreation_profiles::add_elem(const char* value, size_t size) {
  elem_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// -------------------------------------------------------------------

// MsgFolkCreation_activities

// repeated string elem = 1;
inline int MsgFolkCreation_activities::elem_size() const {
  return elem_.size();
}
inline void MsgFolkCreation_activities::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MsgFolkCreation_activities::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MsgFolkCreation_activities::mutable_elem() {
  return &elem_;
}
inline const ::std::string& MsgFolkCreation_activities::elem(int index) const {
  return elem_.Get(index);
}
inline ::std::string* MsgFolkCreation_activities::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline void MsgFolkCreation_activities::set_elem(int index, const ::std::string& value) {
  elem_.Mutable(index)->assign(value);
}
inline void MsgFolkCreation_activities::set_elem(int index, const char* value) {
  elem_.Mutable(index)->assign(value);
}
inline void MsgFolkCreation_activities::set_elem(int index, const char* value, size_t size) {
  elem_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgFolkCreation_activities::add_elem() {
  return elem_.Add();
}
inline void MsgFolkCreation_activities::add_elem(const ::std::string& value) {
  elem_.Add()->assign(value);
}
inline void MsgFolkCreation_activities::add_elem(const char* value) {
  elem_.Add()->assign(value);
}
inline void MsgFolkCreation_activities::add_elem(const char* value, size_t size) {
  elem_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// -------------------------------------------------------------------

// MsgFolkCreation

// required .MsgsSimToClient.MsgFolkCreation_profiles profiles = 1;
inline bool MsgFolkCreation::has_profiles() const {
  return _has_bit(0);
}
inline void MsgFolkCreation::clear_profiles() {
  if (profiles_ != NULL) profiles_->::MsgsSimToClient::MsgFolkCreation_profiles::Clear();
  _clear_bit(0);
}
inline const ::MsgsSimToClient::MsgFolkCreation_profiles& MsgFolkCreation::profiles() const {
  return profiles_ != NULL ? *profiles_ : *default_instance_->profiles_;
}
inline ::MsgsSimToClient::MsgFolkCreation_profiles* MsgFolkCreation::mutable_profiles() {
  _set_bit(0);
  if (profiles_ == NULL) profiles_ = new ::MsgsSimToClient::MsgFolkCreation_profiles;
  return profiles_;
}

// required .MsgsSimToClient.MsgFolkCreation_activities activities = 2;
inline bool MsgFolkCreation::has_activities() const {
  return _has_bit(1);
}
inline void MsgFolkCreation::clear_activities() {
  if (activities_ != NULL) activities_->::MsgsSimToClient::MsgFolkCreation_activities::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgFolkCreation_activities& MsgFolkCreation::activities() const {
  return activities_ != NULL ? *activities_ : *default_instance_->activities_;
}
inline ::MsgsSimToClient::MsgFolkCreation_activities* MsgFolkCreation::mutable_activities() {
  _set_bit(1);
  if (activities_ == NULL) activities_ = new ::MsgsSimToClient::MsgFolkCreation_activities;
  return activities_;
}

// optional int32 container_size = 3;
inline bool MsgFolkCreation::has_container_size() const {
  return _has_bit(2);
}
inline void MsgFolkCreation::clear_container_size() {
  container_size_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgFolkCreation::container_size() const {
  return container_size_;
}
inline void MsgFolkCreation::set_container_size(::google::protobuf::int32 value) {
  _set_bit(2);
  container_size_ = value;
}

// optional int32 edge_number = 4;
inline bool MsgFolkCreation::has_edge_number() const {
  return _has_bit(3);
}
inline void MsgFolkCreation::clear_edge_number() {
  edge_number_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgFolkCreation::edge_number() const {
  return edge_number_;
}
inline void MsgFolkCreation::set_edge_number(::google::protobuf::int32 value) {
  _set_bit(3);
  edge_number_ = value;
}

// -------------------------------------------------------------------

// MsgFolkGraphEdgeUpdate

// required int32 folk = 1;
inline bool MsgFolkGraphEdgeUpdate::has_folk() const {
  return _has_bit(0);
}
inline void MsgFolkGraphEdgeUpdate::clear_folk() {
  folk_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgFolkGraphEdgeUpdate::folk() const {
  return folk_;
}
inline void MsgFolkGraphEdgeUpdate::set_folk(::google::protobuf::int32 value) {
  _set_bit(0);
  folk_ = value;
}

// required int32 shape_id = 2;
inline bool MsgFolkGraphEdgeUpdate::has_shape_id() const {
  return _has_bit(1);
}
inline void MsgFolkGraphEdgeUpdate::clear_shape_id() {
  shape_id_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgFolkGraphEdgeUpdate::shape_id() const {
  return shape_id_;
}
inline void MsgFolkGraphEdgeUpdate::set_shape_id(::google::protobuf::int32 value) {
  _set_bit(1);
  shape_id_ = value;
}

// repeated int32 crowd_occupation = 3;
inline int MsgFolkGraphEdgeUpdate::crowd_occupation_size() const {
  return crowd_occupation_.size();
}
inline void MsgFolkGraphEdgeUpdate::clear_crowd_occupation() {
  crowd_occupation_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MsgFolkGraphEdgeUpdate::crowd_occupation() const {
  return crowd_occupation_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MsgFolkGraphEdgeUpdate::mutable_crowd_occupation() {
  return &crowd_occupation_;
}
inline ::google::protobuf::int32 MsgFolkGraphEdgeUpdate::crowd_occupation(int index) const {
  return crowd_occupation_.Get(index);
}
inline void MsgFolkGraphEdgeUpdate::set_crowd_occupation(int index, ::google::protobuf::int32 value) {
  crowd_occupation_.Set(index, value);
}
inline void MsgFolkGraphEdgeUpdate::add_crowd_occupation(::google::protobuf::int32 value) {
  crowd_occupation_.Add(value);
}

// -------------------------------------------------------------------

// MsgFolkGraphUpdate

// repeated .MsgsSimToClient.MsgFolkGraphEdgeUpdate elem = 1;
inline int MsgFolkGraphUpdate::elem_size() const {
  return elem_.size();
}
inline void MsgFolkGraphUpdate::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate >&
MsgFolkGraphUpdate::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate >*
MsgFolkGraphUpdate::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgFolkGraphEdgeUpdate& MsgFolkGraphUpdate::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgFolkGraphEdgeUpdate* MsgFolkGraphUpdate::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgFolkGraphEdgeUpdate* MsgFolkGraphUpdate::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgControlCheckPointSetFrequencyAck

// -------------------------------------------------------------------

// MsgControlCheckPointSaveNowAck

// -------------------------------------------------------------------

// MsgControlCheckPointSaveBegin

// -------------------------------------------------------------------

// MsgControlCheckPointSaveBeginAck

// -------------------------------------------------------------------

// MsgControlCheckPointSaveEnd

// optional string name = 1;
inline bool MsgControlCheckPointSaveEnd::has_name() const {
  return _has_bit(0);
}
inline void MsgControlCheckPointSaveEnd::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MsgControlCheckPointSaveEnd::name() const {
  return *name_;
}
inline void MsgControlCheckPointSaveEnd::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgControlCheckPointSaveEnd::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgControlCheckPointSaveEnd::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgControlCheckPointSaveEnd::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// MsgControlCheckPointListAck

// -------------------------------------------------------------------

// MsgControlCheckPointList

// repeated string checkpoint = 1;
inline int MsgControlCheckPointList::checkpoint_size() const {
  return checkpoint_.size();
}
inline void MsgControlCheckPointList::clear_checkpoint() {
  checkpoint_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MsgControlCheckPointList::checkpoint() const {
  return checkpoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MsgControlCheckPointList::mutable_checkpoint() {
  return &checkpoint_;
}
inline const ::std::string& MsgControlCheckPointList::checkpoint(int index) const {
  return checkpoint_.Get(index);
}
inline ::std::string* MsgControlCheckPointList::mutable_checkpoint(int index) {
  return checkpoint_.Mutable(index);
}
inline void MsgControlCheckPointList::set_checkpoint(int index, const ::std::string& value) {
  checkpoint_.Mutable(index)->assign(value);
}
inline void MsgControlCheckPointList::set_checkpoint(int index, const char* value) {
  checkpoint_.Mutable(index)->assign(value);
}
inline void MsgControlCheckPointList::set_checkpoint(int index, const char* value, size_t size) {
  checkpoint_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgControlCheckPointList::add_checkpoint() {
  return checkpoint_.Add();
}
inline void MsgControlCheckPointList::add_checkpoint(const ::std::string& value) {
  checkpoint_.Add()->assign(value);
}
inline void MsgControlCheckPointList::add_checkpoint(const char* value) {
  checkpoint_.Add()->assign(value);
}
inline void MsgControlCheckPointList::add_checkpoint(const char* value, size_t size) {
  checkpoint_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// -------------------------------------------------------------------

// MsgControlCheckPointDeleteAck

// -------------------------------------------------------------------

// MsgControlSendCurrentStateBegin

// -------------------------------------------------------------------

// MsgControlSendCurrentStateEnd

// -------------------------------------------------------------------

// MagicActionCreateUrban

// required string name = 1;
inline bool MagicActionCreateUrban::has_name() const {
  return _has_bit(0);
}
inline void MagicActionCreateUrban::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MagicActionCreateUrban::name() const {
  return *name_;
}
inline void MagicActionCreateUrban::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MagicActionCreateUrban::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MagicActionCreateUrban::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MagicActionCreateUrban::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .Common.MsgLocation location = 2;
inline bool MagicActionCreateUrban::has_location() const {
  return _has_bit(1);
}
inline void MagicActionCreateUrban::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgLocation& MagicActionCreateUrban::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MagicActionCreateUrban::mutable_location() {
  _set_bit(1);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// -------------------------------------------------------------------

// MagicActionUpdateUrban

// required uint32 oid = 1;
inline bool MagicActionUpdateUrban::has_oid() const {
  return _has_bit(0);
}
inline void MagicActionUpdateUrban::clear_oid() {
  oid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MagicActionUpdateUrban::oid() const {
  return oid_;
}
inline void MagicActionUpdateUrban::set_oid(::google::protobuf::uint32 value) {
  _set_bit(0);
  oid_ = value;
}

// -------------------------------------------------------------------

// MagicActionDestroyUrban

// required uint32 oid = 1;
inline bool MagicActionDestroyUrban::has_oid() const {
  return _has_bit(0);
}
inline void MagicActionDestroyUrban::clear_oid() {
  oid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MagicActionDestroyUrban::oid() const {
  return oid_;
}
inline void MagicActionDestroyUrban::set_oid(::google::protobuf::uint32 value) {
  _set_bit(0);
  oid_ = value;
}

// -------------------------------------------------------------------

// MsgUrbanMagicAction

// optional .MsgsSimToClient.MagicActionCreateUrban create_urban = 1;
inline bool MsgUrbanMagicAction::has_create_urban() const {
  return _has_bit(0);
}
inline void MsgUrbanMagicAction::clear_create_urban() {
  if (create_urban_ != NULL) create_urban_->::MsgsSimToClient::MagicActionCreateUrban::Clear();
  _clear_bit(0);
}
inline const ::MsgsSimToClient::MagicActionCreateUrban& MsgUrbanMagicAction::create_urban() const {
  return create_urban_ != NULL ? *create_urban_ : *default_instance_->create_urban_;
}
inline ::MsgsSimToClient::MagicActionCreateUrban* MsgUrbanMagicAction::mutable_create_urban() {
  _set_bit(0);
  if (create_urban_ == NULL) create_urban_ = new ::MsgsSimToClient::MagicActionCreateUrban;
  return create_urban_;
}

// optional .MsgsSimToClient.MagicActionUpdateUrban update_urban = 2;
inline bool MsgUrbanMagicAction::has_update_urban() const {
  return _has_bit(1);
}
inline void MsgUrbanMagicAction::clear_update_urban() {
  if (update_urban_ != NULL) update_urban_->::MsgsSimToClient::MagicActionUpdateUrban::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MagicActionUpdateUrban& MsgUrbanMagicAction::update_urban() const {
  return update_urban_ != NULL ? *update_urban_ : *default_instance_->update_urban_;
}
inline ::MsgsSimToClient::MagicActionUpdateUrban* MsgUrbanMagicAction::mutable_update_urban() {
  _set_bit(1);
  if (update_urban_ == NULL) update_urban_ = new ::MsgsSimToClient::MagicActionUpdateUrban;
  return update_urban_;
}

// optional .MsgsSimToClient.MagicActionDestroyUrban destroy_urban = 3;
inline bool MsgUrbanMagicAction::has_destroy_urban() const {
  return _has_bit(2);
}
inline void MsgUrbanMagicAction::clear_destroy_urban() {
  if (destroy_urban_ != NULL) destroy_urban_->::MsgsSimToClient::MagicActionDestroyUrban::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MagicActionDestroyUrban& MsgUrbanMagicAction::destroy_urban() const {
  return destroy_urban_ != NULL ? *destroy_urban_ : *default_instance_->destroy_urban_;
}
inline ::MsgsSimToClient::MagicActionDestroyUrban* MsgUrbanMagicAction::mutable_destroy_urban() {
  _set_bit(2);
  if (destroy_urban_ == NULL) destroy_urban_ = new ::MsgsSimToClient::MagicActionDestroyUrban;
  return destroy_urban_;
}

// -------------------------------------------------------------------

// MsgUrbanMagicActionAck

// required .MsgsSimToClient.MsgUrbanMagicActionAck.ErrorCode error_code = 1;
inline bool MsgUrbanMagicActionAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgUrbanMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode MsgUrbanMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode >(error_code_);
}
inline void MsgUrbanMagicActionAck::set_error_code(::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// UrbanAttributes_Architecture

// required float height = 1;
inline bool UrbanAttributes_Architecture::has_height() const {
  return _has_bit(0);
}
inline void UrbanAttributes_Architecture::clear_height() {
  height_ = 0;
  _clear_bit(0);
}
inline float UrbanAttributes_Architecture::height() const {
  return height_;
}
inline void UrbanAttributes_Architecture::set_height(float value) {
  _set_bit(0);
  height_ = value;
}

// required int32 floor_number = 2;
inline bool UrbanAttributes_Architecture::has_floor_number() const {
  return _has_bit(1);
}
inline void UrbanAttributes_Architecture::clear_floor_number() {
  floor_number_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 UrbanAttributes_Architecture::floor_number() const {
  return floor_number_;
}
inline void UrbanAttributes_Architecture::set_floor_number(::google::protobuf::int32 value) {
  _set_bit(1);
  floor_number_ = value;
}

// required string roof_shape = 3;
inline bool UrbanAttributes_Architecture::has_roof_shape() const {
  return _has_bit(2);
}
inline void UrbanAttributes_Architecture::clear_roof_shape() {
  if (roof_shape_ != &_default_roof_shape_) {
    roof_shape_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& UrbanAttributes_Architecture::roof_shape() const {
  return *roof_shape_;
}
inline void UrbanAttributes_Architecture::set_roof_shape(const ::std::string& value) {
  _set_bit(2);
  if (roof_shape_ == &_default_roof_shape_) {
    roof_shape_ = new ::std::string;
  }
  roof_shape_->assign(value);
}
inline void UrbanAttributes_Architecture::set_roof_shape(const char* value) {
  _set_bit(2);
  if (roof_shape_ == &_default_roof_shape_) {
    roof_shape_ = new ::std::string;
  }
  roof_shape_->assign(value);
}
inline void UrbanAttributes_Architecture::set_roof_shape(const char* value, size_t size) {
  _set_bit(2);
  if (roof_shape_ == &_default_roof_shape_) {
    roof_shape_ = new ::std::string;
  }
  roof_shape_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UrbanAttributes_Architecture::mutable_roof_shape() {
  _set_bit(2);
  if (roof_shape_ == &_default_roof_shape_) {
    roof_shape_ = new ::std::string;
  }
  return roof_shape_;
}

// required string material = 4;
inline bool UrbanAttributes_Architecture::has_material() const {
  return _has_bit(3);
}
inline void UrbanAttributes_Architecture::clear_material() {
  if (material_ != &_default_material_) {
    material_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& UrbanAttributes_Architecture::material() const {
  return *material_;
}
inline void UrbanAttributes_Architecture::set_material(const ::std::string& value) {
  _set_bit(3);
  if (material_ == &_default_material_) {
    material_ = new ::std::string;
  }
  material_->assign(value);
}
inline void UrbanAttributes_Architecture::set_material(const char* value) {
  _set_bit(3);
  if (material_ == &_default_material_) {
    material_ = new ::std::string;
  }
  material_->assign(value);
}
inline void UrbanAttributes_Architecture::set_material(const char* value, size_t size) {
  _set_bit(3);
  if (material_ == &_default_material_) {
    material_ = new ::std::string;
  }
  material_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UrbanAttributes_Architecture::mutable_material() {
  _set_bit(3);
  if (material_ == &_default_material_) {
    material_ = new ::std::string;
  }
  return material_;
}

// required float occupation = 5;
inline bool UrbanAttributes_Architecture::has_occupation() const {
  return _has_bit(4);
}
inline void UrbanAttributes_Architecture::clear_occupation() {
  occupation_ = 0;
  _clear_bit(4);
}
inline float UrbanAttributes_Architecture::occupation() const {
  return occupation_;
}
inline void UrbanAttributes_Architecture::set_occupation(float value) {
  _set_bit(4);
  occupation_ = value;
}

// required float trafficability = 6;
inline bool UrbanAttributes_Architecture::has_trafficability() const {
  return _has_bit(5);
}
inline void UrbanAttributes_Architecture::clear_trafficability() {
  trafficability_ = 0;
  _clear_bit(5);
}
inline float UrbanAttributes_Architecture::trafficability() const {
  return trafficability_;
}
inline void UrbanAttributes_Architecture::set_trafficability(float value) {
  _set_bit(5);
  trafficability_ = value;
}

// -------------------------------------------------------------------

// UrbanAttributes_Structure

// required uint32 state = 1;
inline bool UrbanAttributes_Structure::has_state() const {
  return _has_bit(0);
}
inline void UrbanAttributes_Structure::clear_state() {
  state_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 UrbanAttributes_Structure::state() const {
  return state_;
}
inline void UrbanAttributes_Structure::set_state(::google::protobuf::uint32 value) {
  _set_bit(0);
  state_ = value;
}

// -------------------------------------------------------------------

// UrbanAttributes_Infrastructures

// repeated .Common.ResourceNetwork resource_network = 1;
inline int UrbanAttributes_Infrastructures::resource_network_size() const {
  return resource_network_.size();
}
inline void UrbanAttributes_Infrastructures::clear_resource_network() {
  resource_network_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork >&
UrbanAttributes_Infrastructures::resource_network() const {
  return resource_network_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork >*
UrbanAttributes_Infrastructures::mutable_resource_network() {
  return &resource_network_;
}
inline const ::Common::ResourceNetwork& UrbanAttributes_Infrastructures::resource_network(int index) const {
  return resource_network_.Get(index);
}
inline ::Common::ResourceNetwork* UrbanAttributes_Infrastructures::mutable_resource_network(int index) {
  return resource_network_.Mutable(index);
}
inline ::Common::ResourceNetwork* UrbanAttributes_Infrastructures::add_resource_network() {
  return resource_network_.Add();
}

// -------------------------------------------------------------------

// UrbanAttributes

// optional .MsgsSimToClient.UrbanAttributes.Architecture architecture = 1;
inline bool UrbanAttributes::has_architecture() const {
  return _has_bit(0);
}
inline void UrbanAttributes::clear_architecture() {
  if (architecture_ != NULL) architecture_->::MsgsSimToClient::UrbanAttributes_Architecture::Clear();
  _clear_bit(0);
}
inline const ::MsgsSimToClient::UrbanAttributes_Architecture& UrbanAttributes::architecture() const {
  return architecture_ != NULL ? *architecture_ : *default_instance_->architecture_;
}
inline ::MsgsSimToClient::UrbanAttributes_Architecture* UrbanAttributes::mutable_architecture() {
  _set_bit(0);
  if (architecture_ == NULL) architecture_ = new ::MsgsSimToClient::UrbanAttributes_Architecture;
  return architecture_;
}

// optional .MsgsSimToClient.UrbanAttributes.Structure structure = 2;
inline bool UrbanAttributes::has_structure() const {
  return _has_bit(1);
}
inline void UrbanAttributes::clear_structure() {
  if (structure_ != NULL) structure_->::MsgsSimToClient::UrbanAttributes_Structure::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::UrbanAttributes_Structure& UrbanAttributes::structure() const {
  return structure_ != NULL ? *structure_ : *default_instance_->structure_;
}
inline ::MsgsSimToClient::UrbanAttributes_Structure* UrbanAttributes::mutable_structure() {
  _set_bit(1);
  if (structure_ == NULL) structure_ = new ::MsgsSimToClient::UrbanAttributes_Structure;
  return structure_;
}

// optional .Common.RgbaColor color = 3;
inline bool UrbanAttributes::has_color() const {
  return _has_bit(2);
}
inline void UrbanAttributes::clear_color() {
  if (color_ != NULL) color_->::Common::RgbaColor::Clear();
  _clear_bit(2);
}
inline const ::Common::RgbaColor& UrbanAttributes::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::Common::RgbaColor* UrbanAttributes::mutable_color() {
  _set_bit(2);
  if (color_ == NULL) color_ = new ::Common::RgbaColor;
  return color_;
}

// optional .MsgsSimToClient.UrbanAttributes.Infrastructures infrastructures = 4;
inline bool UrbanAttributes::has_infrastructures() const {
  return _has_bit(3);
}
inline void UrbanAttributes::clear_infrastructures() {
  if (infrastructures_ != NULL) infrastructures_->::MsgsSimToClient::UrbanAttributes_Infrastructures::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::UrbanAttributes_Infrastructures& UrbanAttributes::infrastructures() const {
  return infrastructures_ != NULL ? *infrastructures_ : *default_instance_->infrastructures_;
}
inline ::MsgsSimToClient::UrbanAttributes_Infrastructures* UrbanAttributes::mutable_infrastructures() {
  _set_bit(3);
  if (infrastructures_ == NULL) infrastructures_ = new ::MsgsSimToClient::UrbanAttributes_Infrastructures;
  return infrastructures_;
}

// -------------------------------------------------------------------

// MsgUrbanCreation

// required .Common.UrbanObjectId urban_object = 1;
inline bool MsgUrbanCreation::has_urban_object() const {
  return _has_bit(0);
}
inline void MsgUrbanCreation::clear_urban_object() {
  if (urban_object_ != NULL) urban_object_->::Common::UrbanObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::UrbanObjectId& MsgUrbanCreation::urban_object() const {
  return urban_object_ != NULL ? *urban_object_ : *default_instance_->urban_object_;
}
inline ::Common::UrbanObjectId* MsgUrbanCreation::mutable_urban_object() {
  _set_bit(0);
  if (urban_object_ == NULL) urban_object_ = new ::Common::UrbanObjectId;
  return urban_object_;
}

// required string name = 2;
inline bool MsgUrbanCreation::has_name() const {
  return _has_bit(1);
}
inline void MsgUrbanCreation::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgUrbanCreation::name() const {
  return *name_;
}
inline void MsgUrbanCreation::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgUrbanCreation::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgUrbanCreation::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgUrbanCreation::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .Common.MsgLocation location = 3;
inline bool MsgUrbanCreation::has_location() const {
  return _has_bit(2);
}
inline void MsgUrbanCreation::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgLocation& MsgUrbanCreation::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgUrbanCreation::mutable_location() {
  _set_bit(2);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// optional .MsgsSimToClient.UrbanAttributes attributes = 4;
inline bool MsgUrbanCreation::has_attributes() const {
  return _has_bit(3);
}
inline void MsgUrbanCreation::clear_attributes() {
  if (attributes_ != NULL) attributes_->::MsgsSimToClient::UrbanAttributes::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::UrbanAttributes& MsgUrbanCreation::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::MsgsSimToClient::UrbanAttributes* MsgUrbanCreation::mutable_attributes() {
  _set_bit(3);
  if (attributes_ == NULL) attributes_ = new ::MsgsSimToClient::UrbanAttributes;
  return attributes_;
}

// optional .Common.UrbanObjectId parent = 5;
inline bool MsgUrbanCreation::has_parent() const {
  return _has_bit(4);
}
inline void MsgUrbanCreation::clear_parent() {
  if (parent_ != NULL) parent_->::Common::UrbanObjectId::Clear();
  _clear_bit(4);
}
inline const ::Common::UrbanObjectId& MsgUrbanCreation::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::Common::UrbanObjectId* MsgUrbanCreation::mutable_parent() {
  _set_bit(4);
  if (parent_ == NULL) parent_ = new ::Common::UrbanObjectId;
  return parent_;
}

// -------------------------------------------------------------------

// MsgUrbanDetection

// required .Common.UnitId observer = 1;
inline bool MsgUrbanDetection::has_observer() const {
  return _has_bit(0);
}
inline void MsgUrbanDetection::clear_observer() {
  if (observer_ != NULL) observer_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUrbanDetection::observer() const {
  return observer_ != NULL ? *observer_ : *default_instance_->observer_;
}
inline ::Common::UnitId* MsgUrbanDetection::mutable_observer() {
  _set_bit(0);
  if (observer_ == NULL) observer_ = new ::Common::UnitId;
  return observer_;
}

// required .Common.UrbanObjectId urban_object = 2;
inline bool MsgUrbanDetection::has_urban_object() const {
  return _has_bit(1);
}
inline void MsgUrbanDetection::clear_urban_object() {
  if (urban_object_ != NULL) urban_object_->::Common::UrbanObjectId::Clear();
  _clear_bit(1);
}
inline const ::Common::UrbanObjectId& MsgUrbanDetection::urban_object() const {
  return urban_object_ != NULL ? *urban_object_ : *default_instance_->urban_object_;
}
inline ::Common::UrbanObjectId* MsgUrbanDetection::mutable_urban_object() {
  _set_bit(1);
  if (urban_object_ == NULL) urban_object_ = new ::Common::UrbanObjectId;
  return urban_object_;
}

// required .Common.EnumUnitVisibility visibility = 3;
inline bool MsgUrbanDetection::has_visibility() const {
  return _has_bit(2);
}
inline void MsgUrbanDetection::clear_visibility() {
  visibility_ = 0;
  _clear_bit(2);
}
inline Common::EnumUnitVisibility MsgUrbanDetection::visibility() const {
  return static_cast< Common::EnumUnitVisibility >(visibility_);
}
inline void MsgUrbanDetection::set_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(2);
  visibility_ = value;
}

// -------------------------------------------------------------------

// MsgUrbanUpdate

// required .Common.UrbanObjectId urban_object = 1;
inline bool MsgUrbanUpdate::has_urban_object() const {
  return _has_bit(0);
}
inline void MsgUrbanUpdate::clear_urban_object() {
  if (urban_object_ != NULL) urban_object_->::Common::UrbanObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::UrbanObjectId& MsgUrbanUpdate::urban_object() const {
  return urban_object_ != NULL ? *urban_object_ : *default_instance_->urban_object_;
}
inline ::Common::UrbanObjectId* MsgUrbanUpdate::mutable_urban_object() {
  _set_bit(0);
  if (urban_object_ == NULL) urban_object_ = new ::Common::UrbanObjectId;
  return urban_object_;
}

// optional .Common.MsgLocation location = 2;
inline bool MsgUrbanUpdate::has_location() const {
  return _has_bit(1);
}
inline void MsgUrbanUpdate::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgLocation& MsgUrbanUpdate::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgUrbanUpdate::mutable_location() {
  _set_bit(1);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// optional .MsgsSimToClient.UrbanAttributes attributes = 3;
inline bool MsgUrbanUpdate::has_attributes() const {
  return _has_bit(2);
}
inline void MsgUrbanUpdate::clear_attributes() {
  if (attributes_ != NULL) attributes_->::MsgsSimToClient::UrbanAttributes::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::UrbanAttributes& MsgUrbanUpdate::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::MsgsSimToClient::UrbanAttributes* MsgUrbanUpdate::mutable_attributes() {
  _set_bit(2);
  if (attributes_ == NULL) attributes_ = new ::MsgsSimToClient::UrbanAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupCreation

// required .Common.KnowledgeGroupId knowledge_group = 1;
inline bool MsgKnowledgeGroupCreation::has_knowledge_group() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupCreation::mutable_knowledge_group() {
  _set_bit(0);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .Common.PartyId party = 2;
inline bool MsgKnowledgeGroupCreation::has_party() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgKnowledgeGroupCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgKnowledgeGroupCreation::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.KnowledgeGroupId parent = 3;
inline bool MsgKnowledgeGroupCreation::has_parent() const {
  return _has_bit(2);
}
inline void MsgKnowledgeGroupCreation::clear_parent() {
  if (parent_ != NULL) parent_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupCreation::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupCreation::mutable_parent() {
  _set_bit(2);
  if (parent_ == NULL) parent_ = new ::Common::KnowledgeGroupId;
  return parent_;
}

// required string type = 4;
inline bool MsgKnowledgeGroupCreation::has_type() const {
  return _has_bit(3);
}
inline void MsgKnowledgeGroupCreation::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& MsgKnowledgeGroupCreation::type() const {
  return *type_;
}
inline void MsgKnowledgeGroupCreation::set_type(const ::std::string& value) {
  _set_bit(3);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MsgKnowledgeGroupCreation::set_type(const char* value) {
  _set_bit(3);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MsgKnowledgeGroupCreation::set_type(const char* value, size_t size) {
  _set_bit(3);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgKnowledgeGroupCreation::mutable_type() {
  _set_bit(3);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// optional bool jam = 5;
inline bool MsgKnowledgeGroupCreation::has_jam() const {
  return _has_bit(4);
}
inline void MsgKnowledgeGroupCreation::clear_jam() {
  jam_ = false;
  _clear_bit(4);
}
inline bool MsgKnowledgeGroupCreation::jam() const {
  return jam_;
}
inline void MsgKnowledgeGroupCreation::set_jam(bool value) {
  _set_bit(4);
  jam_ = value;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupUpdate

// required .Common.KnowledgeGroupId knowledge_group = 1;
inline bool MsgKnowledgeGroupUpdate::has_knowledge_group() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupUpdate::mutable_knowledge_group() {
  _set_bit(0);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional .Common.PartyId party = 2;
inline bool MsgKnowledgeGroupUpdate::has_party() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupUpdate::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgKnowledgeGroupUpdate::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgKnowledgeGroupUpdate::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.KnowledgeGroupId parent = 3;
inline bool MsgKnowledgeGroupUpdate::has_parent() const {
  return _has_bit(2);
}
inline void MsgKnowledgeGroupUpdate::clear_parent() {
  if (parent_ != NULL) parent_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupUpdate::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupUpdate::mutable_parent() {
  _set_bit(2);
  if (parent_ == NULL) parent_ = new ::Common::KnowledgeGroupId;
  return parent_;
}

// optional bool enabled = 4;
inline bool MsgKnowledgeGroupUpdate::has_enabled() const {
  return _has_bit(3);
}
inline void MsgKnowledgeGroupUpdate::clear_enabled() {
  enabled_ = false;
  _clear_bit(3);
}
inline bool MsgKnowledgeGroupUpdate::enabled() const {
  return enabled_;
}
inline void MsgKnowledgeGroupUpdate::set_enabled(bool value) {
  _set_bit(3);
  enabled_ = value;
}

// optional string type = 5;
inline bool MsgKnowledgeGroupUpdate::has_type() const {
  return _has_bit(4);
}
inline void MsgKnowledgeGroupUpdate::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MsgKnowledgeGroupUpdate::type() const {
  return *type_;
}
inline void MsgKnowledgeGroupUpdate::set_type(const ::std::string& value) {
  _set_bit(4);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MsgKnowledgeGroupUpdate::set_type(const char* value) {
  _set_bit(4);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MsgKnowledgeGroupUpdate::set_type(const char* value, size_t size) {
  _set_bit(4);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgKnowledgeGroupUpdate::mutable_type() {
  _set_bit(4);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// -------------------------------------------------------------------

// KnowledgeGroupAck

// -------------------------------------------------------------------

// MsgKnowledgeGroupMagicActionAck

// required .Common.KnowledgeGroupId knowledge_group = 1;
inline bool MsgKnowledgeGroupMagicActionAck::has_knowledge_group() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupMagicActionAck::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupMagicActionAck::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupMagicActionAck::mutable_knowledge_group() {
  _set_bit(0);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
inline bool MsgKnowledgeGroupMagicActionAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode MsgKnowledgeGroupMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode >(error_code_);
}
inline void MsgKnowledgeGroupMagicActionAck::set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupCreationAck

// required .Common.KnowledgeGroupId knowledge_group = 1;
inline bool MsgKnowledgeGroupCreationAck::has_knowledge_group() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupCreationAck::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupCreationAck::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupCreationAck::mutable_knowledge_group() {
  _set_bit(0);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
inline bool MsgKnowledgeGroupCreationAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupCreationAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode MsgKnowledgeGroupCreationAck::error_code() const {
  return static_cast< ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode >(error_code_);
}
inline void MsgKnowledgeGroupCreationAck::set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupUpdateAck

// required .Common.KnowledgeGroupId knowledge_group = 1;
inline bool MsgKnowledgeGroupUpdateAck::has_knowledge_group() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupUpdateAck::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupUpdateAck::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupUpdateAck::mutable_knowledge_group() {
  _set_bit(0);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
inline bool MsgKnowledgeGroupUpdateAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupUpdateAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode MsgKnowledgeGroupUpdateAck::error_code() const {
  return static_cast< ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode >(error_code_);
}
inline void MsgKnowledgeGroupUpdateAck::set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupDestruction

// required .Common.KnowledgeGroupId knowledge_group = 1;
inline bool MsgKnowledgeGroupDestruction::has_knowledge_group() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupDestruction::mutable_knowledge_group() {
  _set_bit(0);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .Common.PartyId party = 2;
inline bool MsgKnowledgeGroupDestruction::has_party() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupDestruction::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgKnowledgeGroupDestruction::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgKnowledgeGroupDestruction::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgControlGlobalWeatherAck

// -------------------------------------------------------------------

// MsgControlLocalWeatherAck

// -------------------------------------------------------------------

// MsgControlGlobalWeather

// required .Common.WeatherId weather = 1;
inline bool MsgControlGlobalWeather::has_weather() const {
  return _has_bit(0);
}
inline void MsgControlGlobalWeather::clear_weather() {
  if (weather_ != NULL) weather_->::Common::WeatherId::Clear();
  _clear_bit(0);
}
inline const ::Common::WeatherId& MsgControlGlobalWeather::weather() const {
  return weather_ != NULL ? *weather_ : *default_instance_->weather_;
}
inline ::Common::WeatherId* MsgControlGlobalWeather::mutable_weather() {
  _set_bit(0);
  if (weather_ == NULL) weather_ = new ::Common::WeatherId;
  return weather_;
}

// required .Common.MsgWeatherAttributes attributes = 2;
inline bool MsgControlGlobalWeather::has_attributes() const {
  return _has_bit(1);
}
inline void MsgControlGlobalWeather::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::MsgWeatherAttributes::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgWeatherAttributes& MsgControlGlobalWeather::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::MsgWeatherAttributes* MsgControlGlobalWeather::mutable_attributes() {
  _set_bit(1);
  if (attributes_ == NULL) attributes_ = new ::Common::MsgWeatherAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgControlLocalWeatherCreation

// required .Common.WeatherId weather = 1;
inline bool MsgControlLocalWeatherCreation::has_weather() const {
  return _has_bit(0);
}
inline void MsgControlLocalWeatherCreation::clear_weather() {
  if (weather_ != NULL) weather_->::Common::WeatherId::Clear();
  _clear_bit(0);
}
inline const ::Common::WeatherId& MsgControlLocalWeatherCreation::weather() const {
  return weather_ != NULL ? *weather_ : *default_instance_->weather_;
}
inline ::Common::WeatherId* MsgControlLocalWeatherCreation::mutable_weather() {
  _set_bit(0);
  if (weather_ == NULL) weather_ = new ::Common::WeatherId;
  return weather_;
}

// optional .Common.MsgCoordLatLong top_left_coordinate = 2;
inline bool MsgControlLocalWeatherCreation::has_top_left_coordinate() const {
  return _has_bit(1);
}
inline void MsgControlLocalWeatherCreation::clear_top_left_coordinate() {
  if (top_left_coordinate_ != NULL) top_left_coordinate_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgCoordLatLong& MsgControlLocalWeatherCreation::top_left_coordinate() const {
  return top_left_coordinate_ != NULL ? *top_left_coordinate_ : *default_instance_->top_left_coordinate_;
}
inline ::Common::MsgCoordLatLong* MsgControlLocalWeatherCreation::mutable_top_left_coordinate() {
  _set_bit(1);
  if (top_left_coordinate_ == NULL) top_left_coordinate_ = new ::Common::MsgCoordLatLong;
  return top_left_coordinate_;
}

// optional .Common.MsgCoordLatLong bottom_right_coordinate = 3;
inline bool MsgControlLocalWeatherCreation::has_bottom_right_coordinate() const {
  return _has_bit(2);
}
inline void MsgControlLocalWeatherCreation::clear_bottom_right_coordinate() {
  if (bottom_right_coordinate_ != NULL) bottom_right_coordinate_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgCoordLatLong& MsgControlLocalWeatherCreation::bottom_right_coordinate() const {
  return bottom_right_coordinate_ != NULL ? *bottom_right_coordinate_ : *default_instance_->bottom_right_coordinate_;
}
inline ::Common::MsgCoordLatLong* MsgControlLocalWeatherCreation::mutable_bottom_right_coordinate() {
  _set_bit(2);
  if (bottom_right_coordinate_ == NULL) bottom_right_coordinate_ = new ::Common::MsgCoordLatLong;
  return bottom_right_coordinate_;
}

// optional .Common.MsgWeatherAttributes attributes = 4;
inline bool MsgControlLocalWeatherCreation::has_attributes() const {
  return _has_bit(3);
}
inline void MsgControlLocalWeatherCreation::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::MsgWeatherAttributes::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgWeatherAttributes& MsgControlLocalWeatherCreation::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::MsgWeatherAttributes* MsgControlLocalWeatherCreation::mutable_attributes() {
  _set_bit(3);
  if (attributes_ == NULL) attributes_ = new ::Common::MsgWeatherAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgControlLocalWeatherDestruction

// required .Common.WeatherId weather = 1;
inline bool MsgControlLocalWeatherDestruction::has_weather() const {
  return _has_bit(0);
}
inline void MsgControlLocalWeatherDestruction::clear_weather() {
  if (weather_ != NULL) weather_->::Common::WeatherId::Clear();
  _clear_bit(0);
}
inline const ::Common::WeatherId& MsgControlLocalWeatherDestruction::weather() const {
  return weather_ != NULL ? *weather_ : *default_instance_->weather_;
}
inline ::Common::WeatherId* MsgControlLocalWeatherDestruction::mutable_weather() {
  _set_bit(0);
  if (weather_ == NULL) weather_ = new ::Common::WeatherId;
  return weather_;
}

// -------------------------------------------------------------------

// MsgSimToClient_Content

// optional .MsgsSimToClient.MsgUnitOrderAck unit_order_ack = 1;
inline bool MsgSimToClient_Content::has_unit_order_ack() const {
  return _has_bit(0);
}
inline void MsgSimToClient_Content::clear_unit_order_ack() {
  if (unit_order_ack_ != NULL) unit_order_ack_->::MsgsSimToClient::MsgUnitOrderAck::Clear();
  _clear_bit(0);
}
inline const ::MsgsSimToClient::MsgUnitOrderAck& MsgSimToClient_Content::unit_order_ack() const {
  return unit_order_ack_ != NULL ? *unit_order_ack_ : *default_instance_->unit_order_ack_;
}
inline ::MsgsSimToClient::MsgUnitOrderAck* MsgSimToClient_Content::mutable_unit_order_ack() {
  _set_bit(0);
  if (unit_order_ack_ == NULL) unit_order_ack_ = new ::MsgsSimToClient::MsgUnitOrderAck;
  return unit_order_ack_;
}

// optional .MsgsSimToClient.MsgAutomatOrderAck automat_order_ack = 2;
inline bool MsgSimToClient_Content::has_automat_order_ack() const {
  return _has_bit(1);
}
inline void MsgSimToClient_Content::clear_automat_order_ack() {
  if (automat_order_ack_ != NULL) automat_order_ack_->::MsgsSimToClient::MsgAutomatOrderAck::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgAutomatOrderAck& MsgSimToClient_Content::automat_order_ack() const {
  return automat_order_ack_ != NULL ? *automat_order_ack_ : *default_instance_->automat_order_ack_;
}
inline ::MsgsSimToClient::MsgAutomatOrderAck* MsgSimToClient_Content::mutable_automat_order_ack() {
  _set_bit(1);
  if (automat_order_ack_ == NULL) automat_order_ack_ = new ::MsgsSimToClient::MsgAutomatOrderAck;
  return automat_order_ack_;
}

// optional .MsgsSimToClient.MsgCrowdOrderAck crowd_order_ack = 3;
inline bool MsgSimToClient_Content::has_crowd_order_ack() const {
  return _has_bit(2);
}
inline void MsgSimToClient_Content::clear_crowd_order_ack() {
  if (crowd_order_ack_ != NULL) crowd_order_ack_->::MsgsSimToClient::MsgCrowdOrderAck::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgCrowdOrderAck& MsgSimToClient_Content::crowd_order_ack() const {
  return crowd_order_ack_ != NULL ? *crowd_order_ack_ : *default_instance_->crowd_order_ack_;
}
inline ::MsgsSimToClient::MsgCrowdOrderAck* MsgSimToClient_Content::mutable_crowd_order_ack() {
  _set_bit(2);
  if (crowd_order_ack_ == NULL) crowd_order_ack_ = new ::MsgsSimToClient::MsgCrowdOrderAck;
  return crowd_order_ack_;
}

// optional .MsgsSimToClient.MsgFragOrderAck frag_order_ack = 4;
inline bool MsgSimToClient_Content::has_frag_order_ack() const {
  return _has_bit(3);
}
inline void MsgSimToClient_Content::clear_frag_order_ack() {
  if (frag_order_ack_ != NULL) frag_order_ack_->::MsgsSimToClient::MsgFragOrderAck::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::MsgFragOrderAck& MsgSimToClient_Content::frag_order_ack() const {
  return frag_order_ack_ != NULL ? *frag_order_ack_ : *default_instance_->frag_order_ack_;
}
inline ::MsgsSimToClient::MsgFragOrderAck* MsgSimToClient_Content::mutable_frag_order_ack() {
  _set_bit(3);
  if (frag_order_ack_ == NULL) frag_order_ack_ = new ::MsgsSimToClient::MsgFragOrderAck;
  return frag_order_ack_;
}

// optional .MsgsSimToClient.MsgSetAutomatModeAck set_automat_mode_ack = 5;
inline bool MsgSimToClient_Content::has_set_automat_mode_ack() const {
  return _has_bit(4);
}
inline void MsgSimToClient_Content::clear_set_automat_mode_ack() {
  if (set_automat_mode_ack_ != NULL) set_automat_mode_ack_->::MsgsSimToClient::MsgSetAutomatModeAck::Clear();
  _clear_bit(4);
}
inline const ::MsgsSimToClient::MsgSetAutomatModeAck& MsgSimToClient_Content::set_automat_mode_ack() const {
  return set_automat_mode_ack_ != NULL ? *set_automat_mode_ack_ : *default_instance_->set_automat_mode_ack_;
}
inline ::MsgsSimToClient::MsgSetAutomatModeAck* MsgSimToClient_Content::mutable_set_automat_mode_ack() {
  _set_bit(4);
  if (set_automat_mode_ack_ == NULL) set_automat_mode_ack_ = new ::MsgsSimToClient::MsgSetAutomatModeAck;
  return set_automat_mode_ack_;
}

// optional .MsgsSimToClient.MsgUnitCreationRequestAck unit_creation_request_ack = 6;
inline bool MsgSimToClient_Content::has_unit_creation_request_ack() const {
  return _has_bit(5);
}
inline void MsgSimToClient_Content::clear_unit_creation_request_ack() {
  if (unit_creation_request_ack_ != NULL) unit_creation_request_ack_->::MsgsSimToClient::MsgUnitCreationRequestAck::Clear();
  _clear_bit(5);
}
inline const ::MsgsSimToClient::MsgUnitCreationRequestAck& MsgSimToClient_Content::unit_creation_request_ack() const {
  return unit_creation_request_ack_ != NULL ? *unit_creation_request_ack_ : *default_instance_->unit_creation_request_ack_;
}
inline ::MsgsSimToClient::MsgUnitCreationRequestAck* MsgSimToClient_Content::mutable_unit_creation_request_ack() {
  _set_bit(5);
  if (unit_creation_request_ack_ == NULL) unit_creation_request_ack_ = new ::MsgsSimToClient::MsgUnitCreationRequestAck;
  return unit_creation_request_ack_;
}

// optional .MsgsSimToClient.MsgMagicActionAck magic_action_ack = 7;
inline bool MsgSimToClient_Content::has_magic_action_ack() const {
  return _has_bit(6);
}
inline void MsgSimToClient_Content::clear_magic_action_ack() {
  if (magic_action_ack_ != NULL) magic_action_ack_->::MsgsSimToClient::MsgMagicActionAck::Clear();
  _clear_bit(6);
}
inline const ::MsgsSimToClient::MsgMagicActionAck& MsgSimToClient_Content::magic_action_ack() const {
  return magic_action_ack_ != NULL ? *magic_action_ack_ : *default_instance_->magic_action_ack_;
}
inline ::MsgsSimToClient::MsgMagicActionAck* MsgSimToClient_Content::mutable_magic_action_ack() {
  _set_bit(6);
  if (magic_action_ack_ == NULL) magic_action_ack_ = new ::MsgsSimToClient::MsgMagicActionAck;
  return magic_action_ack_;
}

// optional .MsgsSimToClient.MsgUnitMagicActionAck unit_magic_action_ack = 8;
inline bool MsgSimToClient_Content::has_unit_magic_action_ack() const {
  return _has_bit(7);
}
inline void MsgSimToClient_Content::clear_unit_magic_action_ack() {
  if (unit_magic_action_ack_ != NULL) unit_magic_action_ack_->::MsgsSimToClient::MsgUnitMagicActionAck::Clear();
  _clear_bit(7);
}
inline const ::MsgsSimToClient::MsgUnitMagicActionAck& MsgSimToClient_Content::unit_magic_action_ack() const {
  return unit_magic_action_ack_ != NULL ? *unit_magic_action_ack_ : *default_instance_->unit_magic_action_ack_;
}
inline ::MsgsSimToClient::MsgUnitMagicActionAck* MsgSimToClient_Content::mutable_unit_magic_action_ack() {
  _set_bit(7);
  if (unit_magic_action_ack_ == NULL) unit_magic_action_ack_ = new ::MsgsSimToClient::MsgUnitMagicActionAck;
  return unit_magic_action_ack_;
}

// optional .MsgsSimToClient.MsgObjectMagicActionAck object_magic_action_ack = 9;
inline bool MsgSimToClient_Content::has_object_magic_action_ack() const {
  return _has_bit(8);
}
inline void MsgSimToClient_Content::clear_object_magic_action_ack() {
  if (object_magic_action_ack_ != NULL) object_magic_action_ack_->::MsgsSimToClient::MsgObjectMagicActionAck::Clear();
  _clear_bit(8);
}
inline const ::MsgsSimToClient::MsgObjectMagicActionAck& MsgSimToClient_Content::object_magic_action_ack() const {
  return object_magic_action_ack_ != NULL ? *object_magic_action_ack_ : *default_instance_->object_magic_action_ack_;
}
inline ::MsgsSimToClient::MsgObjectMagicActionAck* MsgSimToClient_Content::mutable_object_magic_action_ack() {
  _set_bit(8);
  if (object_magic_action_ack_ == NULL) object_magic_action_ack_ = new ::MsgsSimToClient::MsgObjectMagicActionAck;
  return object_magic_action_ack_;
}

// optional .MsgsSimToClient.MsgCrowdMagicActionAck crowd_magic_action_ack = 10;
inline bool MsgSimToClient_Content::has_crowd_magic_action_ack() const {
  return _has_bit(9);
}
inline void MsgSimToClient_Content::clear_crowd_magic_action_ack() {
  if (crowd_magic_action_ack_ != NULL) crowd_magic_action_ack_->::MsgsSimToClient::MsgCrowdMagicActionAck::Clear();
  _clear_bit(9);
}
inline const ::MsgsSimToClient::MsgCrowdMagicActionAck& MsgSimToClient_Content::crowd_magic_action_ack() const {
  return crowd_magic_action_ack_ != NULL ? *crowd_magic_action_ack_ : *default_instance_->crowd_magic_action_ack_;
}
inline ::MsgsSimToClient::MsgCrowdMagicActionAck* MsgSimToClient_Content::mutable_crowd_magic_action_ack() {
  _set_bit(9);
  if (crowd_magic_action_ack_ == NULL) crowd_magic_action_ack_ = new ::MsgsSimToClient::MsgCrowdMagicActionAck;
  return crowd_magic_action_ack_;
}

// optional .MsgsSimToClient.MsgChangeDiplomacyAck change_diplomacy_ack = 11;
inline bool MsgSimToClient_Content::has_change_diplomacy_ack() const {
  return _has_bit(10);
}
inline void MsgSimToClient_Content::clear_change_diplomacy_ack() {
  if (change_diplomacy_ack_ != NULL) change_diplomacy_ack_->::MsgsSimToClient::MsgChangeDiplomacyAck::Clear();
  _clear_bit(10);
}
inline const ::MsgsSimToClient::MsgChangeDiplomacyAck& MsgSimToClient_Content::change_diplomacy_ack() const {
  return change_diplomacy_ack_ != NULL ? *change_diplomacy_ack_ : *default_instance_->change_diplomacy_ack_;
}
inline ::MsgsSimToClient::MsgChangeDiplomacyAck* MsgSimToClient_Content::mutable_change_diplomacy_ack() {
  _set_bit(10);
  if (change_diplomacy_ack_ == NULL) change_diplomacy_ack_ = new ::MsgsSimToClient::MsgChangeDiplomacyAck;
  return change_diplomacy_ack_;
}

// optional .MsgsSimToClient.MsgAutomatChangeKnowledgeGroupAck automat_change_knowledge_group_ack = 12;
inline bool MsgSimToClient_Content::has_automat_change_knowledge_group_ack() const {
  return _has_bit(11);
}
inline void MsgSimToClient_Content::clear_automat_change_knowledge_group_ack() {
  if (automat_change_knowledge_group_ack_ != NULL) automat_change_knowledge_group_ack_->::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck::Clear();
  _clear_bit(11);
}
inline const ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck& MsgSimToClient_Content::automat_change_knowledge_group_ack() const {
  return automat_change_knowledge_group_ack_ != NULL ? *automat_change_knowledge_group_ack_ : *default_instance_->automat_change_knowledge_group_ack_;
}
inline ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck* MsgSimToClient_Content::mutable_automat_change_knowledge_group_ack() {
  _set_bit(11);
  if (automat_change_knowledge_group_ack_ == NULL) automat_change_knowledge_group_ack_ = new ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck;
  return automat_change_knowledge_group_ack_;
}

// optional .MsgsSimToClient.MsgAutomatChangeLogisticLinksAck automat_change_logistic_links_ack = 13;
inline bool MsgSimToClient_Content::has_automat_change_logistic_links_ack() const {
  return _has_bit(12);
}
inline void MsgSimToClient_Content::clear_automat_change_logistic_links_ack() {
  if (automat_change_logistic_links_ack_ != NULL) automat_change_logistic_links_ack_->::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck::Clear();
  _clear_bit(12);
}
inline const ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck& MsgSimToClient_Content::automat_change_logistic_links_ack() const {
  return automat_change_logistic_links_ack_ != NULL ? *automat_change_logistic_links_ack_ : *default_instance_->automat_change_logistic_links_ack_;
}
inline ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck* MsgSimToClient_Content::mutable_automat_change_logistic_links_ack() {
  _set_bit(12);
  if (automat_change_logistic_links_ack_ == NULL) automat_change_logistic_links_ack_ = new ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck;
  return automat_change_logistic_links_ack_;
}

// optional .MsgsSimToClient.MsgAutomatChangeSuperiorAck automat_change_superior_ack = 14;
inline bool MsgSimToClient_Content::has_automat_change_superior_ack() const {
  return _has_bit(13);
}
inline void MsgSimToClient_Content::clear_automat_change_superior_ack() {
  if (automat_change_superior_ack_ != NULL) automat_change_superior_ack_->::MsgsSimToClient::MsgAutomatChangeSuperiorAck::Clear();
  _clear_bit(13);
}
inline const ::MsgsSimToClient::MsgAutomatChangeSuperiorAck& MsgSimToClient_Content::automat_change_superior_ack() const {
  return automat_change_superior_ack_ != NULL ? *automat_change_superior_ack_ : *default_instance_->automat_change_superior_ack_;
}
inline ::MsgsSimToClient::MsgAutomatChangeSuperiorAck* MsgSimToClient_Content::mutable_automat_change_superior_ack() {
  _set_bit(13);
  if (automat_change_superior_ack_ == NULL) automat_change_superior_ack_ = new ::MsgsSimToClient::MsgAutomatChangeSuperiorAck;
  return automat_change_superior_ack_;
}

// optional .MsgsSimToClient.MsgUnitChangeSuperiorAck unit_change_superior_ack = 15;
inline bool MsgSimToClient_Content::has_unit_change_superior_ack() const {
  return _has_bit(14);
}
inline void MsgSimToClient_Content::clear_unit_change_superior_ack() {
  if (unit_change_superior_ack_ != NULL) unit_change_superior_ack_->::MsgsSimToClient::MsgUnitChangeSuperiorAck::Clear();
  _clear_bit(14);
}
inline const ::MsgsSimToClient::MsgUnitChangeSuperiorAck& MsgSimToClient_Content::unit_change_superior_ack() const {
  return unit_change_superior_ack_ != NULL ? *unit_change_superior_ack_ : *default_instance_->unit_change_superior_ack_;
}
inline ::MsgsSimToClient::MsgUnitChangeSuperiorAck* MsgSimToClient_Content::mutable_unit_change_superior_ack() {
  _set_bit(14);
  if (unit_change_superior_ack_ == NULL) unit_change_superior_ack_ = new ::MsgsSimToClient::MsgUnitChangeSuperiorAck;
  return unit_change_superior_ack_;
}

// optional .MsgsSimToClient.MsgLogSupplyPushFlowAck log_supply_push_flow_ack = 16;
inline bool MsgSimToClient_Content::has_log_supply_push_flow_ack() const {
  return _has_bit(15);
}
inline void MsgSimToClient_Content::clear_log_supply_push_flow_ack() {
  if (log_supply_push_flow_ack_ != NULL) log_supply_push_flow_ack_->::MsgsSimToClient::MsgLogSupplyPushFlowAck::Clear();
  _clear_bit(15);
}
inline const ::MsgsSimToClient::MsgLogSupplyPushFlowAck& MsgSimToClient_Content::log_supply_push_flow_ack() const {
  return log_supply_push_flow_ack_ != NULL ? *log_supply_push_flow_ack_ : *default_instance_->log_supply_push_flow_ack_;
}
inline ::MsgsSimToClient::MsgLogSupplyPushFlowAck* MsgSimToClient_Content::mutable_log_supply_push_flow_ack() {
  _set_bit(15);
  if (log_supply_push_flow_ack_ == NULL) log_supply_push_flow_ack_ = new ::MsgsSimToClient::MsgLogSupplyPushFlowAck;
  return log_supply_push_flow_ack_;
}

// optional .MsgsSimToClient.MsgLogSupplyChangeQuotasAck log_supply_change_quotas_ack = 17;
inline bool MsgSimToClient_Content::has_log_supply_change_quotas_ack() const {
  return _has_bit(16);
}
inline void MsgSimToClient_Content::clear_log_supply_change_quotas_ack() {
  if (log_supply_change_quotas_ack_ != NULL) log_supply_change_quotas_ack_->::MsgsSimToClient::MsgLogSupplyChangeQuotasAck::Clear();
  _clear_bit(16);
}
inline const ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck& MsgSimToClient_Content::log_supply_change_quotas_ack() const {
  return log_supply_change_quotas_ack_ != NULL ? *log_supply_change_quotas_ack_ : *default_instance_->log_supply_change_quotas_ack_;
}
inline ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck* MsgSimToClient_Content::mutable_log_supply_change_quotas_ack() {
  _set_bit(16);
  if (log_supply_change_quotas_ack_ == NULL) log_supply_change_quotas_ack_ = new ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck;
  return log_supply_change_quotas_ack_;
}

// optional .MsgsSimToClient.MsgControlInformation control_information = 18;
inline bool MsgSimToClient_Content::has_control_information() const {
  return _has_bit(17);
}
inline void MsgSimToClient_Content::clear_control_information() {
  if (control_information_ != NULL) control_information_->::MsgsSimToClient::MsgControlInformation::Clear();
  _clear_bit(17);
}
inline const ::MsgsSimToClient::MsgControlInformation& MsgSimToClient_Content::control_information() const {
  return control_information_ != NULL ? *control_information_ : *default_instance_->control_information_;
}
inline ::MsgsSimToClient::MsgControlInformation* MsgSimToClient_Content::mutable_control_information() {
  _set_bit(17);
  if (control_information_ == NULL) control_information_ = new ::MsgsSimToClient::MsgControlInformation;
  return control_information_;
}

// optional .MsgsSimToClient.MsgControlProfilingInformation control_profiling_information = 19;
inline bool MsgSimToClient_Content::has_control_profiling_information() const {
  return _has_bit(18);
}
inline void MsgSimToClient_Content::clear_control_profiling_information() {
  if (control_profiling_information_ != NULL) control_profiling_information_->::MsgsSimToClient::MsgControlProfilingInformation::Clear();
  _clear_bit(18);
}
inline const ::MsgsSimToClient::MsgControlProfilingInformation& MsgSimToClient_Content::control_profiling_information() const {
  return control_profiling_information_ != NULL ? *control_profiling_information_ : *default_instance_->control_profiling_information_;
}
inline ::MsgsSimToClient::MsgControlProfilingInformation* MsgSimToClient_Content::mutable_control_profiling_information() {
  _set_bit(18);
  if (control_profiling_information_ == NULL) control_profiling_information_ = new ::MsgsSimToClient::MsgControlProfilingInformation;
  return control_profiling_information_;
}

// optional .MsgsSimToClient.MsgControlBeginTick control_begin_tick = 20;
inline bool MsgSimToClient_Content::has_control_begin_tick() const {
  return _has_bit(19);
}
inline void MsgSimToClient_Content::clear_control_begin_tick() {
  if (control_begin_tick_ != NULL) control_begin_tick_->::MsgsSimToClient::MsgControlBeginTick::Clear();
  _clear_bit(19);
}
inline const ::MsgsSimToClient::MsgControlBeginTick& MsgSimToClient_Content::control_begin_tick() const {
  return control_begin_tick_ != NULL ? *control_begin_tick_ : *default_instance_->control_begin_tick_;
}
inline ::MsgsSimToClient::MsgControlBeginTick* MsgSimToClient_Content::mutable_control_begin_tick() {
  _set_bit(19);
  if (control_begin_tick_ == NULL) control_begin_tick_ = new ::MsgsSimToClient::MsgControlBeginTick;
  return control_begin_tick_;
}

// optional .MsgsSimToClient.MsgControlEndTick control_end_tick = 21;
inline bool MsgSimToClient_Content::has_control_end_tick() const {
  return _has_bit(20);
}
inline void MsgSimToClient_Content::clear_control_end_tick() {
  if (control_end_tick_ != NULL) control_end_tick_->::MsgsSimToClient::MsgControlEndTick::Clear();
  _clear_bit(20);
}
inline const ::MsgsSimToClient::MsgControlEndTick& MsgSimToClient_Content::control_end_tick() const {
  return control_end_tick_ != NULL ? *control_end_tick_ : *default_instance_->control_end_tick_;
}
inline ::MsgsSimToClient::MsgControlEndTick* MsgSimToClient_Content::mutable_control_end_tick() {
  _set_bit(20);
  if (control_end_tick_ == NULL) control_end_tick_ = new ::MsgsSimToClient::MsgControlEndTick;
  return control_end_tick_;
}

// optional .MsgsSimToClient.MsgControlStopAck control_stop_ack = 22;
inline bool MsgSimToClient_Content::has_control_stop_ack() const {
  return _has_bit(21);
}
inline void MsgSimToClient_Content::clear_control_stop_ack() {
  if (control_stop_ack_ != NULL) control_stop_ack_->::MsgsSimToClient::MsgControlStopAck::Clear();
  _clear_bit(21);
}
inline const ::MsgsSimToClient::MsgControlStopAck& MsgSimToClient_Content::control_stop_ack() const {
  return control_stop_ack_ != NULL ? *control_stop_ack_ : *default_instance_->control_stop_ack_;
}
inline ::MsgsSimToClient::MsgControlStopAck* MsgSimToClient_Content::mutable_control_stop_ack() {
  _set_bit(21);
  if (control_stop_ack_ == NULL) control_stop_ack_ = new ::MsgsSimToClient::MsgControlStopAck;
  return control_stop_ack_;
}

// optional .MsgsSimToClient.MsgControlPauseAck control_pause_ack = 23;
inline bool MsgSimToClient_Content::has_control_pause_ack() const {
  return _has_bit(22);
}
inline void MsgSimToClient_Content::clear_control_pause_ack() {
  if (control_pause_ack_ != NULL) control_pause_ack_->::MsgsSimToClient::MsgControlPauseAck::Clear();
  _clear_bit(22);
}
inline const ::MsgsSimToClient::MsgControlPauseAck& MsgSimToClient_Content::control_pause_ack() const {
  return control_pause_ack_ != NULL ? *control_pause_ack_ : *default_instance_->control_pause_ack_;
}
inline ::MsgsSimToClient::MsgControlPauseAck* MsgSimToClient_Content::mutable_control_pause_ack() {
  _set_bit(22);
  if (control_pause_ack_ == NULL) control_pause_ack_ = new ::MsgsSimToClient::MsgControlPauseAck;
  return control_pause_ack_;
}

// optional .MsgsSimToClient.MsgControlResumeAck control_resume_ack = 24;
inline bool MsgSimToClient_Content::has_control_resume_ack() const {
  return _has_bit(23);
}
inline void MsgSimToClient_Content::clear_control_resume_ack() {
  if (control_resume_ack_ != NULL) control_resume_ack_->::MsgsSimToClient::MsgControlResumeAck::Clear();
  _clear_bit(23);
}
inline const ::MsgsSimToClient::MsgControlResumeAck& MsgSimToClient_Content::control_resume_ack() const {
  return control_resume_ack_ != NULL ? *control_resume_ack_ : *default_instance_->control_resume_ack_;
}
inline ::MsgsSimToClient::MsgControlResumeAck* MsgSimToClient_Content::mutable_control_resume_ack() {
  _set_bit(23);
  if (control_resume_ack_ == NULL) control_resume_ack_ = new ::MsgsSimToClient::MsgControlResumeAck;
  return control_resume_ack_;
}

// optional .MsgsSimToClient.MsgControlChangeTimeFactorAck control_change_time_factor_ack = 25;
inline bool MsgSimToClient_Content::has_control_change_time_factor_ack() const {
  return _has_bit(24);
}
inline void MsgSimToClient_Content::clear_control_change_time_factor_ack() {
  if (control_change_time_factor_ack_ != NULL) control_change_time_factor_ack_->::MsgsSimToClient::MsgControlChangeTimeFactorAck::Clear();
  _clear_bit(24);
}
inline const ::MsgsSimToClient::MsgControlChangeTimeFactorAck& MsgSimToClient_Content::control_change_time_factor_ack() const {
  return control_change_time_factor_ack_ != NULL ? *control_change_time_factor_ack_ : *default_instance_->control_change_time_factor_ack_;
}
inline ::MsgsSimToClient::MsgControlChangeTimeFactorAck* MsgSimToClient_Content::mutable_control_change_time_factor_ack() {
  _set_bit(24);
  if (control_change_time_factor_ack_ == NULL) control_change_time_factor_ack_ = new ::MsgsSimToClient::MsgControlChangeTimeFactorAck;
  return control_change_time_factor_ack_;
}

// optional .MsgsSimToClient.MsgControlDatetimeChangeAck control_date_time_change_ack = 26;
inline bool MsgSimToClient_Content::has_control_date_time_change_ack() const {
  return _has_bit(25);
}
inline void MsgSimToClient_Content::clear_control_date_time_change_ack() {
  if (control_date_time_change_ack_ != NULL) control_date_time_change_ack_->::MsgsSimToClient::MsgControlDatetimeChangeAck::Clear();
  _clear_bit(25);
}
inline const ::MsgsSimToClient::MsgControlDatetimeChangeAck& MsgSimToClient_Content::control_date_time_change_ack() const {
  return control_date_time_change_ack_ != NULL ? *control_date_time_change_ack_ : *default_instance_->control_date_time_change_ack_;
}
inline ::MsgsSimToClient::MsgControlDatetimeChangeAck* MsgSimToClient_Content::mutable_control_date_time_change_ack() {
  _set_bit(25);
  if (control_date_time_change_ack_ == NULL) control_date_time_change_ack_ = new ::MsgsSimToClient::MsgControlDatetimeChangeAck;
  return control_date_time_change_ack_;
}

// optional .MsgsSimToClient.MsgControlCheckPointSaveEnd control_checkpoint_save_end = 27;
inline bool MsgSimToClient_Content::has_control_checkpoint_save_end() const {
  return _has_bit(26);
}
inline void MsgSimToClient_Content::clear_control_checkpoint_save_end() {
  if (control_checkpoint_save_end_ != NULL) control_checkpoint_save_end_->::MsgsSimToClient::MsgControlCheckPointSaveEnd::Clear();
  _clear_bit(26);
}
inline const ::MsgsSimToClient::MsgControlCheckPointSaveEnd& MsgSimToClient_Content::control_checkpoint_save_end() const {
  return control_checkpoint_save_end_ != NULL ? *control_checkpoint_save_end_ : *default_instance_->control_checkpoint_save_end_;
}
inline ::MsgsSimToClient::MsgControlCheckPointSaveEnd* MsgSimToClient_Content::mutable_control_checkpoint_save_end() {
  _set_bit(26);
  if (control_checkpoint_save_end_ == NULL) control_checkpoint_save_end_ = new ::MsgsSimToClient::MsgControlCheckPointSaveEnd;
  return control_checkpoint_save_end_;
}

// optional .MsgsSimToClient.MsgFormationCreation formation_creation = 28;
inline bool MsgSimToClient_Content::has_formation_creation() const {
  return _has_bit(27);
}
inline void MsgSimToClient_Content::clear_formation_creation() {
  if (formation_creation_ != NULL) formation_creation_->::MsgsSimToClient::MsgFormationCreation::Clear();
  _clear_bit(27);
}
inline const ::MsgsSimToClient::MsgFormationCreation& MsgSimToClient_Content::formation_creation() const {
  return formation_creation_ != NULL ? *formation_creation_ : *default_instance_->formation_creation_;
}
inline ::MsgsSimToClient::MsgFormationCreation* MsgSimToClient_Content::mutable_formation_creation() {
  _set_bit(27);
  if (formation_creation_ == NULL) formation_creation_ = new ::MsgsSimToClient::MsgFormationCreation;
  return formation_creation_;
}

// optional .MsgsSimToClient.MsgPartyCreation party_creation = 29;
inline bool MsgSimToClient_Content::has_party_creation() const {
  return _has_bit(28);
}
inline void MsgSimToClient_Content::clear_party_creation() {
  if (party_creation_ != NULL) party_creation_->::MsgsSimToClient::MsgPartyCreation::Clear();
  _clear_bit(28);
}
inline const ::MsgsSimToClient::MsgPartyCreation& MsgSimToClient_Content::party_creation() const {
  return party_creation_ != NULL ? *party_creation_ : *default_instance_->party_creation_;
}
inline ::MsgsSimToClient::MsgPartyCreation* MsgSimToClient_Content::mutable_party_creation() {
  _set_bit(28);
  if (party_creation_ == NULL) party_creation_ = new ::MsgsSimToClient::MsgPartyCreation;
  return party_creation_;
}

// optional .MsgsSimToClient.MsgAutomatCreation automat_creation = 30;
inline bool MsgSimToClient_Content::has_automat_creation() const {
  return _has_bit(29);
}
inline void MsgSimToClient_Content::clear_automat_creation() {
  if (automat_creation_ != NULL) automat_creation_->::MsgsSimToClient::MsgAutomatCreation::Clear();
  _clear_bit(29);
}
inline const ::MsgsSimToClient::MsgAutomatCreation& MsgSimToClient_Content::automat_creation() const {
  return automat_creation_ != NULL ? *automat_creation_ : *default_instance_->automat_creation_;
}
inline ::MsgsSimToClient::MsgAutomatCreation* MsgSimToClient_Content::mutable_automat_creation() {
  _set_bit(29);
  if (automat_creation_ == NULL) automat_creation_ = new ::MsgsSimToClient::MsgAutomatCreation;
  return automat_creation_;
}

// optional .MsgsSimToClient.MsgAutomatAttributes automat_attributes = 31;
inline bool MsgSimToClient_Content::has_automat_attributes() const {
  return _has_bit(30);
}
inline void MsgSimToClient_Content::clear_automat_attributes() {
  if (automat_attributes_ != NULL) automat_attributes_->::MsgsSimToClient::MsgAutomatAttributes::Clear();
  _clear_bit(30);
}
inline const ::MsgsSimToClient::MsgAutomatAttributes& MsgSimToClient_Content::automat_attributes() const {
  return automat_attributes_ != NULL ? *automat_attributes_ : *default_instance_->automat_attributes_;
}
inline ::MsgsSimToClient::MsgAutomatAttributes* MsgSimToClient_Content::mutable_automat_attributes() {
  _set_bit(30);
  if (automat_attributes_ == NULL) automat_attributes_ = new ::MsgsSimToClient::MsgAutomatAttributes;
  return automat_attributes_;
}

// optional .MsgsSimToClient.MsgUnitCreation unit_creation = 32;
inline bool MsgSimToClient_Content::has_unit_creation() const {
  return _has_bit(31);
}
inline void MsgSimToClient_Content::clear_unit_creation() {
  if (unit_creation_ != NULL) unit_creation_->::MsgsSimToClient::MsgUnitCreation::Clear();
  _clear_bit(31);
}
inline const ::MsgsSimToClient::MsgUnitCreation& MsgSimToClient_Content::unit_creation() const {
  return unit_creation_ != NULL ? *unit_creation_ : *default_instance_->unit_creation_;
}
inline ::MsgsSimToClient::MsgUnitCreation* MsgSimToClient_Content::mutable_unit_creation() {
  _set_bit(31);
  if (unit_creation_ == NULL) unit_creation_ = new ::MsgsSimToClient::MsgUnitCreation;
  return unit_creation_;
}

// optional .MsgsSimToClient.MsgUnitAttributes unit_attributes = 33;
inline bool MsgSimToClient_Content::has_unit_attributes() const {
  return _has_bit(32);
}
inline void MsgSimToClient_Content::clear_unit_attributes() {
  if (unit_attributes_ != NULL) unit_attributes_->::MsgsSimToClient::MsgUnitAttributes::Clear();
  _clear_bit(32);
}
inline const ::MsgsSimToClient::MsgUnitAttributes& MsgSimToClient_Content::unit_attributes() const {
  return unit_attributes_ != NULL ? *unit_attributes_ : *default_instance_->unit_attributes_;
}
inline ::MsgsSimToClient::MsgUnitAttributes* MsgSimToClient_Content::mutable_unit_attributes() {
  _set_bit(32);
  if (unit_attributes_ == NULL) unit_attributes_ = new ::MsgsSimToClient::MsgUnitAttributes;
  return unit_attributes_;
}

// optional .MsgsSimToClient.MsgUnitPathFind unit_pathfind = 34;
inline bool MsgSimToClient_Content::has_unit_pathfind() const {
  return _has_bit(33);
}
inline void MsgSimToClient_Content::clear_unit_pathfind() {
  if (unit_pathfind_ != NULL) unit_pathfind_->::MsgsSimToClient::MsgUnitPathFind::Clear();
  _clear_bit(33);
}
inline const ::MsgsSimToClient::MsgUnitPathFind& MsgSimToClient_Content::unit_pathfind() const {
  return unit_pathfind_ != NULL ? *unit_pathfind_ : *default_instance_->unit_pathfind_;
}
inline ::MsgsSimToClient::MsgUnitPathFind* MsgSimToClient_Content::mutable_unit_pathfind() {
  _set_bit(33);
  if (unit_pathfind_ == NULL) unit_pathfind_ = new ::MsgsSimToClient::MsgUnitPathFind;
  return unit_pathfind_;
}

// optional .MsgsSimToClient.MsgUnitDestruction unit_destruction = 35;
inline bool MsgSimToClient_Content::has_unit_destruction() const {
  return _has_bit(34);
}
inline void MsgSimToClient_Content::clear_unit_destruction() {
  if (unit_destruction_ != NULL) unit_destruction_->::MsgsSimToClient::MsgUnitDestruction::Clear();
  _clear_bit(34);
}
inline const ::MsgsSimToClient::MsgUnitDestruction& MsgSimToClient_Content::unit_destruction() const {
  return unit_destruction_ != NULL ? *unit_destruction_ : *default_instance_->unit_destruction_;
}
inline ::MsgsSimToClient::MsgUnitDestruction* MsgSimToClient_Content::mutable_unit_destruction() {
  _set_bit(34);
  if (unit_destruction_ == NULL) unit_destruction_ = new ::MsgsSimToClient::MsgUnitDestruction;
  return unit_destruction_;
}

// optional .MsgsSimToClient.MsgUnitEnvironmentType unit_environment_type = 36;
inline bool MsgSimToClient_Content::has_unit_environment_type() const {
  return _has_bit(35);
}
inline void MsgSimToClient_Content::clear_unit_environment_type() {
  if (unit_environment_type_ != NULL) unit_environment_type_->::MsgsSimToClient::MsgUnitEnvironmentType::Clear();
  _clear_bit(35);
}
inline const ::MsgsSimToClient::MsgUnitEnvironmentType& MsgSimToClient_Content::unit_environment_type() const {
  return unit_environment_type_ != NULL ? *unit_environment_type_ : *default_instance_->unit_environment_type_;
}
inline ::MsgsSimToClient::MsgUnitEnvironmentType* MsgSimToClient_Content::mutable_unit_environment_type() {
  _set_bit(35);
  if (unit_environment_type_ == NULL) unit_environment_type_ = new ::MsgsSimToClient::MsgUnitEnvironmentType;
  return unit_environment_type_;
}

// optional .Common.MsgChangeDiplomacy change_diplomacy = 37;
inline bool MsgSimToClient_Content::has_change_diplomacy() const {
  return _has_bit(36);
}
inline void MsgSimToClient_Content::clear_change_diplomacy() {
  if (change_diplomacy_ != NULL) change_diplomacy_->::Common::MsgChangeDiplomacy::Clear();
  _clear_bit(36);
}
inline const ::Common::MsgChangeDiplomacy& MsgSimToClient_Content::change_diplomacy() const {
  return change_diplomacy_ != NULL ? *change_diplomacy_ : *default_instance_->change_diplomacy_;
}
inline ::Common::MsgChangeDiplomacy* MsgSimToClient_Content::mutable_change_diplomacy() {
  _set_bit(36);
  if (change_diplomacy_ == NULL) change_diplomacy_ = new ::Common::MsgChangeDiplomacy;
  return change_diplomacy_;
}

// optional .Common.MsgUnitChangeSuperior unit_change_superior = 38;
inline bool MsgSimToClient_Content::has_unit_change_superior() const {
  return _has_bit(37);
}
inline void MsgSimToClient_Content::clear_unit_change_superior() {
  if (unit_change_superior_ != NULL) unit_change_superior_->::Common::MsgUnitChangeSuperior::Clear();
  _clear_bit(37);
}
inline const ::Common::MsgUnitChangeSuperior& MsgSimToClient_Content::unit_change_superior() const {
  return unit_change_superior_ != NULL ? *unit_change_superior_ : *default_instance_->unit_change_superior_;
}
inline ::Common::MsgUnitChangeSuperior* MsgSimToClient_Content::mutable_unit_change_superior() {
  _set_bit(37);
  if (unit_change_superior_ == NULL) unit_change_superior_ = new ::Common::MsgUnitChangeSuperior;
  return unit_change_superior_;
}

// optional .Common.MsgAutomatChangeLogisticLinks automat_change_logistic_links = 39;
inline bool MsgSimToClient_Content::has_automat_change_logistic_links() const {
  return _has_bit(38);
}
inline void MsgSimToClient_Content::clear_automat_change_logistic_links() {
  if (automat_change_logistic_links_ != NULL) automat_change_logistic_links_->::Common::MsgAutomatChangeLogisticLinks::Clear();
  _clear_bit(38);
}
inline const ::Common::MsgAutomatChangeLogisticLinks& MsgSimToClient_Content::automat_change_logistic_links() const {
  return automat_change_logistic_links_ != NULL ? *automat_change_logistic_links_ : *default_instance_->automat_change_logistic_links_;
}
inline ::Common::MsgAutomatChangeLogisticLinks* MsgSimToClient_Content::mutable_automat_change_logistic_links() {
  _set_bit(38);
  if (automat_change_logistic_links_ == NULL) automat_change_logistic_links_ = new ::Common::MsgAutomatChangeLogisticLinks;
  return automat_change_logistic_links_;
}

// optional .Common.MsgAutomatChangeKnowledgeGroup automat_change_knowledge_group = 40;
inline bool MsgSimToClient_Content::has_automat_change_knowledge_group() const {
  return _has_bit(39);
}
inline void MsgSimToClient_Content::clear_automat_change_knowledge_group() {
  if (automat_change_knowledge_group_ != NULL) automat_change_knowledge_group_->::Common::MsgAutomatChangeKnowledgeGroup::Clear();
  _clear_bit(39);
}
inline const ::Common::MsgAutomatChangeKnowledgeGroup& MsgSimToClient_Content::automat_change_knowledge_group() const {
  return automat_change_knowledge_group_ != NULL ? *automat_change_knowledge_group_ : *default_instance_->automat_change_knowledge_group_;
}
inline ::Common::MsgAutomatChangeKnowledgeGroup* MsgSimToClient_Content::mutable_automat_change_knowledge_group() {
  _set_bit(39);
  if (automat_change_knowledge_group_ == NULL) automat_change_knowledge_group_ = new ::Common::MsgAutomatChangeKnowledgeGroup;
  return automat_change_knowledge_group_;
}

// optional .Common.MsgAutomatChangeSuperior automat_change_superior = 41;
inline bool MsgSimToClient_Content::has_automat_change_superior() const {
  return _has_bit(40);
}
inline void MsgSimToClient_Content::clear_automat_change_superior() {
  if (automat_change_superior_ != NULL) automat_change_superior_->::Common::MsgAutomatChangeSuperior::Clear();
  _clear_bit(40);
}
inline const ::Common::MsgAutomatChangeSuperior& MsgSimToClient_Content::automat_change_superior() const {
  return automat_change_superior_ != NULL ? *automat_change_superior_ : *default_instance_->automat_change_superior_;
}
inline ::Common::MsgAutomatChangeSuperior* MsgSimToClient_Content::mutable_automat_change_superior() {
  _set_bit(40);
  if (automat_change_superior_ == NULL) automat_change_superior_ = new ::Common::MsgAutomatChangeSuperior;
  return automat_change_superior_;
}

// optional .MsgsSimToClient.MsgUnitKnowledgeCreation unit_knowledge_creation = 42;
inline bool MsgSimToClient_Content::has_unit_knowledge_creation() const {
  return _has_bit(41);
}
inline void MsgSimToClient_Content::clear_unit_knowledge_creation() {
  if (unit_knowledge_creation_ != NULL) unit_knowledge_creation_->::MsgsSimToClient::MsgUnitKnowledgeCreation::Clear();
  _clear_bit(41);
}
inline const ::MsgsSimToClient::MsgUnitKnowledgeCreation& MsgSimToClient_Content::unit_knowledge_creation() const {
  return unit_knowledge_creation_ != NULL ? *unit_knowledge_creation_ : *default_instance_->unit_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgUnitKnowledgeCreation* MsgSimToClient_Content::mutable_unit_knowledge_creation() {
  _set_bit(41);
  if (unit_knowledge_creation_ == NULL) unit_knowledge_creation_ = new ::MsgsSimToClient::MsgUnitKnowledgeCreation;
  return unit_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgUnitKnowledgeUpdate unit_knowledge_update = 43;
inline bool MsgSimToClient_Content::has_unit_knowledge_update() const {
  return _has_bit(42);
}
inline void MsgSimToClient_Content::clear_unit_knowledge_update() {
  if (unit_knowledge_update_ != NULL) unit_knowledge_update_->::MsgsSimToClient::MsgUnitKnowledgeUpdate::Clear();
  _clear_bit(42);
}
inline const ::MsgsSimToClient::MsgUnitKnowledgeUpdate& MsgSimToClient_Content::unit_knowledge_update() const {
  return unit_knowledge_update_ != NULL ? *unit_knowledge_update_ : *default_instance_->unit_knowledge_update_;
}
inline ::MsgsSimToClient::MsgUnitKnowledgeUpdate* MsgSimToClient_Content::mutable_unit_knowledge_update() {
  _set_bit(42);
  if (unit_knowledge_update_ == NULL) unit_knowledge_update_ = new ::MsgsSimToClient::MsgUnitKnowledgeUpdate;
  return unit_knowledge_update_;
}

// optional .MsgsSimToClient.MsgUnitKnowledgeDestruction unit_knowledge_destruction = 44;
inline bool MsgSimToClient_Content::has_unit_knowledge_destruction() const {
  return _has_bit(43);
}
inline void MsgSimToClient_Content::clear_unit_knowledge_destruction() {
  if (unit_knowledge_destruction_ != NULL) unit_knowledge_destruction_->::MsgsSimToClient::MsgUnitKnowledgeDestruction::Clear();
  _clear_bit(43);
}
inline const ::MsgsSimToClient::MsgUnitKnowledgeDestruction& MsgSimToClient_Content::unit_knowledge_destruction() const {
  return unit_knowledge_destruction_ != NULL ? *unit_knowledge_destruction_ : *default_instance_->unit_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgUnitKnowledgeDestruction* MsgSimToClient_Content::mutable_unit_knowledge_destruction() {
  _set_bit(43);
  if (unit_knowledge_destruction_ == NULL) unit_knowledge_destruction_ = new ::MsgsSimToClient::MsgUnitKnowledgeDestruction;
  return unit_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgStartUnitFire start_unit_fire = 45;
inline bool MsgSimToClient_Content::has_start_unit_fire() const {
  return _has_bit(44);
}
inline void MsgSimToClient_Content::clear_start_unit_fire() {
  if (start_unit_fire_ != NULL) start_unit_fire_->::MsgsSimToClient::MsgStartUnitFire::Clear();
  _clear_bit(44);
}
inline const ::MsgsSimToClient::MsgStartUnitFire& MsgSimToClient_Content::start_unit_fire() const {
  return start_unit_fire_ != NULL ? *start_unit_fire_ : *default_instance_->start_unit_fire_;
}
inline ::MsgsSimToClient::MsgStartUnitFire* MsgSimToClient_Content::mutable_start_unit_fire() {
  _set_bit(44);
  if (start_unit_fire_ == NULL) start_unit_fire_ = new ::MsgsSimToClient::MsgStartUnitFire;
  return start_unit_fire_;
}

// optional .MsgsSimToClient.MsgStopUnitFire stop_unit_fire = 46;
inline bool MsgSimToClient_Content::has_stop_unit_fire() const {
  return _has_bit(45);
}
inline void MsgSimToClient_Content::clear_stop_unit_fire() {
  if (stop_unit_fire_ != NULL) stop_unit_fire_->::MsgsSimToClient::MsgStopUnitFire::Clear();
  _clear_bit(45);
}
inline const ::MsgsSimToClient::MsgStopUnitFire& MsgSimToClient_Content::stop_unit_fire() const {
  return stop_unit_fire_ != NULL ? *stop_unit_fire_ : *default_instance_->stop_unit_fire_;
}
inline ::MsgsSimToClient::MsgStopUnitFire* MsgSimToClient_Content::mutable_stop_unit_fire() {
  _set_bit(45);
  if (stop_unit_fire_ == NULL) stop_unit_fire_ = new ::MsgsSimToClient::MsgStopUnitFire;
  return stop_unit_fire_;
}

// optional .MsgsSimToClient.MsgStartCrowdFire start_crowd_fire = 47;
inline bool MsgSimToClient_Content::has_start_crowd_fire() const {
  return _has_bit(46);
}
inline void MsgSimToClient_Content::clear_start_crowd_fire() {
  if (start_crowd_fire_ != NULL) start_crowd_fire_->::MsgsSimToClient::MsgStartCrowdFire::Clear();
  _clear_bit(46);
}
inline const ::MsgsSimToClient::MsgStartCrowdFire& MsgSimToClient_Content::start_crowd_fire() const {
  return start_crowd_fire_ != NULL ? *start_crowd_fire_ : *default_instance_->start_crowd_fire_;
}
inline ::MsgsSimToClient::MsgStartCrowdFire* MsgSimToClient_Content::mutable_start_crowd_fire() {
  _set_bit(46);
  if (start_crowd_fire_ == NULL) start_crowd_fire_ = new ::MsgsSimToClient::MsgStartCrowdFire;
  return start_crowd_fire_;
}

// optional .MsgsSimToClient.MsgStopCrowdFire stop_crowd_fire = 48;
inline bool MsgSimToClient_Content::has_stop_crowd_fire() const {
  return _has_bit(47);
}
inline void MsgSimToClient_Content::clear_stop_crowd_fire() {
  if (stop_crowd_fire_ != NULL) stop_crowd_fire_->::MsgsSimToClient::MsgStopCrowdFire::Clear();
  _clear_bit(47);
}
inline const ::MsgsSimToClient::MsgStopCrowdFire& MsgSimToClient_Content::stop_crowd_fire() const {
  return stop_crowd_fire_ != NULL ? *stop_crowd_fire_ : *default_instance_->stop_crowd_fire_;
}
inline ::MsgsSimToClient::MsgStopCrowdFire* MsgSimToClient_Content::mutable_stop_crowd_fire() {
  _set_bit(47);
  if (stop_crowd_fire_ == NULL) stop_crowd_fire_ = new ::MsgsSimToClient::MsgStopCrowdFire;
  return stop_crowd_fire_;
}

// optional .MsgsSimToClient.MsgExplosion explosion = 49;
inline bool MsgSimToClient_Content::has_explosion() const {
  return _has_bit(48);
}
inline void MsgSimToClient_Content::clear_explosion() {
  if (explosion_ != NULL) explosion_->::MsgsSimToClient::MsgExplosion::Clear();
  _clear_bit(48);
}
inline const ::MsgsSimToClient::MsgExplosion& MsgSimToClient_Content::explosion() const {
  return explosion_ != NULL ? *explosion_ : *default_instance_->explosion_;
}
inline ::MsgsSimToClient::MsgExplosion* MsgSimToClient_Content::mutable_explosion() {
  _set_bit(48);
  if (explosion_ == NULL) explosion_ = new ::MsgsSimToClient::MsgExplosion;
  return explosion_;
}

// optional .MsgsSimToClient.MsgStartFireEffect start_fire_effect = 50;
inline bool MsgSimToClient_Content::has_start_fire_effect() const {
  return _has_bit(49);
}
inline void MsgSimToClient_Content::clear_start_fire_effect() {
  if (start_fire_effect_ != NULL) start_fire_effect_->::MsgsSimToClient::MsgStartFireEffect::Clear();
  _clear_bit(49);
}
inline const ::MsgsSimToClient::MsgStartFireEffect& MsgSimToClient_Content::start_fire_effect() const {
  return start_fire_effect_ != NULL ? *start_fire_effect_ : *default_instance_->start_fire_effect_;
}
inline ::MsgsSimToClient::MsgStartFireEffect* MsgSimToClient_Content::mutable_start_fire_effect() {
  _set_bit(49);
  if (start_fire_effect_ == NULL) start_fire_effect_ = new ::MsgsSimToClient::MsgStartFireEffect;
  return start_fire_effect_;
}

// optional .MsgsSimToClient.MsgStopFireEffect stop_fire_effect = 51;
inline bool MsgSimToClient_Content::has_stop_fire_effect() const {
  return _has_bit(50);
}
inline void MsgSimToClient_Content::clear_stop_fire_effect() {
  if (stop_fire_effect_ != NULL) stop_fire_effect_->::MsgsSimToClient::MsgStopFireEffect::Clear();
  _clear_bit(50);
}
inline const ::MsgsSimToClient::MsgStopFireEffect& MsgSimToClient_Content::stop_fire_effect() const {
  return stop_fire_effect_ != NULL ? *stop_fire_effect_ : *default_instance_->stop_fire_effect_;
}
inline ::MsgsSimToClient::MsgStopFireEffect* MsgSimToClient_Content::mutable_stop_fire_effect() {
  _set_bit(50);
  if (stop_fire_effect_ == NULL) stop_fire_effect_ = new ::MsgsSimToClient::MsgStopFireEffect;
  return stop_fire_effect_;
}

// optional .MsgsSimToClient.MsgReport report = 52;
inline bool MsgSimToClient_Content::has_report() const {
  return _has_bit(51);
}
inline void MsgSimToClient_Content::clear_report() {
  if (report_ != NULL) report_->::MsgsSimToClient::MsgReport::Clear();
  _clear_bit(51);
}
inline const ::MsgsSimToClient::MsgReport& MsgSimToClient_Content::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::MsgsSimToClient::MsgReport* MsgSimToClient_Content::mutable_report() {
  _set_bit(51);
  if (report_ == NULL) report_ = new ::MsgsSimToClient::MsgReport;
  return report_;
}

// optional .MsgsSimToClient.MsgInvalidateReport invalidate_report = 53;
inline bool MsgSimToClient_Content::has_invalidate_report() const {
  return _has_bit(52);
}
inline void MsgSimToClient_Content::clear_invalidate_report() {
  if (invalidate_report_ != NULL) invalidate_report_->::MsgsSimToClient::MsgInvalidateReport::Clear();
  _clear_bit(52);
}
inline const ::MsgsSimToClient::MsgInvalidateReport& MsgSimToClient_Content::invalidate_report() const {
  return invalidate_report_ != NULL ? *invalidate_report_ : *default_instance_->invalidate_report_;
}
inline ::MsgsSimToClient::MsgInvalidateReport* MsgSimToClient_Content::mutable_invalidate_report() {
  _set_bit(52);
  if (invalidate_report_ == NULL) invalidate_report_ = new ::MsgsSimToClient::MsgInvalidateReport;
  return invalidate_report_;
}

// optional .MsgsSimToClient.MsgTrace trace = 54;
inline bool MsgSimToClient_Content::has_trace() const {
  return _has_bit(53);
}
inline void MsgSimToClient_Content::clear_trace() {
  if (trace_ != NULL) trace_->::MsgsSimToClient::MsgTrace::Clear();
  _clear_bit(53);
}
inline const ::MsgsSimToClient::MsgTrace& MsgSimToClient_Content::trace() const {
  return trace_ != NULL ? *trace_ : *default_instance_->trace_;
}
inline ::MsgsSimToClient::MsgTrace* MsgSimToClient_Content::mutable_trace() {
  _set_bit(53);
  if (trace_ == NULL) trace_ = new ::MsgsSimToClient::MsgTrace;
  return trace_;
}

// optional .MsgsSimToClient.MsgDecisionalState decisional_state = 55;
inline bool MsgSimToClient_Content::has_decisional_state() const {
  return _has_bit(54);
}
inline void MsgSimToClient_Content::clear_decisional_state() {
  if (decisional_state_ != NULL) decisional_state_->::MsgsSimToClient::MsgDecisionalState::Clear();
  _clear_bit(54);
}
inline const ::MsgsSimToClient::MsgDecisionalState& MsgSimToClient_Content::decisional_state() const {
  return decisional_state_ != NULL ? *decisional_state_ : *default_instance_->decisional_state_;
}
inline ::MsgsSimToClient::MsgDecisionalState* MsgSimToClient_Content::mutable_decisional_state() {
  _set_bit(54);
  if (decisional_state_ == NULL) decisional_state_ = new ::MsgsSimToClient::MsgDecisionalState;
  return decisional_state_;
}

// optional .MsgsSimToClient.MsgDebugPoints debug_points = 56;
inline bool MsgSimToClient_Content::has_debug_points() const {
  return _has_bit(55);
}
inline void MsgSimToClient_Content::clear_debug_points() {
  if (debug_points_ != NULL) debug_points_->::MsgsSimToClient::MsgDebugPoints::Clear();
  _clear_bit(55);
}
inline const ::MsgsSimToClient::MsgDebugPoints& MsgSimToClient_Content::debug_points() const {
  return debug_points_ != NULL ? *debug_points_ : *default_instance_->debug_points_;
}
inline ::MsgsSimToClient::MsgDebugPoints* MsgSimToClient_Content::mutable_debug_points() {
  _set_bit(55);
  if (debug_points_ == NULL) debug_points_ = new ::MsgsSimToClient::MsgDebugPoints;
  return debug_points_;
}

// optional .MsgsSimToClient.MsgUnitVisionCones unit_vision_cones = 57;
inline bool MsgSimToClient_Content::has_unit_vision_cones() const {
  return _has_bit(56);
}
inline void MsgSimToClient_Content::clear_unit_vision_cones() {
  if (unit_vision_cones_ != NULL) unit_vision_cones_->::MsgsSimToClient::MsgUnitVisionCones::Clear();
  _clear_bit(56);
}
inline const ::MsgsSimToClient::MsgUnitVisionCones& MsgSimToClient_Content::unit_vision_cones() const {
  return unit_vision_cones_ != NULL ? *unit_vision_cones_ : *default_instance_->unit_vision_cones_;
}
inline ::MsgsSimToClient::MsgUnitVisionCones* MsgSimToClient_Content::mutable_unit_vision_cones() {
  _set_bit(56);
  if (unit_vision_cones_ == NULL) unit_vision_cones_ = new ::MsgsSimToClient::MsgUnitVisionCones;
  return unit_vision_cones_;
}

// optional .MsgsSimToClient.MsgUnitDetection unit_detection = 58;
inline bool MsgSimToClient_Content::has_unit_detection() const {
  return _has_bit(57);
}
inline void MsgSimToClient_Content::clear_unit_detection() {
  if (unit_detection_ != NULL) unit_detection_->::MsgsSimToClient::MsgUnitDetection::Clear();
  _clear_bit(57);
}
inline const ::MsgsSimToClient::MsgUnitDetection& MsgSimToClient_Content::unit_detection() const {
  return unit_detection_ != NULL ? *unit_detection_ : *default_instance_->unit_detection_;
}
inline ::MsgsSimToClient::MsgUnitDetection* MsgSimToClient_Content::mutable_unit_detection() {
  _set_bit(57);
  if (unit_detection_ == NULL) unit_detection_ = new ::MsgsSimToClient::MsgUnitDetection;
  return unit_detection_;
}

// optional .MsgsSimToClient.MsgObjectDetection object_detection = 59;
inline bool MsgSimToClient_Content::has_object_detection() const {
  return _has_bit(58);
}
inline void MsgSimToClient_Content::clear_object_detection() {
  if (object_detection_ != NULL) object_detection_->::MsgsSimToClient::MsgObjectDetection::Clear();
  _clear_bit(58);
}
inline const ::MsgsSimToClient::MsgObjectDetection& MsgSimToClient_Content::object_detection() const {
  return object_detection_ != NULL ? *object_detection_ : *default_instance_->object_detection_;
}
inline ::MsgsSimToClient::MsgObjectDetection* MsgSimToClient_Content::mutable_object_detection() {
  _set_bit(58);
  if (object_detection_ == NULL) object_detection_ = new ::MsgsSimToClient::MsgObjectDetection;
  return object_detection_;
}

// optional .MsgsSimToClient.MsgCrowdConcentrationDetection crowd_concentration_detection = 60;
inline bool MsgSimToClient_Content::has_crowd_concentration_detection() const {
  return _has_bit(59);
}
inline void MsgSimToClient_Content::clear_crowd_concentration_detection() {
  if (crowd_concentration_detection_ != NULL) crowd_concentration_detection_->::MsgsSimToClient::MsgCrowdConcentrationDetection::Clear();
  _clear_bit(59);
}
inline const ::MsgsSimToClient::MsgCrowdConcentrationDetection& MsgSimToClient_Content::crowd_concentration_detection() const {
  return crowd_concentration_detection_ != NULL ? *crowd_concentration_detection_ : *default_instance_->crowd_concentration_detection_;
}
inline ::MsgsSimToClient::MsgCrowdConcentrationDetection* MsgSimToClient_Content::mutable_crowd_concentration_detection() {
  _set_bit(59);
  if (crowd_concentration_detection_ == NULL) crowd_concentration_detection_ = new ::MsgsSimToClient::MsgCrowdConcentrationDetection;
  return crowd_concentration_detection_;
}

// optional .MsgsSimToClient.MsgCrowdFlowDetection crowd_flow_detection = 61;
inline bool MsgSimToClient_Content::has_crowd_flow_detection() const {
  return _has_bit(60);
}
inline void MsgSimToClient_Content::clear_crowd_flow_detection() {
  if (crowd_flow_detection_ != NULL) crowd_flow_detection_->::MsgsSimToClient::MsgCrowdFlowDetection::Clear();
  _clear_bit(60);
}
inline const ::MsgsSimToClient::MsgCrowdFlowDetection& MsgSimToClient_Content::crowd_flow_detection() const {
  return crowd_flow_detection_ != NULL ? *crowd_flow_detection_ : *default_instance_->crowd_flow_detection_;
}
inline ::MsgsSimToClient::MsgCrowdFlowDetection* MsgSimToClient_Content::mutable_crowd_flow_detection() {
  _set_bit(60);
  if (crowd_flow_detection_ == NULL) crowd_flow_detection_ = new ::MsgsSimToClient::MsgCrowdFlowDetection;
  return crowd_flow_detection_;
}

// optional .Common.MsgUnitOrder unit_order = 62;
inline bool MsgSimToClient_Content::has_unit_order() const {
  return _has_bit(61);
}
inline void MsgSimToClient_Content::clear_unit_order() {
  if (unit_order_ != NULL) unit_order_->::Common::MsgUnitOrder::Clear();
  _clear_bit(61);
}
inline const ::Common::MsgUnitOrder& MsgSimToClient_Content::unit_order() const {
  return unit_order_ != NULL ? *unit_order_ : *default_instance_->unit_order_;
}
inline ::Common::MsgUnitOrder* MsgSimToClient_Content::mutable_unit_order() {
  _set_bit(61);
  if (unit_order_ == NULL) unit_order_ = new ::Common::MsgUnitOrder;
  return unit_order_;
}

// optional .Common.MsgAutomatOrder automat_order = 63;
inline bool MsgSimToClient_Content::has_automat_order() const {
  return _has_bit(62);
}
inline void MsgSimToClient_Content::clear_automat_order() {
  if (automat_order_ != NULL) automat_order_->::Common::MsgAutomatOrder::Clear();
  _clear_bit(62);
}
inline const ::Common::MsgAutomatOrder& MsgSimToClient_Content::automat_order() const {
  return automat_order_ != NULL ? *automat_order_ : *default_instance_->automat_order_;
}
inline ::Common::MsgAutomatOrder* MsgSimToClient_Content::mutable_automat_order() {
  _set_bit(62);
  if (automat_order_ == NULL) automat_order_ = new ::Common::MsgAutomatOrder;
  return automat_order_;
}

// optional .Common.MsgCrowdOrder crowd_order = 64;
inline bool MsgSimToClient_Content::has_crowd_order() const {
  return _has_bit(63);
}
inline void MsgSimToClient_Content::clear_crowd_order() {
  if (crowd_order_ != NULL) crowd_order_->::Common::MsgCrowdOrder::Clear();
  _clear_bit(63);
}
inline const ::Common::MsgCrowdOrder& MsgSimToClient_Content::crowd_order() const {
  return crowd_order_ != NULL ? *crowd_order_ : *default_instance_->crowd_order_;
}
inline ::Common::MsgCrowdOrder* MsgSimToClient_Content::mutable_crowd_order() {
  _set_bit(63);
  if (crowd_order_ == NULL) crowd_order_ = new ::Common::MsgCrowdOrder;
  return crowd_order_;
}

// optional .MsgsSimToClient.MsgObjectCreation object_creation = 65;
inline bool MsgSimToClient_Content::has_object_creation() const {
  return _has_bit(64);
}
inline void MsgSimToClient_Content::clear_object_creation() {
  if (object_creation_ != NULL) object_creation_->::MsgsSimToClient::MsgObjectCreation::Clear();
  _clear_bit(64);
}
inline const ::MsgsSimToClient::MsgObjectCreation& MsgSimToClient_Content::object_creation() const {
  return object_creation_ != NULL ? *object_creation_ : *default_instance_->object_creation_;
}
inline ::MsgsSimToClient::MsgObjectCreation* MsgSimToClient_Content::mutable_object_creation() {
  _set_bit(64);
  if (object_creation_ == NULL) object_creation_ = new ::MsgsSimToClient::MsgObjectCreation;
  return object_creation_;
}

// optional .MsgsSimToClient.MsgObjectDestruction object_destruction = 66;
inline bool MsgSimToClient_Content::has_object_destruction() const {
  return _has_bit(65);
}
inline void MsgSimToClient_Content::clear_object_destruction() {
  if (object_destruction_ != NULL) object_destruction_->::MsgsSimToClient::MsgObjectDestruction::Clear();
  _clear_bit(65);
}
inline const ::MsgsSimToClient::MsgObjectDestruction& MsgSimToClient_Content::object_destruction() const {
  return object_destruction_ != NULL ? *object_destruction_ : *default_instance_->object_destruction_;
}
inline ::MsgsSimToClient::MsgObjectDestruction* MsgSimToClient_Content::mutable_object_destruction() {
  _set_bit(65);
  if (object_destruction_ == NULL) object_destruction_ = new ::MsgsSimToClient::MsgObjectDestruction;
  return object_destruction_;
}

// optional .MsgsSimToClient.MsgObjectUpdate object_update = 67;
inline bool MsgSimToClient_Content::has_object_update() const {
  return _has_bit(66);
}
inline void MsgSimToClient_Content::clear_object_update() {
  if (object_update_ != NULL) object_update_->::MsgsSimToClient::MsgObjectUpdate::Clear();
  _clear_bit(66);
}
inline const ::MsgsSimToClient::MsgObjectUpdate& MsgSimToClient_Content::object_update() const {
  return object_update_ != NULL ? *object_update_ : *default_instance_->object_update_;
}
inline ::MsgsSimToClient::MsgObjectUpdate* MsgSimToClient_Content::mutable_object_update() {
  _set_bit(66);
  if (object_update_ == NULL) object_update_ = new ::MsgsSimToClient::MsgObjectUpdate;
  return object_update_;
}

// optional .MsgsSimToClient.MsgObjectKnowledgeCreation object_knowledge_creation = 68;
inline bool MsgSimToClient_Content::has_object_knowledge_creation() const {
  return _has_bit(67);
}
inline void MsgSimToClient_Content::clear_object_knowledge_creation() {
  if (object_knowledge_creation_ != NULL) object_knowledge_creation_->::MsgsSimToClient::MsgObjectKnowledgeCreation::Clear();
  _clear_bit(67);
}
inline const ::MsgsSimToClient::MsgObjectKnowledgeCreation& MsgSimToClient_Content::object_knowledge_creation() const {
  return object_knowledge_creation_ != NULL ? *object_knowledge_creation_ : *default_instance_->object_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgObjectKnowledgeCreation* MsgSimToClient_Content::mutable_object_knowledge_creation() {
  _set_bit(67);
  if (object_knowledge_creation_ == NULL) object_knowledge_creation_ = new ::MsgsSimToClient::MsgObjectKnowledgeCreation;
  return object_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgObjectKnowledgeUpdate object_knowledge_update = 69;
inline bool MsgSimToClient_Content::has_object_knowledge_update() const {
  return _has_bit(68);
}
inline void MsgSimToClient_Content::clear_object_knowledge_update() {
  if (object_knowledge_update_ != NULL) object_knowledge_update_->::MsgsSimToClient::MsgObjectKnowledgeUpdate::Clear();
  _clear_bit(68);
}
inline const ::MsgsSimToClient::MsgObjectKnowledgeUpdate& MsgSimToClient_Content::object_knowledge_update() const {
  return object_knowledge_update_ != NULL ? *object_knowledge_update_ : *default_instance_->object_knowledge_update_;
}
inline ::MsgsSimToClient::MsgObjectKnowledgeUpdate* MsgSimToClient_Content::mutable_object_knowledge_update() {
  _set_bit(68);
  if (object_knowledge_update_ == NULL) object_knowledge_update_ = new ::MsgsSimToClient::MsgObjectKnowledgeUpdate;
  return object_knowledge_update_;
}

// optional .MsgsSimToClient.MsgObjectKnowledgeDestruction object_knowledge_destruction = 70;
inline bool MsgSimToClient_Content::has_object_knowledge_destruction() const {
  return _has_bit(69);
}
inline void MsgSimToClient_Content::clear_object_knowledge_destruction() {
  if (object_knowledge_destruction_ != NULL) object_knowledge_destruction_->::MsgsSimToClient::MsgObjectKnowledgeDestruction::Clear();
  _clear_bit(69);
}
inline const ::MsgsSimToClient::MsgObjectKnowledgeDestruction& MsgSimToClient_Content::object_knowledge_destruction() const {
  return object_knowledge_destruction_ != NULL ? *object_knowledge_destruction_ : *default_instance_->object_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgObjectKnowledgeDestruction* MsgSimToClient_Content::mutable_object_knowledge_destruction() {
  _set_bit(69);
  if (object_knowledge_destruction_ == NULL) object_knowledge_destruction_ = new ::MsgsSimToClient::MsgObjectKnowledgeDestruction;
  return object_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgLogMedicalHandlingCreation log_medical_handling_creation = 71;
inline bool MsgSimToClient_Content::has_log_medical_handling_creation() const {
  return _has_bit(70);
}
inline void MsgSimToClient_Content::clear_log_medical_handling_creation() {
  if (log_medical_handling_creation_ != NULL) log_medical_handling_creation_->::MsgsSimToClient::MsgLogMedicalHandlingCreation::Clear();
  _clear_bit(70);
}
inline const ::MsgsSimToClient::MsgLogMedicalHandlingCreation& MsgSimToClient_Content::log_medical_handling_creation() const {
  return log_medical_handling_creation_ != NULL ? *log_medical_handling_creation_ : *default_instance_->log_medical_handling_creation_;
}
inline ::MsgsSimToClient::MsgLogMedicalHandlingCreation* MsgSimToClient_Content::mutable_log_medical_handling_creation() {
  _set_bit(70);
  if (log_medical_handling_creation_ == NULL) log_medical_handling_creation_ = new ::MsgsSimToClient::MsgLogMedicalHandlingCreation;
  return log_medical_handling_creation_;
}

// optional .MsgsSimToClient.MsgLogMedicalHandlingUpdate log_medical_handling_update = 72;
inline bool MsgSimToClient_Content::has_log_medical_handling_update() const {
  return _has_bit(71);
}
inline void MsgSimToClient_Content::clear_log_medical_handling_update() {
  if (log_medical_handling_update_ != NULL) log_medical_handling_update_->::MsgsSimToClient::MsgLogMedicalHandlingUpdate::Clear();
  _clear_bit(71);
}
inline const ::MsgsSimToClient::MsgLogMedicalHandlingUpdate& MsgSimToClient_Content::log_medical_handling_update() const {
  return log_medical_handling_update_ != NULL ? *log_medical_handling_update_ : *default_instance_->log_medical_handling_update_;
}
inline ::MsgsSimToClient::MsgLogMedicalHandlingUpdate* MsgSimToClient_Content::mutable_log_medical_handling_update() {
  _set_bit(71);
  if (log_medical_handling_update_ == NULL) log_medical_handling_update_ = new ::MsgsSimToClient::MsgLogMedicalHandlingUpdate;
  return log_medical_handling_update_;
}

// optional .MsgsSimToClient.MsgLogMedicalHandlingDestruction log_medical_handling_destruction = 73;
inline bool MsgSimToClient_Content::has_log_medical_handling_destruction() const {
  return _has_bit(72);
}
inline void MsgSimToClient_Content::clear_log_medical_handling_destruction() {
  if (log_medical_handling_destruction_ != NULL) log_medical_handling_destruction_->::MsgsSimToClient::MsgLogMedicalHandlingDestruction::Clear();
  _clear_bit(72);
}
inline const ::MsgsSimToClient::MsgLogMedicalHandlingDestruction& MsgSimToClient_Content::log_medical_handling_destruction() const {
  return log_medical_handling_destruction_ != NULL ? *log_medical_handling_destruction_ : *default_instance_->log_medical_handling_destruction_;
}
inline ::MsgsSimToClient::MsgLogMedicalHandlingDestruction* MsgSimToClient_Content::mutable_log_medical_handling_destruction() {
  _set_bit(72);
  if (log_medical_handling_destruction_ == NULL) log_medical_handling_destruction_ = new ::MsgsSimToClient::MsgLogMedicalHandlingDestruction;
  return log_medical_handling_destruction_;
}

// optional .MsgsSimToClient.MsgLogMedicalState log_medical_state = 74;
inline bool MsgSimToClient_Content::has_log_medical_state() const {
  return _has_bit(73);
}
inline void MsgSimToClient_Content::clear_log_medical_state() {
  if (log_medical_state_ != NULL) log_medical_state_->::MsgsSimToClient::MsgLogMedicalState::Clear();
  _clear_bit(73);
}
inline const ::MsgsSimToClient::MsgLogMedicalState& MsgSimToClient_Content::log_medical_state() const {
  return log_medical_state_ != NULL ? *log_medical_state_ : *default_instance_->log_medical_state_;
}
inline ::MsgsSimToClient::MsgLogMedicalState* MsgSimToClient_Content::mutable_log_medical_state() {
  _set_bit(73);
  if (log_medical_state_ == NULL) log_medical_state_ = new ::MsgsSimToClient::MsgLogMedicalState;
  return log_medical_state_;
}

// optional .MsgsSimToClient.MsgLogMaintenanceHandlingCreation log_maintenance_handling_creation = 75;
inline bool MsgSimToClient_Content::has_log_maintenance_handling_creation() const {
  return _has_bit(74);
}
inline void MsgSimToClient_Content::clear_log_maintenance_handling_creation() {
  if (log_maintenance_handling_creation_ != NULL) log_maintenance_handling_creation_->::MsgsSimToClient::MsgLogMaintenanceHandlingCreation::Clear();
  _clear_bit(74);
}
inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation& MsgSimToClient_Content::log_maintenance_handling_creation() const {
  return log_maintenance_handling_creation_ != NULL ? *log_maintenance_handling_creation_ : *default_instance_->log_maintenance_handling_creation_;
}
inline ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation* MsgSimToClient_Content::mutable_log_maintenance_handling_creation() {
  _set_bit(74);
  if (log_maintenance_handling_creation_ == NULL) log_maintenance_handling_creation_ = new ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation;
  return log_maintenance_handling_creation_;
}

// optional .MsgsSimToClient.MsgLogMaintenanceHandlingUpdate log_maintenance_handling_update = 76;
inline bool MsgSimToClient_Content::has_log_maintenance_handling_update() const {
  return _has_bit(75);
}
inline void MsgSimToClient_Content::clear_log_maintenance_handling_update() {
  if (log_maintenance_handling_update_ != NULL) log_maintenance_handling_update_->::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate::Clear();
  _clear_bit(75);
}
inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate& MsgSimToClient_Content::log_maintenance_handling_update() const {
  return log_maintenance_handling_update_ != NULL ? *log_maintenance_handling_update_ : *default_instance_->log_maintenance_handling_update_;
}
inline ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate* MsgSimToClient_Content::mutable_log_maintenance_handling_update() {
  _set_bit(75);
  if (log_maintenance_handling_update_ == NULL) log_maintenance_handling_update_ = new ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate;
  return log_maintenance_handling_update_;
}

// optional .MsgsSimToClient.MsgLogMaintenanceHandlingDestruction log_maintenance_handling_destruction = 77;
inline bool MsgSimToClient_Content::has_log_maintenance_handling_destruction() const {
  return _has_bit(76);
}
inline void MsgSimToClient_Content::clear_log_maintenance_handling_destruction() {
  if (log_maintenance_handling_destruction_ != NULL) log_maintenance_handling_destruction_->::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction::Clear();
  _clear_bit(76);
}
inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction& MsgSimToClient_Content::log_maintenance_handling_destruction() const {
  return log_maintenance_handling_destruction_ != NULL ? *log_maintenance_handling_destruction_ : *default_instance_->log_maintenance_handling_destruction_;
}
inline ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction* MsgSimToClient_Content::mutable_log_maintenance_handling_destruction() {
  _set_bit(76);
  if (log_maintenance_handling_destruction_ == NULL) log_maintenance_handling_destruction_ = new ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction;
  return log_maintenance_handling_destruction_;
}

// optional .MsgsSimToClient.MsgLogMaintenanceState log_maintenance_state = 78;
inline bool MsgSimToClient_Content::has_log_maintenance_state() const {
  return _has_bit(77);
}
inline void MsgSimToClient_Content::clear_log_maintenance_state() {
  if (log_maintenance_state_ != NULL) log_maintenance_state_->::MsgsSimToClient::MsgLogMaintenanceState::Clear();
  _clear_bit(77);
}
inline const ::MsgsSimToClient::MsgLogMaintenanceState& MsgSimToClient_Content::log_maintenance_state() const {
  return log_maintenance_state_ != NULL ? *log_maintenance_state_ : *default_instance_->log_maintenance_state_;
}
inline ::MsgsSimToClient::MsgLogMaintenanceState* MsgSimToClient_Content::mutable_log_maintenance_state() {
  _set_bit(77);
  if (log_maintenance_state_ == NULL) log_maintenance_state_ = new ::MsgsSimToClient::MsgLogMaintenanceState;
  return log_maintenance_state_;
}

// optional .MsgsSimToClient.MsgLogSupplyHandlingCreation log_supply_handling_creation = 79;
inline bool MsgSimToClient_Content::has_log_supply_handling_creation() const {
  return _has_bit(78);
}
inline void MsgSimToClient_Content::clear_log_supply_handling_creation() {
  if (log_supply_handling_creation_ != NULL) log_supply_handling_creation_->::MsgsSimToClient::MsgLogSupplyHandlingCreation::Clear();
  _clear_bit(78);
}
inline const ::MsgsSimToClient::MsgLogSupplyHandlingCreation& MsgSimToClient_Content::log_supply_handling_creation() const {
  return log_supply_handling_creation_ != NULL ? *log_supply_handling_creation_ : *default_instance_->log_supply_handling_creation_;
}
inline ::MsgsSimToClient::MsgLogSupplyHandlingCreation* MsgSimToClient_Content::mutable_log_supply_handling_creation() {
  _set_bit(78);
  if (log_supply_handling_creation_ == NULL) log_supply_handling_creation_ = new ::MsgsSimToClient::MsgLogSupplyHandlingCreation;
  return log_supply_handling_creation_;
}

// optional .MsgsSimToClient.MsgLogSupplyHandlingUpdate log_supply_handling_update = 80;
inline bool MsgSimToClient_Content::has_log_supply_handling_update() const {
  return _has_bit(79);
}
inline void MsgSimToClient_Content::clear_log_supply_handling_update() {
  if (log_supply_handling_update_ != NULL) log_supply_handling_update_->::MsgsSimToClient::MsgLogSupplyHandlingUpdate::Clear();
  _clear_bit(79);
}
inline const ::MsgsSimToClient::MsgLogSupplyHandlingUpdate& MsgSimToClient_Content::log_supply_handling_update() const {
  return log_supply_handling_update_ != NULL ? *log_supply_handling_update_ : *default_instance_->log_supply_handling_update_;
}
inline ::MsgsSimToClient::MsgLogSupplyHandlingUpdate* MsgSimToClient_Content::mutable_log_supply_handling_update() {
  _set_bit(79);
  if (log_supply_handling_update_ == NULL) log_supply_handling_update_ = new ::MsgsSimToClient::MsgLogSupplyHandlingUpdate;
  return log_supply_handling_update_;
}

// optional .MsgsSimToClient.MsgLogSupplyHandlingDestruction log_supply_handling_destruction = 81;
inline bool MsgSimToClient_Content::has_log_supply_handling_destruction() const {
  return _has_bit(80);
}
inline void MsgSimToClient_Content::clear_log_supply_handling_destruction() {
  if (log_supply_handling_destruction_ != NULL) log_supply_handling_destruction_->::MsgsSimToClient::MsgLogSupplyHandlingDestruction::Clear();
  _clear_bit(80);
}
inline const ::MsgsSimToClient::MsgLogSupplyHandlingDestruction& MsgSimToClient_Content::log_supply_handling_destruction() const {
  return log_supply_handling_destruction_ != NULL ? *log_supply_handling_destruction_ : *default_instance_->log_supply_handling_destruction_;
}
inline ::MsgsSimToClient::MsgLogSupplyHandlingDestruction* MsgSimToClient_Content::mutable_log_supply_handling_destruction() {
  _set_bit(80);
  if (log_supply_handling_destruction_ == NULL) log_supply_handling_destruction_ = new ::MsgsSimToClient::MsgLogSupplyHandlingDestruction;
  return log_supply_handling_destruction_;
}

// optional .MsgsSimToClient.MsgLogSupplyState log_supply_state = 82;
inline bool MsgSimToClient_Content::has_log_supply_state() const {
  return _has_bit(81);
}
inline void MsgSimToClient_Content::clear_log_supply_state() {
  if (log_supply_state_ != NULL) log_supply_state_->::MsgsSimToClient::MsgLogSupplyState::Clear();
  _clear_bit(81);
}
inline const ::MsgsSimToClient::MsgLogSupplyState& MsgSimToClient_Content::log_supply_state() const {
  return log_supply_state_ != NULL ? *log_supply_state_ : *default_instance_->log_supply_state_;
}
inline ::MsgsSimToClient::MsgLogSupplyState* MsgSimToClient_Content::mutable_log_supply_state() {
  _set_bit(81);
  if (log_supply_state_ == NULL) log_supply_state_ = new ::MsgsSimToClient::MsgLogSupplyState;
  return log_supply_state_;
}

// optional .MsgsSimToClient.MsgLogSupplyQuotas log_supply_quotas = 83;
inline bool MsgSimToClient_Content::has_log_supply_quotas() const {
  return _has_bit(82);
}
inline void MsgSimToClient_Content::clear_log_supply_quotas() {
  if (log_supply_quotas_ != NULL) log_supply_quotas_->::MsgsSimToClient::MsgLogSupplyQuotas::Clear();
  _clear_bit(82);
}
inline const ::MsgsSimToClient::MsgLogSupplyQuotas& MsgSimToClient_Content::log_supply_quotas() const {
  return log_supply_quotas_ != NULL ? *log_supply_quotas_ : *default_instance_->log_supply_quotas_;
}
inline ::MsgsSimToClient::MsgLogSupplyQuotas* MsgSimToClient_Content::mutable_log_supply_quotas() {
  _set_bit(82);
  if (log_supply_quotas_ == NULL) log_supply_quotas_ = new ::MsgsSimToClient::MsgLogSupplyQuotas;
  return log_supply_quotas_;
}

// optional .MsgsSimToClient.MsgCrowdCreation crowd_creation = 84;
inline bool MsgSimToClient_Content::has_crowd_creation() const {
  return _has_bit(83);
}
inline void MsgSimToClient_Content::clear_crowd_creation() {
  if (crowd_creation_ != NULL) crowd_creation_->::MsgsSimToClient::MsgCrowdCreation::Clear();
  _clear_bit(83);
}
inline const ::MsgsSimToClient::MsgCrowdCreation& MsgSimToClient_Content::crowd_creation() const {
  return crowd_creation_ != NULL ? *crowd_creation_ : *default_instance_->crowd_creation_;
}
inline ::MsgsSimToClient::MsgCrowdCreation* MsgSimToClient_Content::mutable_crowd_creation() {
  _set_bit(83);
  if (crowd_creation_ == NULL) crowd_creation_ = new ::MsgsSimToClient::MsgCrowdCreation;
  return crowd_creation_;
}

// optional .MsgsSimToClient.MsgCrowdUpdate crowd_update = 85;
inline bool MsgSimToClient_Content::has_crowd_update() const {
  return _has_bit(84);
}
inline void MsgSimToClient_Content::clear_crowd_update() {
  if (crowd_update_ != NULL) crowd_update_->::MsgsSimToClient::MsgCrowdUpdate::Clear();
  _clear_bit(84);
}
inline const ::MsgsSimToClient::MsgCrowdUpdate& MsgSimToClient_Content::crowd_update() const {
  return crowd_update_ != NULL ? *crowd_update_ : *default_instance_->crowd_update_;
}
inline ::MsgsSimToClient::MsgCrowdUpdate* MsgSimToClient_Content::mutable_crowd_update() {
  _set_bit(84);
  if (crowd_update_ == NULL) crowd_update_ = new ::MsgsSimToClient::MsgCrowdUpdate;
  return crowd_update_;
}

// optional .MsgsSimToClient.MsgCrowdConcentrationCreation crowd_concentration_creation = 86;
inline bool MsgSimToClient_Content::has_crowd_concentration_creation() const {
  return _has_bit(85);
}
inline void MsgSimToClient_Content::clear_crowd_concentration_creation() {
  if (crowd_concentration_creation_ != NULL) crowd_concentration_creation_->::MsgsSimToClient::MsgCrowdConcentrationCreation::Clear();
  _clear_bit(85);
}
inline const ::MsgsSimToClient::MsgCrowdConcentrationCreation& MsgSimToClient_Content::crowd_concentration_creation() const {
  return crowd_concentration_creation_ != NULL ? *crowd_concentration_creation_ : *default_instance_->crowd_concentration_creation_;
}
inline ::MsgsSimToClient::MsgCrowdConcentrationCreation* MsgSimToClient_Content::mutable_crowd_concentration_creation() {
  _set_bit(85);
  if (crowd_concentration_creation_ == NULL) crowd_concentration_creation_ = new ::MsgsSimToClient::MsgCrowdConcentrationCreation;
  return crowd_concentration_creation_;
}

// optional .MsgsSimToClient.MsgCrowdConcentrationDestruction crowd_concentration_destruction = 87;
inline bool MsgSimToClient_Content::has_crowd_concentration_destruction() const {
  return _has_bit(86);
}
inline void MsgSimToClient_Content::clear_crowd_concentration_destruction() {
  if (crowd_concentration_destruction_ != NULL) crowd_concentration_destruction_->::MsgsSimToClient::MsgCrowdConcentrationDestruction::Clear();
  _clear_bit(86);
}
inline const ::MsgsSimToClient::MsgCrowdConcentrationDestruction& MsgSimToClient_Content::crowd_concentration_destruction() const {
  return crowd_concentration_destruction_ != NULL ? *crowd_concentration_destruction_ : *default_instance_->crowd_concentration_destruction_;
}
inline ::MsgsSimToClient::MsgCrowdConcentrationDestruction* MsgSimToClient_Content::mutable_crowd_concentration_destruction() {
  _set_bit(86);
  if (crowd_concentration_destruction_ == NULL) crowd_concentration_destruction_ = new ::MsgsSimToClient::MsgCrowdConcentrationDestruction;
  return crowd_concentration_destruction_;
}

// optional .MsgsSimToClient.MsgCrowdConcentrationUpdate crowd_concentration_update = 88;
inline bool MsgSimToClient_Content::has_crowd_concentration_update() const {
  return _has_bit(87);
}
inline void MsgSimToClient_Content::clear_crowd_concentration_update() {
  if (crowd_concentration_update_ != NULL) crowd_concentration_update_->::MsgsSimToClient::MsgCrowdConcentrationUpdate::Clear();
  _clear_bit(87);
}
inline const ::MsgsSimToClient::MsgCrowdConcentrationUpdate& MsgSimToClient_Content::crowd_concentration_update() const {
  return crowd_concentration_update_ != NULL ? *crowd_concentration_update_ : *default_instance_->crowd_concentration_update_;
}
inline ::MsgsSimToClient::MsgCrowdConcentrationUpdate* MsgSimToClient_Content::mutable_crowd_concentration_update() {
  _set_bit(87);
  if (crowd_concentration_update_ == NULL) crowd_concentration_update_ = new ::MsgsSimToClient::MsgCrowdConcentrationUpdate;
  return crowd_concentration_update_;
}

// optional .MsgsSimToClient.MsgCrowdFlowCreation crowd_flow_creation = 89;
inline bool MsgSimToClient_Content::has_crowd_flow_creation() const {
  return _has_bit(88);
}
inline void MsgSimToClient_Content::clear_crowd_flow_creation() {
  if (crowd_flow_creation_ != NULL) crowd_flow_creation_->::MsgsSimToClient::MsgCrowdFlowCreation::Clear();
  _clear_bit(88);
}
inline const ::MsgsSimToClient::MsgCrowdFlowCreation& MsgSimToClient_Content::crowd_flow_creation() const {
  return crowd_flow_creation_ != NULL ? *crowd_flow_creation_ : *default_instance_->crowd_flow_creation_;
}
inline ::MsgsSimToClient::MsgCrowdFlowCreation* MsgSimToClient_Content::mutable_crowd_flow_creation() {
  _set_bit(88);
  if (crowd_flow_creation_ == NULL) crowd_flow_creation_ = new ::MsgsSimToClient::MsgCrowdFlowCreation;
  return crowd_flow_creation_;
}

// optional .MsgsSimToClient.MsgCrowdFlowDestruction crowd_flow_destruction = 90;
inline bool MsgSimToClient_Content::has_crowd_flow_destruction() const {
  return _has_bit(89);
}
inline void MsgSimToClient_Content::clear_crowd_flow_destruction() {
  if (crowd_flow_destruction_ != NULL) crowd_flow_destruction_->::MsgsSimToClient::MsgCrowdFlowDestruction::Clear();
  _clear_bit(89);
}
inline const ::MsgsSimToClient::MsgCrowdFlowDestruction& MsgSimToClient_Content::crowd_flow_destruction() const {
  return crowd_flow_destruction_ != NULL ? *crowd_flow_destruction_ : *default_instance_->crowd_flow_destruction_;
}
inline ::MsgsSimToClient::MsgCrowdFlowDestruction* MsgSimToClient_Content::mutable_crowd_flow_destruction() {
  _set_bit(89);
  if (crowd_flow_destruction_ == NULL) crowd_flow_destruction_ = new ::MsgsSimToClient::MsgCrowdFlowDestruction;
  return crowd_flow_destruction_;
}

// optional .MsgsSimToClient.MsgCrowdFlowUpdate crowd_flow_update = 91;
inline bool MsgSimToClient_Content::has_crowd_flow_update() const {
  return _has_bit(90);
}
inline void MsgSimToClient_Content::clear_crowd_flow_update() {
  if (crowd_flow_update_ != NULL) crowd_flow_update_->::MsgsSimToClient::MsgCrowdFlowUpdate::Clear();
  _clear_bit(90);
}
inline const ::MsgsSimToClient::MsgCrowdFlowUpdate& MsgSimToClient_Content::crowd_flow_update() const {
  return crowd_flow_update_ != NULL ? *crowd_flow_update_ : *default_instance_->crowd_flow_update_;
}
inline ::MsgsSimToClient::MsgCrowdFlowUpdate* MsgSimToClient_Content::mutable_crowd_flow_update() {
  _set_bit(90);
  if (crowd_flow_update_ == NULL) crowd_flow_update_ = new ::MsgsSimToClient::MsgCrowdFlowUpdate;
  return crowd_flow_update_;
}

// optional .MsgsSimToClient.MsgCrowdKnowledgeCreation crowd_knowledge_creation = 92;
inline bool MsgSimToClient_Content::has_crowd_knowledge_creation() const {
  return _has_bit(91);
}
inline void MsgSimToClient_Content::clear_crowd_knowledge_creation() {
  if (crowd_knowledge_creation_ != NULL) crowd_knowledge_creation_->::MsgsSimToClient::MsgCrowdKnowledgeCreation::Clear();
  _clear_bit(91);
}
inline const ::MsgsSimToClient::MsgCrowdKnowledgeCreation& MsgSimToClient_Content::crowd_knowledge_creation() const {
  return crowd_knowledge_creation_ != NULL ? *crowd_knowledge_creation_ : *default_instance_->crowd_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgCrowdKnowledgeCreation* MsgSimToClient_Content::mutable_crowd_knowledge_creation() {
  _set_bit(91);
  if (crowd_knowledge_creation_ == NULL) crowd_knowledge_creation_ = new ::MsgsSimToClient::MsgCrowdKnowledgeCreation;
  return crowd_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgCrowdKnowledgeUpdate crowd_knowledge_update = 93;
inline bool MsgSimToClient_Content::has_crowd_knowledge_update() const {
  return _has_bit(92);
}
inline void MsgSimToClient_Content::clear_crowd_knowledge_update() {
  if (crowd_knowledge_update_ != NULL) crowd_knowledge_update_->::MsgsSimToClient::MsgCrowdKnowledgeUpdate::Clear();
  _clear_bit(92);
}
inline const ::MsgsSimToClient::MsgCrowdKnowledgeUpdate& MsgSimToClient_Content::crowd_knowledge_update() const {
  return crowd_knowledge_update_ != NULL ? *crowd_knowledge_update_ : *default_instance_->crowd_knowledge_update_;
}
inline ::MsgsSimToClient::MsgCrowdKnowledgeUpdate* MsgSimToClient_Content::mutable_crowd_knowledge_update() {
  _set_bit(92);
  if (crowd_knowledge_update_ == NULL) crowd_knowledge_update_ = new ::MsgsSimToClient::MsgCrowdKnowledgeUpdate;
  return crowd_knowledge_update_;
}

// optional .MsgsSimToClient.MsgCrowdKnowledgeDestruction crowd_knowledge_destruction = 94;
inline bool MsgSimToClient_Content::has_crowd_knowledge_destruction() const {
  return _has_bit(93);
}
inline void MsgSimToClient_Content::clear_crowd_knowledge_destruction() {
  if (crowd_knowledge_destruction_ != NULL) crowd_knowledge_destruction_->::MsgsSimToClient::MsgCrowdKnowledgeDestruction::Clear();
  _clear_bit(93);
}
inline const ::MsgsSimToClient::MsgCrowdKnowledgeDestruction& MsgSimToClient_Content::crowd_knowledge_destruction() const {
  return crowd_knowledge_destruction_ != NULL ? *crowd_knowledge_destruction_ : *default_instance_->crowd_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgCrowdKnowledgeDestruction* MsgSimToClient_Content::mutable_crowd_knowledge_destruction() {
  _set_bit(93);
  if (crowd_knowledge_destruction_ == NULL) crowd_knowledge_destruction_ = new ::MsgsSimToClient::MsgCrowdKnowledgeDestruction;
  return crowd_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgCrowdConcentrationKnowledgeCreation crowd_concentration_knowledge_creation = 95;
inline bool MsgSimToClient_Content::has_crowd_concentration_knowledge_creation() const {
  return _has_bit(94);
}
inline void MsgSimToClient_Content::clear_crowd_concentration_knowledge_creation() {
  if (crowd_concentration_knowledge_creation_ != NULL) crowd_concentration_knowledge_creation_->::MsgsSimToClient::MsgCrowdConcentrationKnowledgeCreation::Clear();
  _clear_bit(94);
}
inline const ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeCreation& MsgSimToClient_Content::crowd_concentration_knowledge_creation() const {
  return crowd_concentration_knowledge_creation_ != NULL ? *crowd_concentration_knowledge_creation_ : *default_instance_->crowd_concentration_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeCreation* MsgSimToClient_Content::mutable_crowd_concentration_knowledge_creation() {
  _set_bit(94);
  if (crowd_concentration_knowledge_creation_ == NULL) crowd_concentration_knowledge_creation_ = new ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeCreation;
  return crowd_concentration_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgCrowdConcentrationKnowledgeDestruction crowd_concentration_knowledge_destruction = 96;
inline bool MsgSimToClient_Content::has_crowd_concentration_knowledge_destruction() const {
  return _has_bit(95);
}
inline void MsgSimToClient_Content::clear_crowd_concentration_knowledge_destruction() {
  if (crowd_concentration_knowledge_destruction_ != NULL) crowd_concentration_knowledge_destruction_->::MsgsSimToClient::MsgCrowdConcentrationKnowledgeDestruction::Clear();
  _clear_bit(95);
}
inline const ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeDestruction& MsgSimToClient_Content::crowd_concentration_knowledge_destruction() const {
  return crowd_concentration_knowledge_destruction_ != NULL ? *crowd_concentration_knowledge_destruction_ : *default_instance_->crowd_concentration_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeDestruction* MsgSimToClient_Content::mutable_crowd_concentration_knowledge_destruction() {
  _set_bit(95);
  if (crowd_concentration_knowledge_destruction_ == NULL) crowd_concentration_knowledge_destruction_ = new ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeDestruction;
  return crowd_concentration_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgCrowdConcentrationKnowledgeUpdate crowd_concentration_knowledge_update = 97;
inline bool MsgSimToClient_Content::has_crowd_concentration_knowledge_update() const {
  return _has_bit(96);
}
inline void MsgSimToClient_Content::clear_crowd_concentration_knowledge_update() {
  if (crowd_concentration_knowledge_update_ != NULL) crowd_concentration_knowledge_update_->::MsgsSimToClient::MsgCrowdConcentrationKnowledgeUpdate::Clear();
  _clear_bit(96);
}
inline const ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeUpdate& MsgSimToClient_Content::crowd_concentration_knowledge_update() const {
  return crowd_concentration_knowledge_update_ != NULL ? *crowd_concentration_knowledge_update_ : *default_instance_->crowd_concentration_knowledge_update_;
}
inline ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeUpdate* MsgSimToClient_Content::mutable_crowd_concentration_knowledge_update() {
  _set_bit(96);
  if (crowd_concentration_knowledge_update_ == NULL) crowd_concentration_knowledge_update_ = new ::MsgsSimToClient::MsgCrowdConcentrationKnowledgeUpdate;
  return crowd_concentration_knowledge_update_;
}

// optional .MsgsSimToClient.MsgCrowdFlowKnowledgeCreation crowd_flow_knowledge_creation = 98;
inline bool MsgSimToClient_Content::has_crowd_flow_knowledge_creation() const {
  return _has_bit(97);
}
inline void MsgSimToClient_Content::clear_crowd_flow_knowledge_creation() {
  if (crowd_flow_knowledge_creation_ != NULL) crowd_flow_knowledge_creation_->::MsgsSimToClient::MsgCrowdFlowKnowledgeCreation::Clear();
  _clear_bit(97);
}
inline const ::MsgsSimToClient::MsgCrowdFlowKnowledgeCreation& MsgSimToClient_Content::crowd_flow_knowledge_creation() const {
  return crowd_flow_knowledge_creation_ != NULL ? *crowd_flow_knowledge_creation_ : *default_instance_->crowd_flow_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgCrowdFlowKnowledgeCreation* MsgSimToClient_Content::mutable_crowd_flow_knowledge_creation() {
  _set_bit(97);
  if (crowd_flow_knowledge_creation_ == NULL) crowd_flow_knowledge_creation_ = new ::MsgsSimToClient::MsgCrowdFlowKnowledgeCreation;
  return crowd_flow_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgCrowdFlowKnowledgeDestruction crowd_flow_knowledge_destruction = 99;
inline bool MsgSimToClient_Content::has_crowd_flow_knowledge_destruction() const {
  return _has_bit(98);
}
inline void MsgSimToClient_Content::clear_crowd_flow_knowledge_destruction() {
  if (crowd_flow_knowledge_destruction_ != NULL) crowd_flow_knowledge_destruction_->::MsgsSimToClient::MsgCrowdFlowKnowledgeDestruction::Clear();
  _clear_bit(98);
}
inline const ::MsgsSimToClient::MsgCrowdFlowKnowledgeDestruction& MsgSimToClient_Content::crowd_flow_knowledge_destruction() const {
  return crowd_flow_knowledge_destruction_ != NULL ? *crowd_flow_knowledge_destruction_ : *default_instance_->crowd_flow_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgCrowdFlowKnowledgeDestruction* MsgSimToClient_Content::mutable_crowd_flow_knowledge_destruction() {
  _set_bit(98);
  if (crowd_flow_knowledge_destruction_ == NULL) crowd_flow_knowledge_destruction_ = new ::MsgsSimToClient::MsgCrowdFlowKnowledgeDestruction;
  return crowd_flow_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgCrowdFlowKnowledgeUpdate crowd_flow_knowledge_update = 100;
inline bool MsgSimToClient_Content::has_crowd_flow_knowledge_update() const {
  return _has_bit(99);
}
inline void MsgSimToClient_Content::clear_crowd_flow_knowledge_update() {
  if (crowd_flow_knowledge_update_ != NULL) crowd_flow_knowledge_update_->::MsgsSimToClient::MsgCrowdFlowKnowledgeUpdate::Clear();
  _clear_bit(99);
}
inline const ::MsgsSimToClient::MsgCrowdFlowKnowledgeUpdate& MsgSimToClient_Content::crowd_flow_knowledge_update() const {
  return crowd_flow_knowledge_update_ != NULL ? *crowd_flow_knowledge_update_ : *default_instance_->crowd_flow_knowledge_update_;
}
inline ::MsgsSimToClient::MsgCrowdFlowKnowledgeUpdate* MsgSimToClient_Content::mutable_crowd_flow_knowledge_update() {
  _set_bit(99);
  if (crowd_flow_knowledge_update_ == NULL) crowd_flow_knowledge_update_ = new ::MsgsSimToClient::MsgCrowdFlowKnowledgeUpdate;
  return crowd_flow_knowledge_update_;
}

// optional .MsgsSimToClient.MsgFolkCreation folk_creation = 101;
inline bool MsgSimToClient_Content::has_folk_creation() const {
  return _has_bit(100);
}
inline void MsgSimToClient_Content::clear_folk_creation() {
  if (folk_creation_ != NULL) folk_creation_->::MsgsSimToClient::MsgFolkCreation::Clear();
  _clear_bit(100);
}
inline const ::MsgsSimToClient::MsgFolkCreation& MsgSimToClient_Content::folk_creation() const {
  return folk_creation_ != NULL ? *folk_creation_ : *default_instance_->folk_creation_;
}
inline ::MsgsSimToClient::MsgFolkCreation* MsgSimToClient_Content::mutable_folk_creation() {
  _set_bit(100);
  if (folk_creation_ == NULL) folk_creation_ = new ::MsgsSimToClient::MsgFolkCreation;
  return folk_creation_;
}

// optional .MsgsSimToClient.MsgFolkGraphUpdate folk_graph_update = 102;
inline bool MsgSimToClient_Content::has_folk_graph_update() const {
  return _has_bit(101);
}
inline void MsgSimToClient_Content::clear_folk_graph_update() {
  if (folk_graph_update_ != NULL) folk_graph_update_->::MsgsSimToClient::MsgFolkGraphUpdate::Clear();
  _clear_bit(101);
}
inline const ::MsgsSimToClient::MsgFolkGraphUpdate& MsgSimToClient_Content::folk_graph_update() const {
  return folk_graph_update_ != NULL ? *folk_graph_update_ : *default_instance_->folk_graph_update_;
}
inline ::MsgsSimToClient::MsgFolkGraphUpdate* MsgSimToClient_Content::mutable_folk_graph_update() {
  _set_bit(101);
  if (folk_graph_update_ == NULL) folk_graph_update_ = new ::MsgsSimToClient::MsgFolkGraphUpdate;
  return folk_graph_update_;
}

// optional .MsgsSimToClient.MsgControlGlobalWeatherAck control_global_weather_ack = 103;
inline bool MsgSimToClient_Content::has_control_global_weather_ack() const {
  return _has_bit(102);
}
inline void MsgSimToClient_Content::clear_control_global_weather_ack() {
  if (control_global_weather_ack_ != NULL) control_global_weather_ack_->::MsgsSimToClient::MsgControlGlobalWeatherAck::Clear();
  _clear_bit(102);
}
inline const ::MsgsSimToClient::MsgControlGlobalWeatherAck& MsgSimToClient_Content::control_global_weather_ack() const {
  return control_global_weather_ack_ != NULL ? *control_global_weather_ack_ : *default_instance_->control_global_weather_ack_;
}
inline ::MsgsSimToClient::MsgControlGlobalWeatherAck* MsgSimToClient_Content::mutable_control_global_weather_ack() {
  _set_bit(102);
  if (control_global_weather_ack_ == NULL) control_global_weather_ack_ = new ::MsgsSimToClient::MsgControlGlobalWeatherAck;
  return control_global_weather_ack_;
}

// optional .MsgsSimToClient.MsgControlLocalWeatherAck control_local_weather_ack = 104;
inline bool MsgSimToClient_Content::has_control_local_weather_ack() const {
  return _has_bit(103);
}
inline void MsgSimToClient_Content::clear_control_local_weather_ack() {
  if (control_local_weather_ack_ != NULL) control_local_weather_ack_->::MsgsSimToClient::MsgControlLocalWeatherAck::Clear();
  _clear_bit(103);
}
inline const ::MsgsSimToClient::MsgControlLocalWeatherAck& MsgSimToClient_Content::control_local_weather_ack() const {
  return control_local_weather_ack_ != NULL ? *control_local_weather_ack_ : *default_instance_->control_local_weather_ack_;
}
inline ::MsgsSimToClient::MsgControlLocalWeatherAck* MsgSimToClient_Content::mutable_control_local_weather_ack() {
  _set_bit(103);
  if (control_local_weather_ack_ == NULL) control_local_weather_ack_ = new ::MsgsSimToClient::MsgControlLocalWeatherAck;
  return control_local_weather_ack_;
}

// optional .MsgsSimToClient.MsgControlCheckPointSaveBegin control_checkpoint_save_begin = 105;
inline bool MsgSimToClient_Content::has_control_checkpoint_save_begin() const {
  return _has_bit(104);
}
inline void MsgSimToClient_Content::clear_control_checkpoint_save_begin() {
  if (control_checkpoint_save_begin_ != NULL) control_checkpoint_save_begin_->::MsgsSimToClient::MsgControlCheckPointSaveBegin::Clear();
  _clear_bit(104);
}
inline const ::MsgsSimToClient::MsgControlCheckPointSaveBegin& MsgSimToClient_Content::control_checkpoint_save_begin() const {
  return control_checkpoint_save_begin_ != NULL ? *control_checkpoint_save_begin_ : *default_instance_->control_checkpoint_save_begin_;
}
inline ::MsgsSimToClient::MsgControlCheckPointSaveBegin* MsgSimToClient_Content::mutable_control_checkpoint_save_begin() {
  _set_bit(104);
  if (control_checkpoint_save_begin_ == NULL) control_checkpoint_save_begin_ = new ::MsgsSimToClient::MsgControlCheckPointSaveBegin;
  return control_checkpoint_save_begin_;
}

// optional .MsgsSimToClient.MsgControlCheckPointSetFrequencyAck control_checkpoint_set_frequency_ack = 106;
inline bool MsgSimToClient_Content::has_control_checkpoint_set_frequency_ack() const {
  return _has_bit(105);
}
inline void MsgSimToClient_Content::clear_control_checkpoint_set_frequency_ack() {
  if (control_checkpoint_set_frequency_ack_ != NULL) control_checkpoint_set_frequency_ack_->::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck::Clear();
  _clear_bit(105);
}
inline const ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck& MsgSimToClient_Content::control_checkpoint_set_frequency_ack() const {
  return control_checkpoint_set_frequency_ack_ != NULL ? *control_checkpoint_set_frequency_ack_ : *default_instance_->control_checkpoint_set_frequency_ack_;
}
inline ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck* MsgSimToClient_Content::mutable_control_checkpoint_set_frequency_ack() {
  _set_bit(105);
  if (control_checkpoint_set_frequency_ack_ == NULL) control_checkpoint_set_frequency_ack_ = new ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck;
  return control_checkpoint_set_frequency_ack_;
}

// optional .MsgsSimToClient.MsgControlCheckPointSaveNowAck control_checkpoint_save_now_ack = 107;
inline bool MsgSimToClient_Content::has_control_checkpoint_save_now_ack() const {
  return _has_bit(106);
}
inline void MsgSimToClient_Content::clear_control_checkpoint_save_now_ack() {
  if (control_checkpoint_save_now_ack_ != NULL) control_checkpoint_save_now_ack_->::MsgsSimToClient::MsgControlCheckPointSaveNowAck::Clear();
  _clear_bit(106);
}
inline const ::MsgsSimToClient::MsgControlCheckPointSaveNowAck& MsgSimToClient_Content::control_checkpoint_save_now_ack() const {
  return control_checkpoint_save_now_ack_ != NULL ? *control_checkpoint_save_now_ack_ : *default_instance_->control_checkpoint_save_now_ack_;
}
inline ::MsgsSimToClient::MsgControlCheckPointSaveNowAck* MsgSimToClient_Content::mutable_control_checkpoint_save_now_ack() {
  _set_bit(106);
  if (control_checkpoint_save_now_ack_ == NULL) control_checkpoint_save_now_ack_ = new ::MsgsSimToClient::MsgControlCheckPointSaveNowAck;
  return control_checkpoint_save_now_ack_;
}

// optional .MsgsSimToClient.MsgControlSendCurrentStateBegin control_send_current_state_begin = 108;
inline bool MsgSimToClient_Content::has_control_send_current_state_begin() const {
  return _has_bit(107);
}
inline void MsgSimToClient_Content::clear_control_send_current_state_begin() {
  if (control_send_current_state_begin_ != NULL) control_send_current_state_begin_->::MsgsSimToClient::MsgControlSendCurrentStateBegin::Clear();
  _clear_bit(107);
}
inline const ::MsgsSimToClient::MsgControlSendCurrentStateBegin& MsgSimToClient_Content::control_send_current_state_begin() const {
  return control_send_current_state_begin_ != NULL ? *control_send_current_state_begin_ : *default_instance_->control_send_current_state_begin_;
}
inline ::MsgsSimToClient::MsgControlSendCurrentStateBegin* MsgSimToClient_Content::mutable_control_send_current_state_begin() {
  _set_bit(107);
  if (control_send_current_state_begin_ == NULL) control_send_current_state_begin_ = new ::MsgsSimToClient::MsgControlSendCurrentStateBegin;
  return control_send_current_state_begin_;
}

// optional .MsgsSimToClient.MsgControlSendCurrentStateEnd control_send_current_state_end = 109;
inline bool MsgSimToClient_Content::has_control_send_current_state_end() const {
  return _has_bit(108);
}
inline void MsgSimToClient_Content::clear_control_send_current_state_end() {
  if (control_send_current_state_end_ != NULL) control_send_current_state_end_->::MsgsSimToClient::MsgControlSendCurrentStateEnd::Clear();
  _clear_bit(108);
}
inline const ::MsgsSimToClient::MsgControlSendCurrentStateEnd& MsgSimToClient_Content::control_send_current_state_end() const {
  return control_send_current_state_end_ != NULL ? *control_send_current_state_end_ : *default_instance_->control_send_current_state_end_;
}
inline ::MsgsSimToClient::MsgControlSendCurrentStateEnd* MsgSimToClient_Content::mutable_control_send_current_state_end() {
  _set_bit(108);
  if (control_send_current_state_end_ == NULL) control_send_current_state_end_ = new ::MsgsSimToClient::MsgControlSendCurrentStateEnd;
  return control_send_current_state_end_;
}

// optional .MsgsSimToClient.MsgUrbanCreation urban_creation = 110;
inline bool MsgSimToClient_Content::has_urban_creation() const {
  return _has_bit(109);
}
inline void MsgSimToClient_Content::clear_urban_creation() {
  if (urban_creation_ != NULL) urban_creation_->::MsgsSimToClient::MsgUrbanCreation::Clear();
  _clear_bit(109);
}
inline const ::MsgsSimToClient::MsgUrbanCreation& MsgSimToClient_Content::urban_creation() const {
  return urban_creation_ != NULL ? *urban_creation_ : *default_instance_->urban_creation_;
}
inline ::MsgsSimToClient::MsgUrbanCreation* MsgSimToClient_Content::mutable_urban_creation() {
  _set_bit(109);
  if (urban_creation_ == NULL) urban_creation_ = new ::MsgsSimToClient::MsgUrbanCreation;
  return urban_creation_;
}

// optional .MsgsSimToClient.MsgUrbanUpdate urban_update = 111;
inline bool MsgSimToClient_Content::has_urban_update() const {
  return _has_bit(110);
}
inline void MsgSimToClient_Content::clear_urban_update() {
  if (urban_update_ != NULL) urban_update_->::MsgsSimToClient::MsgUrbanUpdate::Clear();
  _clear_bit(110);
}
inline const ::MsgsSimToClient::MsgUrbanUpdate& MsgSimToClient_Content::urban_update() const {
  return urban_update_ != NULL ? *urban_update_ : *default_instance_->urban_update_;
}
inline ::MsgsSimToClient::MsgUrbanUpdate* MsgSimToClient_Content::mutable_urban_update() {
  _set_bit(110);
  if (urban_update_ == NULL) urban_update_ = new ::MsgsSimToClient::MsgUrbanUpdate;
  return urban_update_;
}

// optional .MsgsSimToClient.MsgUrbanKnowledgeCreation urban_knowledge_creation = 112;
inline bool MsgSimToClient_Content::has_urban_knowledge_creation() const {
  return _has_bit(111);
}
inline void MsgSimToClient_Content::clear_urban_knowledge_creation() {
  if (urban_knowledge_creation_ != NULL) urban_knowledge_creation_->::MsgsSimToClient::MsgUrbanKnowledgeCreation::Clear();
  _clear_bit(111);
}
inline const ::MsgsSimToClient::MsgUrbanKnowledgeCreation& MsgSimToClient_Content::urban_knowledge_creation() const {
  return urban_knowledge_creation_ != NULL ? *urban_knowledge_creation_ : *default_instance_->urban_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgUrbanKnowledgeCreation* MsgSimToClient_Content::mutable_urban_knowledge_creation() {
  _set_bit(111);
  if (urban_knowledge_creation_ == NULL) urban_knowledge_creation_ = new ::MsgsSimToClient::MsgUrbanKnowledgeCreation;
  return urban_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgUrbanKnowledgeUpdate urban_knowledge_update = 113;
inline bool MsgSimToClient_Content::has_urban_knowledge_update() const {
  return _has_bit(112);
}
inline void MsgSimToClient_Content::clear_urban_knowledge_update() {
  if (urban_knowledge_update_ != NULL) urban_knowledge_update_->::MsgsSimToClient::MsgUrbanKnowledgeUpdate::Clear();
  _clear_bit(112);
}
inline const ::MsgsSimToClient::MsgUrbanKnowledgeUpdate& MsgSimToClient_Content::urban_knowledge_update() const {
  return urban_knowledge_update_ != NULL ? *urban_knowledge_update_ : *default_instance_->urban_knowledge_update_;
}
inline ::MsgsSimToClient::MsgUrbanKnowledgeUpdate* MsgSimToClient_Content::mutable_urban_knowledge_update() {
  _set_bit(112);
  if (urban_knowledge_update_ == NULL) urban_knowledge_update_ = new ::MsgsSimToClient::MsgUrbanKnowledgeUpdate;
  return urban_knowledge_update_;
}

// optional .MsgsSimToClient.MsgUrbanKnowledgeDestruction urban_knowledge_destruction = 114;
inline bool MsgSimToClient_Content::has_urban_knowledge_destruction() const {
  return _has_bit(113);
}
inline void MsgSimToClient_Content::clear_urban_knowledge_destruction() {
  if (urban_knowledge_destruction_ != NULL) urban_knowledge_destruction_->::MsgsSimToClient::MsgUrbanKnowledgeDestruction::Clear();
  _clear_bit(113);
}
inline const ::MsgsSimToClient::MsgUrbanKnowledgeDestruction& MsgSimToClient_Content::urban_knowledge_destruction() const {
  return urban_knowledge_destruction_ != NULL ? *urban_knowledge_destruction_ : *default_instance_->urban_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgUrbanKnowledgeDestruction* MsgSimToClient_Content::mutable_urban_knowledge_destruction() {
  _set_bit(113);
  if (urban_knowledge_destruction_ == NULL) urban_knowledge_destruction_ = new ::MsgsSimToClient::MsgUrbanKnowledgeDestruction;
  return urban_knowledge_destruction_;
}

// optional .Common.StockResource stock_resource = 115;
inline bool MsgSimToClient_Content::has_stock_resource() const {
  return _has_bit(114);
}
inline void MsgSimToClient_Content::clear_stock_resource() {
  if (stock_resource_ != NULL) stock_resource_->::Common::StockResource::Clear();
  _clear_bit(114);
}
inline const ::Common::StockResource& MsgSimToClient_Content::stock_resource() const {
  return stock_resource_ != NULL ? *stock_resource_ : *default_instance_->stock_resource_;
}
inline ::Common::StockResource* MsgSimToClient_Content::mutable_stock_resource() {
  _set_bit(114);
  if (stock_resource_ == NULL) stock_resource_ = new ::Common::StockResource;
  return stock_resource_;
}

// optional .MsgsSimToClient.MsgUrbanDetection urban_detection = 116;
inline bool MsgSimToClient_Content::has_urban_detection() const {
  return _has_bit(115);
}
inline void MsgSimToClient_Content::clear_urban_detection() {
  if (urban_detection_ != NULL) urban_detection_->::MsgsSimToClient::MsgUrbanDetection::Clear();
  _clear_bit(115);
}
inline const ::MsgsSimToClient::MsgUrbanDetection& MsgSimToClient_Content::urban_detection() const {
  return urban_detection_ != NULL ? *urban_detection_ : *default_instance_->urban_detection_;
}
inline ::MsgsSimToClient::MsgUrbanDetection* MsgSimToClient_Content::mutable_urban_detection() {
  _set_bit(115);
  if (urban_detection_ == NULL) urban_detection_ = new ::MsgsSimToClient::MsgUrbanDetection;
  return urban_detection_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupMagicActionAck knowledge_group_magic_action_ack = 117;
inline bool MsgSimToClient_Content::has_knowledge_group_magic_action_ack() const {
  return _has_bit(116);
}
inline void MsgSimToClient_Content::clear_knowledge_group_magic_action_ack() {
  if (knowledge_group_magic_action_ack_ != NULL) knowledge_group_magic_action_ack_->::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck::Clear();
  _clear_bit(116);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck& MsgSimToClient_Content::knowledge_group_magic_action_ack() const {
  return knowledge_group_magic_action_ack_ != NULL ? *knowledge_group_magic_action_ack_ : *default_instance_->knowledge_group_magic_action_ack_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck* MsgSimToClient_Content::mutable_knowledge_group_magic_action_ack() {
  _set_bit(116);
  if (knowledge_group_magic_action_ack_ == NULL) knowledge_group_magic_action_ack_ = new ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck;
  return knowledge_group_magic_action_ack_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupCreation knowledge_group_creation = 118;
inline bool MsgSimToClient_Content::has_knowledge_group_creation() const {
  return _has_bit(117);
}
inline void MsgSimToClient_Content::clear_knowledge_group_creation() {
  if (knowledge_group_creation_ != NULL) knowledge_group_creation_->::MsgsSimToClient::MsgKnowledgeGroupCreation::Clear();
  _clear_bit(117);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupCreation& MsgSimToClient_Content::knowledge_group_creation() const {
  return knowledge_group_creation_ != NULL ? *knowledge_group_creation_ : *default_instance_->knowledge_group_creation_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupCreation* MsgSimToClient_Content::mutable_knowledge_group_creation() {
  _set_bit(117);
  if (knowledge_group_creation_ == NULL) knowledge_group_creation_ = new ::MsgsSimToClient::MsgKnowledgeGroupCreation;
  return knowledge_group_creation_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupUpdate knowledge_group_update = 119;
inline bool MsgSimToClient_Content::has_knowledge_group_update() const {
  return _has_bit(118);
}
inline void MsgSimToClient_Content::clear_knowledge_group_update() {
  if (knowledge_group_update_ != NULL) knowledge_group_update_->::MsgsSimToClient::MsgKnowledgeGroupUpdate::Clear();
  _clear_bit(118);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupUpdate& MsgSimToClient_Content::knowledge_group_update() const {
  return knowledge_group_update_ != NULL ? *knowledge_group_update_ : *default_instance_->knowledge_group_update_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupUpdate* MsgSimToClient_Content::mutable_knowledge_group_update() {
  _set_bit(118);
  if (knowledge_group_update_ == NULL) knowledge_group_update_ = new ::MsgsSimToClient::MsgKnowledgeGroupUpdate;
  return knowledge_group_update_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupCreationAck knowledge_group_creation_ack = 120;
inline bool MsgSimToClient_Content::has_knowledge_group_creation_ack() const {
  return _has_bit(119);
}
inline void MsgSimToClient_Content::clear_knowledge_group_creation_ack() {
  if (knowledge_group_creation_ack_ != NULL) knowledge_group_creation_ack_->::MsgsSimToClient::MsgKnowledgeGroupCreationAck::Clear();
  _clear_bit(119);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupCreationAck& MsgSimToClient_Content::knowledge_group_creation_ack() const {
  return knowledge_group_creation_ack_ != NULL ? *knowledge_group_creation_ack_ : *default_instance_->knowledge_group_creation_ack_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupCreationAck* MsgSimToClient_Content::mutable_knowledge_group_creation_ack() {
  _set_bit(119);
  if (knowledge_group_creation_ack_ == NULL) knowledge_group_creation_ack_ = new ::MsgsSimToClient::MsgKnowledgeGroupCreationAck;
  return knowledge_group_creation_ack_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupUpdateAck knowledge_group_update_ack = 121;
inline bool MsgSimToClient_Content::has_knowledge_group_update_ack() const {
  return _has_bit(120);
}
inline void MsgSimToClient_Content::clear_knowledge_group_update_ack() {
  if (knowledge_group_update_ack_ != NULL) knowledge_group_update_ack_->::MsgsSimToClient::MsgKnowledgeGroupUpdateAck::Clear();
  _clear_bit(120);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck& MsgSimToClient_Content::knowledge_group_update_ack() const {
  return knowledge_group_update_ack_ != NULL ? *knowledge_group_update_ack_ : *default_instance_->knowledge_group_update_ack_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck* MsgSimToClient_Content::mutable_knowledge_group_update_ack() {
  _set_bit(120);
  if (knowledge_group_update_ack_ == NULL) knowledge_group_update_ack_ = new ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck;
  return knowledge_group_update_ack_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupDestruction knowledge_group_destruction = 122;
inline bool MsgSimToClient_Content::has_knowledge_group_destruction() const {
  return _has_bit(121);
}
inline void MsgSimToClient_Content::clear_knowledge_group_destruction() {
  if (knowledge_group_destruction_ != NULL) knowledge_group_destruction_->::MsgsSimToClient::MsgKnowledgeGroupDestruction::Clear();
  _clear_bit(121);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupDestruction& MsgSimToClient_Content::knowledge_group_destruction() const {
  return knowledge_group_destruction_ != NULL ? *knowledge_group_destruction_ : *default_instance_->knowledge_group_destruction_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupDestruction* MsgSimToClient_Content::mutable_knowledge_group_destruction() {
  _set_bit(121);
  if (knowledge_group_destruction_ == NULL) knowledge_group_destruction_ = new ::MsgsSimToClient::MsgKnowledgeGroupDestruction;
  return knowledge_group_destruction_;
}

// optional .MsgsSimToClient.MsgActionCreateFireOrderAck action_create_fire_order_ack = 123;
inline bool MsgSimToClient_Content::has_action_create_fire_order_ack() const {
  return _has_bit(122);
}
inline void MsgSimToClient_Content::clear_action_create_fire_order_ack() {
  if (action_create_fire_order_ack_ != NULL) action_create_fire_order_ack_->::MsgsSimToClient::MsgActionCreateFireOrderAck::Clear();
  _clear_bit(122);
}
inline const ::MsgsSimToClient::MsgActionCreateFireOrderAck& MsgSimToClient_Content::action_create_fire_order_ack() const {
  return action_create_fire_order_ack_ != NULL ? *action_create_fire_order_ack_ : *default_instance_->action_create_fire_order_ack_;
}
inline ::MsgsSimToClient::MsgActionCreateFireOrderAck* MsgSimToClient_Content::mutable_action_create_fire_order_ack() {
  _set_bit(122);
  if (action_create_fire_order_ack_ == NULL) action_create_fire_order_ack_ = new ::MsgsSimToClient::MsgActionCreateFireOrderAck;
  return action_create_fire_order_ack_;
}

// optional .MsgsSimToClient.MsgControlGlobalWeather control_global_weather = 124;
inline bool MsgSimToClient_Content::has_control_global_weather() const {
  return _has_bit(123);
}
inline void MsgSimToClient_Content::clear_control_global_weather() {
  if (control_global_weather_ != NULL) control_global_weather_->::MsgsSimToClient::MsgControlGlobalWeather::Clear();
  _clear_bit(123);
}
inline const ::MsgsSimToClient::MsgControlGlobalWeather& MsgSimToClient_Content::control_global_weather() const {
  return control_global_weather_ != NULL ? *control_global_weather_ : *default_instance_->control_global_weather_;
}
inline ::MsgsSimToClient::MsgControlGlobalWeather* MsgSimToClient_Content::mutable_control_global_weather() {
  _set_bit(123);
  if (control_global_weather_ == NULL) control_global_weather_ = new ::MsgsSimToClient::MsgControlGlobalWeather;
  return control_global_weather_;
}

// optional .MsgsSimToClient.MsgControlLocalWeatherCreation control_local_weather_creation = 125;
inline bool MsgSimToClient_Content::has_control_local_weather_creation() const {
  return _has_bit(124);
}
inline void MsgSimToClient_Content::clear_control_local_weather_creation() {
  if (control_local_weather_creation_ != NULL) control_local_weather_creation_->::MsgsSimToClient::MsgControlLocalWeatherCreation::Clear();
  _clear_bit(124);
}
inline const ::MsgsSimToClient::MsgControlLocalWeatherCreation& MsgSimToClient_Content::control_local_weather_creation() const {
  return control_local_weather_creation_ != NULL ? *control_local_weather_creation_ : *default_instance_->control_local_weather_creation_;
}
inline ::MsgsSimToClient::MsgControlLocalWeatherCreation* MsgSimToClient_Content::mutable_control_local_weather_creation() {
  _set_bit(124);
  if (control_local_weather_creation_ == NULL) control_local_weather_creation_ = new ::MsgsSimToClient::MsgControlLocalWeatherCreation;
  return control_local_weather_creation_;
}

// optional .MsgsSimToClient.MsgControlLocalWeatherDestruction control_local_weather_destruction = 126;
inline bool MsgSimToClient_Content::has_control_local_weather_destruction() const {
  return _has_bit(125);
}
inline void MsgSimToClient_Content::clear_control_local_weather_destruction() {
  if (control_local_weather_destruction_ != NULL) control_local_weather_destruction_->::MsgsSimToClient::MsgControlLocalWeatherDestruction::Clear();
  _clear_bit(125);
}
inline const ::MsgsSimToClient::MsgControlLocalWeatherDestruction& MsgSimToClient_Content::control_local_weather_destruction() const {
  return control_local_weather_destruction_ != NULL ? *control_local_weather_destruction_ : *default_instance_->control_local_weather_destruction_;
}
inline ::MsgsSimToClient::MsgControlLocalWeatherDestruction* MsgSimToClient_Content::mutable_control_local_weather_destruction() {
  _set_bit(125);
  if (control_local_weather_destruction_ == NULL) control_local_weather_destruction_ = new ::MsgsSimToClient::MsgControlLocalWeatherDestruction;
  return control_local_weather_destruction_;
}

// -------------------------------------------------------------------

// MsgSimToClient

// optional int32 context = 1;
inline bool MsgSimToClient::has_context() const {
  return _has_bit(0);
}
inline void MsgSimToClient::clear_context() {
  context_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgSimToClient::context() const {
  return context_;
}
inline void MsgSimToClient::set_context(::google::protobuf::int32 value) {
  _set_bit(0);
  context_ = value;
}

// required .MsgsSimToClient.MsgSimToClient.Content message = 2;
inline bool MsgSimToClient::has_message() const {
  return _has_bit(1);
}
inline void MsgSimToClient::clear_message() {
  if (message_ != NULL) message_->::MsgsSimToClient::MsgSimToClient_Content::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgSimToClient_Content& MsgSimToClient::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::MsgsSimToClient::MsgSimToClient_Content* MsgSimToClient::mutable_message() {
  _set_bit(1);
  if (message_ == NULL) message_ = new ::MsgsSimToClient::MsgSimToClient_Content;
  return message_;
}


}  // namespace MsgsSimToClient

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::OrderAck_ErrorCode>() {
  return ::MsgsSimToClient::OrderAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::UnitActionAck_ErrorCode>() {
  return ::MsgsSimToClient::UnitActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgMagicActionAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgMagicActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgCrowdMagicActionAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgCrowdMagicActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode>() {
  return ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode>() {
  return ::MsgsSimToClient::HierarchyModificationAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow>() {
  return ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas>() {
  return ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode>() {
  return ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::ControlAck_ErrorCode>() {
  return ::MsgsSimToClient::ControlAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::RulesOfEngagement_Value>() {
  return ::MsgsSimToClient::RulesOfEngagement_Value_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::ForceRatio_Value>() {
  return ::MsgsSimToClient::ForceRatio_Value_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgUnitAttributes_Posture>() {
  return ::MsgsSimToClient::MsgUnitAttributes_Posture_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgUnitAttributes_FireAvailability>() {
  return ::MsgsSimToClient::MsgUnitAttributes_FireAvailability_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgUnitAttributes_CrowdRoe>() {
  return ::MsgsSimToClient::MsgUnitAttributes_CrowdRoe_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode>() {
  return ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< MsgsSimToClient::EnumLogSupplyHandlingStatus>() {
  return MsgsSimToClient::EnumLogSupplyHandlingStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< MsgsSimToClient::EnumUnitIdentificationLevel>() {
  return MsgsSimToClient::EnumUnitIdentificationLevel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< MsgsSimToClient::EnumReportType>() {
  return MsgsSimToClient::EnumReportType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_SimToClient_2eproto__INCLUDED
