// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_SimToClient_2eproto__INCLUDED
#define PROTOBUF_SimToClient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Common.pb.h"

namespace MsgsSimToClient {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SimToClient_2eproto();
void protobuf_AssignDesc_SimToClient_2eproto();
void protobuf_ShutdownFile_SimToClient_2eproto();

class OrderAck;
class MsgUnitOrderAck;
class MsgAutomatOrderAck;
class MsgPopulationOrderAck;
class MsgFragOrderAck;
class MsgSetAutomatModeAck;
class UnitActionAck;
class MsgUnitCreationRequestAck;
class MsgMagicActionAck;
class MsgUnitMagicActionAck;
class MsgObjectMagicActionAck;
class MsgPopulationMagicActionAck;
class MsgChangeDiplomacyAck;
class HierarchyModificationAck;
class MsgAutomatChangeKnowledgeGroupAck;
class MsgAutomatChangeLogisticLinksAck;
class MsgAutomatChangeSuperiorAck;
class MsgUnitChangeSuperiorAck;
class MsgLogSupplyPushFlowAck;
class MsgLogSupplyChangeQuotasAck;
class MsgActionCreateFireOrderAck;
class MsgControlInformation;
class MsgControlProfilingInformation;
class MsgControlBeginTick;
class MsgControlEndTick;
class ControlAck;
class MsgControlDatetimeChangeAck;
class MsgControlChangeTimeFactorAck;
class MsgControlStopAck;
class MsgControlPauseAck;
class MsgControlResumeAck;
class MsgTeamCreation;
class MsgAutomatCreation_oid_parent;
class MsgAutomatCreation;
class RulesOfEngagement;
class ForceRatio;
class MsgAutomatAttributes;
class MsgUnitCreation;
class BorrowedEquipments;
class BorrowedEquipments_BorrowedEquipment;
class LentEquipments;
class LentEquipments_LentEquipment;
class ResourceDotations;
class ResourceDotations_ResourceDotation;
class EquipmentDotations;
class EquipmentDotations_EquipmentDotation;
class HumanDotations;
class HumanDotations_HumanDotation;
class ContaminationState;
class NBCAgents;
class Communication;
class MsgUnitAttributes;
class MsgUnitPathFind;
class MsgUnitDestruction;
class MsgUnitEnvironmentType;
class MsgUnitKnowledgeCreation;
class AutomatPerception;
class SeqOfAutomatPerception;
class MsgUnitKnowledgeUpdate;
class MsgUnitKnowledgeDestruction;
class MsgStartUnitFire_target;
class MsgStartUnitFire;
class UnitHumanFireDamage;
class SeqOfUnitHumanFireDamage;
class MsgUnitEquipmentFireDamage;
class SeqOfUnitEquipmentFireDamage;
class MsgUnitFireDamages;
class MsgUnitsFireDamages;
class MsgPopulationFireDamages;
class MsgPopulationsFireDamages;
class MsgStopUnitFire;
class MsgStartPopulationFire;
class MsgStopPopulationFire;
class MsgExplosion;
class MsgStartFireEffect;
class MsgStopFireEffect;
class MsgReport;
class MsgInvalidateReport;
class MsgTrace;
class MsgDecisionalState;
class MsgDebugPoints;
class SeqOfHeading;
class MsgVisionCone;
class SeqOfVisionCone;
class MsgUnitVisionCones;
class MsgUnitDetection;
class MsgObjectDetection;
class MsgPopulationConcentrationDetection;
class MsgPopulationFlowDetection;
class MsgObjectCreation;
class MsgObjectDestruction;
class MsgObjectUpdate;
class MsgObjectKnowledgeCreation;
class MsgObjectKnowledgeUpdate;
class MsgObjectKnowledgeDestruction;
class MsgUrbanKnowledgeCreation;
class MsgUrbanKnowledgeUpdate;
class MsgUrbanKnowledgeDestruction;
class MsgLogMedicalHandlingCreation;
class MsgLogMedicalHandlingUpdate;
class MsgLogMedicalHandlingDestruction;
class MsgLogMedicalEquipmentAvailability;
class SeqOfLogMedicalEquipmentAvailability;
class MsgLogMedicalState;
class MsgLogMaintenanceHandlingCreation;
class MsgLogMaintenanceHandlingUpdate;
class MsgLogMaintenanceHandlingDestruction;
class MsgLogMaintenanceEquipmentAvailability;
class SeqOfLogMaintenanceEquipmentAvailability;
class MsgLogMaintenanceState;
class MsgLogSupplyHandlingCreation;
class MsgDotationQuery;
class SeqOfDotationQuery;
class MsgLogSupplyHandlingUpdate;
class MsgLogSupplyHandlingDestruction;
class MsgLogSupplyEquimentAvailability;
class SeqOfLogSupplyEquimentAvailability;
class MsgLogSupplyState;
class MsgLogSupplyQuotas;
class MsgPopulationCreation;
class MsgPopulationUpdate;
class MsgPopulationConcentrationCreation;
class MsgPopulationConcentrationDestruction;
class MsgPopulationConcentrationUpdate;
class MsgPopulationFlowCreation;
class MsgPopulationFlowDestruction;
class MsgPopulationFlowUpdate;
class MsgPopulationKnowledgeCreation;
class MsgPopulationKnowledgeUpdate;
class MsgPopulationKnowledgeDestruction;
class MsgPopulationConcentrationKnowledgeCreation;
class MsgPopulationConcentrationKnowledgeUpdate;
class MsgPopulationConcentrationKnowledgeDestruction;
class MsgPopulationFlowKnowledgeCreation;
class MsgFlowPart;
class SeqOfFlowPart;
class MsgPopulationFlowKnowledgeUpdate;
class MsgPopulationFlowKnowledgeDestruction;
class MsgFolkCreation_profiles;
class MsgFolkCreation_activities;
class MsgFolkCreation;
class MsgFolkGraphEdgeUpdate;
class MsgFolkGraphUpdate;
class MsgControlCheckPointSetFrequencyAck;
class MsgControlCheckPointSaveNowAck;
class MsgControlCheckPointSaveBegin;
class MsgControlCheckPointSaveBeginAck;
class MsgControlCheckPointSaveEnd;
class MsgControlSendCurrentStateBegin;
class MsgControlSendCurrentStateEnd;
class MagicActionCreateUrban;
class MagicActionUpdateUrban;
class MagicActionDestroyUrban;
class MsgUrbanMagicAction;
class MsgUrbanMagicActionAck;
class MsgUrbanAttributes;
class MsgUrbanAttributes_Architecture;
class MsgUrbanAttributes_Structure;
class MsgUrbanAttributes_Infrastructures;
class MsgUrbanAttributes_RgbaColor;
class MsgUrbanCreation;
class MsgUrbanDetection;
class MsgUrbanUpdate;
class MsgKnowledgeGroupCreation;
class MsgKnowledgeGroupUpdate;
class KnowledgeGroupAck;
class MsgKnowledgeGroupMagicActionAck;
class MsgKnowledgeGroupCreationAck;
class MsgKnowledgeGroupUpdateAck;
class MsgKnowledgeGroupDestruction;
class MsgControlGlobalMeteoAck;
class MsgControlLocalMeteoAck;
class MsgControlGlobalMeteo;
class MsgControlLocalMeteoCreation;
class MsgControlLocalMeteoDestruction;
class MsgSimToClient;
class MsgSimToClient_Content;

enum OrderAck_ErrorCode {
  OrderAck_ErrorCode_no_error = 0,
  OrderAck_ErrorCode_error_invalid_unit = 1,
  OrderAck_ErrorCode_error_invalid_limit = 2,
  OrderAck_ErrorCode_error_invalid_lima = 3,
  OrderAck_ErrorCode_error_invalid_mission = 4,
  OrderAck_ErrorCode_error_invalid_mission_parameters = 5,
  OrderAck_ErrorCode_error_unit_cannot_receive_order = 6,
  OrderAck_ErrorCode_error_invalid_order_conduite = 7,
  OrderAck_ErrorCode_error_invalid_order_mission = 8,
  OrderAck_ErrorCode_error_invalid_order_initial = 9,
  OrderAck_ErrorCode_error_invalid_order_conduite_parameters = 10,
  OrderAck_ErrorCode_error_unit_surrendered = 11,
  OrderAck_ErrorCode_error_invalid_lima_function = 12
};
bool OrderAck_ErrorCode_IsValid(int value);
const OrderAck_ErrorCode OrderAck_ErrorCode_ErrorCode_MIN = OrderAck_ErrorCode_no_error;
const OrderAck_ErrorCode OrderAck_ErrorCode_ErrorCode_MAX = OrderAck_ErrorCode_error_invalid_lima_function;

const ::google::protobuf::EnumDescriptor* OrderAck_ErrorCode_descriptor();
inline const ::std::string& OrderAck_ErrorCode_Name(OrderAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderAck_ErrorCode_descriptor(), value);
}
inline bool OrderAck_ErrorCode_Parse(
    const ::std::string& name, OrderAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderAck_ErrorCode>(
    OrderAck_ErrorCode_descriptor(), name, value);
}
enum MsgSetAutomatModeAck_ErrorCode {
  MsgSetAutomatModeAck_ErrorCode_no_error = 0,
  MsgSetAutomatModeAck_ErrorCode_error_invalid_unit = 1,
  MsgSetAutomatModeAck_ErrorCode_error_not_allowed = 2
};
bool MsgSetAutomatModeAck_ErrorCode_IsValid(int value);
const MsgSetAutomatModeAck_ErrorCode MsgSetAutomatModeAck_ErrorCode_ErrorCode_MIN = MsgSetAutomatModeAck_ErrorCode_no_error;
const MsgSetAutomatModeAck_ErrorCode MsgSetAutomatModeAck_ErrorCode_ErrorCode_MAX = MsgSetAutomatModeAck_ErrorCode_error_not_allowed;

const ::google::protobuf::EnumDescriptor* MsgSetAutomatModeAck_ErrorCode_descriptor();
inline const ::std::string& MsgSetAutomatModeAck_ErrorCode_Name(MsgSetAutomatModeAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgSetAutomatModeAck_ErrorCode_descriptor(), value);
}
inline bool MsgSetAutomatModeAck_ErrorCode_Parse(
    const ::std::string& name, MsgSetAutomatModeAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgSetAutomatModeAck_ErrorCode>(
    MsgSetAutomatModeAck_ErrorCode_descriptor(), name, value);
}
enum UnitActionAck_ErrorCode {
  UnitActionAck_ErrorCode_no_error = 0,
  UnitActionAck_ErrorCode_error_invalid_unit = 1,
  UnitActionAck_ErrorCode_error_automate_embraye = 2,
  UnitActionAck_ErrorCode_error_invalid_attribute = 3,
  UnitActionAck_ErrorCode_error_unit_surrendered = 4
};
bool UnitActionAck_ErrorCode_IsValid(int value);
const UnitActionAck_ErrorCode UnitActionAck_ErrorCode_ErrorCode_MIN = UnitActionAck_ErrorCode_no_error;
const UnitActionAck_ErrorCode UnitActionAck_ErrorCode_ErrorCode_MAX = UnitActionAck_ErrorCode_error_unit_surrendered;

const ::google::protobuf::EnumDescriptor* UnitActionAck_ErrorCode_descriptor();
inline const ::std::string& UnitActionAck_ErrorCode_Name(UnitActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitActionAck_ErrorCode_descriptor(), value);
}
inline bool UnitActionAck_ErrorCode_Parse(
    const ::std::string& name, UnitActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitActionAck_ErrorCode>(
    UnitActionAck_ErrorCode_descriptor(), name, value);
}
enum MsgMagicActionAck_ErrorCode {
  MsgMagicActionAck_ErrorCode_no_error = 0,
  MsgMagicActionAck_ErrorCode_error_invalid_attribute = 1
};
bool MsgMagicActionAck_ErrorCode_IsValid(int value);
const MsgMagicActionAck_ErrorCode MsgMagicActionAck_ErrorCode_ErrorCode_MIN = MsgMagicActionAck_ErrorCode_no_error;
const MsgMagicActionAck_ErrorCode MsgMagicActionAck_ErrorCode_ErrorCode_MAX = MsgMagicActionAck_ErrorCode_error_invalid_attribute;

const ::google::protobuf::EnumDescriptor* MsgMagicActionAck_ErrorCode_descriptor();
inline const ::std::string& MsgMagicActionAck_ErrorCode_Name(MsgMagicActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgMagicActionAck_ErrorCode_descriptor(), value);
}
inline bool MsgMagicActionAck_ErrorCode_Parse(
    const ::std::string& name, MsgMagicActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgMagicActionAck_ErrorCode>(
    MsgMagicActionAck_ErrorCode_descriptor(), name, value);
}
enum MsgObjectMagicActionAck_ErrorCode {
  MsgObjectMagicActionAck_ErrorCode_no_error = 0,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_object = 1,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_id = 2,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_camp = 3,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_localisation = 4,
  MsgObjectMagicActionAck_ErrorCode_error_missing_specific_attributes = 5,
  MsgObjectMagicActionAck_ErrorCode_error_invalid_specific_attributes = 6
};
bool MsgObjectMagicActionAck_ErrorCode_IsValid(int value);
const MsgObjectMagicActionAck_ErrorCode MsgObjectMagicActionAck_ErrorCode_ErrorCode_MIN = MsgObjectMagicActionAck_ErrorCode_no_error;
const MsgObjectMagicActionAck_ErrorCode MsgObjectMagicActionAck_ErrorCode_ErrorCode_MAX = MsgObjectMagicActionAck_ErrorCode_error_invalid_specific_attributes;

const ::google::protobuf::EnumDescriptor* MsgObjectMagicActionAck_ErrorCode_descriptor();
inline const ::std::string& MsgObjectMagicActionAck_ErrorCode_Name(MsgObjectMagicActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgObjectMagicActionAck_ErrorCode_descriptor(), value);
}
inline bool MsgObjectMagicActionAck_ErrorCode_Parse(
    const ::std::string& name, MsgObjectMagicActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgObjectMagicActionAck_ErrorCode>(
    MsgObjectMagicActionAck_ErrorCode_descriptor(), name, value);
}
enum MsgPopulationMagicActionAck_ErrorCode {
  MsgPopulationMagicActionAck_ErrorCode_no_error = 0,
  MsgPopulationMagicActionAck_ErrorCode_error_invalid_unit = 1,
  MsgPopulationMagicActionAck_ErrorCode_error_invalid_attribute = 2
};
bool MsgPopulationMagicActionAck_ErrorCode_IsValid(int value);
const MsgPopulationMagicActionAck_ErrorCode MsgPopulationMagicActionAck_ErrorCode_ErrorCode_MIN = MsgPopulationMagicActionAck_ErrorCode_no_error;
const MsgPopulationMagicActionAck_ErrorCode MsgPopulationMagicActionAck_ErrorCode_ErrorCode_MAX = MsgPopulationMagicActionAck_ErrorCode_error_invalid_attribute;

const ::google::protobuf::EnumDescriptor* MsgPopulationMagicActionAck_ErrorCode_descriptor();
inline const ::std::string& MsgPopulationMagicActionAck_ErrorCode_Name(MsgPopulationMagicActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgPopulationMagicActionAck_ErrorCode_descriptor(), value);
}
inline bool MsgPopulationMagicActionAck_ErrorCode_Parse(
    const ::std::string& name, MsgPopulationMagicActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgPopulationMagicActionAck_ErrorCode>(
    MsgPopulationMagicActionAck_ErrorCode_descriptor(), name, value);
}
enum MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode {
  MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_no_error_diplomacy = 0,
  MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_error_invalid_camp_diplomacy = 1
};
bool MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_IsValid(int value);
const MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_EnumChangeDiplomacyErrorCode_MIN = MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_no_error_diplomacy;
const MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_EnumChangeDiplomacyErrorCode_MAX = MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_error_invalid_camp_diplomacy;

const ::google::protobuf::EnumDescriptor* MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor();
inline const ::std::string& MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_Name(MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor(), value);
}
inline bool MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_Parse(
    const ::std::string& name, MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode>(
    MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor(), name, value);
}
enum HierarchyModificationAck_ErrorCode {
  HierarchyModificationAck_ErrorCode_no_error_hierarchy = 0,
  HierarchyModificationAck_ErrorCode_error_invalid_pion = 1,
  HierarchyModificationAck_ErrorCode_error_invalid_automate = 2,
  HierarchyModificationAck_ErrorCode_error_invalid_formation = 3,
  HierarchyModificationAck_ErrorCode_error_invalid_automate_tc2 = 4,
  HierarchyModificationAck_ErrorCode_error_invalid_automate_maintenance = 5,
  HierarchyModificationAck_ErrorCode_error_invalid_automate_sante = 6,
  HierarchyModificationAck_ErrorCode_error_invalid_automate_supply = 7,
  HierarchyModificationAck_ErrorCode_error_unit_surrendered_hierarchy = 8,
  HierarchyModificationAck_ErrorCode_error_invalid_team_hierarchy = 9,
  HierarchyModificationAck_ErrorCode_error_invalid_knowledge_group = 10,
  HierarchyModificationAck_ErrorCode_error_teams_mismatched = 11
};
bool HierarchyModificationAck_ErrorCode_IsValid(int value);
const HierarchyModificationAck_ErrorCode HierarchyModificationAck_ErrorCode_ErrorCode_MIN = HierarchyModificationAck_ErrorCode_no_error_hierarchy;
const HierarchyModificationAck_ErrorCode HierarchyModificationAck_ErrorCode_ErrorCode_MAX = HierarchyModificationAck_ErrorCode_error_teams_mismatched;

const ::google::protobuf::EnumDescriptor* HierarchyModificationAck_ErrorCode_descriptor();
inline const ::std::string& HierarchyModificationAck_ErrorCode_Name(HierarchyModificationAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    HierarchyModificationAck_ErrorCode_descriptor(), value);
}
inline bool HierarchyModificationAck_ErrorCode_Parse(
    const ::std::string& name, HierarchyModificationAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HierarchyModificationAck_ErrorCode>(
    HierarchyModificationAck_ErrorCode_descriptor(), name, value);
}
enum MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow {
  MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_no_error_pushflow = 0,
  MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_donneur_pushflow = 1,
  MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_receveur_pushflow = 2
};
bool MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_IsValid(int value);
const MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_EnumLogSupplyPushFlow_MIN = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_no_error_pushflow;
const MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_EnumLogSupplyPushFlow_MAX = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_receveur_pushflow;

const ::google::protobuf::EnumDescriptor* MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor();
inline const ::std::string& MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_Name(MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor(), value);
}
inline bool MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_Parse(
    const ::std::string& name, MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow>(
    MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor(), name, value);
}
enum MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas {
  MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_no_error_quotas = 0,
  MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_donneur_quotas = 1,
  MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_receveur_quotas = 2
};
bool MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_IsValid(int value);
const MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_LogSupplyChangeQuotas_MIN = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_no_error_quotas;
const MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_LogSupplyChangeQuotas_MAX = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_receveur_quotas;

const ::google::protobuf::EnumDescriptor* MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor();
inline const ::std::string& MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_Name(MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor(), value);
}
inline bool MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_Parse(
    const ::std::string& name, MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas>(
    MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor(), name, value);
}
enum MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode {
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_no_error = 0,
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_reporter = 1,
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_target = 2,
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_munition = 3,
  MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_target_no_illuminated = 4
};
bool MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_IsValid(int value);
const MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_EnumActionCreateFireOrderErrorCode_MIN = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_no_error;
const MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_EnumActionCreateFireOrderErrorCode_MAX = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_target_no_illuminated;

const ::google::protobuf::EnumDescriptor* MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor();
inline const ::std::string& MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_Name(MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor(), value);
}
inline bool MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_Parse(
    const ::std::string& name, MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode>(
    MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor(), name, value);
}
enum ControlAck_ErrorCode {
  ControlAck_ErrorCode_no_error = 0,
  ControlAck_ErrorCode_error_already_started = 1,
  ControlAck_ErrorCode_error_not_started = 2,
  ControlAck_ErrorCode_error_not_paused = 3,
  ControlAck_ErrorCode_error_already_paused = 4,
  ControlAck_ErrorCode_error_invalid_time_factor = 5,
  ControlAck_ErrorCode_error_invalid_date_time = 6
};
bool ControlAck_ErrorCode_IsValid(int value);
const ControlAck_ErrorCode ControlAck_ErrorCode_ErrorCode_MIN = ControlAck_ErrorCode_no_error;
const ControlAck_ErrorCode ControlAck_ErrorCode_ErrorCode_MAX = ControlAck_ErrorCode_error_invalid_date_time;

const ::google::protobuf::EnumDescriptor* ControlAck_ErrorCode_descriptor();
inline const ::std::string& ControlAck_ErrorCode_Name(ControlAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlAck_ErrorCode_descriptor(), value);
}
inline bool ControlAck_ErrorCode_Parse(
    const ::std::string& name, ControlAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlAck_ErrorCode>(
    ControlAck_ErrorCode_descriptor(), name, value);
}
enum RulesOfEngagement_Value {
  RulesOfEngagement_Value_none_roe = 0,
  RulesOfEngagement_Value_tir_libre = 1,
  RulesOfEngagement_Value_tir_sur_riposte = 2,
  RulesOfEngagement_Value_tir_interdit = 3
};
bool RulesOfEngagement_Value_IsValid(int value);
const RulesOfEngagement_Value RulesOfEngagement_Value_Value_MIN = RulesOfEngagement_Value_none_roe;
const RulesOfEngagement_Value RulesOfEngagement_Value_Value_MAX = RulesOfEngagement_Value_tir_interdit;

const ::google::protobuf::EnumDescriptor* RulesOfEngagement_Value_descriptor();
inline const ::std::string& RulesOfEngagement_Value_Name(RulesOfEngagement_Value value) {
  return ::google::protobuf::internal::NameOfEnum(
    RulesOfEngagement_Value_descriptor(), value);
}
inline bool RulesOfEngagement_Value_Parse(
    const ::std::string& name, RulesOfEngagement_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RulesOfEngagement_Value>(
    RulesOfEngagement_Value_descriptor(), name, value);
}
enum ForceRatio_Value {
  ForceRatio_Value_none_force_ratio = 0,
  ForceRatio_Value_neutre = 1,
  ForceRatio_Value_favorable = 2,
  ForceRatio_Value_defavorable = 3
};
bool ForceRatio_Value_IsValid(int value);
const ForceRatio_Value ForceRatio_Value_Value_MIN = ForceRatio_Value_none_force_ratio;
const ForceRatio_Value ForceRatio_Value_Value_MAX = ForceRatio_Value_defavorable;

const ::google::protobuf::EnumDescriptor* ForceRatio_Value_descriptor();
inline const ::std::string& ForceRatio_Value_Name(ForceRatio_Value value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForceRatio_Value_descriptor(), value);
}
inline bool ForceRatio_Value_Parse(
    const ::std::string& name, ForceRatio_Value* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForceRatio_Value>(
    ForceRatio_Value_descriptor(), name, value);
}
enum MsgUnitAttributes_Posture {
  MsgUnitAttributes_Posture_mouvement = 0,
  MsgUnitAttributes_Posture_mouvement_discret = 1,
  MsgUnitAttributes_Posture_arret = 2,
  MsgUnitAttributes_Posture_poste_reflexe = 3,
  MsgUnitAttributes_Posture_poste = 4,
  MsgUnitAttributes_Posture_poste_amenage = 5,
  MsgUnitAttributes_Posture_poste_prepare_genie = 6
};
bool MsgUnitAttributes_Posture_IsValid(int value);
const MsgUnitAttributes_Posture MsgUnitAttributes_Posture_Posture_MIN = MsgUnitAttributes_Posture_mouvement;
const MsgUnitAttributes_Posture MsgUnitAttributes_Posture_Posture_MAX = MsgUnitAttributes_Posture_poste_prepare_genie;

const ::google::protobuf::EnumDescriptor* MsgUnitAttributes_Posture_descriptor();
inline const ::std::string& MsgUnitAttributes_Posture_Name(MsgUnitAttributes_Posture value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgUnitAttributes_Posture_descriptor(), value);
}
inline bool MsgUnitAttributes_Posture_Parse(
    const ::std::string& name, MsgUnitAttributes_Posture* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgUnitAttributes_Posture>(
    MsgUnitAttributes_Posture_descriptor(), name, value);
}
enum MsgUnitAttributes_FireAvailability {
  MsgUnitAttributes_FireAvailability_none_fire_available = 0,
  MsgUnitAttributes_FireAvailability_pret_au_tir = 1,
  MsgUnitAttributes_FireAvailability_indisponible = 2
};
bool MsgUnitAttributes_FireAvailability_IsValid(int value);
const MsgUnitAttributes_FireAvailability MsgUnitAttributes_FireAvailability_FireAvailability_MIN = MsgUnitAttributes_FireAvailability_none_fire_available;
const MsgUnitAttributes_FireAvailability MsgUnitAttributes_FireAvailability_FireAvailability_MAX = MsgUnitAttributes_FireAvailability_indisponible;

const ::google::protobuf::EnumDescriptor* MsgUnitAttributes_FireAvailability_descriptor();
inline const ::std::string& MsgUnitAttributes_FireAvailability_Name(MsgUnitAttributes_FireAvailability value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgUnitAttributes_FireAvailability_descriptor(), value);
}
inline bool MsgUnitAttributes_FireAvailability_Parse(
    const ::std::string& name, MsgUnitAttributes_FireAvailability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgUnitAttributes_FireAvailability>(
    MsgUnitAttributes_FireAvailability_descriptor(), name, value);
}
enum MsgUnitAttributes_PopulationRoe {
  MsgUnitAttributes_PopulationRoe_none = 0,
  MsgUnitAttributes_PopulationRoe_emploi_force_interdit = 1,
  MsgUnitAttributes_PopulationRoe_maintien_a_distance_par_moyens_non_letaux = 2,
  MsgUnitAttributes_PopulationRoe_dispersion_par_moyens_de_defense_actifs = 3,
  MsgUnitAttributes_PopulationRoe_armes_letales_autorisees = 4
};
bool MsgUnitAttributes_PopulationRoe_IsValid(int value);
const MsgUnitAttributes_PopulationRoe MsgUnitAttributes_PopulationRoe_PopulationRoe_MIN = MsgUnitAttributes_PopulationRoe_none;
const MsgUnitAttributes_PopulationRoe MsgUnitAttributes_PopulationRoe_PopulationRoe_MAX = MsgUnitAttributes_PopulationRoe_armes_letales_autorisees;

const ::google::protobuf::EnumDescriptor* MsgUnitAttributes_PopulationRoe_descriptor();
inline const ::std::string& MsgUnitAttributes_PopulationRoe_Name(MsgUnitAttributes_PopulationRoe value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgUnitAttributes_PopulationRoe_descriptor(), value);
}
inline bool MsgUnitAttributes_PopulationRoe_Parse(
    const ::std::string& name, MsgUnitAttributes_PopulationRoe* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgUnitAttributes_PopulationRoe>(
    MsgUnitAttributes_PopulationRoe_descriptor(), name, value);
}
enum MsgUrbanMagicActionAck_ErrorCode {
  MsgUrbanMagicActionAck_ErrorCode_no_error = 0,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_urban = 1,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_id = 2,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_camp = 3,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_localisation = 4,
  MsgUrbanMagicActionAck_ErrorCode_error_missing_specific_attributes = 5,
  MsgUrbanMagicActionAck_ErrorCode_error_invalid_specific_attributes = 6
};
bool MsgUrbanMagicActionAck_ErrorCode_IsValid(int value);
const MsgUrbanMagicActionAck_ErrorCode MsgUrbanMagicActionAck_ErrorCode_ErrorCode_MIN = MsgUrbanMagicActionAck_ErrorCode_no_error;
const MsgUrbanMagicActionAck_ErrorCode MsgUrbanMagicActionAck_ErrorCode_ErrorCode_MAX = MsgUrbanMagicActionAck_ErrorCode_error_invalid_specific_attributes;

const ::google::protobuf::EnumDescriptor* MsgUrbanMagicActionAck_ErrorCode_descriptor();
inline const ::std::string& MsgUrbanMagicActionAck_ErrorCode_Name(MsgUrbanMagicActionAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgUrbanMagicActionAck_ErrorCode_descriptor(), value);
}
inline bool MsgUrbanMagicActionAck_ErrorCode_Parse(
    const ::std::string& name, MsgUrbanMagicActionAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgUrbanMagicActionAck_ErrorCode>(
    MsgUrbanMagicActionAck_ErrorCode_descriptor(), name, value);
}
enum KnowledgeGroupAck_ErrorCode {
  KnowledgeGroupAck_ErrorCode_no_error = 0,
  KnowledgeGroupAck_ErrorCode_error_invalid_unit = 1,
  KnowledgeGroupAck_ErrorCode_error_invalid_superior = 2,
  KnowledgeGroupAck_ErrorCode_error_invalid_camp = 3,
  KnowledgeGroupAck_ErrorCode_error_invalid_knowledgegroup = 4,
  KnowledgeGroupAck_ErrorCode_error_invalid_type = 5
};
bool KnowledgeGroupAck_ErrorCode_IsValid(int value);
const KnowledgeGroupAck_ErrorCode KnowledgeGroupAck_ErrorCode_ErrorCode_MIN = KnowledgeGroupAck_ErrorCode_no_error;
const KnowledgeGroupAck_ErrorCode KnowledgeGroupAck_ErrorCode_ErrorCode_MAX = KnowledgeGroupAck_ErrorCode_error_invalid_type;

const ::google::protobuf::EnumDescriptor* KnowledgeGroupAck_ErrorCode_descriptor();
inline const ::std::string& KnowledgeGroupAck_ErrorCode_Name(KnowledgeGroupAck_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    KnowledgeGroupAck_ErrorCode_descriptor(), value);
}
inline bool KnowledgeGroupAck_ErrorCode_Parse(
    const ::std::string& name, KnowledgeGroupAck_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KnowledgeGroupAck_ErrorCode>(
    KnowledgeGroupAck_ErrorCode_descriptor(), name, value);
}
enum EnumLogSupplyHandlingStatus {
  convoi_en_attente_camions = 1,
  convoi_constitution = 2,
  convoi_deplacement_vers_point_chargement = 3,
  convoi_chargement = 4,
  convoi_deplacement_vers_point_dechargement = 5,
  convoi_dechargement = 6,
  convoi_deplacement_retour = 7,
  termine = 8
};
bool EnumLogSupplyHandlingStatus_IsValid(int value);
const EnumLogSupplyHandlingStatus EnumLogSupplyHandlingStatus_MIN = convoi_en_attente_camions;
const EnumLogSupplyHandlingStatus EnumLogSupplyHandlingStatus_MAX = termine;

const ::google::protobuf::EnumDescriptor* EnumLogSupplyHandlingStatus_descriptor();
inline const ::std::string& EnumLogSupplyHandlingStatus_Name(EnumLogSupplyHandlingStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumLogSupplyHandlingStatus_descriptor(), value);
}
inline bool EnumLogSupplyHandlingStatus_Parse(
    const ::std::string& name, EnumLogSupplyHandlingStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumLogSupplyHandlingStatus>(
    EnumLogSupplyHandlingStatus_descriptor(), name, value);
}
enum EnumUnitIdentificationLevel {
  identifiee = 0,
  reconnue = 1,
  detectee = 2,
  signale = 3
};
bool EnumUnitIdentificationLevel_IsValid(int value);
const EnumUnitIdentificationLevel EnumUnitIdentificationLevel_MIN = identifiee;
const EnumUnitIdentificationLevel EnumUnitIdentificationLevel_MAX = signale;

const ::google::protobuf::EnumDescriptor* EnumUnitIdentificationLevel_descriptor();
inline const ::std::string& EnumUnitIdentificationLevel_Name(EnumUnitIdentificationLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumUnitIdentificationLevel_descriptor(), value);
}
inline bool EnumUnitIdentificationLevel_Parse(
    const ::std::string& name, EnumUnitIdentificationLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumUnitIdentificationLevel>(
    EnumUnitIdentificationLevel_descriptor(), name, value);
}
enum EnumReportType {
  information = 0,
  operational = 1,
  exceptional_event = 2,
  warning = 3
};
bool EnumReportType_IsValid(int value);
const EnumReportType EnumReportType_MIN = information;
const EnumReportType EnumReportType_MAX = warning;

const ::google::protobuf::EnumDescriptor* EnumReportType_descriptor();
inline const ::std::string& EnumReportType_Name(EnumReportType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumReportType_descriptor(), value);
}
inline bool EnumReportType_Parse(
    const ::std::string& name, EnumReportType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumReportType>(
    EnumReportType_descriptor(), name, value);
}
// ===================================================================

class OrderAck : public ::google::protobuf::Message {
 public:
  OrderAck();
  virtual ~OrderAck();
  
  OrderAck(const OrderAck& from);
  
  inline OrderAck& operator=(const OrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderAck& default_instance();
  void Swap(OrderAck* other);
  
  // implements Message ----------------------------------------------
  
  OrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderAck& from);
  void MergeFrom(const OrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OrderAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = OrderAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = OrderAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_invalid_limit = OrderAck_ErrorCode_error_invalid_limit;
  static const ErrorCode error_invalid_lima = OrderAck_ErrorCode_error_invalid_lima;
  static const ErrorCode error_invalid_mission = OrderAck_ErrorCode_error_invalid_mission;
  static const ErrorCode error_invalid_mission_parameters = OrderAck_ErrorCode_error_invalid_mission_parameters;
  static const ErrorCode error_unit_cannot_receive_order = OrderAck_ErrorCode_error_unit_cannot_receive_order;
  static const ErrorCode error_invalid_order_conduite = OrderAck_ErrorCode_error_invalid_order_conduite;
  static const ErrorCode error_invalid_order_mission = OrderAck_ErrorCode_error_invalid_order_mission;
  static const ErrorCode error_invalid_order_initial = OrderAck_ErrorCode_error_invalid_order_initial;
  static const ErrorCode error_invalid_order_conduite_parameters = OrderAck_ErrorCode_error_invalid_order_conduite_parameters;
  static const ErrorCode error_unit_surrendered = OrderAck_ErrorCode_error_unit_surrendered;
  static const ErrorCode error_invalid_lima_function = OrderAck_ErrorCode_error_invalid_lima_function;
  static inline bool ErrorCode_IsValid(int value) {
    return OrderAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    OrderAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    OrderAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return OrderAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return OrderAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return OrderAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitOrderAck : public ::google::protobuf::Message {
 public:
  MsgUnitOrderAck();
  virtual ~MsgUnitOrderAck();
  
  MsgUnitOrderAck(const MsgUnitOrderAck& from);
  
  inline MsgUnitOrderAck& operator=(const MsgUnitOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitOrderAck& default_instance();
  void Swap(MsgUnitOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitOrderAck& from);
  void MergeFrom(const MsgUnitOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId tasker = 1;
  inline bool has_tasker() const;
  inline void clear_tasker();
  static const int kTaskerFieldNumber = 1;
  inline const ::Common::UnitId& tasker() const;
  inline ::Common::UnitId* mutable_tasker();
  
  // required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::OrderAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* tasker_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatOrderAck : public ::google::protobuf::Message {
 public:
  MsgAutomatOrderAck();
  virtual ~MsgAutomatOrderAck();
  
  MsgAutomatOrderAck(const MsgAutomatOrderAck& from);
  
  inline MsgAutomatOrderAck& operator=(const MsgAutomatOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatOrderAck& default_instance();
  void Swap(MsgAutomatOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatOrderAck& from);
  void MergeFrom(const MsgAutomatOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId tasker = 1;
  inline bool has_tasker() const;
  inline void clear_tasker();
  static const int kTaskerFieldNumber = 1;
  inline const ::Common::AutomatId& tasker() const;
  inline ::Common::AutomatId* mutable_tasker();
  
  // required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::OrderAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* tasker_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationOrderAck : public ::google::protobuf::Message {
 public:
  MsgPopulationOrderAck();
  virtual ~MsgPopulationOrderAck();
  
  MsgPopulationOrderAck(const MsgPopulationOrderAck& from);
  
  inline MsgPopulationOrderAck& operator=(const MsgPopulationOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationOrderAck& default_instance();
  void Swap(MsgPopulationOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationOrderAck& from);
  void MergeFrom(const MsgPopulationOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationId tasker = 1;
  inline bool has_tasker() const;
  inline void clear_tasker();
  static const int kTaskerFieldNumber = 1;
  inline const ::Common::PopulationId& tasker() const;
  inline ::Common::PopulationId* mutable_tasker();
  
  // required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::OrderAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationId* tasker_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgFragOrderAck : public ::google::protobuf::Message {
 public:
  MsgFragOrderAck();
  virtual ~MsgFragOrderAck();
  
  MsgFragOrderAck(const MsgFragOrderAck& from);
  
  inline MsgFragOrderAck& operator=(const MsgFragOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFragOrderAck& default_instance();
  void Swap(MsgFragOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgFragOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFragOrderAck& from);
  void MergeFrom(const MsgFragOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.Tasker tasker = 1;
  inline bool has_tasker() const;
  inline void clear_tasker();
  static const int kTaskerFieldNumber = 1;
  inline const ::Common::Tasker& tasker() const;
  inline ::Common::Tasker* mutable_tasker();
  
  // required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::OrderAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::Tasker* tasker_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFragOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgSetAutomatModeAck : public ::google::protobuf::Message {
 public:
  MsgSetAutomatModeAck();
  virtual ~MsgSetAutomatModeAck();
  
  MsgSetAutomatModeAck(const MsgSetAutomatModeAck& from);
  
  inline MsgSetAutomatModeAck& operator=(const MsgSetAutomatModeAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgSetAutomatModeAck& default_instance();
  void Swap(MsgSetAutomatModeAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgSetAutomatModeAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgSetAutomatModeAck& from);
  void MergeFrom(const MsgSetAutomatModeAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgSetAutomatModeAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgSetAutomatModeAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = MsgSetAutomatModeAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_not_allowed = MsgSetAutomatModeAck_ErrorCode_error_not_allowed;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgSetAutomatModeAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgSetAutomatModeAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgSetAutomatModeAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgSetAutomatModeAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgSetAutomatModeAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgSetAutomatModeAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::AutomatId& id() const;
  inline ::Common::AutomatId* mutable_id();
  
  // required .MsgsSimToClient.MsgSetAutomatModeAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* id_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgSetAutomatModeAck* default_instance_;
};
// -------------------------------------------------------------------

class UnitActionAck : public ::google::protobuf::Message {
 public:
  UnitActionAck();
  virtual ~UnitActionAck();
  
  UnitActionAck(const UnitActionAck& from);
  
  inline UnitActionAck& operator=(const UnitActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitActionAck& default_instance();
  void Swap(UnitActionAck* other);
  
  // implements Message ----------------------------------------------
  
  UnitActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitActionAck& from);
  void MergeFrom(const UnitActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef UnitActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = UnitActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = UnitActionAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_automate_embraye = UnitActionAck_ErrorCode_error_automate_embraye;
  static const ErrorCode error_invalid_attribute = UnitActionAck_ErrorCode_error_invalid_attribute;
  static const ErrorCode error_unit_surrendered = UnitActionAck_ErrorCode_error_unit_surrendered;
  static inline bool ErrorCode_IsValid(int value) {
    return UnitActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    UnitActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    UnitActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return UnitActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return UnitActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return UnitActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UnitActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitCreationRequestAck : public ::google::protobuf::Message {
 public:
  MsgUnitCreationRequestAck();
  virtual ~MsgUnitCreationRequestAck();
  
  MsgUnitCreationRequestAck(const MsgUnitCreationRequestAck& from);
  
  inline MsgUnitCreationRequestAck& operator=(const MsgUnitCreationRequestAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitCreationRequestAck& default_instance();
  void Swap(MsgUnitCreationRequestAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitCreationRequestAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitCreationRequestAck& from);
  void MergeFrom(const MsgUnitCreationRequestAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.UnitActionAck.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::MsgsSimToClient::UnitActionAck_ErrorCode error() const;
  inline void set_error(::MsgsSimToClient::UnitActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitCreationRequestAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgMagicActionAck();
  virtual ~MsgMagicActionAck();
  
  MsgMagicActionAck(const MsgMagicActionAck& from);
  
  inline MsgMagicActionAck& operator=(const MsgMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgMagicActionAck& default_instance();
  void Swap(MsgMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgMagicActionAck& from);
  void MergeFrom(const MsgMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgMagicActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgMagicActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_attribute = MsgMagicActionAck_ErrorCode_error_invalid_attribute;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgMagicActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgMagicActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgMagicActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgMagicActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgMagicActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgMagicActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgMagicActionAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::MsgMagicActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgMagicActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgUnitMagicActionAck();
  virtual ~MsgUnitMagicActionAck();
  
  MsgUnitMagicActionAck(const MsgUnitMagicActionAck& from);
  
  inline MsgUnitMagicActionAck& operator=(const MsgUnitMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitMagicActionAck& default_instance();
  void Swap(MsgUnitMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitMagicActionAck& from);
  void MergeFrom(const MsgUnitMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // required .MsgsSimToClient.UnitActionAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::UnitActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::UnitActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgObjectMagicActionAck();
  virtual ~MsgObjectMagicActionAck();
  
  MsgObjectMagicActionAck(const MsgObjectMagicActionAck& from);
  
  inline MsgObjectMagicActionAck& operator=(const MsgObjectMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectMagicActionAck& default_instance();
  void Swap(MsgObjectMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectMagicActionAck& from);
  void MergeFrom(const MsgObjectMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgObjectMagicActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgObjectMagicActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_object = MsgObjectMagicActionAck_ErrorCode_error_invalid_object;
  static const ErrorCode error_invalid_id = MsgObjectMagicActionAck_ErrorCode_error_invalid_id;
  static const ErrorCode error_invalid_camp = MsgObjectMagicActionAck_ErrorCode_error_invalid_camp;
  static const ErrorCode error_invalid_localisation = MsgObjectMagicActionAck_ErrorCode_error_invalid_localisation;
  static const ErrorCode error_missing_specific_attributes = MsgObjectMagicActionAck_ErrorCode_error_missing_specific_attributes;
  static const ErrorCode error_invalid_specific_attributes = MsgObjectMagicActionAck_ErrorCode_error_invalid_specific_attributes;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgObjectMagicActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgObjectMagicActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgObjectMagicActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgObjectMagicActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgObjectMagicActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgObjectMagicActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgObjectMagicActionAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgPopulationMagicActionAck();
  virtual ~MsgPopulationMagicActionAck();
  
  MsgPopulationMagicActionAck(const MsgPopulationMagicActionAck& from);
  
  inline MsgPopulationMagicActionAck& operator=(const MsgPopulationMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationMagicActionAck& default_instance();
  void Swap(MsgPopulationMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationMagicActionAck& from);
  void MergeFrom(const MsgPopulationMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgPopulationMagicActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgPopulationMagicActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = MsgPopulationMagicActionAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_invalid_attribute = MsgPopulationMagicActionAck_ErrorCode_error_invalid_attribute;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgPopulationMagicActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgPopulationMagicActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgPopulationMagicActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgPopulationMagicActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgPopulationMagicActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgPopulationMagicActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationId& id() const;
  inline ::Common::PopulationId* mutable_id();
  
  // required .MsgsSimToClient.MsgPopulationMagicActionAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::MsgPopulationMagicActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgPopulationMagicActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationId* id_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgChangeDiplomacyAck : public ::google::protobuf::Message {
 public:
  MsgChangeDiplomacyAck();
  virtual ~MsgChangeDiplomacyAck();
  
  MsgChangeDiplomacyAck(const MsgChangeDiplomacyAck& from);
  
  inline MsgChangeDiplomacyAck& operator=(const MsgChangeDiplomacyAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChangeDiplomacyAck& default_instance();
  void Swap(MsgChangeDiplomacyAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgChangeDiplomacyAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChangeDiplomacyAck& from);
  void MergeFrom(const MsgChangeDiplomacyAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode EnumChangeDiplomacyErrorCode;
  static const EnumChangeDiplomacyErrorCode no_error_diplomacy = MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_no_error_diplomacy;
  static const EnumChangeDiplomacyErrorCode error_invalid_camp_diplomacy = MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_error_invalid_camp_diplomacy;
  static inline bool EnumChangeDiplomacyErrorCode_IsValid(int value) {
    return MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_IsValid(value);
  }
  static const EnumChangeDiplomacyErrorCode EnumChangeDiplomacyErrorCode_MIN =
    MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_EnumChangeDiplomacyErrorCode_MIN;
  static const EnumChangeDiplomacyErrorCode EnumChangeDiplomacyErrorCode_MAX =
    MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_EnumChangeDiplomacyErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  EnumChangeDiplomacyErrorCode_descriptor() {
    return MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor();
  }
  static inline const ::std::string& EnumChangeDiplomacyErrorCode_Name(EnumChangeDiplomacyErrorCode value) {
    return MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_Name(value);
  }
  static inline bool EnumChangeDiplomacyErrorCode_Parse(const ::std::string& name,
      EnumChangeDiplomacyErrorCode* value) {
    return MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Common.PartyId party1 = 1;
  inline bool has_party1() const;
  inline void clear_party1();
  static const int kParty1FieldNumber = 1;
  inline const ::Common::PartyId& party1() const;
  inline ::Common::PartyId* mutable_party1();
  
  // required .Common.PartyId party2 = 2;
  inline bool has_party2() const;
  inline void clear_party2();
  static const int kParty2FieldNumber = 2;
  inline const ::Common::PartyId& party2() const;
  inline ::Common::PartyId* mutable_party2();
  
  // required .Common.EnumDiplomacy diplomatie = 3;
  inline bool has_diplomatie() const;
  inline void clear_diplomatie();
  static const int kDiplomatieFieldNumber = 3;
  inline Common::EnumDiplomacy diplomatie() const;
  inline void set_diplomatie(Common::EnumDiplomacy value);
  
  // required .MsgsSimToClient.MsgChangeDiplomacyAck.EnumChangeDiplomacyErrorCode error_code = 4;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 4;
  inline ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PartyId* party1_;
  ::Common::PartyId* party2_;
  int diplomatie_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgChangeDiplomacyAck* default_instance_;
};
// -------------------------------------------------------------------

class HierarchyModificationAck : public ::google::protobuf::Message {
 public:
  HierarchyModificationAck();
  virtual ~HierarchyModificationAck();
  
  HierarchyModificationAck(const HierarchyModificationAck& from);
  
  inline HierarchyModificationAck& operator=(const HierarchyModificationAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HierarchyModificationAck& default_instance();
  void Swap(HierarchyModificationAck* other);
  
  // implements Message ----------------------------------------------
  
  HierarchyModificationAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HierarchyModificationAck& from);
  void MergeFrom(const HierarchyModificationAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef HierarchyModificationAck_ErrorCode ErrorCode;
  static const ErrorCode no_error_hierarchy = HierarchyModificationAck_ErrorCode_no_error_hierarchy;
  static const ErrorCode error_invalid_pion = HierarchyModificationAck_ErrorCode_error_invalid_pion;
  static const ErrorCode error_invalid_automate = HierarchyModificationAck_ErrorCode_error_invalid_automate;
  static const ErrorCode error_invalid_formation = HierarchyModificationAck_ErrorCode_error_invalid_formation;
  static const ErrorCode error_invalid_automate_tc2 = HierarchyModificationAck_ErrorCode_error_invalid_automate_tc2;
  static const ErrorCode error_invalid_automate_maintenance = HierarchyModificationAck_ErrorCode_error_invalid_automate_maintenance;
  static const ErrorCode error_invalid_automate_sante = HierarchyModificationAck_ErrorCode_error_invalid_automate_sante;
  static const ErrorCode error_invalid_automate_supply = HierarchyModificationAck_ErrorCode_error_invalid_automate_supply;
  static const ErrorCode error_unit_surrendered_hierarchy = HierarchyModificationAck_ErrorCode_error_unit_surrendered_hierarchy;
  static const ErrorCode error_invalid_team_hierarchy = HierarchyModificationAck_ErrorCode_error_invalid_team_hierarchy;
  static const ErrorCode error_invalid_knowledge_group = HierarchyModificationAck_ErrorCode_error_invalid_knowledge_group;
  static const ErrorCode error_teams_mismatched = HierarchyModificationAck_ErrorCode_error_teams_mismatched;
  static inline bool ErrorCode_IsValid(int value) {
    return HierarchyModificationAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    HierarchyModificationAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    HierarchyModificationAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return HierarchyModificationAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return HierarchyModificationAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return HierarchyModificationAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HierarchyModificationAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatChangeKnowledgeGroupAck : public ::google::protobuf::Message {
 public:
  MsgAutomatChangeKnowledgeGroupAck();
  virtual ~MsgAutomatChangeKnowledgeGroupAck();
  
  MsgAutomatChangeKnowledgeGroupAck(const MsgAutomatChangeKnowledgeGroupAck& from);
  
  inline MsgAutomatChangeKnowledgeGroupAck& operator=(const MsgAutomatChangeKnowledgeGroupAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatChangeKnowledgeGroupAck& default_instance();
  void Swap(MsgAutomatChangeKnowledgeGroupAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatChangeKnowledgeGroupAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatChangeKnowledgeGroupAck& from);
  void MergeFrom(const MsgAutomatChangeKnowledgeGroupAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatChangeKnowledgeGroupAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatChangeLogisticLinksAck : public ::google::protobuf::Message {
 public:
  MsgAutomatChangeLogisticLinksAck();
  virtual ~MsgAutomatChangeLogisticLinksAck();
  
  MsgAutomatChangeLogisticLinksAck(const MsgAutomatChangeLogisticLinksAck& from);
  
  inline MsgAutomatChangeLogisticLinksAck& operator=(const MsgAutomatChangeLogisticLinksAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatChangeLogisticLinksAck& default_instance();
  void Swap(MsgAutomatChangeLogisticLinksAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatChangeLogisticLinksAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatChangeLogisticLinksAck& from);
  void MergeFrom(const MsgAutomatChangeLogisticLinksAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatChangeLogisticLinksAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatChangeSuperiorAck : public ::google::protobuf::Message {
 public:
  MsgAutomatChangeSuperiorAck();
  virtual ~MsgAutomatChangeSuperiorAck();
  
  MsgAutomatChangeSuperiorAck(const MsgAutomatChangeSuperiorAck& from);
  
  inline MsgAutomatChangeSuperiorAck& operator=(const MsgAutomatChangeSuperiorAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatChangeSuperiorAck& default_instance();
  void Swap(MsgAutomatChangeSuperiorAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatChangeSuperiorAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatChangeSuperiorAck& from);
  void MergeFrom(const MsgAutomatChangeSuperiorAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatChangeSuperiorAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitChangeSuperiorAck : public ::google::protobuf::Message {
 public:
  MsgUnitChangeSuperiorAck();
  virtual ~MsgUnitChangeSuperiorAck();
  
  MsgUnitChangeSuperiorAck(const MsgUnitChangeSuperiorAck& from);
  
  inline MsgUnitChangeSuperiorAck& operator=(const MsgUnitChangeSuperiorAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitChangeSuperiorAck& default_instance();
  void Swap(MsgUnitChangeSuperiorAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitChangeSuperiorAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitChangeSuperiorAck& from);
  void MergeFrom(const MsgUnitChangeSuperiorAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitChangeSuperiorAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyPushFlowAck : public ::google::protobuf::Message {
 public:
  MsgLogSupplyPushFlowAck();
  virtual ~MsgLogSupplyPushFlowAck();
  
  MsgLogSupplyPushFlowAck(const MsgLogSupplyPushFlowAck& from);
  
  inline MsgLogSupplyPushFlowAck& operator=(const MsgLogSupplyPushFlowAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyPushFlowAck& default_instance();
  void Swap(MsgLogSupplyPushFlowAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyPushFlowAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyPushFlowAck& from);
  void MergeFrom(const MsgLogSupplyPushFlowAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow EnumLogSupplyPushFlow;
  static const EnumLogSupplyPushFlow no_error_pushflow = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_no_error_pushflow;
  static const EnumLogSupplyPushFlow error_invalid_donneur_pushflow = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_donneur_pushflow;
  static const EnumLogSupplyPushFlow error_invalid_receveur_pushflow = MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_error_invalid_receveur_pushflow;
  static inline bool EnumLogSupplyPushFlow_IsValid(int value) {
    return MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_IsValid(value);
  }
  static const EnumLogSupplyPushFlow EnumLogSupplyPushFlow_MIN =
    MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_EnumLogSupplyPushFlow_MIN;
  static const EnumLogSupplyPushFlow EnumLogSupplyPushFlow_MAX =
    MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_EnumLogSupplyPushFlow_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  EnumLogSupplyPushFlow_descriptor() {
    return MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor();
  }
  static inline const ::std::string& EnumLogSupplyPushFlow_Name(EnumLogSupplyPushFlow value) {
    return MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_Name(value);
  }
  static inline bool EnumLogSupplyPushFlow_Parse(const ::std::string& name,
      EnumLogSupplyPushFlow* value) {
    return MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MsgLogSupplyPushFlowAck.EnumLogSupplyPushFlow ack = 1;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 1;
  inline ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow ack() const;
  inline void set_ack(::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int ack_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyPushFlowAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyChangeQuotasAck : public ::google::protobuf::Message {
 public:
  MsgLogSupplyChangeQuotasAck();
  virtual ~MsgLogSupplyChangeQuotasAck();
  
  MsgLogSupplyChangeQuotasAck(const MsgLogSupplyChangeQuotasAck& from);
  
  inline MsgLogSupplyChangeQuotasAck& operator=(const MsgLogSupplyChangeQuotasAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyChangeQuotasAck& default_instance();
  void Swap(MsgLogSupplyChangeQuotasAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyChangeQuotasAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyChangeQuotasAck& from);
  void MergeFrom(const MsgLogSupplyChangeQuotasAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas LogSupplyChangeQuotas;
  static const LogSupplyChangeQuotas no_error_quotas = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_no_error_quotas;
  static const LogSupplyChangeQuotas error_invalid_donneur_quotas = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_donneur_quotas;
  static const LogSupplyChangeQuotas error_invalid_receveur_quotas = MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_error_invalid_receveur_quotas;
  static inline bool LogSupplyChangeQuotas_IsValid(int value) {
    return MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_IsValid(value);
  }
  static const LogSupplyChangeQuotas LogSupplyChangeQuotas_MIN =
    MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_LogSupplyChangeQuotas_MIN;
  static const LogSupplyChangeQuotas LogSupplyChangeQuotas_MAX =
    MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_LogSupplyChangeQuotas_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  LogSupplyChangeQuotas_descriptor() {
    return MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor();
  }
  static inline const ::std::string& LogSupplyChangeQuotas_Name(LogSupplyChangeQuotas value) {
    return MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_Name(value);
  }
  static inline bool LogSupplyChangeQuotas_Parse(const ::std::string& name,
      LogSupplyChangeQuotas* value) {
    return MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MsgLogSupplyChangeQuotasAck.LogSupplyChangeQuotas ack = 1;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 1;
  inline ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas ack() const;
  inline void set_ack(::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int ack_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyChangeQuotasAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgActionCreateFireOrderAck : public ::google::protobuf::Message {
 public:
  MsgActionCreateFireOrderAck();
  virtual ~MsgActionCreateFireOrderAck();
  
  MsgActionCreateFireOrderAck(const MsgActionCreateFireOrderAck& from);
  
  inline MsgActionCreateFireOrderAck& operator=(const MsgActionCreateFireOrderAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgActionCreateFireOrderAck& default_instance();
  void Swap(MsgActionCreateFireOrderAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgActionCreateFireOrderAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgActionCreateFireOrderAck& from);
  void MergeFrom(const MsgActionCreateFireOrderAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode EnumActionCreateFireOrderErrorCode;
  static const EnumActionCreateFireOrderErrorCode no_error = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_no_error;
  static const EnumActionCreateFireOrderErrorCode error_invalid_reporter = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_reporter;
  static const EnumActionCreateFireOrderErrorCode error_invalid_target = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_target;
  static const EnumActionCreateFireOrderErrorCode error_invalid_munition = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_invalid_munition;
  static const EnumActionCreateFireOrderErrorCode error_target_no_illuminated = MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_error_target_no_illuminated;
  static inline bool EnumActionCreateFireOrderErrorCode_IsValid(int value) {
    return MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_IsValid(value);
  }
  static const EnumActionCreateFireOrderErrorCode EnumActionCreateFireOrderErrorCode_MIN =
    MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_EnumActionCreateFireOrderErrorCode_MIN;
  static const EnumActionCreateFireOrderErrorCode EnumActionCreateFireOrderErrorCode_MAX =
    MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_EnumActionCreateFireOrderErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  EnumActionCreateFireOrderErrorCode_descriptor() {
    return MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor();
  }
  static inline const ::std::string& EnumActionCreateFireOrderErrorCode_Name(EnumActionCreateFireOrderErrorCode value) {
    return MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_Name(value);
  }
  static inline bool EnumActionCreateFireOrderErrorCode_Parse(const ::std::string& name,
      EnumActionCreateFireOrderErrorCode* value) {
    return MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgActionCreateFireOrderAck.EnumActionCreateFireOrderErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgActionCreateFireOrderAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlInformation : public ::google::protobuf::Message {
 public:
  MsgControlInformation();
  virtual ~MsgControlInformation();
  
  MsgControlInformation(const MsgControlInformation& from);
  
  inline MsgControlInformation& operator=(const MsgControlInformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlInformation& default_instance();
  void Swap(MsgControlInformation* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlInformation& from);
  void MergeFrom(const MsgControlInformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 current_tick = 1;
  inline bool has_current_tick() const;
  inline void clear_current_tick();
  static const int kCurrentTickFieldNumber = 1;
  inline ::google::protobuf::int32 current_tick() const;
  inline void set_current_tick(::google::protobuf::int32 value);
  
  // required .Common.MsgDateTime initial_date_time = 2;
  inline bool has_initial_date_time() const;
  inline void clear_initial_date_time();
  static const int kInitialDateTimeFieldNumber = 2;
  inline const ::Common::MsgDateTime& initial_date_time() const;
  inline ::Common::MsgDateTime* mutable_initial_date_time();
  
  // required .Common.MsgDateTime date_time = 3;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 3;
  inline const ::Common::MsgDateTime& date_time() const;
  inline ::Common::MsgDateTime* mutable_date_time();
  
  // required int32 tick_duration = 4;
  inline bool has_tick_duration() const;
  inline void clear_tick_duration();
  static const int kTickDurationFieldNumber = 4;
  inline ::google::protobuf::int32 tick_duration() const;
  inline void set_tick_duration(::google::protobuf::int32 value);
  
  // required int32 time_factor = 5;
  inline bool has_time_factor() const;
  inline void clear_time_factor();
  static const int kTimeFactorFieldNumber = 5;
  inline ::google::protobuf::int32 time_factor() const;
  inline void set_time_factor(::google::protobuf::int32 value);
  
  // required int32 checkpoint_frequency = 6;
  inline bool has_checkpoint_frequency() const;
  inline void clear_checkpoint_frequency();
  static const int kCheckpointFrequencyFieldNumber = 6;
  inline ::google::protobuf::int32 checkpoint_frequency() const;
  inline void set_checkpoint_frequency(::google::protobuf::int32 value);
  
  // required .Common.EnumSimulationState status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline Common::EnumSimulationState status() const;
  inline void set_status(Common::EnumSimulationState value);
  
  // required bool send_vision_cones = 8;
  inline bool has_send_vision_cones() const;
  inline void clear_send_vision_cones();
  static const int kSendVisionConesFieldNumber = 8;
  inline bool send_vision_cones() const;
  inline void set_send_vision_cones(bool value);
  
  // required bool profiling_enabled = 9;
  inline bool has_profiling_enabled() const;
  inline void clear_profiling_enabled();
  static const int kProfilingEnabledFieldNumber = 9;
  inline bool profiling_enabled() const;
  inline void set_profiling_enabled(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 current_tick_;
  ::Common::MsgDateTime* initial_date_time_;
  ::Common::MsgDateTime* date_time_;
  ::google::protobuf::int32 tick_duration_;
  ::google::protobuf::int32 time_factor_;
  ::google::protobuf::int32 checkpoint_frequency_;
  int status_;
  bool send_vision_cones_;
  bool profiling_enabled_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlInformation* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlProfilingInformation : public ::google::protobuf::Message {
 public:
  MsgControlProfilingInformation();
  virtual ~MsgControlProfilingInformation();
  
  MsgControlProfilingInformation(const MsgControlProfilingInformation& from);
  
  inline MsgControlProfilingInformation& operator=(const MsgControlProfilingInformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlProfilingInformation& default_instance();
  void Swap(MsgControlProfilingInformation* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlProfilingInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlProfilingInformation& from);
  void MergeFrom(const MsgControlProfilingInformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float perception = 1;
  inline bool has_perception() const;
  inline void clear_perception();
  static const int kPerceptionFieldNumber = 1;
  inline float perception() const;
  inline void set_perception(float value);
  
  // required float decision = 2;
  inline bool has_decision() const;
  inline void clear_decision();
  static const int kDecisionFieldNumber = 2;
  inline float decision() const;
  inline void set_decision(float value);
  
  // required float action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline float action() const;
  inline void set_action(float value);
  
  // required float main_loop = 4;
  inline bool has_main_loop() const;
  inline void clear_main_loop();
  static const int kMainLoopFieldNumber = 4;
  inline float main_loop() const;
  inline void set_main_loop(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float perception_;
  float decision_;
  float action_;
  float main_loop_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlProfilingInformation* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlBeginTick : public ::google::protobuf::Message {
 public:
  MsgControlBeginTick();
  virtual ~MsgControlBeginTick();
  
  MsgControlBeginTick(const MsgControlBeginTick& from);
  
  inline MsgControlBeginTick& operator=(const MsgControlBeginTick& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlBeginTick& default_instance();
  void Swap(MsgControlBeginTick* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlBeginTick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlBeginTick& from);
  void MergeFrom(const MsgControlBeginTick& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 current_tick = 1;
  inline bool has_current_tick() const;
  inline void clear_current_tick();
  static const int kCurrentTickFieldNumber = 1;
  inline ::google::protobuf::int32 current_tick() const;
  inline void set_current_tick(::google::protobuf::int32 value);
  
  // required .Common.MsgDateTime date_time = 2;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 2;
  inline const ::Common::MsgDateTime& date_time() const;
  inline ::Common::MsgDateTime* mutable_date_time();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 current_tick_;
  ::Common::MsgDateTime* date_time_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlBeginTick* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlEndTick : public ::google::protobuf::Message {
 public:
  MsgControlEndTick();
  virtual ~MsgControlEndTick();
  
  MsgControlEndTick(const MsgControlEndTick& from);
  
  inline MsgControlEndTick& operator=(const MsgControlEndTick& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlEndTick& default_instance();
  void Swap(MsgControlEndTick* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlEndTick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlEndTick& from);
  void MergeFrom(const MsgControlEndTick& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 current_tick = 1;
  inline bool has_current_tick() const;
  inline void clear_current_tick();
  static const int kCurrentTickFieldNumber = 1;
  inline ::google::protobuf::int32 current_tick() const;
  inline void set_current_tick(::google::protobuf::int32 value);
  
  // required int32 tick_duration = 2;
  inline bool has_tick_duration() const;
  inline void clear_tick_duration();
  static const int kTickDurationFieldNumber = 2;
  inline ::google::protobuf::int32 tick_duration() const;
  inline void set_tick_duration(::google::protobuf::int32 value);
  
  // required int32 long_pathfinds = 3;
  inline bool has_long_pathfinds() const;
  inline void clear_long_pathfinds();
  static const int kLongPathfindsFieldNumber = 3;
  inline ::google::protobuf::int32 long_pathfinds() const;
  inline void set_long_pathfinds(::google::protobuf::int32 value);
  
  // required int32 short_pathfinds = 4;
  inline bool has_short_pathfinds() const;
  inline void clear_short_pathfinds();
  static const int kShortPathfindsFieldNumber = 4;
  inline ::google::protobuf::int32 short_pathfinds() const;
  inline void set_short_pathfinds(::google::protobuf::int32 value);
  
  // required int32 memory = 5;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 5;
  inline ::google::protobuf::int32 memory() const;
  inline void set_memory(::google::protobuf::int32 value);
  
  // required int32 virtual_memory = 6;
  inline bool has_virtual_memory() const;
  inline void clear_virtual_memory();
  static const int kVirtualMemoryFieldNumber = 6;
  inline ::google::protobuf::int32 virtual_memory() const;
  inline void set_virtual_memory(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 current_tick_;
  ::google::protobuf::int32 tick_duration_;
  ::google::protobuf::int32 long_pathfinds_;
  ::google::protobuf::int32 short_pathfinds_;
  ::google::protobuf::int32 memory_;
  ::google::protobuf::int32 virtual_memory_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlEndTick* default_instance_;
};
// -------------------------------------------------------------------

class ControlAck : public ::google::protobuf::Message {
 public:
  ControlAck();
  virtual ~ControlAck();
  
  ControlAck(const ControlAck& from);
  
  inline ControlAck& operator=(const ControlAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlAck& default_instance();
  void Swap(ControlAck* other);
  
  // implements Message ----------------------------------------------
  
  ControlAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlAck& from);
  void MergeFrom(const ControlAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ControlAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = ControlAck_ErrorCode_no_error;
  static const ErrorCode error_already_started = ControlAck_ErrorCode_error_already_started;
  static const ErrorCode error_not_started = ControlAck_ErrorCode_error_not_started;
  static const ErrorCode error_not_paused = ControlAck_ErrorCode_error_not_paused;
  static const ErrorCode error_already_paused = ControlAck_ErrorCode_error_already_paused;
  static const ErrorCode error_invalid_time_factor = ControlAck_ErrorCode_error_invalid_time_factor;
  static const ErrorCode error_invalid_date_time = ControlAck_ErrorCode_error_invalid_date_time;
  static inline bool ErrorCode_IsValid(int value) {
    return ControlAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    ControlAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    ControlAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return ControlAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return ControlAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return ControlAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ControlAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlDatetimeChangeAck : public ::google::protobuf::Message {
 public:
  MsgControlDatetimeChangeAck();
  virtual ~MsgControlDatetimeChangeAck();
  
  MsgControlDatetimeChangeAck(const MsgControlDatetimeChangeAck& from);
  
  inline MsgControlDatetimeChangeAck& operator=(const MsgControlDatetimeChangeAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlDatetimeChangeAck& default_instance();
  void Swap(MsgControlDatetimeChangeAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlDatetimeChangeAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlDatetimeChangeAck& from);
  void MergeFrom(const MsgControlDatetimeChangeAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlDatetimeChangeAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlChangeTimeFactorAck : public ::google::protobuf::Message {
 public:
  MsgControlChangeTimeFactorAck();
  virtual ~MsgControlChangeTimeFactorAck();
  
  MsgControlChangeTimeFactorAck(const MsgControlChangeTimeFactorAck& from);
  
  inline MsgControlChangeTimeFactorAck& operator=(const MsgControlChangeTimeFactorAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlChangeTimeFactorAck& default_instance();
  void Swap(MsgControlChangeTimeFactorAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlChangeTimeFactorAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlChangeTimeFactorAck& from);
  void MergeFrom(const MsgControlChangeTimeFactorAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 time_factor = 1;
  inline bool has_time_factor() const;
  inline void clear_time_factor();
  static const int kTimeFactorFieldNumber = 1;
  inline ::google::protobuf::int32 time_factor() const;
  inline void set_time_factor(::google::protobuf::int32 value);
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 time_factor_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlChangeTimeFactorAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlStopAck : public ::google::protobuf::Message {
 public:
  MsgControlStopAck();
  virtual ~MsgControlStopAck();
  
  MsgControlStopAck(const MsgControlStopAck& from);
  
  inline MsgControlStopAck& operator=(const MsgControlStopAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlStopAck& default_instance();
  void Swap(MsgControlStopAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlStopAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlStopAck& from);
  void MergeFrom(const MsgControlStopAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlStopAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlPauseAck : public ::google::protobuf::Message {
 public:
  MsgControlPauseAck();
  virtual ~MsgControlPauseAck();
  
  MsgControlPauseAck(const MsgControlPauseAck& from);
  
  inline MsgControlPauseAck& operator=(const MsgControlPauseAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlPauseAck& default_instance();
  void Swap(MsgControlPauseAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlPauseAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlPauseAck& from);
  void MergeFrom(const MsgControlPauseAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlPauseAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlResumeAck : public ::google::protobuf::Message {
 public:
  MsgControlResumeAck();
  virtual ~MsgControlResumeAck();
  
  MsgControlResumeAck(const MsgControlResumeAck& from);
  
  inline MsgControlResumeAck& operator=(const MsgControlResumeAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlResumeAck& default_instance();
  void Swap(MsgControlResumeAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlResumeAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlResumeAck& from);
  void MergeFrom(const MsgControlResumeAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::ControlAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlResumeAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgTeamCreation : public ::google::protobuf::Message {
 public:
  MsgTeamCreation();
  virtual ~MsgTeamCreation();
  
  MsgTeamCreation(const MsgTeamCreation& from);
  
  inline MsgTeamCreation& operator=(const MsgTeamCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTeamCreation& default_instance();
  void Swap(MsgTeamCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgTeamCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgTeamCreation& from);
  void MergeFrom(const MsgTeamCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PartyId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PartyId& id() const;
  inline ::Common::PartyId* mutable_id();
  
  // required string nom = 2;
  inline bool has_nom() const;
  inline void clear_nom();
  static const int kNomFieldNumber = 2;
  inline const ::std::string& nom() const;
  inline void set_nom(const ::std::string& value);
  inline void set_nom(const char* value);
  inline void set_nom(const char* value, size_t size);
  inline ::std::string* mutable_nom();
  
  // required .Common.EnumDiplomacy type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline Common::EnumDiplomacy type() const;
  inline void set_type(Common::EnumDiplomacy value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PartyId* id_;
  ::std::string* nom_;
  static const ::std::string _default_nom_;
  int type_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgTeamCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatCreation_oid_parent : public ::google::protobuf::Message {
 public:
  MsgAutomatCreation_oid_parent();
  virtual ~MsgAutomatCreation_oid_parent();
  
  MsgAutomatCreation_oid_parent(const MsgAutomatCreation_oid_parent& from);
  
  inline MsgAutomatCreation_oid_parent& operator=(const MsgAutomatCreation_oid_parent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatCreation_oid_parent& default_instance();
  void Swap(MsgAutomatCreation_oid_parent* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatCreation_oid_parent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatCreation_oid_parent& from);
  void MergeFrom(const MsgAutomatCreation_oid_parent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.FormationId formation = 1;
  inline bool has_formation() const;
  inline void clear_formation();
  static const int kFormationFieldNumber = 1;
  inline const ::Common::FormationId& formation() const;
  inline ::Common::FormationId* mutable_formation();
  
  // optional .Common.AutomatId automat = 2;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 2;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FormationId* formation_;
  ::Common::AutomatId* automat_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatCreation_oid_parent* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatCreation : public ::google::protobuf::Message {
 public:
  MsgAutomatCreation();
  virtual ~MsgAutomatCreation();
  
  MsgAutomatCreation(const MsgAutomatCreation& from);
  
  inline MsgAutomatCreation& operator=(const MsgAutomatCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatCreation& default_instance();
  void Swap(MsgAutomatCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatCreation& from);
  void MergeFrom(const MsgAutomatCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.AutomatId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::AutomatId& id() const;
  inline ::Common::AutomatId* mutable_id();
  
  // optional .Common.AutomatType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::AutomatType& type() const;
  inline ::Common::AutomatType* mutable_type();
  
  // optional string nom = 3;
  inline bool has_nom() const;
  inline void clear_nom();
  static const int kNomFieldNumber = 3;
  inline const ::std::string& nom() const;
  inline void set_nom(const ::std::string& value);
  inline void set_nom(const char* value);
  inline void set_nom(const char* value, size_t size);
  inline ::std::string* mutable_nom();
  
  // optional .MsgsSimToClient.MsgAutomatCreation_oid_parent oid_parent = 4;
  inline bool has_oid_parent() const;
  inline void clear_oid_parent();
  static const int kOidParentFieldNumber = 4;
  inline const ::MsgsSimToClient::MsgAutomatCreation_oid_parent& oid_parent() const;
  inline ::MsgsSimToClient::MsgAutomatCreation_oid_parent* mutable_oid_parent();
  
  // optional .Common.PartyId party = 5;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 5;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.KnowledgeGroupId knowledge_group = 6;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 6;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* id_;
  ::Common::AutomatType* type_;
  ::std::string* nom_;
  static const ::std::string _default_nom_;
  ::MsgsSimToClient::MsgAutomatCreation_oid_parent* oid_parent_;
  ::Common::PartyId* party_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatCreation* default_instance_;
};
// -------------------------------------------------------------------

class RulesOfEngagement : public ::google::protobuf::Message {
 public:
  RulesOfEngagement();
  virtual ~RulesOfEngagement();
  
  RulesOfEngagement(const RulesOfEngagement& from);
  
  inline RulesOfEngagement& operator=(const RulesOfEngagement& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RulesOfEngagement& default_instance();
  void Swap(RulesOfEngagement* other);
  
  // implements Message ----------------------------------------------
  
  RulesOfEngagement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RulesOfEngagement& from);
  void MergeFrom(const RulesOfEngagement& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef RulesOfEngagement_Value Value;
  static const Value none_roe = RulesOfEngagement_Value_none_roe;
  static const Value tir_libre = RulesOfEngagement_Value_tir_libre;
  static const Value tir_sur_riposte = RulesOfEngagement_Value_tir_sur_riposte;
  static const Value tir_interdit = RulesOfEngagement_Value_tir_interdit;
  static inline bool Value_IsValid(int value) {
    return RulesOfEngagement_Value_IsValid(value);
  }
  static const Value Value_MIN =
    RulesOfEngagement_Value_Value_MIN;
  static const Value Value_MAX =
    RulesOfEngagement_Value_Value_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  Value_descriptor() {
    return RulesOfEngagement_Value_descriptor();
  }
  static inline const ::std::string& Value_Name(Value value) {
    return RulesOfEngagement_Value_Name(value);
  }
  static inline bool Value_Parse(const ::std::string& name,
      Value* value) {
    return RulesOfEngagement_Value_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RulesOfEngagement* default_instance_;
};
// -------------------------------------------------------------------

class ForceRatio : public ::google::protobuf::Message {
 public:
  ForceRatio();
  virtual ~ForceRatio();
  
  ForceRatio(const ForceRatio& from);
  
  inline ForceRatio& operator=(const ForceRatio& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForceRatio& default_instance();
  void Swap(ForceRatio* other);
  
  // implements Message ----------------------------------------------
  
  ForceRatio* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForceRatio& from);
  void MergeFrom(const ForceRatio& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ForceRatio_Value Value;
  static const Value none_force_ratio = ForceRatio_Value_none_force_ratio;
  static const Value neutre = ForceRatio_Value_neutre;
  static const Value favorable = ForceRatio_Value_favorable;
  static const Value defavorable = ForceRatio_Value_defavorable;
  static inline bool Value_IsValid(int value) {
    return ForceRatio_Value_IsValid(value);
  }
  static const Value Value_MIN =
    ForceRatio_Value_Value_MIN;
  static const Value Value_MAX =
    ForceRatio_Value_Value_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  Value_descriptor() {
    return ForceRatio_Value_descriptor();
  }
  static inline const ::std::string& Value_Name(Value value) {
    return ForceRatio_Value_Name(value);
  }
  static inline bool Value_Parse(const ::std::string& name,
      Value* value) {
    return ForceRatio_Value_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ForceRatio* default_instance_;
};
// -------------------------------------------------------------------

class MsgAutomatAttributes : public ::google::protobuf::Message {
 public:
  MsgAutomatAttributes();
  virtual ~MsgAutomatAttributes();
  
  MsgAutomatAttributes(const MsgAutomatAttributes& from);
  
  inline MsgAutomatAttributes& operator=(const MsgAutomatAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgAutomatAttributes& default_instance();
  void Swap(MsgAutomatAttributes* other);
  
  // implements Message ----------------------------------------------
  
  MsgAutomatAttributes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgAutomatAttributes& from);
  void MergeFrom(const MsgAutomatAttributes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::AutomatId& id() const;
  inline ::Common::AutomatId* mutable_id();
  
  // optional .Common.EnumAutomatMode etat_automate = 2;
  inline bool has_etat_automate() const;
  inline void clear_etat_automate();
  static const int kEtatAutomateFieldNumber = 2;
  inline Common::EnumAutomatMode etat_automate() const;
  inline void set_etat_automate(Common::EnumAutomatMode value);
  
  // optional .MsgsSimToClient.ForceRatio.Value rapport_de_force = 3;
  inline bool has_rapport_de_force() const;
  inline void clear_rapport_de_force();
  static const int kRapportDeForceFieldNumber = 3;
  inline ::MsgsSimToClient::ForceRatio_Value rapport_de_force() const;
  inline void set_rapport_de_force(::MsgsSimToClient::ForceRatio_Value value);
  
  // optional .Common.EnumMeetingEngagementStatus combat_de_rencontre = 4;
  inline bool has_combat_de_rencontre() const;
  inline void clear_combat_de_rencontre();
  static const int kCombatDeRencontreFieldNumber = 4;
  inline Common::EnumMeetingEngagementStatus combat_de_rencontre() const;
  inline void set_combat_de_rencontre(Common::EnumMeetingEngagementStatus value);
  
  // optional .Common.EnumOperationalStatus etat_operationnel = 5;
  inline bool has_etat_operationnel() const;
  inline void clear_etat_operationnel();
  static const int kEtatOperationnelFieldNumber = 5;
  inline Common::EnumOperationalStatus etat_operationnel() const;
  inline void set_etat_operationnel(Common::EnumOperationalStatus value);
  
  // optional .MsgsSimToClient.RulesOfEngagement.Value roe = 6;
  inline bool has_roe() const;
  inline void clear_roe();
  static const int kRoeFieldNumber = 6;
  inline ::MsgsSimToClient::RulesOfEngagement_Value roe() const;
  inline void set_roe(::MsgsSimToClient::RulesOfEngagement_Value value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* id_;
  int etat_automate_;
  int rapport_de_force_;
  int combat_de_rencontre_;
  int etat_operationnel_;
  int roe_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgAutomatAttributes* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitCreation : public ::google::protobuf::Message {
 public:
  MsgUnitCreation();
  virtual ~MsgUnitCreation();
  
  MsgUnitCreation(const MsgUnitCreation& from);
  
  inline MsgUnitCreation& operator=(const MsgUnitCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitCreation& default_instance();
  void Swap(MsgUnitCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitCreation& from);
  void MergeFrom(const MsgUnitCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // required .Common.UnitType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::UnitType& type() const;
  inline ::Common::UnitType* mutable_type();
  
  // required string nom = 3;
  inline bool has_nom() const;
  inline void clear_nom();
  static const int kNomFieldNumber = 3;
  inline const ::std::string& nom() const;
  inline void set_nom(const ::std::string& value);
  inline void set_nom(const char* value);
  inline void set_nom(const char* value, size_t size);
  inline ::std::string* mutable_nom();
  
  // required .Common.AutomatId automat = 4;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 4;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
  // required bool pc = 5;
  inline bool has_pc() const;
  inline void clear_pc();
  static const int kPcFieldNumber = 5;
  inline bool pc() const;
  inline void set_pc(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  ::Common::UnitType* type_;
  ::std::string* nom_;
  static const ::std::string _default_nom_;
  ::Common::AutomatId* automat_;
  bool pc_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitCreation* default_instance_;
};
// -------------------------------------------------------------------

class BorrowedEquipments_BorrowedEquipment : public ::google::protobuf::Message {
 public:
  BorrowedEquipments_BorrowedEquipment();
  virtual ~BorrowedEquipments_BorrowedEquipment();
  
  BorrowedEquipments_BorrowedEquipment(const BorrowedEquipments_BorrowedEquipment& from);
  
  inline BorrowedEquipments_BorrowedEquipment& operator=(const BorrowedEquipments_BorrowedEquipment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BorrowedEquipments_BorrowedEquipment& default_instance();
  void Swap(BorrowedEquipments_BorrowedEquipment* other);
  
  // implements Message ----------------------------------------------
  
  BorrowedEquipments_BorrowedEquipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BorrowedEquipments_BorrowedEquipment& from);
  void MergeFrom(const BorrowedEquipments_BorrowedEquipment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 1;
  inline const ::Common::UnitId& owner() const;
  inline ::Common::UnitId* mutable_owner();
  
  // required .Common.EquipmentType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::EquipmentType& type() const;
  inline ::Common::EquipmentType* mutable_type();
  
  // required int32 nombre = 3;
  inline bool has_nombre() const;
  inline void clear_nombre();
  static const int kNombreFieldNumber = 3;
  inline ::google::protobuf::int32 nombre() const;
  inline void set_nombre(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* owner_;
  ::Common::EquipmentType* type_;
  ::google::protobuf::int32 nombre_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BorrowedEquipments_BorrowedEquipment* default_instance_;
};
// -------------------------------------------------------------------

class BorrowedEquipments : public ::google::protobuf::Message {
 public:
  BorrowedEquipments();
  virtual ~BorrowedEquipments();
  
  BorrowedEquipments(const BorrowedEquipments& from);
  
  inline BorrowedEquipments& operator=(const BorrowedEquipments& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BorrowedEquipments& default_instance();
  void Swap(BorrowedEquipments* other);
  
  // implements Message ----------------------------------------------
  
  BorrowedEquipments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BorrowedEquipments& from);
  void MergeFrom(const BorrowedEquipments& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BorrowedEquipments_BorrowedEquipment BorrowedEquipment;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.BorrowedEquipments.BorrowedEquipment elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment >* mutable_elem();
  inline const ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment& elem(int index) const;
  inline ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment* mutable_elem(int index);
  inline ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BorrowedEquipments* default_instance_;
};
// -------------------------------------------------------------------

class LentEquipments_LentEquipment : public ::google::protobuf::Message {
 public:
  LentEquipments_LentEquipment();
  virtual ~LentEquipments_LentEquipment();
  
  LentEquipments_LentEquipment(const LentEquipments_LentEquipment& from);
  
  inline LentEquipments_LentEquipment& operator=(const LentEquipments_LentEquipment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LentEquipments_LentEquipment& default_instance();
  void Swap(LentEquipments_LentEquipment* other);
  
  // implements Message ----------------------------------------------
  
  LentEquipments_LentEquipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LentEquipments_LentEquipment& from);
  void MergeFrom(const LentEquipments_LentEquipment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId borrower = 1;
  inline bool has_borrower() const;
  inline void clear_borrower();
  static const int kBorrowerFieldNumber = 1;
  inline const ::Common::UnitId& borrower() const;
  inline ::Common::UnitId* mutable_borrower();
  
  // required .Common.EquipmentType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::EquipmentType& type() const;
  inline ::Common::EquipmentType* mutable_type();
  
  // required int32 nombre = 3;
  inline bool has_nombre() const;
  inline void clear_nombre();
  static const int kNombreFieldNumber = 3;
  inline ::google::protobuf::int32 nombre() const;
  inline void set_nombre(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* borrower_;
  ::Common::EquipmentType* type_;
  ::google::protobuf::int32 nombre_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LentEquipments_LentEquipment* default_instance_;
};
// -------------------------------------------------------------------

class LentEquipments : public ::google::protobuf::Message {
 public:
  LentEquipments();
  virtual ~LentEquipments();
  
  LentEquipments(const LentEquipments& from);
  
  inline LentEquipments& operator=(const LentEquipments& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LentEquipments& default_instance();
  void Swap(LentEquipments* other);
  
  // implements Message ----------------------------------------------
  
  LentEquipments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LentEquipments& from);
  void MergeFrom(const LentEquipments& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LentEquipments_LentEquipment LentEquipment;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.LentEquipments.LentEquipment elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment >* mutable_elem();
  inline const ::MsgsSimToClient::LentEquipments_LentEquipment& elem(int index) const;
  inline ::MsgsSimToClient::LentEquipments_LentEquipment* mutable_elem(int index);
  inline ::MsgsSimToClient::LentEquipments_LentEquipment* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LentEquipments* default_instance_;
};
// -------------------------------------------------------------------

class ResourceDotations_ResourceDotation : public ::google::protobuf::Message {
 public:
  ResourceDotations_ResourceDotation();
  virtual ~ResourceDotations_ResourceDotation();
  
  ResourceDotations_ResourceDotation(const ResourceDotations_ResourceDotation& from);
  
  inline ResourceDotations_ResourceDotation& operator=(const ResourceDotations_ResourceDotation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceDotations_ResourceDotation& default_instance();
  void Swap(ResourceDotations_ResourceDotation* other);
  
  // implements Message ----------------------------------------------
  
  ResourceDotations_ResourceDotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceDotations_ResourceDotation& from);
  void MergeFrom(const ResourceDotations_ResourceDotation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ResourceType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::Common::ResourceType& type() const;
  inline ::Common::ResourceType* mutable_type();
  
  // required int32 quantite_disponible = 2;
  inline bool has_quantite_disponible() const;
  inline void clear_quantite_disponible();
  static const int kQuantiteDisponibleFieldNumber = 2;
  inline ::google::protobuf::int32 quantite_disponible() const;
  inline void set_quantite_disponible(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ResourceType* type_;
  ::google::protobuf::int32 quantite_disponible_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResourceDotations_ResourceDotation* default_instance_;
};
// -------------------------------------------------------------------

class ResourceDotations : public ::google::protobuf::Message {
 public:
  ResourceDotations();
  virtual ~ResourceDotations();
  
  ResourceDotations(const ResourceDotations& from);
  
  inline ResourceDotations& operator=(const ResourceDotations& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceDotations& default_instance();
  void Swap(ResourceDotations* other);
  
  // implements Message ----------------------------------------------
  
  ResourceDotations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceDotations& from);
  void MergeFrom(const ResourceDotations& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ResourceDotations_ResourceDotation ResourceDotation;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.ResourceDotations.ResourceDotation elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation >* mutable_elem();
  inline const ::MsgsSimToClient::ResourceDotations_ResourceDotation& elem(int index) const;
  inline ::MsgsSimToClient::ResourceDotations_ResourceDotation* mutable_elem(int index);
  inline ::MsgsSimToClient::ResourceDotations_ResourceDotation* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ResourceDotations* default_instance_;
};
// -------------------------------------------------------------------

class EquipmentDotations_EquipmentDotation : public ::google::protobuf::Message {
 public:
  EquipmentDotations_EquipmentDotation();
  virtual ~EquipmentDotations_EquipmentDotation();
  
  EquipmentDotations_EquipmentDotation(const EquipmentDotations_EquipmentDotation& from);
  
  inline EquipmentDotations_EquipmentDotation& operator=(const EquipmentDotations_EquipmentDotation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipmentDotations_EquipmentDotation& default_instance();
  void Swap(EquipmentDotations_EquipmentDotation* other);
  
  // implements Message ----------------------------------------------
  
  EquipmentDotations_EquipmentDotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipmentDotations_EquipmentDotation& from);
  void MergeFrom(const EquipmentDotations_EquipmentDotation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EquipmentType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::Common::EquipmentType& type() const;
  inline ::Common::EquipmentType* mutable_type();
  
  // required int32 nb_disponibles = 2;
  inline bool has_nb_disponibles() const;
  inline void clear_nb_disponibles();
  static const int kNbDisponiblesFieldNumber = 2;
  inline ::google::protobuf::int32 nb_disponibles() const;
  inline void set_nb_disponibles(::google::protobuf::int32 value);
  
  // required int32 nb_indisponibles = 3;
  inline bool has_nb_indisponibles() const;
  inline void clear_nb_indisponibles();
  static const int kNbIndisponiblesFieldNumber = 3;
  inline ::google::protobuf::int32 nb_indisponibles() const;
  inline void set_nb_indisponibles(::google::protobuf::int32 value);
  
  // required int32 nb_reparables = 4;
  inline bool has_nb_reparables() const;
  inline void clear_nb_reparables();
  static const int kNbReparablesFieldNumber = 4;
  inline ::google::protobuf::int32 nb_reparables() const;
  inline void set_nb_reparables(::google::protobuf::int32 value);
  
  // required int32 nb_dans_chaine_maintenance = 5;
  inline bool has_nb_dans_chaine_maintenance() const;
  inline void clear_nb_dans_chaine_maintenance();
  static const int kNbDansChaineMaintenanceFieldNumber = 5;
  inline ::google::protobuf::int32 nb_dans_chaine_maintenance() const;
  inline void set_nb_dans_chaine_maintenance(::google::protobuf::int32 value);
  
  // required int32 nb_prisonniers = 6;
  inline bool has_nb_prisonniers() const;
  inline void clear_nb_prisonniers();
  static const int kNbPrisonniersFieldNumber = 6;
  inline ::google::protobuf::int32 nb_prisonniers() const;
  inline void set_nb_prisonniers(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::EquipmentType* type_;
  ::google::protobuf::int32 nb_disponibles_;
  ::google::protobuf::int32 nb_indisponibles_;
  ::google::protobuf::int32 nb_reparables_;
  ::google::protobuf::int32 nb_dans_chaine_maintenance_;
  ::google::protobuf::int32 nb_prisonniers_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static EquipmentDotations_EquipmentDotation* default_instance_;
};
// -------------------------------------------------------------------

class EquipmentDotations : public ::google::protobuf::Message {
 public:
  EquipmentDotations();
  virtual ~EquipmentDotations();
  
  EquipmentDotations(const EquipmentDotations& from);
  
  inline EquipmentDotations& operator=(const EquipmentDotations& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipmentDotations& default_instance();
  void Swap(EquipmentDotations* other);
  
  // implements Message ----------------------------------------------
  
  EquipmentDotations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipmentDotations& from);
  void MergeFrom(const EquipmentDotations& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef EquipmentDotations_EquipmentDotation EquipmentDotation;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.EquipmentDotations.EquipmentDotation elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation >* mutable_elem();
  inline const ::MsgsSimToClient::EquipmentDotations_EquipmentDotation& elem(int index) const;
  inline ::MsgsSimToClient::EquipmentDotations_EquipmentDotation* mutable_elem(int index);
  inline ::MsgsSimToClient::EquipmentDotations_EquipmentDotation* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static EquipmentDotations* default_instance_;
};
// -------------------------------------------------------------------

class HumanDotations_HumanDotation : public ::google::protobuf::Message {
 public:
  HumanDotations_HumanDotation();
  virtual ~HumanDotations_HumanDotation();
  
  HumanDotations_HumanDotation(const HumanDotations_HumanDotation& from);
  
  inline HumanDotations_HumanDotation& operator=(const HumanDotations_HumanDotation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HumanDotations_HumanDotation& default_instance();
  void Swap(HumanDotations_HumanDotation* other);
  
  // implements Message ----------------------------------------------
  
  HumanDotations_HumanDotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HumanDotations_HumanDotation& from);
  void MergeFrom(const HumanDotations_HumanDotation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EnumHumanRank rang = 1;
  inline bool has_rang() const;
  inline void clear_rang();
  static const int kRangFieldNumber = 1;
  inline Common::EnumHumanRank rang() const;
  inline void set_rang(Common::EnumHumanRank value);
  
  // required int32 nb_total = 2;
  inline bool has_nb_total() const;
  inline void clear_nb_total();
  static const int kNbTotalFieldNumber = 2;
  inline ::google::protobuf::int32 nb_total() const;
  inline void set_nb_total(::google::protobuf::int32 value);
  
  // required int32 nb_operationnels = 3;
  inline bool has_nb_operationnels() const;
  inline void clear_nb_operationnels();
  static const int kNbOperationnelsFieldNumber = 3;
  inline ::google::protobuf::int32 nb_operationnels() const;
  inline void set_nb_operationnels(::google::protobuf::int32 value);
  
  // required int32 nb_morts = 4;
  inline bool has_nb_morts() const;
  inline void clear_nb_morts();
  static const int kNbMortsFieldNumber = 4;
  inline ::google::protobuf::int32 nb_morts() const;
  inline void set_nb_morts(::google::protobuf::int32 value);
  
  // required int32 nb_blesses = 5;
  inline bool has_nb_blesses() const;
  inline void clear_nb_blesses();
  static const int kNbBlessesFieldNumber = 5;
  inline ::google::protobuf::int32 nb_blesses() const;
  inline void set_nb_blesses(::google::protobuf::int32 value);
  
  // required int32 nb_blesses_mentaux = 6;
  inline bool has_nb_blesses_mentaux() const;
  inline void clear_nb_blesses_mentaux();
  static const int kNbBlessesMentauxFieldNumber = 6;
  inline ::google::protobuf::int32 nb_blesses_mentaux() const;
  inline void set_nb_blesses_mentaux(::google::protobuf::int32 value);
  
  // required int32 nb_contamines_nbc = 7;
  inline bool has_nb_contamines_nbc() const;
  inline void clear_nb_contamines_nbc();
  static const int kNbContaminesNbcFieldNumber = 7;
  inline ::google::protobuf::int32 nb_contamines_nbc() const;
  inline void set_nb_contamines_nbc(::google::protobuf::int32 value);
  
  // required int32 nb_dans_chaine_sante = 8;
  inline bool has_nb_dans_chaine_sante() const;
  inline void clear_nb_dans_chaine_sante();
  static const int kNbDansChaineSanteFieldNumber = 8;
  inline ::google::protobuf::int32 nb_dans_chaine_sante() const;
  inline void set_nb_dans_chaine_sante(::google::protobuf::int32 value);
  
  // required int32 nb_utilises_pour_maintenance = 9;
  inline bool has_nb_utilises_pour_maintenance() const;
  inline void clear_nb_utilises_pour_maintenance();
  static const int kNbUtilisesPourMaintenanceFieldNumber = 9;
  inline ::google::protobuf::int32 nb_utilises_pour_maintenance() const;
  inline void set_nb_utilises_pour_maintenance(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int rang_;
  ::google::protobuf::int32 nb_total_;
  ::google::protobuf::int32 nb_operationnels_;
  ::google::protobuf::int32 nb_morts_;
  ::google::protobuf::int32 nb_blesses_;
  ::google::protobuf::int32 nb_blesses_mentaux_;
  ::google::protobuf::int32 nb_contamines_nbc_;
  ::google::protobuf::int32 nb_dans_chaine_sante_;
  ::google::protobuf::int32 nb_utilises_pour_maintenance_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HumanDotations_HumanDotation* default_instance_;
};
// -------------------------------------------------------------------

class HumanDotations : public ::google::protobuf::Message {
 public:
  HumanDotations();
  virtual ~HumanDotations();
  
  HumanDotations(const HumanDotations& from);
  
  inline HumanDotations& operator=(const HumanDotations& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HumanDotations& default_instance();
  void Swap(HumanDotations* other);
  
  // implements Message ----------------------------------------------
  
  HumanDotations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HumanDotations& from);
  void MergeFrom(const HumanDotations& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef HumanDotations_HumanDotation HumanDotation;
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.HumanDotations.HumanDotation elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation >* mutable_elem();
  inline const ::MsgsSimToClient::HumanDotations_HumanDotation& elem(int index) const;
  inline ::MsgsSimToClient::HumanDotations_HumanDotation* mutable_elem(int index);
  inline ::MsgsSimToClient::HumanDotations_HumanDotation* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HumanDotations* default_instance_;
};
// -------------------------------------------------------------------

class ContaminationState : public ::google::protobuf::Message {
 public:
  ContaminationState();
  virtual ~ContaminationState();
  
  ContaminationState(const ContaminationState& from);
  
  inline ContaminationState& operator=(const ContaminationState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContaminationState& default_instance();
  void Swap(ContaminationState* other);
  
  // implements Message ----------------------------------------------
  
  ContaminationState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContaminationState& from);
  void MergeFrom(const ContaminationState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 percentage = 1;
  inline bool has_percentage() const;
  inline void clear_percentage();
  static const int kPercentageFieldNumber = 1;
  inline ::google::protobuf::int32 percentage() const;
  inline void set_percentage(::google::protobuf::int32 value);
  
  // optional float quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline float quantity() const;
  inline void set_quantity(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 percentage_;
  float quantity_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ContaminationState* default_instance_;
};
// -------------------------------------------------------------------

class NBCAgents : public ::google::protobuf::Message {
 public:
  NBCAgents();
  virtual ~NBCAgents();
  
  NBCAgents(const NBCAgents& from);
  
  inline NBCAgents& operator=(const NBCAgents& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NBCAgents& default_instance();
  void Swap(NBCAgents* other);
  
  // implements Message ----------------------------------------------
  
  NBCAgents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NBCAgents& from);
  void MergeFrom(const NBCAgents& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Common.NBCAgentType elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType >* mutable_elem();
  inline const ::Common::NBCAgentType& elem(int index) const;
  inline ::Common::NBCAgentType* mutable_elem(int index);
  inline ::Common::NBCAgentType* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NBCAgents* default_instance_;
};
// -------------------------------------------------------------------

class Communication : public ::google::protobuf::Message {
 public:
  Communication();
  virtual ~Communication();
  
  Communication(const Communication& from);
  
  inline Communication& operator=(const Communication& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Communication& default_instance();
  void Swap(Communication* other);
  
  // implements Message ----------------------------------------------
  
  Communication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Communication& from);
  void MergeFrom(const Communication& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool jammed = 1 [default = false];
  inline bool has_jammed() const;
  inline void clear_jammed();
  static const int kJammedFieldNumber = 1;
  inline bool jammed() const;
  inline void set_jammed(bool value);
  
  // optional .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool jammed_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Communication* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitAttributes : public ::google::protobuf::Message {
 public:
  MsgUnitAttributes();
  virtual ~MsgUnitAttributes();
  
  MsgUnitAttributes(const MsgUnitAttributes& from);
  
  inline MsgUnitAttributes& operator=(const MsgUnitAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitAttributes& default_instance();
  void Swap(MsgUnitAttributes* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitAttributes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitAttributes& from);
  void MergeFrom(const MsgUnitAttributes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgUnitAttributes_Posture Posture;
  static const Posture mouvement = MsgUnitAttributes_Posture_mouvement;
  static const Posture mouvement_discret = MsgUnitAttributes_Posture_mouvement_discret;
  static const Posture arret = MsgUnitAttributes_Posture_arret;
  static const Posture poste_reflexe = MsgUnitAttributes_Posture_poste_reflexe;
  static const Posture poste = MsgUnitAttributes_Posture_poste;
  static const Posture poste_amenage = MsgUnitAttributes_Posture_poste_amenage;
  static const Posture poste_prepare_genie = MsgUnitAttributes_Posture_poste_prepare_genie;
  static inline bool Posture_IsValid(int value) {
    return MsgUnitAttributes_Posture_IsValid(value);
  }
  static const Posture Posture_MIN =
    MsgUnitAttributes_Posture_Posture_MIN;
  static const Posture Posture_MAX =
    MsgUnitAttributes_Posture_Posture_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  Posture_descriptor() {
    return MsgUnitAttributes_Posture_descriptor();
  }
  static inline const ::std::string& Posture_Name(Posture value) {
    return MsgUnitAttributes_Posture_Name(value);
  }
  static inline bool Posture_Parse(const ::std::string& name,
      Posture* value) {
    return MsgUnitAttributes_Posture_Parse(name, value);
  }
  
  typedef MsgUnitAttributes_FireAvailability FireAvailability;
  static const FireAvailability none_fire_available = MsgUnitAttributes_FireAvailability_none_fire_available;
  static const FireAvailability pret_au_tir = MsgUnitAttributes_FireAvailability_pret_au_tir;
  static const FireAvailability indisponible = MsgUnitAttributes_FireAvailability_indisponible;
  static inline bool FireAvailability_IsValid(int value) {
    return MsgUnitAttributes_FireAvailability_IsValid(value);
  }
  static const FireAvailability FireAvailability_MIN =
    MsgUnitAttributes_FireAvailability_FireAvailability_MIN;
  static const FireAvailability FireAvailability_MAX =
    MsgUnitAttributes_FireAvailability_FireAvailability_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  FireAvailability_descriptor() {
    return MsgUnitAttributes_FireAvailability_descriptor();
  }
  static inline const ::std::string& FireAvailability_Name(FireAvailability value) {
    return MsgUnitAttributes_FireAvailability_Name(value);
  }
  static inline bool FireAvailability_Parse(const ::std::string& name,
      FireAvailability* value) {
    return MsgUnitAttributes_FireAvailability_Parse(name, value);
  }
  
  typedef MsgUnitAttributes_PopulationRoe PopulationRoe;
  static const PopulationRoe none = MsgUnitAttributes_PopulationRoe_none;
  static const PopulationRoe emploi_force_interdit = MsgUnitAttributes_PopulationRoe_emploi_force_interdit;
  static const PopulationRoe maintien_a_distance_par_moyens_non_letaux = MsgUnitAttributes_PopulationRoe_maintien_a_distance_par_moyens_non_letaux;
  static const PopulationRoe dispersion_par_moyens_de_defense_actifs = MsgUnitAttributes_PopulationRoe_dispersion_par_moyens_de_defense_actifs;
  static const PopulationRoe armes_letales_autorisees = MsgUnitAttributes_PopulationRoe_armes_letales_autorisees;
  static inline bool PopulationRoe_IsValid(int value) {
    return MsgUnitAttributes_PopulationRoe_IsValid(value);
  }
  static const PopulationRoe PopulationRoe_MIN =
    MsgUnitAttributes_PopulationRoe_PopulationRoe_MIN;
  static const PopulationRoe PopulationRoe_MAX =
    MsgUnitAttributes_PopulationRoe_PopulationRoe_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  PopulationRoe_descriptor() {
    return MsgUnitAttributes_PopulationRoe_descriptor();
  }
  static inline const ::std::string& PopulationRoe_Name(PopulationRoe value) {
    return MsgUnitAttributes_PopulationRoe_Name(value);
  }
  static inline bool PopulationRoe_Parse(const ::std::string& name,
      PopulationRoe* value) {
    return MsgUnitAttributes_PopulationRoe_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // optional .MsgsSimToClient.HumanDotations dotation_eff_personnel = 2;
  inline bool has_dotation_eff_personnel() const;
  inline void clear_dotation_eff_personnel();
  static const int kDotationEffPersonnelFieldNumber = 2;
  inline const ::MsgsSimToClient::HumanDotations& dotation_eff_personnel() const;
  inline ::MsgsSimToClient::HumanDotations* mutable_dotation_eff_personnel();
  
  // optional .MsgsSimToClient.EquipmentDotations dotation_eff_materiel = 3;
  inline bool has_dotation_eff_materiel() const;
  inline void clear_dotation_eff_materiel();
  static const int kDotationEffMaterielFieldNumber = 3;
  inline const ::MsgsSimToClient::EquipmentDotations& dotation_eff_materiel() const;
  inline ::MsgsSimToClient::EquipmentDotations* mutable_dotation_eff_materiel();
  
  // optional .MsgsSimToClient.ResourceDotations dotation_eff_ressource = 4;
  inline bool has_dotation_eff_ressource() const;
  inline void clear_dotation_eff_ressource();
  static const int kDotationEffRessourceFieldNumber = 4;
  inline const ::MsgsSimToClient::ResourceDotations& dotation_eff_ressource() const;
  inline ::MsgsSimToClient::ResourceDotations* mutable_dotation_eff_ressource();
  
  // optional .MsgsSimToClient.LentEquipments equipements_pretes = 5;
  inline bool has_equipements_pretes() const;
  inline void clear_equipements_pretes();
  static const int kEquipementsPretesFieldNumber = 5;
  inline const ::MsgsSimToClient::LentEquipments& equipements_pretes() const;
  inline ::MsgsSimToClient::LentEquipments* mutable_equipements_pretes();
  
  // optional .MsgsSimToClient.BorrowedEquipments equipements_empruntes = 6;
  inline bool has_equipements_empruntes() const;
  inline void clear_equipements_empruntes();
  static const int kEquipementsEmpruntesFieldNumber = 6;
  inline const ::MsgsSimToClient::BorrowedEquipments& equipements_empruntes() const;
  inline ::MsgsSimToClient::BorrowedEquipments* mutable_equipements_empruntes();
  
  // optional .Common.MsgCoordLatLong position = 7;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 7;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
  // optional .Common.MsgHeading direction = 8;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 8;
  inline const ::Common::MsgHeading& direction() const;
  inline ::Common::MsgHeading* mutable_direction();
  
  // optional int32 hauteur = 9 [default = 0];
  inline bool has_hauteur() const;
  inline void clear_hauteur();
  static const int kHauteurFieldNumber = 9;
  inline ::google::protobuf::int32 hauteur() const;
  inline void set_hauteur(::google::protobuf::int32 value);
  
  // optional int32 altitude = 10 [default = 0];
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 10;
  inline ::google::protobuf::int32 altitude() const;
  inline void set_altitude(::google::protobuf::int32 value);
  
  // optional int32 vitesse = 11 [default = 0];
  inline bool has_vitesse() const;
  inline void clear_vitesse();
  static const int kVitesseFieldNumber = 11;
  inline ::google::protobuf::int32 vitesse() const;
  inline void set_vitesse(::google::protobuf::int32 value);
  
  // optional int32 etat_operationnel_brut = 12 [default = 0];
  inline bool has_etat_operationnel_brut() const;
  inline void clear_etat_operationnel_brut();
  static const int kEtatOperationnelBrutFieldNumber = 12;
  inline ::google::protobuf::int32 etat_operationnel_brut() const;
  inline void set_etat_operationnel_brut(::google::protobuf::int32 value);
  
  // optional .Common.UnitIdList reinforcements = 13;
  inline bool has_reinforcements() const;
  inline void clear_reinforcements();
  static const int kReinforcementsFieldNumber = 13;
  inline const ::Common::UnitIdList& reinforcements() const;
  inline ::Common::UnitIdList* mutable_reinforcements();
  
  // optional .Common.UnitId reinforced_unit = 14;
  inline bool has_reinforced_unit() const;
  inline void clear_reinforced_unit();
  static const int kReinforcedUnitFieldNumber = 14;
  inline const ::Common::UnitId& reinforced_unit() const;
  inline ::Common::UnitId* mutable_reinforced_unit();
  
  // optional bool mort = 15 [default = false];
  inline bool has_mort() const;
  inline void clear_mort();
  static const int kMortFieldNumber = 15;
  inline bool mort() const;
  inline void set_mort(bool value);
  
  // optional bool neutralise = 16 [default = false];
  inline bool has_neutralise() const;
  inline void clear_neutralise();
  static const int kNeutraliseFieldNumber = 16;
  inline bool neutralise() const;
  inline void set_neutralise(bool value);
  
  // optional bool mode_furtif_actif = 17 [default = false];
  inline bool has_mode_furtif_actif() const;
  inline void clear_mode_furtif_actif();
  static const int kModeFurtifActifFieldNumber = 17;
  inline bool mode_furtif_actif() const;
  inline void set_mode_furtif_actif(bool value);
  
  // optional bool embarque = 18 [default = false];
  inline bool has_embarque() const;
  inline void clear_embarque();
  static const int kEmbarqueFieldNumber = 18;
  inline bool embarque() const;
  inline void set_embarque(bool value);
  
  // optional bool transporteurs_disponibles = 19 [default = false];
  inline bool has_transporteurs_disponibles() const;
  inline void clear_transporteurs_disponibles();
  static const int kTransporteursDisponiblesFieldNumber = 19;
  inline bool transporteurs_disponibles() const;
  inline void set_transporteurs_disponibles(bool value);
  
  // optional .MsgsSimToClient.MsgUnitAttributes.Posture posture_old = 20;
  inline bool has_posture_old() const;
  inline void clear_posture_old();
  static const int kPostureOldFieldNumber = 20;
  inline ::MsgsSimToClient::MsgUnitAttributes_Posture posture_old() const;
  inline void set_posture_old(::MsgsSimToClient::MsgUnitAttributes_Posture value);
  
  // optional .MsgsSimToClient.MsgUnitAttributes.Posture posture_new = 21;
  inline bool has_posture_new() const;
  inline void clear_posture_new();
  static const int kPostureNewFieldNumber = 21;
  inline ::MsgsSimToClient::MsgUnitAttributes_Posture posture_new() const;
  inline void set_posture_new(::MsgsSimToClient::MsgUnitAttributes_Posture value);
  
  // optional int32 posture_pourcentage = 22 [default = 0];
  inline bool has_posture_pourcentage() const;
  inline void clear_posture_pourcentage();
  static const int kPosturePourcentageFieldNumber = 22;
  inline ::google::protobuf::int32 posture_pourcentage() const;
  inline void set_posture_pourcentage(::google::protobuf::int32 value);
  
  // optional int32 etat_installation = 23 [default = 0];
  inline bool has_etat_installation() const;
  inline void clear_etat_installation();
  static const int kEtatInstallationFieldNumber = 23;
  inline ::google::protobuf::int32 etat_installation() const;
  inline void set_etat_installation(::google::protobuf::int32 value);
  
  // optional bool en_tenue_de_protection_nbc = 24 [default = false];
  inline bool has_en_tenue_de_protection_nbc() const;
  inline void clear_en_tenue_de_protection_nbc();
  static const int kEnTenueDeProtectionNbcFieldNumber = 24;
  inline bool en_tenue_de_protection_nbc() const;
  inline void set_en_tenue_de_protection_nbc(bool value);
  
  // optional .MsgsSimToClient.NBCAgents contamine_par_agents_nbc = 25;
  inline bool has_contamine_par_agents_nbc() const;
  inline void clear_contamine_par_agents_nbc();
  static const int kContamineParAgentsNbcFieldNumber = 25;
  inline const ::MsgsSimToClient::NBCAgents& contamine_par_agents_nbc() const;
  inline ::MsgsSimToClient::NBCAgents* mutable_contamine_par_agents_nbc();
  
  // optional .MsgsSimToClient.ContaminationState etat_contamination = 26;
  inline bool has_etat_contamination() const;
  inline void clear_etat_contamination();
  static const int kEtatContaminationFieldNumber = 26;
  inline const ::MsgsSimToClient::ContaminationState& etat_contamination() const;
  inline ::MsgsSimToClient::ContaminationState* mutable_etat_contamination();
  
  // optional .MsgsSimToClient.Communication communications = 27;
  inline bool has_communications() const;
  inline void clear_communications();
  static const int kCommunicationsFieldNumber = 27;
  inline const ::MsgsSimToClient::Communication& communications() const;
  inline ::MsgsSimToClient::Communication* mutable_communications();
  
  // optional bool radio_emitter_disabled = 28 [default = true];
  inline bool has_radio_emitter_disabled() const;
  inline void clear_radio_emitter_disabled();
  static const int kRadioEmitterDisabledFieldNumber = 28;
  inline bool radio_emitter_disabled() const;
  inline void set_radio_emitter_disabled(bool value);
  
  // optional bool radio_receiver_disabled = 29 [default = true];
  inline bool has_radio_receiver_disabled() const;
  inline void clear_radio_receiver_disabled();
  static const int kRadioReceiverDisabledFieldNumber = 29;
  inline bool radio_receiver_disabled() const;
  inline void set_radio_receiver_disabled(bool value);
  
  // optional bool radar_actif = 30 [default = false];
  inline bool has_radar_actif() const;
  inline void clear_radar_actif();
  static const int kRadarActifFieldNumber = 30;
  inline bool radar_actif() const;
  inline void set_radar_actif(bool value);
  
  // optional .Common.UnitIdList transported_units = 31;
  inline bool has_transported_units() const;
  inline void clear_transported_units();
  static const int kTransportedUnitsFieldNumber = 31;
  inline const ::Common::UnitIdList& transported_units() const;
  inline ::Common::UnitIdList* mutable_transported_units();
  
  // optional .Common.UnitId transporting_unit = 32;
  inline bool has_transporting_unit() const;
  inline void clear_transporting_unit();
  static const int kTransportingUnitFieldNumber = 32;
  inline const ::Common::UnitId& transporting_unit() const;
  inline ::Common::UnitId* mutable_transporting_unit();
  
  // optional .MsgsSimToClient.ForceRatio.Value rapport_de_force = 33;
  inline bool has_rapport_de_force() const;
  inline void clear_rapport_de_force();
  static const int kRapportDeForceFieldNumber = 33;
  inline ::MsgsSimToClient::ForceRatio_Value rapport_de_force() const;
  inline void set_rapport_de_force(::MsgsSimToClient::ForceRatio_Value value);
  
  // optional .Common.EnumMeetingEngagementStatus combat_de_rencontre = 34;
  inline bool has_combat_de_rencontre() const;
  inline void clear_combat_de_rencontre();
  static const int kCombatDeRencontreFieldNumber = 34;
  inline Common::EnumMeetingEngagementStatus combat_de_rencontre() const;
  inline void set_combat_de_rencontre(Common::EnumMeetingEngagementStatus value);
  
  // optional .Common.EnumOperationalStatus etat_operationnel = 35;
  inline bool has_etat_operationnel() const;
  inline void clear_etat_operationnel();
  static const int kEtatOperationnelFieldNumber = 35;
  inline Common::EnumOperationalStatus etat_operationnel() const;
  inline void set_etat_operationnel(Common::EnumOperationalStatus value);
  
  // optional .MsgsSimToClient.MsgUnitAttributes.FireAvailability disponibilite_au_tir_indirect = 36;
  inline bool has_disponibilite_au_tir_indirect() const;
  inline void clear_disponibilite_au_tir_indirect();
  static const int kDisponibiliteAuTirIndirectFieldNumber = 36;
  inline ::MsgsSimToClient::MsgUnitAttributes_FireAvailability disponibilite_au_tir_indirect() const;
  inline void set_disponibilite_au_tir_indirect(::MsgsSimToClient::MsgUnitAttributes_FireAvailability value);
  
  // optional .MsgsSimToClient.RulesOfEngagement.Value roe = 37;
  inline bool has_roe() const;
  inline void clear_roe();
  static const int kRoeFieldNumber = 37;
  inline ::MsgsSimToClient::RulesOfEngagement_Value roe() const;
  inline void set_roe(::MsgsSimToClient::RulesOfEngagement_Value value);
  
  // optional .MsgsSimToClient.MsgUnitAttributes.PopulationRoe roe_population = 38;
  inline bool has_roe_population() const;
  inline void clear_roe_population();
  static const int kRoePopulationFieldNumber = 38;
  inline ::MsgsSimToClient::MsgUnitAttributes_PopulationRoe roe_population() const;
  inline void set_roe_population(::MsgsSimToClient::MsgUnitAttributes_PopulationRoe value);
  
  // optional .Common.EnumUnitTiredness fatigue = 39;
  inline bool has_fatigue() const;
  inline void clear_fatigue();
  static const int kFatigueFieldNumber = 39;
  inline Common::EnumUnitTiredness fatigue() const;
  inline void set_fatigue(Common::EnumUnitTiredness value);
  
  // optional .Common.EnumUnitMorale moral = 40;
  inline bool has_moral() const;
  inline void clear_moral();
  static const int kMoralFieldNumber = 40;
  inline Common::EnumUnitMorale moral() const;
  inline void set_moral(Common::EnumUnitMorale value);
  
  // optional .Common.EnumUnitExperience experience = 41;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 41;
  inline Common::EnumUnitExperience experience() const;
  inline void set_experience(Common::EnumUnitExperience value);
  
  // optional .Common.UnitId surrendered_unit = 42;
  inline bool has_surrendered_unit() const;
  inline void clear_surrendered_unit();
  static const int kSurrenderedUnitFieldNumber = 42;
  inline const ::Common::UnitId& surrendered_unit() const;
  inline ::Common::UnitId* mutable_surrendered_unit();
  
  // optional bool prisonnier = 43 [default = false];
  inline bool has_prisonnier() const;
  inline void clear_prisonnier();
  static const int kPrisonnierFieldNumber = 43;
  inline bool prisonnier() const;
  inline void set_prisonnier(bool value);
  
  // optional bool refugie_pris_en_compte = 44 [default = false];
  inline bool has_refugie_pris_en_compte() const;
  inline void clear_refugie_pris_en_compte();
  static const int kRefugiePrisEnCompteFieldNumber = 44;
  inline bool refugie_pris_en_compte() const;
  inline void set_refugie_pris_en_compte(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  ::MsgsSimToClient::HumanDotations* dotation_eff_personnel_;
  ::MsgsSimToClient::EquipmentDotations* dotation_eff_materiel_;
  ::MsgsSimToClient::ResourceDotations* dotation_eff_ressource_;
  ::MsgsSimToClient::LentEquipments* equipements_pretes_;
  ::MsgsSimToClient::BorrowedEquipments* equipements_empruntes_;
  ::Common::MsgCoordLatLong* position_;
  ::Common::MsgHeading* direction_;
  ::google::protobuf::int32 hauteur_;
  ::google::protobuf::int32 altitude_;
  ::google::protobuf::int32 vitesse_;
  ::google::protobuf::int32 etat_operationnel_brut_;
  ::Common::UnitIdList* reinforcements_;
  ::Common::UnitId* reinforced_unit_;
  bool mort_;
  bool neutralise_;
  bool mode_furtif_actif_;
  bool embarque_;
  bool transporteurs_disponibles_;
  int posture_old_;
  int posture_new_;
  ::google::protobuf::int32 posture_pourcentage_;
  ::google::protobuf::int32 etat_installation_;
  bool en_tenue_de_protection_nbc_;
  ::MsgsSimToClient::NBCAgents* contamine_par_agents_nbc_;
  ::MsgsSimToClient::ContaminationState* etat_contamination_;
  ::MsgsSimToClient::Communication* communications_;
  bool radio_emitter_disabled_;
  bool radio_receiver_disabled_;
  bool radar_actif_;
  ::Common::UnitIdList* transported_units_;
  ::Common::UnitId* transporting_unit_;
  int rapport_de_force_;
  int combat_de_rencontre_;
  int etat_operationnel_;
  int disponibilite_au_tir_indirect_;
  int roe_;
  int roe_population_;
  int fatigue_;
  int moral_;
  int experience_;
  ::Common::UnitId* surrendered_unit_;
  bool prisonnier_;
  bool refugie_pris_en_compte_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(44 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitAttributes* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitPathFind : public ::google::protobuf::Message {
 public:
  MsgUnitPathFind();
  virtual ~MsgUnitPathFind();
  
  MsgUnitPathFind(const MsgUnitPathFind& from);
  
  inline MsgUnitPathFind& operator=(const MsgUnitPathFind& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitPathFind& default_instance();
  void Swap(MsgUnitPathFind* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitPathFind* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitPathFind& from);
  void MergeFrom(const MsgUnitPathFind& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // required .Common.MsgPath itineraire = 2;
  inline bool has_itineraire() const;
  inline void clear_itineraire();
  static const int kItineraireFieldNumber = 2;
  inline const ::Common::MsgPath& itineraire() const;
  inline ::Common::MsgPath* mutable_itineraire();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  ::Common::MsgPath* itineraire_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitPathFind* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitDestruction : public ::google::protobuf::Message {
 public:
  MsgUnitDestruction();
  virtual ~MsgUnitDestruction();
  
  MsgUnitDestruction(const MsgUnitDestruction& from);
  
  inline MsgUnitDestruction& operator=(const MsgUnitDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitDestruction& default_instance();
  void Swap(MsgUnitDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitDestruction& from);
  void MergeFrom(const MsgUnitDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitEnvironmentType : public ::google::protobuf::Message {
 public:
  MsgUnitEnvironmentType();
  virtual ~MsgUnitEnvironmentType();
  
  MsgUnitEnvironmentType(const MsgUnitEnvironmentType& from);
  
  inline MsgUnitEnvironmentType& operator=(const MsgUnitEnvironmentType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitEnvironmentType& default_instance();
  void Swap(MsgUnitEnvironmentType* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitEnvironmentType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitEnvironmentType& from);
  void MergeFrom(const MsgUnitEnvironmentType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // required int32 area = 2;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 2;
  inline ::google::protobuf::int32 area() const;
  inline void set_area(::google::protobuf::int32 value);
  
  // required int32 left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required int32 right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required int32 linear = 5;
  inline bool has_linear() const;
  inline void clear_linear();
  static const int kLinearFieldNumber = 5;
  inline ::google::protobuf::int32 linear() const;
  inline void set_linear(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  ::google::protobuf::int32 area_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 linear_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitEnvironmentType* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgUnitKnowledgeCreation();
  virtual ~MsgUnitKnowledgeCreation();
  
  MsgUnitKnowledgeCreation(const MsgUnitKnowledgeCreation& from);
  
  inline MsgUnitKnowledgeCreation& operator=(const MsgUnitKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitKnowledgeCreation& default_instance();
  void Swap(MsgUnitKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitKnowledgeCreation& from);
  void MergeFrom(const MsgUnitKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitKnowledgeId& id() const;
  inline ::Common::UnitKnowledgeId* mutable_id();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .Common.UnitId unit = 3;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 3;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required .Common.UnitType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::Common::UnitType& type() const;
  inline ::Common::UnitType* mutable_type();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitKnowledgeId* id_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::UnitId* unit_;
  ::Common::UnitType* type_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class AutomatPerception : public ::google::protobuf::Message {
 public:
  AutomatPerception();
  virtual ~AutomatPerception();
  
  AutomatPerception(const AutomatPerception& from);
  
  inline AutomatPerception& operator=(const AutomatPerception& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AutomatPerception& default_instance();
  void Swap(AutomatPerception* other);
  
  // implements Message ----------------------------------------------
  
  AutomatPerception* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutomatPerception& from);
  void MergeFrom(const AutomatPerception& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId automat = 1;
  inline bool has_automat() const;
  inline void clear_automat();
  static const int kAutomatFieldNumber = 1;
  inline const ::Common::AutomatId& automat() const;
  inline ::Common::AutomatId* mutable_automat();
  
  // required .MsgsSimToClient.EnumUnitIdentificationLevel identification_level = 2;
  inline bool has_identification_level() const;
  inline void clear_identification_level();
  static const int kIdentificationLevelFieldNumber = 2;
  inline MsgsSimToClient::EnumUnitIdentificationLevel identification_level() const;
  inline void set_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* automat_;
  int identification_level_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AutomatPerception* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfAutomatPerception : public ::google::protobuf::Message {
 public:
  SeqOfAutomatPerception();
  virtual ~SeqOfAutomatPerception();
  
  SeqOfAutomatPerception(const SeqOfAutomatPerception& from);
  
  inline SeqOfAutomatPerception& operator=(const SeqOfAutomatPerception& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfAutomatPerception& default_instance();
  void Swap(SeqOfAutomatPerception* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfAutomatPerception* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfAutomatPerception& from);
  void MergeFrom(const SeqOfAutomatPerception& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.AutomatPerception elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception >* mutable_elem();
  inline const ::MsgsSimToClient::AutomatPerception& elem(int index) const;
  inline ::MsgsSimToClient::AutomatPerception* mutable_elem(int index);
  inline ::MsgsSimToClient::AutomatPerception* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfAutomatPerception* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgUnitKnowledgeUpdate();
  virtual ~MsgUnitKnowledgeUpdate();
  
  MsgUnitKnowledgeUpdate(const MsgUnitKnowledgeUpdate& from);
  
  inline MsgUnitKnowledgeUpdate& operator=(const MsgUnitKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitKnowledgeUpdate& default_instance();
  void Swap(MsgUnitKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitKnowledgeUpdate& from);
  void MergeFrom(const MsgUnitKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitKnowledgeId& id() const;
  inline ::Common::UnitKnowledgeId* mutable_id();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional int32 pertinence = 3 [default = 0];
  inline bool has_pertinence() const;
  inline void clear_pertinence();
  static const int kPertinenceFieldNumber = 3;
  inline ::google::protobuf::int32 pertinence() const;
  inline void set_pertinence(::google::protobuf::int32 value);
  
  // optional .MsgsSimToClient.EnumUnitIdentificationLevel identification_level = 4;
  inline bool has_identification_level() const;
  inline void clear_identification_level();
  static const int kIdentificationLevelFieldNumber = 4;
  inline MsgsSimToClient::EnumUnitIdentificationLevel identification_level() const;
  inline void set_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value);
  
  // optional .MsgsSimToClient.EnumUnitIdentificationLevel max_identification_level = 5;
  inline bool has_max_identification_level() const;
  inline void clear_max_identification_level();
  static const int kMaxIdentificationLevelFieldNumber = 5;
  inline MsgsSimToClient::EnumUnitIdentificationLevel max_identification_level() const;
  inline void set_max_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value);
  
  // optional int32 etat_op = 6 [default = 0];
  inline bool has_etat_op() const;
  inline void clear_etat_op();
  static const int kEtatOpFieldNumber = 6;
  inline ::google::protobuf::int32 etat_op() const;
  inline void set_etat_op(::google::protobuf::int32 value);
  
  // optional bool mort = 7 [default = false];
  inline bool has_mort() const;
  inline void clear_mort();
  static const int kMortFieldNumber = 7;
  inline bool mort() const;
  inline void set_mort(bool value);
  
  // optional .Common.MsgCoordLatLong position = 8;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 8;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
  // optional .Common.MsgHeading direction = 9;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 9;
  inline const ::Common::MsgHeading& direction() const;
  inline ::Common::MsgHeading* mutable_direction();
  
  // optional int32 speed = 10 [default = 0];
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 10;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);
  
  // optional .Common.PartyId party = 11;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 11;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional bool nature_pc = 12 [default = false];
  inline bool has_nature_pc() const;
  inline void clear_nature_pc();
  static const int kNaturePcFieldNumber = 12;
  inline bool nature_pc() const;
  inline void set_nature_pc(bool value);
  
  // optional .MsgsSimToClient.SeqOfAutomatPerception perception_par_compagnie = 13;
  inline bool has_perception_par_compagnie() const;
  inline void clear_perception_par_compagnie();
  static const int kPerceptionParCompagnieFieldNumber = 13;
  inline const ::MsgsSimToClient::SeqOfAutomatPerception& perception_par_compagnie() const;
  inline ::MsgsSimToClient::SeqOfAutomatPerception* mutable_perception_par_compagnie();
  
  // optional .Common.UnitId surrendered_unit = 14;
  inline bool has_surrendered_unit() const;
  inline void clear_surrendered_unit();
  static const int kSurrenderedUnitFieldNumber = 14;
  inline const ::Common::UnitId& surrendered_unit() const;
  inline ::Common::UnitId* mutable_surrendered_unit();
  
  // optional bool prisonnier = 15 [default = false];
  inline bool has_prisonnier() const;
  inline void clear_prisonnier();
  static const int kPrisonnierFieldNumber = 15;
  inline bool prisonnier() const;
  inline void set_prisonnier(bool value);
  
  // optional bool refugie_pris_en_compte = 16 [default = false];
  inline bool has_refugie_pris_en_compte() const;
  inline void clear_refugie_pris_en_compte();
  static const int kRefugiePrisEnCompteFieldNumber = 16;
  inline bool refugie_pris_en_compte() const;
  inline void set_refugie_pris_en_compte(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitKnowledgeId* id_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::google::protobuf::int32 pertinence_;
  int identification_level_;
  int max_identification_level_;
  ::google::protobuf::int32 etat_op_;
  bool mort_;
  ::Common::MsgCoordLatLong* position_;
  ::Common::MsgHeading* direction_;
  ::google::protobuf::int32 speed_;
  ::Common::PartyId* party_;
  bool nature_pc_;
  ::MsgsSimToClient::SeqOfAutomatPerception* perception_par_compagnie_;
  ::Common::UnitId* surrendered_unit_;
  bool prisonnier_;
  bool refugie_pris_en_compte_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgUnitKnowledgeDestruction();
  virtual ~MsgUnitKnowledgeDestruction();
  
  MsgUnitKnowledgeDestruction(const MsgUnitKnowledgeDestruction& from);
  
  inline MsgUnitKnowledgeDestruction& operator=(const MsgUnitKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitKnowledgeDestruction& default_instance();
  void Swap(MsgUnitKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitKnowledgeDestruction& from);
  void MergeFrom(const MsgUnitKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitKnowledgeId& id() const;
  inline ::Common::UnitKnowledgeId* mutable_id();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitKnowledgeId* id_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgStartUnitFire_target : public ::google::protobuf::Message {
 public:
  MsgStartUnitFire_target();
  virtual ~MsgStartUnitFire_target();
  
  MsgStartUnitFire_target(const MsgStartUnitFire_target& from);
  
  inline MsgStartUnitFire_target& operator=(const MsgStartUnitFire_target& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStartUnitFire_target& default_instance();
  void Swap(MsgStartUnitFire_target* other);
  
  // implements Message ----------------------------------------------
  
  MsgStartUnitFire_target* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStartUnitFire_target& from);
  void MergeFrom(const MsgStartUnitFire_target& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.UnitId unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // optional .Common.PopulationId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& population() const;
  inline ::Common::PopulationId* mutable_population();
  
  // optional .Common.MsgCoordLatLong position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* unit_;
  ::Common::PopulationId* population_;
  ::Common::MsgCoordLatLong* position_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStartUnitFire_target* default_instance_;
};
// -------------------------------------------------------------------

class MsgStartUnitFire : public ::google::protobuf::Message {
 public:
  MsgStartUnitFire();
  virtual ~MsgStartUnitFire();
  
  MsgStartUnitFire(const MsgStartUnitFire& from);
  
  inline MsgStartUnitFire& operator=(const MsgStartUnitFire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStartUnitFire& default_instance();
  void Swap(MsgStartUnitFire* other);
  
  // implements Message ----------------------------------------------
  
  MsgStartUnitFire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStartUnitFire& from);
  void MergeFrom(const MsgStartUnitFire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::FireId& id() const;
  inline ::Common::FireId* mutable_id();
  
  // required .Common.UnitId firing_unit = 2;
  inline bool has_firing_unit() const;
  inline void clear_firing_unit();
  static const int kFiringUnitFieldNumber = 2;
  inline const ::Common::UnitId& firing_unit() const;
  inline ::Common::UnitId* mutable_firing_unit();
  
  // required .MsgsSimToClient.MsgStartUnitFire_target target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgStartUnitFire_target& target() const;
  inline ::MsgsSimToClient::MsgStartUnitFire_target* mutable_target();
  
  // required .Common.MsgStartUnitFire_type type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline Common::MsgStartUnitFire_type type() const;
  inline void set_type(Common::MsgStartUnitFire_type value);
  
  // optional .Common.ResourceType ammunition = 5;
  inline bool has_ammunition() const;
  inline void clear_ammunition();
  static const int kAmmunitionFieldNumber = 5;
  inline const ::Common::ResourceType& ammunition() const;
  inline ::Common::ResourceType* mutable_ammunition();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireId* id_;
  ::Common::UnitId* firing_unit_;
  ::MsgsSimToClient::MsgStartUnitFire_target* target_;
  int type_;
  ::Common::ResourceType* ammunition_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStartUnitFire* default_instance_;
};
// -------------------------------------------------------------------

class UnitHumanFireDamage : public ::google::protobuf::Message {
 public:
  UnitHumanFireDamage();
  virtual ~UnitHumanFireDamage();
  
  UnitHumanFireDamage(const UnitHumanFireDamage& from);
  
  inline UnitHumanFireDamage& operator=(const UnitHumanFireDamage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitHumanFireDamage& default_instance();
  void Swap(UnitHumanFireDamage* other);
  
  // implements Message ----------------------------------------------
  
  UnitHumanFireDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitHumanFireDamage& from);
  void MergeFrom(const UnitHumanFireDamage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EnumHumanRank rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline Common::EnumHumanRank rank() const;
  inline void set_rank(Common::EnumHumanRank value);
  
  // required int32 alive_nbr = 2;
  inline bool has_alive_nbr() const;
  inline void clear_alive_nbr();
  static const int kAliveNbrFieldNumber = 2;
  inline ::google::protobuf::int32 alive_nbr() const;
  inline void set_alive_nbr(::google::protobuf::int32 value);
  
  // required int32 dead_nbr = 3;
  inline bool has_dead_nbr() const;
  inline void clear_dead_nbr();
  static const int kDeadNbrFieldNumber = 3;
  inline ::google::protobuf::int32 dead_nbr() const;
  inline void set_dead_nbr(::google::protobuf::int32 value);
  
  // required int32 wounded_u1_nbr = 4;
  inline bool has_wounded_u1_nbr() const;
  inline void clear_wounded_u1_nbr();
  static const int kWoundedU1NbrFieldNumber = 4;
  inline ::google::protobuf::int32 wounded_u1_nbr() const;
  inline void set_wounded_u1_nbr(::google::protobuf::int32 value);
  
  // required int32 wounded_u2_nbr = 5;
  inline bool has_wounded_u2_nbr() const;
  inline void clear_wounded_u2_nbr();
  static const int kWoundedU2NbrFieldNumber = 5;
  inline ::google::protobuf::int32 wounded_u2_nbr() const;
  inline void set_wounded_u2_nbr(::google::protobuf::int32 value);
  
  // required int32 wounded_u3_nbr = 6;
  inline bool has_wounded_u3_nbr() const;
  inline void clear_wounded_u3_nbr();
  static const int kWoundedU3NbrFieldNumber = 6;
  inline ::google::protobuf::int32 wounded_u3_nbr() const;
  inline void set_wounded_u3_nbr(::google::protobuf::int32 value);
  
  // required int32 wounded_ue_nbr = 7;
  inline bool has_wounded_ue_nbr() const;
  inline void clear_wounded_ue_nbr();
  static const int kWoundedUeNbrFieldNumber = 7;
  inline ::google::protobuf::int32 wounded_ue_nbr() const;
  inline void set_wounded_ue_nbr(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int rank_;
  ::google::protobuf::int32 alive_nbr_;
  ::google::protobuf::int32 dead_nbr_;
  ::google::protobuf::int32 wounded_u1_nbr_;
  ::google::protobuf::int32 wounded_u2_nbr_;
  ::google::protobuf::int32 wounded_u3_nbr_;
  ::google::protobuf::int32 wounded_ue_nbr_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UnitHumanFireDamage* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfUnitHumanFireDamage : public ::google::protobuf::Message {
 public:
  SeqOfUnitHumanFireDamage();
  virtual ~SeqOfUnitHumanFireDamage();
  
  SeqOfUnitHumanFireDamage(const SeqOfUnitHumanFireDamage& from);
  
  inline SeqOfUnitHumanFireDamage& operator=(const SeqOfUnitHumanFireDamage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfUnitHumanFireDamage& default_instance();
  void Swap(SeqOfUnitHumanFireDamage* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfUnitHumanFireDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfUnitHumanFireDamage& from);
  void MergeFrom(const SeqOfUnitHumanFireDamage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.UnitHumanFireDamage elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage >* mutable_elem();
  inline const ::MsgsSimToClient::UnitHumanFireDamage& elem(int index) const;
  inline ::MsgsSimToClient::UnitHumanFireDamage* mutable_elem(int index);
  inline ::MsgsSimToClient::UnitHumanFireDamage* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfUnitHumanFireDamage* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitEquipmentFireDamage : public ::google::protobuf::Message {
 public:
  MsgUnitEquipmentFireDamage();
  virtual ~MsgUnitEquipmentFireDamage();
  
  MsgUnitEquipmentFireDamage(const MsgUnitEquipmentFireDamage& from);
  
  inline MsgUnitEquipmentFireDamage& operator=(const MsgUnitEquipmentFireDamage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitEquipmentFireDamage& default_instance();
  void Swap(MsgUnitEquipmentFireDamage* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitEquipmentFireDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitEquipmentFireDamage& from);
  void MergeFrom(const MsgUnitEquipmentFireDamage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.EquipmentType equipement_type = 1;
  inline bool has_equipement_type() const;
  inline void clear_equipement_type();
  static const int kEquipementTypeFieldNumber = 1;
  inline const ::Common::EquipmentType& equipement_type() const;
  inline ::Common::EquipmentType* mutable_equipement_type();
  
  // required uint32 available_nbr = 2;
  inline bool has_available_nbr() const;
  inline void clear_available_nbr();
  static const int kAvailableNbrFieldNumber = 2;
  inline ::google::protobuf::uint32 available_nbr() const;
  inline void set_available_nbr(::google::protobuf::uint32 value);
  
  // required uint32 unavailable_nbr = 3;
  inline bool has_unavailable_nbr() const;
  inline void clear_unavailable_nbr();
  static const int kUnavailableNbrFieldNumber = 3;
  inline ::google::protobuf::uint32 unavailable_nbr() const;
  inline void set_unavailable_nbr(::google::protobuf::uint32 value);
  
  // required uint32 repairable_nbr = 4;
  inline bool has_repairable_nbr() const;
  inline void clear_repairable_nbr();
  static const int kRepairableNbrFieldNumber = 4;
  inline ::google::protobuf::uint32 repairable_nbr() const;
  inline void set_repairable_nbr(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::EquipmentType* equipement_type_;
  ::google::protobuf::uint32 available_nbr_;
  ::google::protobuf::uint32 unavailable_nbr_;
  ::google::protobuf::uint32 repairable_nbr_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitEquipmentFireDamage* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfUnitEquipmentFireDamage : public ::google::protobuf::Message {
 public:
  SeqOfUnitEquipmentFireDamage();
  virtual ~SeqOfUnitEquipmentFireDamage();
  
  SeqOfUnitEquipmentFireDamage(const SeqOfUnitEquipmentFireDamage& from);
  
  inline SeqOfUnitEquipmentFireDamage& operator=(const SeqOfUnitEquipmentFireDamage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfUnitEquipmentFireDamage& default_instance();
  void Swap(SeqOfUnitEquipmentFireDamage* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfUnitEquipmentFireDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfUnitEquipmentFireDamage& from);
  void MergeFrom(const SeqOfUnitEquipmentFireDamage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgUnitEquipmentFireDamage elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage >* mutable_elem();
  inline const ::MsgsSimToClient::MsgUnitEquipmentFireDamage& elem(int index) const;
  inline ::MsgsSimToClient::MsgUnitEquipmentFireDamage* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgUnitEquipmentFireDamage* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfUnitEquipmentFireDamage* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitFireDamages : public ::google::protobuf::Message {
 public:
  MsgUnitFireDamages();
  virtual ~MsgUnitFireDamages();
  
  MsgUnitFireDamages(const MsgUnitFireDamages& from);
  
  inline MsgUnitFireDamages& operator=(const MsgUnitFireDamages& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitFireDamages& default_instance();
  void Swap(MsgUnitFireDamages* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitFireDamages* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitFireDamages& from);
  void MergeFrom(const MsgUnitFireDamages& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::Common::UnitId& target() const;
  inline ::Common::UnitId* mutable_target();
  
  // required .MsgsSimToClient.SeqOfUnitHumanFireDamage humans = 2;
  inline bool has_humans() const;
  inline void clear_humans();
  static const int kHumansFieldNumber = 2;
  inline const ::MsgsSimToClient::SeqOfUnitHumanFireDamage& humans() const;
  inline ::MsgsSimToClient::SeqOfUnitHumanFireDamage* mutable_humans();
  
  // required .MsgsSimToClient.SeqOfUnitEquipmentFireDamage equipments = 3;
  inline bool has_equipments() const;
  inline void clear_equipments();
  static const int kEquipmentsFieldNumber = 3;
  inline const ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage& equipments() const;
  inline ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage* mutable_equipments();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* target_;
  ::MsgsSimToClient::SeqOfUnitHumanFireDamage* humans_;
  ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage* equipments_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitFireDamages* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitsFireDamages : public ::google::protobuf::Message {
 public:
  MsgUnitsFireDamages();
  virtual ~MsgUnitsFireDamages();
  
  MsgUnitsFireDamages(const MsgUnitsFireDamages& from);
  
  inline MsgUnitsFireDamages& operator=(const MsgUnitsFireDamages& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitsFireDamages& default_instance();
  void Swap(MsgUnitsFireDamages* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitsFireDamages* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitsFireDamages& from);
  void MergeFrom(const MsgUnitsFireDamages& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgUnitFireDamages elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages >* mutable_elem();
  inline const ::MsgsSimToClient::MsgUnitFireDamages& elem(int index) const;
  inline ::MsgsSimToClient::MsgUnitFireDamages* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgUnitFireDamages* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitsFireDamages* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationFireDamages : public ::google::protobuf::Message {
 public:
  MsgPopulationFireDamages();
  virtual ~MsgPopulationFireDamages();
  
  MsgPopulationFireDamages(const MsgPopulationFireDamages& from);
  
  inline MsgPopulationFireDamages& operator=(const MsgPopulationFireDamages& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationFireDamages& default_instance();
  void Swap(MsgPopulationFireDamages* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationFireDamages* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationFireDamages& from);
  void MergeFrom(const MsgPopulationFireDamages& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationId target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::Common::PopulationId& target() const;
  inline ::Common::PopulationId* mutable_target();
  
  // required int32 dead_nbr = 2;
  inline bool has_dead_nbr() const;
  inline void clear_dead_nbr();
  static const int kDeadNbrFieldNumber = 2;
  inline ::google::protobuf::int32 dead_nbr() const;
  inline void set_dead_nbr(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationId* target_;
  ::google::protobuf::int32 dead_nbr_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationFireDamages* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationsFireDamages : public ::google::protobuf::Message {
 public:
  MsgPopulationsFireDamages();
  virtual ~MsgPopulationsFireDamages();
  
  MsgPopulationsFireDamages(const MsgPopulationsFireDamages& from);
  
  inline MsgPopulationsFireDamages& operator=(const MsgPopulationsFireDamages& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationsFireDamages& default_instance();
  void Swap(MsgPopulationsFireDamages* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationsFireDamages* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationsFireDamages& from);
  void MergeFrom(const MsgPopulationsFireDamages& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgPopulationFireDamages elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgPopulationFireDamages >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgPopulationFireDamages >* mutable_elem();
  inline const ::MsgsSimToClient::MsgPopulationFireDamages& elem(int index) const;
  inline ::MsgsSimToClient::MsgPopulationFireDamages* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgPopulationFireDamages* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgPopulationFireDamages > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationsFireDamages* default_instance_;
};
// -------------------------------------------------------------------

class MsgStopUnitFire : public ::google::protobuf::Message {
 public:
  MsgStopUnitFire();
  virtual ~MsgStopUnitFire();
  
  MsgStopUnitFire(const MsgStopUnitFire& from);
  
  inline MsgStopUnitFire& operator=(const MsgStopUnitFire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStopUnitFire& default_instance();
  void Swap(MsgStopUnitFire* other);
  
  // implements Message ----------------------------------------------
  
  MsgStopUnitFire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStopUnitFire& from);
  void MergeFrom(const MsgStopUnitFire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::FireId& id() const;
  inline ::Common::FireId* mutable_id();
  
  // optional .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
  inline bool has_units_damages() const;
  inline void clear_units_damages();
  static const int kUnitsDamagesFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgUnitsFireDamages& units_damages() const;
  inline ::MsgsSimToClient::MsgUnitsFireDamages* mutable_units_damages();
  
  // optional .MsgsSimToClient.MsgPopulationsFireDamages populations_damages = 3;
  inline bool has_populations_damages() const;
  inline void clear_populations_damages();
  static const int kPopulationsDamagesFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgPopulationsFireDamages& populations_damages() const;
  inline ::MsgsSimToClient::MsgPopulationsFireDamages* mutable_populations_damages();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireId* id_;
  ::MsgsSimToClient::MsgUnitsFireDamages* units_damages_;
  ::MsgsSimToClient::MsgPopulationsFireDamages* populations_damages_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStopUnitFire* default_instance_;
};
// -------------------------------------------------------------------

class MsgStartPopulationFire : public ::google::protobuf::Message {
 public:
  MsgStartPopulationFire();
  virtual ~MsgStartPopulationFire();
  
  MsgStartPopulationFire(const MsgStartPopulationFire& from);
  
  inline MsgStartPopulationFire& operator=(const MsgStartPopulationFire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStartPopulationFire& default_instance();
  void Swap(MsgStartPopulationFire* other);
  
  // implements Message ----------------------------------------------
  
  MsgStartPopulationFire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStartPopulationFire& from);
  void MergeFrom(const MsgStartPopulationFire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::FireId& id() const;
  inline ::Common::FireId* mutable_id();
  
  // required .Common.PopulationId firing_population = 2;
  inline bool has_firing_population() const;
  inline void clear_firing_population();
  static const int kFiringPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& firing_population() const;
  inline ::Common::PopulationId* mutable_firing_population();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireId* id_;
  ::Common::PopulationId* firing_population_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStartPopulationFire* default_instance_;
};
// -------------------------------------------------------------------

class MsgStopPopulationFire : public ::google::protobuf::Message {
 public:
  MsgStopPopulationFire();
  virtual ~MsgStopPopulationFire();
  
  MsgStopPopulationFire(const MsgStopPopulationFire& from);
  
  inline MsgStopPopulationFire& operator=(const MsgStopPopulationFire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStopPopulationFire& default_instance();
  void Swap(MsgStopPopulationFire* other);
  
  // implements Message ----------------------------------------------
  
  MsgStopPopulationFire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStopPopulationFire& from);
  void MergeFrom(const MsgStopPopulationFire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::FireId& id() const;
  inline ::Common::FireId* mutable_id();
  
  // required .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
  inline bool has_units_damages() const;
  inline void clear_units_damages();
  static const int kUnitsDamagesFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgUnitsFireDamages& units_damages() const;
  inline ::MsgsSimToClient::MsgUnitsFireDamages* mutable_units_damages();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireId* id_;
  ::MsgsSimToClient::MsgUnitsFireDamages* units_damages_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStopPopulationFire* default_instance_;
};
// -------------------------------------------------------------------

class MsgExplosion : public ::google::protobuf::Message {
 public:
  MsgExplosion();
  virtual ~MsgExplosion();
  
  MsgExplosion(const MsgExplosion& from);
  
  inline MsgExplosion& operator=(const MsgExplosion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgExplosion& default_instance();
  void Swap(MsgExplosion* other);
  
  // implements Message ----------------------------------------------
  
  MsgExplosion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgExplosion& from);
  void MergeFrom(const MsgExplosion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ObjectId& id() const;
  inline ::Common::ObjectId* mutable_id();
  
  // optional .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
  inline bool has_units_damages() const;
  inline void clear_units_damages();
  static const int kUnitsDamagesFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgUnitsFireDamages& units_damages() const;
  inline ::MsgsSimToClient::MsgUnitsFireDamages* mutable_units_damages();
  
  // optional .MsgsSimToClient.MsgPopulationsFireDamages populations_damages = 3;
  inline bool has_populations_damages() const;
  inline void clear_populations_damages();
  static const int kPopulationsDamagesFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgPopulationsFireDamages& populations_damages() const;
  inline ::MsgsSimToClient::MsgPopulationsFireDamages* mutable_populations_damages();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectId* id_;
  ::MsgsSimToClient::MsgUnitsFireDamages* units_damages_;
  ::MsgsSimToClient::MsgPopulationsFireDamages* populations_damages_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgExplosion* default_instance_;
};
// -------------------------------------------------------------------

class MsgStartFireEffect : public ::google::protobuf::Message {
 public:
  MsgStartFireEffect();
  virtual ~MsgStartFireEffect();
  
  MsgStartFireEffect(const MsgStartFireEffect& from);
  
  inline MsgStartFireEffect& operator=(const MsgStartFireEffect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStartFireEffect& default_instance();
  void Swap(MsgStartFireEffect* other);
  
  // implements Message ----------------------------------------------
  
  MsgStartFireEffect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStartFireEffect& from);
  void MergeFrom(const MsgStartFireEffect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireEffectId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::FireEffectId& id() const;
  inline ::Common::FireEffectId* mutable_id();
  
  // required .Common.MsgLocation location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // required .Common.EnumFireEffectType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline Common::EnumFireEffectType type() const;
  inline void set_type(Common::EnumFireEffectType value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireEffectId* id_;
  ::Common::MsgLocation* location_;
  int type_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStartFireEffect* default_instance_;
};
// -------------------------------------------------------------------

class MsgStopFireEffect : public ::google::protobuf::Message {
 public:
  MsgStopFireEffect();
  virtual ~MsgStopFireEffect();
  
  MsgStopFireEffect(const MsgStopFireEffect& from);
  
  inline MsgStopFireEffect& operator=(const MsgStopFireEffect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgStopFireEffect& default_instance();
  void Swap(MsgStopFireEffect* other);
  
  // implements Message ----------------------------------------------
  
  MsgStopFireEffect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgStopFireEffect& from);
  void MergeFrom(const MsgStopFireEffect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.FireEffectId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::FireEffectId& id() const;
  inline ::Common::FireEffectId* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::FireEffectId* id_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgStopFireEffect* default_instance_;
};
// -------------------------------------------------------------------

class MsgReport : public ::google::protobuf::Message {
 public:
  MsgReport();
  virtual ~MsgReport();
  
  MsgReport(const MsgReport& from);
  
  inline MsgReport& operator=(const MsgReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReport& default_instance();
  void Swap(MsgReport* other);
  
  // implements Message ----------------------------------------------
  
  MsgReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgReport& from);
  void MergeFrom(const MsgReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ReportId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ReportId& id() const;
  inline ::Common::ReportId* mutable_id();
  
  // required .Common.Tasker cr = 2;
  inline bool has_cr() const;
  inline void clear_cr();
  static const int kCrFieldNumber = 2;
  inline const ::Common::Tasker& cr() const;
  inline ::Common::Tasker* mutable_cr();
  
  // required .Common.ReportType cr_oid = 3;
  inline bool has_cr_oid() const;
  inline void clear_cr_oid();
  static const int kCrOidFieldNumber = 3;
  inline const ::Common::ReportType& cr_oid() const;
  inline ::Common::ReportType* mutable_cr_oid();
  
  // required .MsgsSimToClient.EnumReportType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline MsgsSimToClient::EnumReportType type() const;
  inline void set_type(MsgsSimToClient::EnumReportType value);
  
  // required .Common.MsgDateTime time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::Common::MsgDateTime& time() const;
  inline ::Common::MsgDateTime* mutable_time();
  
  // optional .Common.MsgMissionParameters parametres = 6;
  inline bool has_parametres() const;
  inline void clear_parametres();
  static const int kParametresFieldNumber = 6;
  inline const ::Common::MsgMissionParameters& parametres() const;
  inline ::Common::MsgMissionParameters* mutable_parametres();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ReportId* id_;
  ::Common::Tasker* cr_;
  ::Common::ReportType* cr_oid_;
  int type_;
  ::Common::MsgDateTime* time_;
  ::Common::MsgMissionParameters* parametres_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgReport* default_instance_;
};
// -------------------------------------------------------------------

class MsgInvalidateReport : public ::google::protobuf::Message {
 public:
  MsgInvalidateReport();
  virtual ~MsgInvalidateReport();
  
  MsgInvalidateReport(const MsgInvalidateReport& from);
  
  inline MsgInvalidateReport& operator=(const MsgInvalidateReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgInvalidateReport& default_instance();
  void Swap(MsgInvalidateReport* other);
  
  // implements Message ----------------------------------------------
  
  MsgInvalidateReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgInvalidateReport& from);
  void MergeFrom(const MsgInvalidateReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ReportId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ReportId& id() const;
  inline ::Common::ReportId* mutable_id();
  
  // required .Common.Tasker source = 2;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 2;
  inline const ::Common::Tasker& source() const;
  inline ::Common::Tasker* mutable_source();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ReportId* id_;
  ::Common::Tasker* source_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgInvalidateReport* default_instance_;
};
// -------------------------------------------------------------------

class MsgTrace : public ::google::protobuf::Message {
 public:
  MsgTrace();
  virtual ~MsgTrace();
  
  MsgTrace(const MsgTrace& from);
  
  inline MsgTrace& operator=(const MsgTrace& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTrace& default_instance();
  void Swap(MsgTrace* other);
  
  // implements Message ----------------------------------------------
  
  MsgTrace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgTrace& from);
  void MergeFrom(const MsgTrace& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.Tasker source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::Common::Tasker& source() const;
  inline ::Common::Tasker* mutable_source();
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::Tasker* source_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgTrace* default_instance_;
};
// -------------------------------------------------------------------

class MsgDecisionalState : public ::google::protobuf::Message {
 public:
  MsgDecisionalState();
  virtual ~MsgDecisionalState();
  
  MsgDecisionalState(const MsgDecisionalState& from);
  
  inline MsgDecisionalState& operator=(const MsgDecisionalState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDecisionalState& default_instance();
  void Swap(MsgDecisionalState* other);
  
  // implements Message ----------------------------------------------
  
  MsgDecisionalState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgDecisionalState& from);
  void MergeFrom(const MsgDecisionalState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.Tasker id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::Tasker& id() const;
  inline ::Common::Tasker* mutable_id();
  
  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // required string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::Tasker* id_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgDecisionalState* default_instance_;
};
// -------------------------------------------------------------------

class MsgDebugPoints : public ::google::protobuf::Message {
 public:
  MsgDebugPoints();
  virtual ~MsgDebugPoints();
  
  MsgDebugPoints(const MsgDebugPoints& from);
  
  inline MsgDebugPoints& operator=(const MsgDebugPoints& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDebugPoints& default_instance();
  void Swap(MsgDebugPoints* other);
  
  // implements Message ----------------------------------------------
  
  MsgDebugPoints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgDebugPoints& from);
  void MergeFrom(const MsgDebugPoints& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.Tasker id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::Tasker& id() const;
  inline ::Common::Tasker* mutable_id();
  
  // required .Common.MsgCoordLatLongList coordinates = 2;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 2;
  inline const ::Common::MsgCoordLatLongList& coordinates() const;
  inline ::Common::MsgCoordLatLongList* mutable_coordinates();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::Tasker* id_;
  ::Common::MsgCoordLatLongList* coordinates_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgDebugPoints* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfHeading : public ::google::protobuf::Message {
 public:
  SeqOfHeading();
  virtual ~SeqOfHeading();
  
  SeqOfHeading(const SeqOfHeading& from);
  
  inline SeqOfHeading& operator=(const SeqOfHeading& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfHeading& default_instance();
  void Swap(SeqOfHeading* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfHeading* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfHeading& from);
  void MergeFrom(const SeqOfHeading& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Common.MsgHeading elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading >* mutable_elem();
  inline const ::Common::MsgHeading& elem(int index) const;
  inline ::Common::MsgHeading* mutable_elem(int index);
  inline ::Common::MsgHeading* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfHeading* default_instance_;
};
// -------------------------------------------------------------------

class MsgVisionCone : public ::google::protobuf::Message {
 public:
  MsgVisionCone();
  virtual ~MsgVisionCone();
  
  MsgVisionCone(const MsgVisionCone& from);
  
  inline MsgVisionCone& operator=(const MsgVisionCone& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgVisionCone& default_instance();
  void Swap(MsgVisionCone* other);
  
  // implements Message ----------------------------------------------
  
  MsgVisionCone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgVisionCone& from);
  void MergeFrom(const MsgVisionCone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MsgCoordLatLong origin = 1;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 1;
  inline const ::Common::MsgCoordLatLong& origin() const;
  inline ::Common::MsgCoordLatLong* mutable_origin();
  
  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // required string sensor = 3;
  inline bool has_sensor() const;
  inline void clear_sensor();
  static const int kSensorFieldNumber = 3;
  inline const ::std::string& sensor() const;
  inline void set_sensor(const ::std::string& value);
  inline void set_sensor(const char* value);
  inline void set_sensor(const char* value, size_t size);
  inline ::std::string* mutable_sensor();
  
  // required .MsgsSimToClient.SeqOfHeading directions = 4;
  inline bool has_directions() const;
  inline void clear_directions();
  static const int kDirectionsFieldNumber = 4;
  inline const ::MsgsSimToClient::SeqOfHeading& directions() const;
  inline ::MsgsSimToClient::SeqOfHeading* mutable_directions();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MsgCoordLatLong* origin_;
  ::google::protobuf::int32 height_;
  ::std::string* sensor_;
  static const ::std::string _default_sensor_;
  ::MsgsSimToClient::SeqOfHeading* directions_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgVisionCone* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfVisionCone : public ::google::protobuf::Message {
 public:
  SeqOfVisionCone();
  virtual ~SeqOfVisionCone();
  
  SeqOfVisionCone(const SeqOfVisionCone& from);
  
  inline SeqOfVisionCone& operator=(const SeqOfVisionCone& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfVisionCone& default_instance();
  void Swap(SeqOfVisionCone* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfVisionCone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfVisionCone& from);
  void MergeFrom(const SeqOfVisionCone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgVisionCone elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone >* mutable_elem();
  inline const ::MsgsSimToClient::MsgVisionCone& elem(int index) const;
  inline ::MsgsSimToClient::MsgVisionCone* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgVisionCone* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfVisionCone* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitVisionCones : public ::google::protobuf::Message {
 public:
  MsgUnitVisionCones();
  virtual ~MsgUnitVisionCones();
  
  MsgUnitVisionCones(const MsgUnitVisionCones& from);
  
  inline MsgUnitVisionCones& operator=(const MsgUnitVisionCones& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitVisionCones& default_instance();
  void Swap(MsgUnitVisionCones* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitVisionCones* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitVisionCones& from);
  void MergeFrom(const MsgUnitVisionCones& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // required .MsgsSimToClient.SeqOfVisionCone cones = 2;
  inline bool has_cones() const;
  inline void clear_cones();
  static const int kConesFieldNumber = 2;
  inline const ::MsgsSimToClient::SeqOfVisionCone& cones() const;
  inline ::MsgsSimToClient::SeqOfVisionCone* mutable_cones();
  
  // required float elongation = 3;
  inline bool has_elongation() const;
  inline void clear_elongation();
  static const int kElongationFieldNumber = 3;
  inline float elongation() const;
  inline void set_elongation(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  ::MsgsSimToClient::SeqOfVisionCone* cones_;
  float elongation_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitVisionCones* default_instance_;
};
// -------------------------------------------------------------------

class MsgUnitDetection : public ::google::protobuf::Message {
 public:
  MsgUnitDetection();
  virtual ~MsgUnitDetection();
  
  MsgUnitDetection(const MsgUnitDetection& from);
  
  inline MsgUnitDetection& operator=(const MsgUnitDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUnitDetection& default_instance();
  void Swap(MsgUnitDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgUnitDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUnitDetection& from);
  void MergeFrom(const MsgUnitDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId observer = 1;
  inline bool has_observer() const;
  inline void clear_observer();
  static const int kObserverFieldNumber = 1;
  inline const ::Common::UnitId& observer() const;
  inline ::Common::UnitId* mutable_observer();
  
  // required .Common.UnitId detected_unit = 2;
  inline bool has_detected_unit() const;
  inline void clear_detected_unit();
  static const int kDetectedUnitFieldNumber = 2;
  inline const ::Common::UnitId& detected_unit() const;
  inline ::Common::UnitId* mutable_detected_unit();
  
  // required .Common.EnumUnitVisibility current_visibility = 3;
  inline bool has_current_visibility() const;
  inline void clear_current_visibility();
  static const int kCurrentVisibilityFieldNumber = 3;
  inline Common::EnumUnitVisibility current_visibility() const;
  inline void set_current_visibility(Common::EnumUnitVisibility value);
  
  // required .Common.EnumUnitVisibility max_visibility = 4;
  inline bool has_max_visibility() const;
  inline void clear_max_visibility();
  static const int kMaxVisibilityFieldNumber = 4;
  inline Common::EnumUnitVisibility max_visibility() const;
  inline void set_max_visibility(Common::EnumUnitVisibility value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* observer_;
  ::Common::UnitId* detected_unit_;
  int current_visibility_;
  int max_visibility_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUnitDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectDetection : public ::google::protobuf::Message {
 public:
  MsgObjectDetection();
  virtual ~MsgObjectDetection();
  
  MsgObjectDetection(const MsgObjectDetection& from);
  
  inline MsgObjectDetection& operator=(const MsgObjectDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectDetection& default_instance();
  void Swap(MsgObjectDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectDetection& from);
  void MergeFrom(const MsgObjectDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId observer = 1;
  inline bool has_observer() const;
  inline void clear_observer();
  static const int kObserverFieldNumber = 1;
  inline const ::Common::UnitId& observer() const;
  inline ::Common::UnitId* mutable_observer();
  
  // required .Common.ObjectId detected_object = 2;
  inline bool has_detected_object() const;
  inline void clear_detected_object();
  static const int kDetectedObjectFieldNumber = 2;
  inline const ::Common::ObjectId& detected_object() const;
  inline ::Common::ObjectId* mutable_detected_object();
  
  // required .Common.EnumUnitVisibility visibility = 3;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 3;
  inline Common::EnumUnitVisibility visibility() const;
  inline void set_visibility(Common::EnumUnitVisibility value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* observer_;
  ::Common::ObjectId* detected_object_;
  int visibility_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationConcentrationDetection : public ::google::protobuf::Message {
 public:
  MsgPopulationConcentrationDetection();
  virtual ~MsgPopulationConcentrationDetection();
  
  MsgPopulationConcentrationDetection(const MsgPopulationConcentrationDetection& from);
  
  inline MsgPopulationConcentrationDetection& operator=(const MsgPopulationConcentrationDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationConcentrationDetection& default_instance();
  void Swap(MsgPopulationConcentrationDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationConcentrationDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationConcentrationDetection& from);
  void MergeFrom(const MsgPopulationConcentrationDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // required .Common.PopulationId detected_population = 2;
  inline bool has_detected_population() const;
  inline void clear_detected_population();
  static const int kDetectedPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& detected_population() const;
  inline ::Common::PopulationId* mutable_detected_population();
  
  // required .Common.PopulationConcentrationId detected_concentration = 3;
  inline bool has_detected_concentration() const;
  inline void clear_detected_concentration();
  static const int kDetectedConcentrationFieldNumber = 3;
  inline const ::Common::PopulationConcentrationId& detected_concentration() const;
  inline ::Common::PopulationConcentrationId* mutable_detected_concentration();
  
  // required .Common.EnumUnitVisibility visibility = 4;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 4;
  inline Common::EnumUnitVisibility visibility() const;
  inline void set_visibility(Common::EnumUnitVisibility value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  ::Common::PopulationId* detected_population_;
  ::Common::PopulationConcentrationId* detected_concentration_;
  int visibility_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationConcentrationDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationFlowDetection : public ::google::protobuf::Message {
 public:
  MsgPopulationFlowDetection();
  virtual ~MsgPopulationFlowDetection();
  
  MsgPopulationFlowDetection(const MsgPopulationFlowDetection& from);
  
  inline MsgPopulationFlowDetection& operator=(const MsgPopulationFlowDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationFlowDetection& default_instance();
  void Swap(MsgPopulationFlowDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationFlowDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationFlowDetection& from);
  void MergeFrom(const MsgPopulationFlowDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // required .Common.PopulationId detected_population = 2;
  inline bool has_detected_population() const;
  inline void clear_detected_population();
  static const int kDetectedPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& detected_population() const;
  inline ::Common::PopulationId* mutable_detected_population();
  
  // required .Common.PopulationFlowId detected_flow = 3;
  inline bool has_detected_flow() const;
  inline void clear_detected_flow();
  static const int kDetectedFlowFieldNumber = 3;
  inline const ::Common::PopulationFlowId& detected_flow() const;
  inline ::Common::PopulationFlowId* mutable_detected_flow();
  
  // required .Common.MsgPath visible_flow = 4;
  inline bool has_visible_flow() const;
  inline void clear_visible_flow();
  static const int kVisibleFlowFieldNumber = 4;
  inline const ::Common::MsgPath& visible_flow() const;
  inline ::Common::MsgPath* mutable_visible_flow();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  ::Common::PopulationId* detected_population_;
  ::Common::PopulationFlowId* detected_flow_;
  ::Common::MsgPath* visible_flow_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationFlowDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectCreation : public ::google::protobuf::Message {
 public:
  MsgObjectCreation();
  virtual ~MsgObjectCreation();
  
  MsgObjectCreation(const MsgObjectCreation& from);
  
  inline MsgObjectCreation& operator=(const MsgObjectCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectCreation& default_instance();
  void Swap(MsgObjectCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectCreation& from);
  void MergeFrom(const MsgObjectCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ObjectId& id() const;
  inline ::Common::ObjectId* mutable_id();
  
  // required .Common.ObjectType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::ObjectType& type() const;
  inline ::Common::ObjectType* mutable_type();
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .Common.PartyId party = 4;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 4;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required .Common.MsgLocation location = 5;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 5;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // required .Common.MsgObjectAttributes attributes = 6;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 6;
  inline const ::Common::MsgObjectAttributes& attributes() const;
  inline ::Common::MsgObjectAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectId* id_;
  ::Common::ObjectType* type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::Common::PartyId* party_;
  ::Common::MsgLocation* location_;
  ::Common::MsgObjectAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectDestruction : public ::google::protobuf::Message {
 public:
  MsgObjectDestruction();
  virtual ~MsgObjectDestruction();
  
  MsgObjectDestruction(const MsgObjectDestruction& from);
  
  inline MsgObjectDestruction& operator=(const MsgObjectDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectDestruction& default_instance();
  void Swap(MsgObjectDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectDestruction& from);
  void MergeFrom(const MsgObjectDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ObjectId& id() const;
  inline ::Common::ObjectId* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectId* id_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectUpdate : public ::google::protobuf::Message {
 public:
  MsgObjectUpdate();
  virtual ~MsgObjectUpdate();
  
  MsgObjectUpdate(const MsgObjectUpdate& from);
  
  inline MsgObjectUpdate& operator=(const MsgObjectUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectUpdate& default_instance();
  void Swap(MsgObjectUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectUpdate& from);
  void MergeFrom(const MsgObjectUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ObjectId& id() const;
  inline ::Common::ObjectId* mutable_id();
  
  // optional .Common.MsgLocation location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // required .Common.MsgObjectAttributes attributes = 3;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  inline const ::Common::MsgObjectAttributes& attributes() const;
  inline ::Common::MsgObjectAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectId* id_;
  ::Common::MsgLocation* location_;
  ::Common::MsgObjectAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgObjectKnowledgeCreation();
  virtual ~MsgObjectKnowledgeCreation();
  
  MsgObjectKnowledgeCreation(const MsgObjectKnowledgeCreation& from);
  
  inline MsgObjectKnowledgeCreation& operator=(const MsgObjectKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectKnowledgeCreation& default_instance();
  void Swap(MsgObjectKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectKnowledgeCreation& from);
  void MergeFrom(const MsgObjectKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ObjectKnowledgeId& id() const;
  inline ::Common::ObjectKnowledgeId* mutable_id();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required .Common.ObjectId object = 3;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 3;
  inline const ::Common::ObjectId& object() const;
  inline ::Common::ObjectId* mutable_object();
  
  // required .Common.ObjectType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::Common::ObjectType& type() const;
  inline ::Common::ObjectType* mutable_type();
  
  // required .Common.MsgObjectAttributes attributes = 5;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::Common::MsgObjectAttributes& attributes() const;
  inline ::Common::MsgObjectAttributes* mutable_attributes();
  
  // optional .Common.KnowledgeGroupId knowledge_group = 6;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 6;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectKnowledgeId* id_;
  ::Common::PartyId* party_;
  ::Common::ObjectId* object_;
  ::Common::ObjectType* type_;
  ::Common::MsgObjectAttributes* attributes_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgObjectKnowledgeUpdate();
  virtual ~MsgObjectKnowledgeUpdate();
  
  MsgObjectKnowledgeUpdate(const MsgObjectKnowledgeUpdate& from);
  
  inline MsgObjectKnowledgeUpdate& operator=(const MsgObjectKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectKnowledgeUpdate& default_instance();
  void Swap(MsgObjectKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectKnowledgeUpdate& from);
  void MergeFrom(const MsgObjectKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ObjectKnowledgeId& id() const;
  inline ::Common::ObjectKnowledgeId* mutable_id();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.ObjectId object = 3;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 3;
  inline const ::Common::ObjectId& object() const;
  inline ::Common::ObjectId* mutable_object();
  
  // optional int32 relevance = 4 [default = 0];
  inline bool has_relevance() const;
  inline void clear_relevance();
  static const int kRelevanceFieldNumber = 4;
  inline ::google::protobuf::int32 relevance() const;
  inline void set_relevance(::google::protobuf::int32 value);
  
  // optional .Common.MsgLocation location = 5;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 5;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // optional .Common.MsgObjectAttributes attributes = 6;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 6;
  inline const ::Common::MsgObjectAttributes& attributes() const;
  inline ::Common::MsgObjectAttributes* mutable_attributes();
  
  // optional bool perceived = 7 [default = false];
  inline bool has_perceived() const;
  inline void clear_perceived();
  static const int kPerceivedFieldNumber = 7;
  inline bool perceived() const;
  inline void set_perceived(bool value);
  
  // optional .Common.AutomatIdList perceiving_automats = 8;
  inline bool has_perceiving_automats() const;
  inline void clear_perceiving_automats();
  static const int kPerceivingAutomatsFieldNumber = 8;
  inline const ::Common::AutomatIdList& perceiving_automats() const;
  inline ::Common::AutomatIdList* mutable_perceiving_automats();
  
  // optional .Common.KnowledgeGroupId knowledge_group = 9;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 9;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectKnowledgeId* id_;
  ::Common::PartyId* party_;
  ::Common::ObjectId* object_;
  ::google::protobuf::int32 relevance_;
  ::Common::MsgLocation* location_;
  ::Common::MsgObjectAttributes* attributes_;
  bool perceived_;
  ::Common::AutomatIdList* perceiving_automats_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgObjectKnowledgeDestruction();
  virtual ~MsgObjectKnowledgeDestruction();
  
  MsgObjectKnowledgeDestruction(const MsgObjectKnowledgeDestruction& from);
  
  inline MsgObjectKnowledgeDestruction& operator=(const MsgObjectKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgObjectKnowledgeDestruction& default_instance();
  void Swap(MsgObjectKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgObjectKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgObjectKnowledgeDestruction& from);
  void MergeFrom(const MsgObjectKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.ObjectKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::ObjectKnowledgeId& id() const;
  inline ::Common::ObjectKnowledgeId* mutable_id();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ObjectKnowledgeId* id_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgObjectKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgUrbanKnowledgeCreation();
  virtual ~MsgUrbanKnowledgeCreation();
  
  MsgUrbanKnowledgeCreation(const MsgUrbanKnowledgeCreation& from);
  
  inline MsgUrbanKnowledgeCreation& operator=(const MsgUrbanKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanKnowledgeCreation& default_instance();
  void Swap(MsgUrbanKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanKnowledgeCreation& from);
  void MergeFrom(const MsgUrbanKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UrbanObjectKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UrbanObjectKnowledgeId& id() const;
  inline ::Common::UrbanObjectKnowledgeId* mutable_id();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required .Common.UrbanObjectId urban_block = 3;
  inline bool has_urban_block() const;
  inline void clear_urban_block();
  static const int kUrbanBlockFieldNumber = 3;
  inline const ::Common::UrbanObjectId& urban_block() const;
  inline ::Common::UrbanObjectId* mutable_urban_block();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UrbanObjectKnowledgeId* id_;
  ::Common::PartyId* party_;
  ::Common::UrbanObjectId* urban_block_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgUrbanKnowledgeUpdate();
  virtual ~MsgUrbanKnowledgeUpdate();
  
  MsgUrbanKnowledgeUpdate(const MsgUrbanKnowledgeUpdate& from);
  
  inline MsgUrbanKnowledgeUpdate& operator=(const MsgUrbanKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanKnowledgeUpdate& default_instance();
  void Swap(MsgUrbanKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanKnowledgeUpdate& from);
  void MergeFrom(const MsgUrbanKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UrbanObjectKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UrbanObjectKnowledgeId& id() const;
  inline ::Common::UrbanObjectKnowledgeId* mutable_id();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // required .Common.UrbanObjectId urban_block = 3;
  inline bool has_urban_block() const;
  inline void clear_urban_block();
  static const int kUrbanBlockFieldNumber = 3;
  inline const ::Common::UrbanObjectId& urban_block() const;
  inline ::Common::UrbanObjectId* mutable_urban_block();
  
  // optional int32 progress = 4;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 4;
  inline ::google::protobuf::int32 progress() const;
  inline void set_progress(::google::protobuf::int32 value);
  
  // optional int32 max_progress = 5;
  inline bool has_max_progress() const;
  inline void clear_max_progress();
  static const int kMaxProgressFieldNumber = 5;
  inline ::google::protobuf::int32 max_progress() const;
  inline void set_max_progress(::google::protobuf::int32 value);
  
  // optional bool perceived = 6;
  inline bool has_perceived() const;
  inline void clear_perceived();
  static const int kPerceivedFieldNumber = 6;
  inline bool perceived() const;
  inline void set_perceived(bool value);
  
  // optional .Common.AutomatIdList automat_perceptions = 7;
  inline bool has_automat_perceptions() const;
  inline void clear_automat_perceptions();
  static const int kAutomatPerceptionsFieldNumber = 7;
  inline const ::Common::AutomatIdList& automat_perceptions() const;
  inline ::Common::AutomatIdList* mutable_automat_perceptions();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UrbanObjectKnowledgeId* id_;
  ::Common::PartyId* party_;
  ::Common::UrbanObjectId* urban_block_;
  ::google::protobuf::int32 progress_;
  ::google::protobuf::int32 max_progress_;
  bool perceived_;
  ::Common::AutomatIdList* automat_perceptions_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgUrbanKnowledgeDestruction();
  virtual ~MsgUrbanKnowledgeDestruction();
  
  MsgUrbanKnowledgeDestruction(const MsgUrbanKnowledgeDestruction& from);
  
  inline MsgUrbanKnowledgeDestruction& operator=(const MsgUrbanKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanKnowledgeDestruction& default_instance();
  void Swap(MsgUrbanKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanKnowledgeDestruction& from);
  void MergeFrom(const MsgUrbanKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UrbanObjectKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UrbanObjectKnowledgeId& id() const;
  inline ::Common::UrbanObjectKnowledgeId* mutable_id();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UrbanObjectKnowledgeId* id_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalHandlingCreation : public ::google::protobuf::Message {
 public:
  MsgLogMedicalHandlingCreation();
  virtual ~MsgLogMedicalHandlingCreation();
  
  MsgLogMedicalHandlingCreation(const MsgLogMedicalHandlingCreation& from);
  
  inline MsgLogMedicalHandlingCreation& operator=(const MsgLogMedicalHandlingCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalHandlingCreation& default_instance();
  void Swap(MsgLogMedicalHandlingCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalHandlingCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalHandlingCreation& from);
  void MergeFrom(const MsgLogMedicalHandlingCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MedicalRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::MedicalRequestId& id() const;
  inline ::Common::MedicalRequestId* mutable_id();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required int32 tick_creation = 3;
  inline bool has_tick_creation() const;
  inline void clear_tick_creation();
  static const int kTickCreationFieldNumber = 3;
  inline ::google::protobuf::int32 tick_creation() const;
  inline void set_tick_creation(::google::protobuf::int32 value);
  
  // required .Common.EnumHumanRank rang = 4;
  inline bool has_rang() const;
  inline void clear_rang();
  static const int kRangFieldNumber = 4;
  inline Common::EnumHumanRank rang() const;
  inline void set_rang(Common::EnumHumanRank value);
  
  // required .Common.EnumHumanWound blessure = 5;
  inline bool has_blessure() const;
  inline void clear_blessure();
  static const int kBlessureFieldNumber = 5;
  inline Common::EnumHumanWound blessure() const;
  inline void set_blessure(Common::EnumHumanWound value);
  
  // optional bool blesse_mental = 6 [default = false];
  inline bool has_blesse_mental() const;
  inline void clear_blesse_mental();
  static const int kBlesseMentalFieldNumber = 6;
  inline bool blesse_mental() const;
  inline void set_blesse_mental(bool value);
  
  // optional bool contamine_nbc = 7 [default = false];
  inline bool has_contamine_nbc() const;
  inline void clear_contamine_nbc();
  static const int kContamineNbcFieldNumber = 7;
  inline bool contamine_nbc() const;
  inline void set_contamine_nbc(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MedicalRequestId* id_;
  ::Common::UnitId* unit_;
  ::google::protobuf::int32 tick_creation_;
  int rang_;
  int blessure_;
  bool blesse_mental_;
  bool contamine_nbc_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalHandlingCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalHandlingUpdate : public ::google::protobuf::Message {
 public:
  MsgLogMedicalHandlingUpdate();
  virtual ~MsgLogMedicalHandlingUpdate();
  
  MsgLogMedicalHandlingUpdate(const MsgLogMedicalHandlingUpdate& from);
  
  inline MsgLogMedicalHandlingUpdate& operator=(const MsgLogMedicalHandlingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalHandlingUpdate& default_instance();
  void Swap(MsgLogMedicalHandlingUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalHandlingUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalHandlingUpdate& from);
  void MergeFrom(const MsgLogMedicalHandlingUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MedicalRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::MedicalRequestId& id() const;
  inline ::Common::MedicalRequestId* mutable_id();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // optional .Common.UnitId provider = 3;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 3;
  inline const ::Common::UnitId& provider() const;
  inline ::Common::UnitId* mutable_provider();
  
  // optional .Common.EnumHumanWound blessure = 4;
  inline bool has_blessure() const;
  inline void clear_blessure();
  static const int kBlessureFieldNumber = 4;
  inline Common::EnumHumanWound blessure() const;
  inline void set_blessure(Common::EnumHumanWound value);
  
  // optional bool blesse_mental = 5 [default = false];
  inline bool has_blesse_mental() const;
  inline void clear_blesse_mental();
  static const int kBlesseMentalFieldNumber = 5;
  inline bool blesse_mental() const;
  inline void set_blesse_mental(bool value);
  
  // optional bool contamine_nbc = 6 [default = false];
  inline bool has_contamine_nbc() const;
  inline void clear_contamine_nbc();
  static const int kContamineNbcFieldNumber = 6;
  inline bool contamine_nbc() const;
  inline void set_contamine_nbc(bool value);
  
  // optional .Common.EnumLogMedicalHandlingStatus etat = 7;
  inline bool has_etat() const;
  inline void clear_etat();
  static const int kEtatFieldNumber = 7;
  inline Common::EnumLogMedicalHandlingStatus etat() const;
  inline void set_etat(Common::EnumLogMedicalHandlingStatus value);
  
  // optional bool diagnostique_effectue = 8 [default = false];
  inline bool has_diagnostique_effectue() const;
  inline void clear_diagnostique_effectue();
  static const int kDiagnostiqueEffectueFieldNumber = 8;
  inline bool diagnostique_effectue() const;
  inline void set_diagnostique_effectue(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MedicalRequestId* id_;
  ::Common::UnitId* unit_;
  ::Common::UnitId* provider_;
  int blessure_;
  bool blesse_mental_;
  bool contamine_nbc_;
  int etat_;
  bool diagnostique_effectue_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalHandlingUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalHandlingDestruction : public ::google::protobuf::Message {
 public:
  MsgLogMedicalHandlingDestruction();
  virtual ~MsgLogMedicalHandlingDestruction();
  
  MsgLogMedicalHandlingDestruction(const MsgLogMedicalHandlingDestruction& from);
  
  inline MsgLogMedicalHandlingDestruction& operator=(const MsgLogMedicalHandlingDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalHandlingDestruction& default_instance();
  void Swap(MsgLogMedicalHandlingDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalHandlingDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalHandlingDestruction& from);
  void MergeFrom(const MsgLogMedicalHandlingDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MedicalRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::MedicalRequestId& id() const;
  inline ::Common::MedicalRequestId* mutable_id();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MedicalRequestId* id_;
  ::Common::UnitId* unit_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalHandlingDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalEquipmentAvailability : public ::google::protobuf::Message {
 public:
  MsgLogMedicalEquipmentAvailability();
  virtual ~MsgLogMedicalEquipmentAvailability();
  
  MsgLogMedicalEquipmentAvailability(const MsgLogMedicalEquipmentAvailability& from);
  
  inline MsgLogMedicalEquipmentAvailability& operator=(const MsgLogMedicalEquipmentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalEquipmentAvailability& default_instance();
  void Swap(MsgLogMedicalEquipmentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalEquipmentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalEquipmentAvailability& from);
  void MergeFrom(const MsgLogMedicalEquipmentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type_equipement = 1;
  inline bool has_type_equipement() const;
  inline void clear_type_equipement();
  static const int kTypeEquipementFieldNumber = 1;
  inline ::google::protobuf::int32 type_equipement() const;
  inline void set_type_equipement(::google::protobuf::int32 value);
  
  // required int32 nbr_total = 2;
  inline bool has_nbr_total() const;
  inline void clear_nbr_total();
  static const int kNbrTotalFieldNumber = 2;
  inline ::google::protobuf::int32 nbr_total() const;
  inline void set_nbr_total(::google::protobuf::int32 value);
  
  // required int32 nbr_disponibles = 3;
  inline bool has_nbr_disponibles() const;
  inline void clear_nbr_disponibles();
  static const int kNbrDisponiblesFieldNumber = 3;
  inline ::google::protobuf::int32 nbr_disponibles() const;
  inline void set_nbr_disponibles(::google::protobuf::int32 value);
  
  // required int32 nbr_au_travail = 4;
  inline bool has_nbr_au_travail() const;
  inline void clear_nbr_au_travail();
  static const int kNbrAuTravailFieldNumber = 4;
  inline ::google::protobuf::int32 nbr_au_travail() const;
  inline void set_nbr_au_travail(::google::protobuf::int32 value);
  
  // optional int32 nbr_pretes = 5 [default = 0];
  inline bool has_nbr_pretes() const;
  inline void clear_nbr_pretes();
  static const int kNbrPretesFieldNumber = 5;
  inline ::google::protobuf::int32 nbr_pretes() const;
  inline void set_nbr_pretes(::google::protobuf::int32 value);
  
  // optional int32 nbr_au_repos = 6 [default = 0];
  inline bool has_nbr_au_repos() const;
  inline void clear_nbr_au_repos();
  static const int kNbrAuReposFieldNumber = 6;
  inline ::google::protobuf::int32 nbr_au_repos() const;
  inline void set_nbr_au_repos(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 type_equipement_;
  ::google::protobuf::int32 nbr_total_;
  ::google::protobuf::int32 nbr_disponibles_;
  ::google::protobuf::int32 nbr_au_travail_;
  ::google::protobuf::int32 nbr_pretes_;
  ::google::protobuf::int32 nbr_au_repos_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalEquipmentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfLogMedicalEquipmentAvailability : public ::google::protobuf::Message {
 public:
  SeqOfLogMedicalEquipmentAvailability();
  virtual ~SeqOfLogMedicalEquipmentAvailability();
  
  SeqOfLogMedicalEquipmentAvailability(const SeqOfLogMedicalEquipmentAvailability& from);
  
  inline SeqOfLogMedicalEquipmentAvailability& operator=(const SeqOfLogMedicalEquipmentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfLogMedicalEquipmentAvailability& default_instance();
  void Swap(SeqOfLogMedicalEquipmentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfLogMedicalEquipmentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfLogMedicalEquipmentAvailability& from);
  void MergeFrom(const SeqOfLogMedicalEquipmentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgLogMedicalEquipmentAvailability elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability >* mutable_elem();
  inline const ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability& elem(int index) const;
  inline ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfLogMedicalEquipmentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMedicalState : public ::google::protobuf::Message {
 public:
  MsgLogMedicalState();
  virtual ~MsgLogMedicalState();
  
  MsgLogMedicalState(const MsgLogMedicalState& from);
  
  inline MsgLogMedicalState& operator=(const MsgLogMedicalState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMedicalState& default_instance();
  void Swap(MsgLogMedicalState* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMedicalState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMedicalState& from);
  void MergeFrom(const MsgLogMedicalState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // optional bool chaine_activee = 2 [default = false];
  inline bool has_chaine_activee() const;
  inline void clear_chaine_activee();
  static const int kChaineActiveeFieldNumber = 2;
  inline bool chaine_activee() const;
  inline void set_chaine_activee(bool value);
  
  // optional .Common.MsgLogMedicalPriorities priorites = 3;
  inline bool has_priorites() const;
  inline void clear_priorites();
  static const int kPrioritesFieldNumber = 3;
  inline const ::Common::MsgLogMedicalPriorities& priorites() const;
  inline ::Common::MsgLogMedicalPriorities* mutable_priorites();
  
  // optional .Common.AutomatIdList tactical_priorities = 4;
  inline bool has_tactical_priorities() const;
  inline void clear_tactical_priorities();
  static const int kTacticalPrioritiesFieldNumber = 4;
  inline const ::Common::AutomatIdList& tactical_priorities() const;
  inline ::Common::AutomatIdList* mutable_tactical_priorities();
  
  // optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_releve = 5;
  inline bool has_disponibilites_ambulances_releve() const;
  inline void clear_disponibilites_ambulances_releve();
  static const int kDisponibilitesAmbulancesReleveFieldNumber = 5;
  inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& disponibilites_ambulances_releve() const;
  inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* mutable_disponibilites_ambulances_releve();
  
  // optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_ramassage = 6;
  inline bool has_disponibilites_ambulances_ramassage() const;
  inline void clear_disponibilites_ambulances_ramassage();
  static const int kDisponibilitesAmbulancesRamassageFieldNumber = 6;
  inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& disponibilites_ambulances_ramassage() const;
  inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* mutable_disponibilites_ambulances_ramassage();
  
  // optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_medecins = 7;
  inline bool has_disponibilites_medecins() const;
  inline void clear_disponibilites_medecins();
  static const int kDisponibilitesMedecinsFieldNumber = 7;
  inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& disponibilites_medecins() const;
  inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* mutable_disponibilites_medecins();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  bool chaine_activee_;
  ::Common::MsgLogMedicalPriorities* priorites_;
  ::Common::AutomatIdList* tactical_priorities_;
  ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* disponibilites_ambulances_releve_;
  ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* disponibilites_ambulances_ramassage_;
  ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* disponibilites_medecins_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMedicalState* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceHandlingCreation : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceHandlingCreation();
  virtual ~MsgLogMaintenanceHandlingCreation();
  
  MsgLogMaintenanceHandlingCreation(const MsgLogMaintenanceHandlingCreation& from);
  
  inline MsgLogMaintenanceHandlingCreation& operator=(const MsgLogMaintenanceHandlingCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceHandlingCreation& default_instance();
  void Swap(MsgLogMaintenanceHandlingCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceHandlingCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceHandlingCreation& from);
  void MergeFrom(const MsgLogMaintenanceHandlingCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MaintenanceRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::MaintenanceRequestId& id() const;
  inline ::Common::MaintenanceRequestId* mutable_id();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required int32 tick_creation = 3;
  inline bool has_tick_creation() const;
  inline void clear_tick_creation();
  static const int kTickCreationFieldNumber = 3;
  inline ::google::protobuf::int32 tick_creation() const;
  inline void set_tick_creation(::google::protobuf::int32 value);
  
  // required .Common.EquipmentType equipement = 4;
  inline bool has_equipement() const;
  inline void clear_equipement();
  static const int kEquipementFieldNumber = 4;
  inline const ::Common::EquipmentType& equipement() const;
  inline ::Common::EquipmentType* mutable_equipement();
  
  // required .Common.BreakdownType breakdown = 5;
  inline bool has_breakdown() const;
  inline void clear_breakdown();
  static const int kBreakdownFieldNumber = 5;
  inline const ::Common::BreakdownType& breakdown() const;
  inline ::Common::BreakdownType* mutable_breakdown();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MaintenanceRequestId* id_;
  ::Common::UnitId* unit_;
  ::google::protobuf::int32 tick_creation_;
  ::Common::EquipmentType* equipement_;
  ::Common::BreakdownType* breakdown_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceHandlingCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceHandlingUpdate : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceHandlingUpdate();
  virtual ~MsgLogMaintenanceHandlingUpdate();
  
  MsgLogMaintenanceHandlingUpdate(const MsgLogMaintenanceHandlingUpdate& from);
  
  inline MsgLogMaintenanceHandlingUpdate& operator=(const MsgLogMaintenanceHandlingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceHandlingUpdate& default_instance();
  void Swap(MsgLogMaintenanceHandlingUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceHandlingUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceHandlingUpdate& from);
  void MergeFrom(const MsgLogMaintenanceHandlingUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MaintenanceRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::MaintenanceRequestId& id() const;
  inline ::Common::MaintenanceRequestId* mutable_id();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
  // required .Common.UnitId provider = 3;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 3;
  inline const ::Common::UnitId& provider() const;
  inline ::Common::UnitId* mutable_provider();
  
  // optional .Common.EnumLogMaintenanceHandlingStatus etat = 4;
  inline bool has_etat() const;
  inline void clear_etat();
  static const int kEtatFieldNumber = 4;
  inline Common::EnumLogMaintenanceHandlingStatus etat() const;
  inline void set_etat(Common::EnumLogMaintenanceHandlingStatus value);
  
  // optional bool diagnostique_effectue = 5 [default = false];
  inline bool has_diagnostique_effectue() const;
  inline void clear_diagnostique_effectue();
  static const int kDiagnostiqueEffectueFieldNumber = 5;
  inline bool diagnostique_effectue() const;
  inline void set_diagnostique_effectue(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MaintenanceRequestId* id_;
  ::Common::UnitId* unit_;
  ::Common::UnitId* provider_;
  int etat_;
  bool diagnostique_effectue_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceHandlingUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceHandlingDestruction : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceHandlingDestruction();
  virtual ~MsgLogMaintenanceHandlingDestruction();
  
  MsgLogMaintenanceHandlingDestruction(const MsgLogMaintenanceHandlingDestruction& from);
  
  inline MsgLogMaintenanceHandlingDestruction& operator=(const MsgLogMaintenanceHandlingDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceHandlingDestruction& default_instance();
  void Swap(MsgLogMaintenanceHandlingDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceHandlingDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceHandlingDestruction& from);
  void MergeFrom(const MsgLogMaintenanceHandlingDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MaintenanceRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::MaintenanceRequestId& id() const;
  inline ::Common::MaintenanceRequestId* mutable_id();
  
  // required .Common.UnitId unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::Common::UnitId& unit() const;
  inline ::Common::UnitId* mutable_unit();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MaintenanceRequestId* id_;
  ::Common::UnitId* unit_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceHandlingDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceEquipmentAvailability : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceEquipmentAvailability();
  virtual ~MsgLogMaintenanceEquipmentAvailability();
  
  MsgLogMaintenanceEquipmentAvailability(const MsgLogMaintenanceEquipmentAvailability& from);
  
  inline MsgLogMaintenanceEquipmentAvailability& operator=(const MsgLogMaintenanceEquipmentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceEquipmentAvailability& default_instance();
  void Swap(MsgLogMaintenanceEquipmentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceEquipmentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceEquipmentAvailability& from);
  void MergeFrom(const MsgLogMaintenanceEquipmentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type_equipement = 1;
  inline bool has_type_equipement() const;
  inline void clear_type_equipement();
  static const int kTypeEquipementFieldNumber = 1;
  inline ::google::protobuf::int32 type_equipement() const;
  inline void set_type_equipement(::google::protobuf::int32 value);
  
  // required int32 nbr_total = 2;
  inline bool has_nbr_total() const;
  inline void clear_nbr_total();
  static const int kNbrTotalFieldNumber = 2;
  inline ::google::protobuf::int32 nbr_total() const;
  inline void set_nbr_total(::google::protobuf::int32 value);
  
  // required int32 nbr_disponibles = 3;
  inline bool has_nbr_disponibles() const;
  inline void clear_nbr_disponibles();
  static const int kNbrDisponiblesFieldNumber = 3;
  inline ::google::protobuf::int32 nbr_disponibles() const;
  inline void set_nbr_disponibles(::google::protobuf::int32 value);
  
  // required int32 nbr_au_travail = 4;
  inline bool has_nbr_au_travail() const;
  inline void clear_nbr_au_travail();
  static const int kNbrAuTravailFieldNumber = 4;
  inline ::google::protobuf::int32 nbr_au_travail() const;
  inline void set_nbr_au_travail(::google::protobuf::int32 value);
  
  // optional int32 nbr_pretes = 5 [default = 0];
  inline bool has_nbr_pretes() const;
  inline void clear_nbr_pretes();
  static const int kNbrPretesFieldNumber = 5;
  inline ::google::protobuf::int32 nbr_pretes() const;
  inline void set_nbr_pretes(::google::protobuf::int32 value);
  
  // optional int32 nbr_au_repos = 6;
  inline bool has_nbr_au_repos() const;
  inline void clear_nbr_au_repos();
  static const int kNbrAuReposFieldNumber = 6;
  inline ::google::protobuf::int32 nbr_au_repos() const;
  inline void set_nbr_au_repos(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 type_equipement_;
  ::google::protobuf::int32 nbr_total_;
  ::google::protobuf::int32 nbr_disponibles_;
  ::google::protobuf::int32 nbr_au_travail_;
  ::google::protobuf::int32 nbr_pretes_;
  ::google::protobuf::int32 nbr_au_repos_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceEquipmentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfLogMaintenanceEquipmentAvailability : public ::google::protobuf::Message {
 public:
  SeqOfLogMaintenanceEquipmentAvailability();
  virtual ~SeqOfLogMaintenanceEquipmentAvailability();
  
  SeqOfLogMaintenanceEquipmentAvailability(const SeqOfLogMaintenanceEquipmentAvailability& from);
  
  inline SeqOfLogMaintenanceEquipmentAvailability& operator=(const SeqOfLogMaintenanceEquipmentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfLogMaintenanceEquipmentAvailability& default_instance();
  void Swap(SeqOfLogMaintenanceEquipmentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfLogMaintenanceEquipmentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfLogMaintenanceEquipmentAvailability& from);
  void MergeFrom(const SeqOfLogMaintenanceEquipmentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgLogMaintenanceEquipmentAvailability elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability >* mutable_elem();
  inline const ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability& elem(int index) const;
  inline ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfLogMaintenanceEquipmentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogMaintenanceState : public ::google::protobuf::Message {
 public:
  MsgLogMaintenanceState();
  virtual ~MsgLogMaintenanceState();
  
  MsgLogMaintenanceState(const MsgLogMaintenanceState& from);
  
  inline MsgLogMaintenanceState& operator=(const MsgLogMaintenanceState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogMaintenanceState& default_instance();
  void Swap(MsgLogMaintenanceState* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogMaintenanceState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogMaintenanceState& from);
  void MergeFrom(const MsgLogMaintenanceState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // optional bool chaine_activee = 2;
  inline bool has_chaine_activee() const;
  inline void clear_chaine_activee();
  static const int kChaineActiveeFieldNumber = 2;
  inline bool chaine_activee() const;
  inline void set_chaine_activee(bool value);
  
  // optional .Common.EnumLogMaintenanceRegimeTravail regime_travail = 3;
  inline bool has_regime_travail() const;
  inline void clear_regime_travail();
  static const int kRegimeTravailFieldNumber = 3;
  inline Common::EnumLogMaintenanceRegimeTravail regime_travail() const;
  inline void set_regime_travail(Common::EnumLogMaintenanceRegimeTravail value);
  
  // optional .Common.MsgLogMaintenancePriorities priorites = 4;
  inline bool has_priorites() const;
  inline void clear_priorites();
  static const int kPrioritesFieldNumber = 4;
  inline const ::Common::MsgLogMaintenancePriorities& priorites() const;
  inline ::Common::MsgLogMaintenancePriorities* mutable_priorites();
  
  // optional .Common.AutomatIdList priorites_tactiques = 5;
  inline bool has_priorites_tactiques() const;
  inline void clear_priorites_tactiques();
  static const int kPrioritesTactiquesFieldNumber = 5;
  inline const ::Common::AutomatIdList& priorites_tactiques() const;
  inline ::Common::AutomatIdList* mutable_priorites_tactiques();
  
  // optional .MsgsSimToClient.SeqOfLogMaintenanceEquipmentAvailability disponibilites_remorqueurs = 6;
  inline bool has_disponibilites_remorqueurs() const;
  inline void clear_disponibilites_remorqueurs();
  static const int kDisponibilitesRemorqueursFieldNumber = 6;
  inline const ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability& disponibilites_remorqueurs() const;
  inline ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* mutable_disponibilites_remorqueurs();
  
  // optional .MsgsSimToClient.SeqOfLogMaintenanceEquipmentAvailability disponibilites_reparateurs = 7;
  inline bool has_disponibilites_reparateurs() const;
  inline void clear_disponibilites_reparateurs();
  static const int kDisponibilitesReparateursFieldNumber = 7;
  inline const ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability& disponibilites_reparateurs() const;
  inline ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* mutable_disponibilites_reparateurs();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  bool chaine_activee_;
  int regime_travail_;
  ::Common::MsgLogMaintenancePriorities* priorites_;
  ::Common::AutomatIdList* priorites_tactiques_;
  ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* disponibilites_remorqueurs_;
  ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* disponibilites_reparateurs_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogMaintenanceState* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyHandlingCreation : public ::google::protobuf::Message {
 public:
  MsgLogSupplyHandlingCreation();
  virtual ~MsgLogSupplyHandlingCreation();
  
  MsgLogSupplyHandlingCreation(const MsgLogSupplyHandlingCreation& from);
  
  inline MsgLogSupplyHandlingCreation& operator=(const MsgLogSupplyHandlingCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyHandlingCreation& default_instance();
  void Swap(MsgLogSupplyHandlingCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyHandlingCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyHandlingCreation& from);
  void MergeFrom(const MsgLogSupplyHandlingCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.SupplyRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::SupplyRequestId& id() const;
  inline ::Common::SupplyRequestId* mutable_id();
  
  // optional .Common.AutomatId consumer = 2;
  inline bool has_consumer() const;
  inline void clear_consumer();
  static const int kConsumerFieldNumber = 2;
  inline const ::Common::AutomatId& consumer() const;
  inline ::Common::AutomatId* mutable_consumer();
  
  // optional int32 tick_creation = 3;
  inline bool has_tick_creation() const;
  inline void clear_tick_creation();
  static const int kTickCreationFieldNumber = 3;
  inline ::google::protobuf::int32 tick_creation() const;
  inline void set_tick_creation(::google::protobuf::int32 value);
  
  // optional .MsgsSimToClient.SeqOfDotationQuery dotations = 4;
  inline bool has_dotations() const;
  inline void clear_dotations();
  static const int kDotationsFieldNumber = 4;
  inline const ::MsgsSimToClient::SeqOfDotationQuery& dotations() const;
  inline ::MsgsSimToClient::SeqOfDotationQuery* mutable_dotations();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::SupplyRequestId* id_;
  ::Common::AutomatId* consumer_;
  ::google::protobuf::int32 tick_creation_;
  ::MsgsSimToClient::SeqOfDotationQuery* dotations_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyHandlingCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgDotationQuery : public ::google::protobuf::Message {
 public:
  MsgDotationQuery();
  virtual ~MsgDotationQuery();
  
  MsgDotationQuery(const MsgDotationQuery& from);
  
  inline MsgDotationQuery& operator=(const MsgDotationQuery& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDotationQuery& default_instance();
  void Swap(MsgDotationQuery* other);
  
  // implements Message ----------------------------------------------
  
  MsgDotationQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgDotationQuery& from);
  void MergeFrom(const MsgDotationQuery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.ResourceType resource = 1;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 1;
  inline const ::Common::ResourceType& resource() const;
  inline ::Common::ResourceType* mutable_resource();
  
  // optional int32 quantite_demandee = 2;
  inline bool has_quantite_demandee() const;
  inline void clear_quantite_demandee();
  static const int kQuantiteDemandeeFieldNumber = 2;
  inline ::google::protobuf::int32 quantite_demandee() const;
  inline void set_quantite_demandee(::google::protobuf::int32 value);
  
  // optional int32 quantite_accordee = 3;
  inline bool has_quantite_accordee() const;
  inline void clear_quantite_accordee();
  static const int kQuantiteAccordeeFieldNumber = 3;
  inline ::google::protobuf::int32 quantite_accordee() const;
  inline void set_quantite_accordee(::google::protobuf::int32 value);
  
  // optional int32 quantite_en_transit = 4;
  inline bool has_quantite_en_transit() const;
  inline void clear_quantite_en_transit();
  static const int kQuantiteEnTransitFieldNumber = 4;
  inline ::google::protobuf::int32 quantite_en_transit() const;
  inline void set_quantite_en_transit(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::ResourceType* resource_;
  ::google::protobuf::int32 quantite_demandee_;
  ::google::protobuf::int32 quantite_accordee_;
  ::google::protobuf::int32 quantite_en_transit_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgDotationQuery* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfDotationQuery : public ::google::protobuf::Message {
 public:
  SeqOfDotationQuery();
  virtual ~SeqOfDotationQuery();
  
  SeqOfDotationQuery(const SeqOfDotationQuery& from);
  
  inline SeqOfDotationQuery& operator=(const SeqOfDotationQuery& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfDotationQuery& default_instance();
  void Swap(SeqOfDotationQuery* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfDotationQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfDotationQuery& from);
  void MergeFrom(const SeqOfDotationQuery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgDotationQuery elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery >* mutable_elem();
  inline const ::MsgsSimToClient::MsgDotationQuery& elem(int index) const;
  inline ::MsgsSimToClient::MsgDotationQuery* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgDotationQuery* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfDotationQuery* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyHandlingUpdate : public ::google::protobuf::Message {
 public:
  MsgLogSupplyHandlingUpdate();
  virtual ~MsgLogSupplyHandlingUpdate();
  
  MsgLogSupplyHandlingUpdate(const MsgLogSupplyHandlingUpdate& from);
  
  inline MsgLogSupplyHandlingUpdate& operator=(const MsgLogSupplyHandlingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyHandlingUpdate& default_instance();
  void Swap(MsgLogSupplyHandlingUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyHandlingUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyHandlingUpdate& from);
  void MergeFrom(const MsgLogSupplyHandlingUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.SupplyRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::SupplyRequestId& id() const;
  inline ::Common::SupplyRequestId* mutable_id();
  
  // optional .Common.AutomatId consumer = 2;
  inline bool has_consumer() const;
  inline void clear_consumer();
  static const int kConsumerFieldNumber = 2;
  inline const ::Common::AutomatId& consumer() const;
  inline ::Common::AutomatId* mutable_consumer();
  
  // optional .Common.AutomatId supplier = 3;
  inline bool has_supplier() const;
  inline void clear_supplier();
  static const int kSupplierFieldNumber = 3;
  inline const ::Common::AutomatId& supplier() const;
  inline ::Common::AutomatId* mutable_supplier();
  
  // optional .Common.AutomatId convoy_provider = 4;
  inline bool has_convoy_provider() const;
  inline void clear_convoy_provider();
  static const int kConvoyProviderFieldNumber = 4;
  inline const ::Common::AutomatId& convoy_provider() const;
  inline ::Common::AutomatId* mutable_convoy_provider();
  
  // optional .Common.UnitId convoying_unit = 5;
  inline bool has_convoying_unit() const;
  inline void clear_convoying_unit();
  static const int kConvoyingUnitFieldNumber = 5;
  inline const ::Common::UnitId& convoying_unit() const;
  inline ::Common::UnitId* mutable_convoying_unit();
  
  // optional .MsgsSimToClient.EnumLogSupplyHandlingStatus etat = 6;
  inline bool has_etat() const;
  inline void clear_etat();
  static const int kEtatFieldNumber = 6;
  inline MsgsSimToClient::EnumLogSupplyHandlingStatus etat() const;
  inline void set_etat(MsgsSimToClient::EnumLogSupplyHandlingStatus value);
  
  // optional .MsgsSimToClient.SeqOfDotationQuery dotations = 7;
  inline bool has_dotations() const;
  inline void clear_dotations();
  static const int kDotationsFieldNumber = 7;
  inline const ::MsgsSimToClient::SeqOfDotationQuery& dotations() const;
  inline ::MsgsSimToClient::SeqOfDotationQuery* mutable_dotations();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::SupplyRequestId* id_;
  ::Common::AutomatId* consumer_;
  ::Common::AutomatId* supplier_;
  ::Common::AutomatId* convoy_provider_;
  ::Common::UnitId* convoying_unit_;
  int etat_;
  ::MsgsSimToClient::SeqOfDotationQuery* dotations_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyHandlingUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyHandlingDestruction : public ::google::protobuf::Message {
 public:
  MsgLogSupplyHandlingDestruction();
  virtual ~MsgLogSupplyHandlingDestruction();
  
  MsgLogSupplyHandlingDestruction(const MsgLogSupplyHandlingDestruction& from);
  
  inline MsgLogSupplyHandlingDestruction& operator=(const MsgLogSupplyHandlingDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyHandlingDestruction& default_instance();
  void Swap(MsgLogSupplyHandlingDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyHandlingDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyHandlingDestruction& from);
  void MergeFrom(const MsgLogSupplyHandlingDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.SupplyRequestId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::SupplyRequestId& id() const;
  inline ::Common::SupplyRequestId* mutable_id();
  
  // required .Common.AutomatId consumer = 2;
  inline bool has_consumer() const;
  inline void clear_consumer();
  static const int kConsumerFieldNumber = 2;
  inline const ::Common::AutomatId& consumer() const;
  inline ::Common::AutomatId* mutable_consumer();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::SupplyRequestId* id_;
  ::Common::AutomatId* consumer_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyHandlingDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyEquimentAvailability : public ::google::protobuf::Message {
 public:
  MsgLogSupplyEquimentAvailability();
  virtual ~MsgLogSupplyEquimentAvailability();
  
  MsgLogSupplyEquimentAvailability(const MsgLogSupplyEquimentAvailability& from);
  
  inline MsgLogSupplyEquimentAvailability& operator=(const MsgLogSupplyEquimentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyEquimentAvailability& default_instance();
  void Swap(MsgLogSupplyEquimentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyEquimentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyEquimentAvailability& from);
  void MergeFrom(const MsgLogSupplyEquimentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.EquipmentType equipment = 1;
  inline bool has_equipment() const;
  inline void clear_equipment();
  static const int kEquipmentFieldNumber = 1;
  inline const ::Common::EquipmentType& equipment() const;
  inline ::Common::EquipmentType* mutable_equipment();
  
  // optional int32 nbr_total = 2;
  inline bool has_nbr_total() const;
  inline void clear_nbr_total();
  static const int kNbrTotalFieldNumber = 2;
  inline ::google::protobuf::int32 nbr_total() const;
  inline void set_nbr_total(::google::protobuf::int32 value);
  
  // optional int32 nbr_disponibles = 3;
  inline bool has_nbr_disponibles() const;
  inline void clear_nbr_disponibles();
  static const int kNbrDisponiblesFieldNumber = 3;
  inline ::google::protobuf::int32 nbr_disponibles() const;
  inline void set_nbr_disponibles(::google::protobuf::int32 value);
  
  // optional int32 nbr_au_travail = 4;
  inline bool has_nbr_au_travail() const;
  inline void clear_nbr_au_travail();
  static const int kNbrAuTravailFieldNumber = 4;
  inline ::google::protobuf::int32 nbr_au_travail() const;
  inline void set_nbr_au_travail(::google::protobuf::int32 value);
  
  // optional int32 nbr_pretes = 5 [default = 0];
  inline bool has_nbr_pretes() const;
  inline void clear_nbr_pretes();
  static const int kNbrPretesFieldNumber = 5;
  inline ::google::protobuf::int32 nbr_pretes() const;
  inline void set_nbr_pretes(::google::protobuf::int32 value);
  
  // optional int32 nbr_au_repos = 6;
  inline bool has_nbr_au_repos() const;
  inline void clear_nbr_au_repos();
  static const int kNbrAuReposFieldNumber = 6;
  inline ::google::protobuf::int32 nbr_au_repos() const;
  inline void set_nbr_au_repos(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::EquipmentType* equipment_;
  ::google::protobuf::int32 nbr_total_;
  ::google::protobuf::int32 nbr_disponibles_;
  ::google::protobuf::int32 nbr_au_travail_;
  ::google::protobuf::int32 nbr_pretes_;
  ::google::protobuf::int32 nbr_au_repos_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyEquimentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfLogSupplyEquimentAvailability : public ::google::protobuf::Message {
 public:
  SeqOfLogSupplyEquimentAvailability();
  virtual ~SeqOfLogSupplyEquimentAvailability();
  
  SeqOfLogSupplyEquimentAvailability(const SeqOfLogSupplyEquimentAvailability& from);
  
  inline SeqOfLogSupplyEquimentAvailability& operator=(const SeqOfLogSupplyEquimentAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfLogSupplyEquimentAvailability& default_instance();
  void Swap(SeqOfLogSupplyEquimentAvailability* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfLogSupplyEquimentAvailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfLogSupplyEquimentAvailability& from);
  void MergeFrom(const SeqOfLogSupplyEquimentAvailability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgLogSupplyEquimentAvailability elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability >* mutable_elem();
  inline const ::MsgsSimToClient::MsgLogSupplyEquimentAvailability& elem(int index) const;
  inline ::MsgsSimToClient::MsgLogSupplyEquimentAvailability* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgLogSupplyEquimentAvailability* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfLogSupplyEquimentAvailability* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyState : public ::google::protobuf::Message {
 public:
  MsgLogSupplyState();
  virtual ~MsgLogSupplyState();
  
  MsgLogSupplyState(const MsgLogSupplyState& from);
  
  inline MsgLogSupplyState& operator=(const MsgLogSupplyState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyState& default_instance();
  void Swap(MsgLogSupplyState* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyState& from);
  void MergeFrom(const MsgLogSupplyState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Common.UnitId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::UnitId& id() const;
  inline ::Common::UnitId* mutable_id();
  
  // optional bool chaine_activee = 2;
  inline bool has_chaine_activee() const;
  inline void clear_chaine_activee();
  static const int kChaineActiveeFieldNumber = 2;
  inline bool chaine_activee() const;
  inline void set_chaine_activee(bool value);
  
  // optional .Common.SeqOfDotationStock stocks = 3;
  inline bool has_stocks() const;
  inline void clear_stocks();
  static const int kStocksFieldNumber = 3;
  inline const ::Common::SeqOfDotationStock& stocks() const;
  inline ::Common::SeqOfDotationStock* mutable_stocks();
  
  // optional .MsgsSimToClient.SeqOfLogSupplyEquimentAvailability disponibilites_transporteurs_convois = 4;
  inline bool has_disponibilites_transporteurs_convois() const;
  inline void clear_disponibilites_transporteurs_convois();
  static const int kDisponibilitesTransporteursConvoisFieldNumber = 4;
  inline const ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability& disponibilites_transporteurs_convois() const;
  inline ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability* mutable_disponibilites_transporteurs_convois();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::UnitId* id_;
  bool chaine_activee_;
  ::Common::SeqOfDotationStock* stocks_;
  ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability* disponibilites_transporteurs_convois_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyState* default_instance_;
};
// -------------------------------------------------------------------

class MsgLogSupplyQuotas : public ::google::protobuf::Message {
 public:
  MsgLogSupplyQuotas();
  virtual ~MsgLogSupplyQuotas();
  
  MsgLogSupplyQuotas(const MsgLogSupplyQuotas& from);
  
  inline MsgLogSupplyQuotas& operator=(const MsgLogSupplyQuotas& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogSupplyQuotas& default_instance();
  void Swap(MsgLogSupplyQuotas* other);
  
  // implements Message ----------------------------------------------
  
  MsgLogSupplyQuotas* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgLogSupplyQuotas& from);
  void MergeFrom(const MsgLogSupplyQuotas& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.AutomatId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::AutomatId& id() const;
  inline ::Common::AutomatId* mutable_id();
  
  // required .Common.SeqOfDotationQuota quotas = 2;
  inline bool has_quotas() const;
  inline void clear_quotas();
  static const int kQuotasFieldNumber = 2;
  inline const ::Common::SeqOfDotationQuota& quotas() const;
  inline ::Common::SeqOfDotationQuota* mutable_quotas();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::AutomatId* id_;
  ::Common::SeqOfDotationQuota* quotas_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgLogSupplyQuotas* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationCreation : public ::google::protobuf::Message {
 public:
  MsgPopulationCreation();
  virtual ~MsgPopulationCreation();
  
  MsgPopulationCreation(const MsgPopulationCreation& from);
  
  inline MsgPopulationCreation& operator=(const MsgPopulationCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationCreation& default_instance();
  void Swap(MsgPopulationCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationCreation& from);
  void MergeFrom(const MsgPopulationCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationId& id() const;
  inline ::Common::PopulationId* mutable_id();
  
  // required .Common.PopulationType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::Common::PopulationType& type() const;
  inline ::Common::PopulationType* mutable_type();
  
  // optional string nom = 3;
  inline bool has_nom() const;
  inline void clear_nom();
  static const int kNomFieldNumber = 3;
  inline const ::std::string& nom() const;
  inline void set_nom(const ::std::string& value);
  inline void set_nom(const char* value);
  inline void set_nom(const char* value, size_t size);
  inline ::std::string* mutable_nom();
  
  // required .Common.PartyId party = 4;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 4;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationId* id_;
  ::Common::PopulationType* type_;
  ::std::string* nom_;
  static const ::std::string _default_nom_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationUpdate : public ::google::protobuf::Message {
 public:
  MsgPopulationUpdate();
  virtual ~MsgPopulationUpdate();
  
  MsgPopulationUpdate(const MsgPopulationUpdate& from);
  
  inline MsgPopulationUpdate& operator=(const MsgPopulationUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationUpdate& default_instance();
  void Swap(MsgPopulationUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationUpdate& from);
  void MergeFrom(const MsgPopulationUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationId& id() const;
  inline ::Common::PopulationId* mutable_id();
  
  // optional int32 etat_domination = 2 [default = 0];
  inline bool has_etat_domination() const;
  inline void clear_etat_domination();
  static const int kEtatDominationFieldNumber = 2;
  inline ::google::protobuf::int32 etat_domination() const;
  inline void set_etat_domination(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationId* id_;
  ::google::protobuf::int32 etat_domination_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationConcentrationCreation : public ::google::protobuf::Message {
 public:
  MsgPopulationConcentrationCreation();
  virtual ~MsgPopulationConcentrationCreation();
  
  MsgPopulationConcentrationCreation(const MsgPopulationConcentrationCreation& from);
  
  inline MsgPopulationConcentrationCreation& operator=(const MsgPopulationConcentrationCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationConcentrationCreation& default_instance();
  void Swap(MsgPopulationConcentrationCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationConcentrationCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationConcentrationCreation& from);
  void MergeFrom(const MsgPopulationConcentrationCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationConcentrationId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationConcentrationId& id() const;
  inline ::Common::PopulationConcentrationId* mutable_id();
  
  // required .Common.PopulationId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& population() const;
  inline ::Common::PopulationId* mutable_population();
  
  // required .Common.MsgCoordLatLong position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationConcentrationId* id_;
  ::Common::PopulationId* population_;
  ::Common::MsgCoordLatLong* position_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationConcentrationCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationConcentrationDestruction : public ::google::protobuf::Message {
 public:
  MsgPopulationConcentrationDestruction();
  virtual ~MsgPopulationConcentrationDestruction();
  
  MsgPopulationConcentrationDestruction(const MsgPopulationConcentrationDestruction& from);
  
  inline MsgPopulationConcentrationDestruction& operator=(const MsgPopulationConcentrationDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationConcentrationDestruction& default_instance();
  void Swap(MsgPopulationConcentrationDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationConcentrationDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationConcentrationDestruction& from);
  void MergeFrom(const MsgPopulationConcentrationDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationConcentrationId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationConcentrationId& id() const;
  inline ::Common::PopulationConcentrationId* mutable_id();
  
  // required .Common.PopulationId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& population() const;
  inline ::Common::PopulationId* mutable_population();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationConcentrationId* id_;
  ::Common::PopulationId* population_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationConcentrationDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationConcentrationUpdate : public ::google::protobuf::Message {
 public:
  MsgPopulationConcentrationUpdate();
  virtual ~MsgPopulationConcentrationUpdate();
  
  MsgPopulationConcentrationUpdate(const MsgPopulationConcentrationUpdate& from);
  
  inline MsgPopulationConcentrationUpdate& operator=(const MsgPopulationConcentrationUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationConcentrationUpdate& default_instance();
  void Swap(MsgPopulationConcentrationUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationConcentrationUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationConcentrationUpdate& from);
  void MergeFrom(const MsgPopulationConcentrationUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationConcentrationId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationConcentrationId& id() const;
  inline ::Common::PopulationConcentrationId* mutable_id();
  
  // required .Common.PopulationId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& population() const;
  inline ::Common::PopulationId* mutable_population();
  
  // optional int32 nb_humains_vivants = 3 [default = 0];
  inline bool has_nb_humains_vivants() const;
  inline void clear_nb_humains_vivants();
  static const int kNbHumainsVivantsFieldNumber = 3;
  inline ::google::protobuf::int32 nb_humains_vivants() const;
  inline void set_nb_humains_vivants(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_morts = 4 [default = 0];
  inline bool has_nb_humains_morts() const;
  inline void clear_nb_humains_morts();
  static const int kNbHumainsMortsFieldNumber = 4;
  inline ::google::protobuf::int32 nb_humains_morts() const;
  inline void set_nb_humains_morts(::google::protobuf::int32 value);
  
  // optional .Common.EnumPopulationAttitude attitude = 5;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 5;
  inline Common::EnumPopulationAttitude attitude() const;
  inline void set_attitude(Common::EnumPopulationAttitude value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationConcentrationId* id_;
  ::Common::PopulationId* population_;
  ::google::protobuf::int32 nb_humains_vivants_;
  ::google::protobuf::int32 nb_humains_morts_;
  int attitude_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationConcentrationUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationFlowCreation : public ::google::protobuf::Message {
 public:
  MsgPopulationFlowCreation();
  virtual ~MsgPopulationFlowCreation();
  
  MsgPopulationFlowCreation(const MsgPopulationFlowCreation& from);
  
  inline MsgPopulationFlowCreation& operator=(const MsgPopulationFlowCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationFlowCreation& default_instance();
  void Swap(MsgPopulationFlowCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationFlowCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationFlowCreation& from);
  void MergeFrom(const MsgPopulationFlowCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationFlowId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationFlowId& id() const;
  inline ::Common::PopulationFlowId* mutable_id();
  
  // required .Common.PopulationId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& population() const;
  inline ::Common::PopulationId* mutable_population();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationFlowId* id_;
  ::Common::PopulationId* population_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationFlowCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationFlowDestruction : public ::google::protobuf::Message {
 public:
  MsgPopulationFlowDestruction();
  virtual ~MsgPopulationFlowDestruction();
  
  MsgPopulationFlowDestruction(const MsgPopulationFlowDestruction& from);
  
  inline MsgPopulationFlowDestruction& operator=(const MsgPopulationFlowDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationFlowDestruction& default_instance();
  void Swap(MsgPopulationFlowDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationFlowDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationFlowDestruction& from);
  void MergeFrom(const MsgPopulationFlowDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationFlowId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationFlowId& id() const;
  inline ::Common::PopulationFlowId* mutable_id();
  
  // required .Common.PopulationId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& population() const;
  inline ::Common::PopulationId* mutable_population();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationFlowId* id_;
  ::Common::PopulationId* population_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationFlowDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationFlowUpdate : public ::google::protobuf::Message {
 public:
  MsgPopulationFlowUpdate();
  virtual ~MsgPopulationFlowUpdate();
  
  MsgPopulationFlowUpdate(const MsgPopulationFlowUpdate& from);
  
  inline MsgPopulationFlowUpdate& operator=(const MsgPopulationFlowUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationFlowUpdate& default_instance();
  void Swap(MsgPopulationFlowUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationFlowUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationFlowUpdate& from);
  void MergeFrom(const MsgPopulationFlowUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationFlowId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationFlowId& id() const;
  inline ::Common::PopulationFlowId* mutable_id();
  
  // required .Common.PopulationId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationId& population() const;
  inline ::Common::PopulationId* mutable_population();
  
  // optional .Common.MsgPath itineraire = 3;
  inline bool has_itineraire() const;
  inline void clear_itineraire();
  static const int kItineraireFieldNumber = 3;
  inline const ::Common::MsgPath& itineraire() const;
  inline ::Common::MsgPath* mutable_itineraire();
  
  // optional .Common.MsgPath flux = 4;
  inline bool has_flux() const;
  inline void clear_flux();
  static const int kFluxFieldNumber = 4;
  inline const ::Common::MsgPath& flux() const;
  inline ::Common::MsgPath* mutable_flux();
  
  // optional .Common.MsgHeading direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline const ::Common::MsgHeading& direction() const;
  inline ::Common::MsgHeading* mutable_direction();
  
  // optional int32 vitesse = 6 [default = 0];
  inline bool has_vitesse() const;
  inline void clear_vitesse();
  static const int kVitesseFieldNumber = 6;
  inline ::google::protobuf::int32 vitesse() const;
  inline void set_vitesse(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_vivants = 7 [default = 0];
  inline bool has_nb_humains_vivants() const;
  inline void clear_nb_humains_vivants();
  static const int kNbHumainsVivantsFieldNumber = 7;
  inline ::google::protobuf::int32 nb_humains_vivants() const;
  inline void set_nb_humains_vivants(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_morts = 8 [default = 0];
  inline bool has_nb_humains_morts() const;
  inline void clear_nb_humains_morts();
  static const int kNbHumainsMortsFieldNumber = 8;
  inline ::google::protobuf::int32 nb_humains_morts() const;
  inline void set_nb_humains_morts(::google::protobuf::int32 value);
  
  // optional .Common.EnumPopulationAttitude attitude = 9;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 9;
  inline Common::EnumPopulationAttitude attitude() const;
  inline void set_attitude(Common::EnumPopulationAttitude value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationFlowId* id_;
  ::Common::PopulationId* population_;
  ::Common::MsgPath* itineraire_;
  ::Common::MsgPath* flux_;
  ::Common::MsgHeading* direction_;
  ::google::protobuf::int32 vitesse_;
  ::google::protobuf::int32 nb_humains_vivants_;
  ::google::protobuf::int32 nb_humains_morts_;
  int attitude_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationFlowUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgPopulationKnowledgeCreation();
  virtual ~MsgPopulationKnowledgeCreation();
  
  MsgPopulationKnowledgeCreation(const MsgPopulationKnowledgeCreation& from);
  
  inline MsgPopulationKnowledgeCreation& operator=(const MsgPopulationKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationKnowledgeCreation& default_instance();
  void Swap(MsgPopulationKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationKnowledgeCreation& from);
  void MergeFrom(const MsgPopulationKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationKnowledgeId& id() const;
  inline ::Common::PopulationKnowledgeId* mutable_id();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional .Common.PopulationId population = 3;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 3;
  inline const ::Common::PopulationId& population() const;
  inline ::Common::PopulationId* mutable_population();
  
  // optional .Common.PartyId party = 4;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 4;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationKnowledgeId* id_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::PopulationId* population_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgPopulationKnowledgeUpdate();
  virtual ~MsgPopulationKnowledgeUpdate();
  
  MsgPopulationKnowledgeUpdate(const MsgPopulationKnowledgeUpdate& from);
  
  inline MsgPopulationKnowledgeUpdate& operator=(const MsgPopulationKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationKnowledgeUpdate& default_instance();
  void Swap(MsgPopulationKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationKnowledgeUpdate& from);
  void MergeFrom(const MsgPopulationKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationKnowledgeId& id() const;
  inline ::Common::PopulationKnowledgeId* mutable_id();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional int32 etat_domination = 3 [default = 0];
  inline bool has_etat_domination() const;
  inline void clear_etat_domination();
  static const int kEtatDominationFieldNumber = 3;
  inline ::google::protobuf::int32 etat_domination() const;
  inline void set_etat_domination(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationKnowledgeId* id_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::google::protobuf::int32 etat_domination_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgPopulationKnowledgeDestruction();
  virtual ~MsgPopulationKnowledgeDestruction();
  
  MsgPopulationKnowledgeDestruction(const MsgPopulationKnowledgeDestruction& from);
  
  inline MsgPopulationKnowledgeDestruction& operator=(const MsgPopulationKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationKnowledgeDestruction& default_instance();
  void Swap(MsgPopulationKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationKnowledgeDestruction& from);
  void MergeFrom(const MsgPopulationKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationKnowledgeId& id() const;
  inline ::Common::PopulationKnowledgeId* mutable_id();
  
  // required .Common.KnowledgeGroupId knowledge_group = 2;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 2;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationKnowledgeId* id_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationConcentrationKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgPopulationConcentrationKnowledgeCreation();
  virtual ~MsgPopulationConcentrationKnowledgeCreation();
  
  MsgPopulationConcentrationKnowledgeCreation(const MsgPopulationConcentrationKnowledgeCreation& from);
  
  inline MsgPopulationConcentrationKnowledgeCreation& operator=(const MsgPopulationConcentrationKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationConcentrationKnowledgeCreation& default_instance();
  void Swap(MsgPopulationConcentrationKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationConcentrationKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationConcentrationKnowledgeCreation& from);
  void MergeFrom(const MsgPopulationConcentrationKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationConcentrationKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationConcentrationKnowledgeId& id() const;
  inline ::Common::PopulationConcentrationKnowledgeId* mutable_id();
  
  // required .Common.PopulationKnowledgeId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationKnowledgeId& population() const;
  inline ::Common::PopulationKnowledgeId* mutable_population();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .Common.PopulationConcentrationId concentration = 4;
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 4;
  inline const ::Common::PopulationConcentrationId& concentration() const;
  inline ::Common::PopulationConcentrationId* mutable_concentration();
  
  // optional .Common.MsgCoordLatLong position = 5;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 5;
  inline const ::Common::MsgCoordLatLong& position() const;
  inline ::Common::MsgCoordLatLong* mutable_position();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationConcentrationKnowledgeId* id_;
  ::Common::PopulationKnowledgeId* population_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::PopulationConcentrationId* concentration_;
  ::Common::MsgCoordLatLong* position_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationConcentrationKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationConcentrationKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgPopulationConcentrationKnowledgeUpdate();
  virtual ~MsgPopulationConcentrationKnowledgeUpdate();
  
  MsgPopulationConcentrationKnowledgeUpdate(const MsgPopulationConcentrationKnowledgeUpdate& from);
  
  inline MsgPopulationConcentrationKnowledgeUpdate& operator=(const MsgPopulationConcentrationKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationConcentrationKnowledgeUpdate& default_instance();
  void Swap(MsgPopulationConcentrationKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationConcentrationKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationConcentrationKnowledgeUpdate& from);
  void MergeFrom(const MsgPopulationConcentrationKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationConcentrationKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationConcentrationKnowledgeId& id() const;
  inline ::Common::PopulationConcentrationKnowledgeId* mutable_id();
  
  // required .Common.PopulationKnowledgeId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationKnowledgeId& population() const;
  inline ::Common::PopulationKnowledgeId* mutable_population();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional .Common.PopulationConcentrationId concentration = 4;
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 4;
  inline const ::Common::PopulationConcentrationId& concentration() const;
  inline ::Common::PopulationConcentrationId* mutable_concentration();
  
  // optional int32 nb_humains_vivants = 5;
  inline bool has_nb_humains_vivants() const;
  inline void clear_nb_humains_vivants();
  static const int kNbHumainsVivantsFieldNumber = 5;
  inline ::google::protobuf::int32 nb_humains_vivants() const;
  inline void set_nb_humains_vivants(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_morts = 6;
  inline bool has_nb_humains_morts() const;
  inline void clear_nb_humains_morts();
  static const int kNbHumainsMortsFieldNumber = 6;
  inline ::google::protobuf::int32 nb_humains_morts() const;
  inline void set_nb_humains_morts(::google::protobuf::int32 value);
  
  // optional .Common.EnumPopulationAttitude attitude = 7;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 7;
  inline Common::EnumPopulationAttitude attitude() const;
  inline void set_attitude(Common::EnumPopulationAttitude value);
  
  // optional int32 pertinence = 8;
  inline bool has_pertinence() const;
  inline void clear_pertinence();
  static const int kPertinenceFieldNumber = 8;
  inline ::google::protobuf::int32 pertinence() const;
  inline void set_pertinence(::google::protobuf::int32 value);
  
  // optional bool est_percu = 9;
  inline bool has_est_percu() const;
  inline void clear_est_percu();
  static const int kEstPercuFieldNumber = 9;
  inline bool est_percu() const;
  inline void set_est_percu(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationConcentrationKnowledgeId* id_;
  ::Common::PopulationKnowledgeId* population_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::PopulationConcentrationId* concentration_;
  ::google::protobuf::int32 nb_humains_vivants_;
  ::google::protobuf::int32 nb_humains_morts_;
  int attitude_;
  ::google::protobuf::int32 pertinence_;
  bool est_percu_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationConcentrationKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationConcentrationKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgPopulationConcentrationKnowledgeDestruction();
  virtual ~MsgPopulationConcentrationKnowledgeDestruction();
  
  MsgPopulationConcentrationKnowledgeDestruction(const MsgPopulationConcentrationKnowledgeDestruction& from);
  
  inline MsgPopulationConcentrationKnowledgeDestruction& operator=(const MsgPopulationConcentrationKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationConcentrationKnowledgeDestruction& default_instance();
  void Swap(MsgPopulationConcentrationKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationConcentrationKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationConcentrationKnowledgeDestruction& from);
  void MergeFrom(const MsgPopulationConcentrationKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationConcentrationKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationConcentrationKnowledgeId& id() const;
  inline ::Common::PopulationConcentrationKnowledgeId* mutable_id();
  
  // required .Common.PopulationKnowledgeId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationKnowledgeId& population() const;
  inline ::Common::PopulationKnowledgeId* mutable_population();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationConcentrationKnowledgeId* id_;
  ::Common::PopulationKnowledgeId* population_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationConcentrationKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationFlowKnowledgeCreation : public ::google::protobuf::Message {
 public:
  MsgPopulationFlowKnowledgeCreation();
  virtual ~MsgPopulationFlowKnowledgeCreation();
  
  MsgPopulationFlowKnowledgeCreation(const MsgPopulationFlowKnowledgeCreation& from);
  
  inline MsgPopulationFlowKnowledgeCreation& operator=(const MsgPopulationFlowKnowledgeCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationFlowKnowledgeCreation& default_instance();
  void Swap(MsgPopulationFlowKnowledgeCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationFlowKnowledgeCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationFlowKnowledgeCreation& from);
  void MergeFrom(const MsgPopulationFlowKnowledgeCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationFlowKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationFlowKnowledgeId& id() const;
  inline ::Common::PopulationFlowKnowledgeId* mutable_id();
  
  // required .Common.PopulationKnowledgeId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationKnowledgeId& population() const;
  inline ::Common::PopulationKnowledgeId* mutable_population();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // required .Common.PopulationFlowId flow = 4;
  inline bool has_flow() const;
  inline void clear_flow();
  static const int kFlowFieldNumber = 4;
  inline const ::Common::PopulationFlowId& flow() const;
  inline ::Common::PopulationFlowId* mutable_flow();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationFlowKnowledgeId* id_;
  ::Common::PopulationKnowledgeId* population_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::PopulationFlowId* flow_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationFlowKnowledgeCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgFlowPart : public ::google::protobuf::Message {
 public:
  MsgFlowPart();
  virtual ~MsgFlowPart();
  
  MsgFlowPart(const MsgFlowPart& from);
  
  inline MsgFlowPart& operator=(const MsgFlowPart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFlowPart& default_instance();
  void Swap(MsgFlowPart* other);
  
  // implements Message ----------------------------------------------
  
  MsgFlowPart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFlowPart& from);
  void MergeFrom(const MsgFlowPart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.MsgPath forme = 1;
  inline bool has_forme() const;
  inline void clear_forme();
  static const int kFormeFieldNumber = 1;
  inline const ::Common::MsgPath& forme() const;
  inline ::Common::MsgPath* mutable_forme();
  
  // required int32 pertinence = 2;
  inline bool has_pertinence() const;
  inline void clear_pertinence();
  static const int kPertinenceFieldNumber = 2;
  inline ::google::protobuf::int32 pertinence() const;
  inline void set_pertinence(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::MsgPath* forme_;
  ::google::protobuf::int32 pertinence_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFlowPart* default_instance_;
};
// -------------------------------------------------------------------

class SeqOfFlowPart : public ::google::protobuf::Message {
 public:
  SeqOfFlowPart();
  virtual ~SeqOfFlowPart();
  
  SeqOfFlowPart(const SeqOfFlowPart& from);
  
  inline SeqOfFlowPart& operator=(const SeqOfFlowPart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqOfFlowPart& default_instance();
  void Swap(SeqOfFlowPart* other);
  
  // implements Message ----------------------------------------------
  
  SeqOfFlowPart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeqOfFlowPart& from);
  void MergeFrom(const SeqOfFlowPart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgFlowPart elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart >* mutable_elem();
  inline const ::MsgsSimToClient::MsgFlowPart& elem(int index) const;
  inline ::MsgsSimToClient::MsgFlowPart* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgFlowPart* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SeqOfFlowPart* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationFlowKnowledgeUpdate : public ::google::protobuf::Message {
 public:
  MsgPopulationFlowKnowledgeUpdate();
  virtual ~MsgPopulationFlowKnowledgeUpdate();
  
  MsgPopulationFlowKnowledgeUpdate(const MsgPopulationFlowKnowledgeUpdate& from);
  
  inline MsgPopulationFlowKnowledgeUpdate& operator=(const MsgPopulationFlowKnowledgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationFlowKnowledgeUpdate& default_instance();
  void Swap(MsgPopulationFlowKnowledgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationFlowKnowledgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationFlowKnowledgeUpdate& from);
  void MergeFrom(const MsgPopulationFlowKnowledgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationFlowKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationFlowKnowledgeId& id() const;
  inline ::Common::PopulationFlowKnowledgeId* mutable_id();
  
  // required .Common.PopulationKnowledgeId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationKnowledgeId& population() const;
  inline ::Common::PopulationKnowledgeId* mutable_population();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
  // optional .Common.PopulationFlowId flow = 4;
  inline bool has_flow() const;
  inline void clear_flow();
  static const int kFlowFieldNumber = 4;
  inline const ::Common::PopulationFlowId& flow() const;
  inline ::Common::PopulationFlowId* mutable_flow();
  
  // optional .MsgsSimToClient.SeqOfFlowPart portions_flux = 5;
  inline bool has_portions_flux() const;
  inline void clear_portions_flux();
  static const int kPortionsFluxFieldNumber = 5;
  inline const ::MsgsSimToClient::SeqOfFlowPart& portions_flux() const;
  inline ::MsgsSimToClient::SeqOfFlowPart* mutable_portions_flux();
  
  // optional .Common.MsgHeading direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline const ::Common::MsgHeading& direction() const;
  inline ::Common::MsgHeading* mutable_direction();
  
  // optional int32 vitesse = 7;
  inline bool has_vitesse() const;
  inline void clear_vitesse();
  static const int kVitesseFieldNumber = 7;
  inline ::google::protobuf::int32 vitesse() const;
  inline void set_vitesse(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_vivants = 8;
  inline bool has_nb_humains_vivants() const;
  inline void clear_nb_humains_vivants();
  static const int kNbHumainsVivantsFieldNumber = 8;
  inline ::google::protobuf::int32 nb_humains_vivants() const;
  inline void set_nb_humains_vivants(::google::protobuf::int32 value);
  
  // optional int32 nb_humains_morts = 9;
  inline bool has_nb_humains_morts() const;
  inline void clear_nb_humains_morts();
  static const int kNbHumainsMortsFieldNumber = 9;
  inline ::google::protobuf::int32 nb_humains_morts() const;
  inline void set_nb_humains_morts(::google::protobuf::int32 value);
  
  // optional .Common.EnumPopulationAttitude attitude = 10;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 10;
  inline Common::EnumPopulationAttitude attitude() const;
  inline void set_attitude(Common::EnumPopulationAttitude value);
  
  // optional bool est_percu = 11;
  inline bool has_est_percu() const;
  inline void clear_est_percu();
  static const int kEstPercuFieldNumber = 11;
  inline bool est_percu() const;
  inline void set_est_percu(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationFlowKnowledgeId* id_;
  ::Common::PopulationKnowledgeId* population_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  ::Common::PopulationFlowId* flow_;
  ::MsgsSimToClient::SeqOfFlowPart* portions_flux_;
  ::Common::MsgHeading* direction_;
  ::google::protobuf::int32 vitesse_;
  ::google::protobuf::int32 nb_humains_vivants_;
  ::google::protobuf::int32 nb_humains_morts_;
  int attitude_;
  bool est_percu_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationFlowKnowledgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgPopulationFlowKnowledgeDestruction : public ::google::protobuf::Message {
 public:
  MsgPopulationFlowKnowledgeDestruction();
  virtual ~MsgPopulationFlowKnowledgeDestruction();
  
  MsgPopulationFlowKnowledgeDestruction(const MsgPopulationFlowKnowledgeDestruction& from);
  
  inline MsgPopulationFlowKnowledgeDestruction& operator=(const MsgPopulationFlowKnowledgeDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPopulationFlowKnowledgeDestruction& default_instance();
  void Swap(MsgPopulationFlowKnowledgeDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgPopulationFlowKnowledgeDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPopulationFlowKnowledgeDestruction& from);
  void MergeFrom(const MsgPopulationFlowKnowledgeDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.PopulationFlowKnowledgeId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::PopulationFlowKnowledgeId& id() const;
  inline ::Common::PopulationFlowKnowledgeId* mutable_id();
  
  // required .Common.PopulationKnowledgeId population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline const ::Common::PopulationKnowledgeId& population() const;
  inline ::Common::PopulationKnowledgeId* mutable_population();
  
  // required .Common.KnowledgeGroupId knowledge_group = 3;
  inline bool has_knowledge_group() const;
  inline void clear_knowledge_group();
  static const int kKnowledgeGroupFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& knowledge_group() const;
  inline ::Common::KnowledgeGroupId* mutable_knowledge_group();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::PopulationFlowKnowledgeId* id_;
  ::Common::PopulationKnowledgeId* population_;
  ::Common::KnowledgeGroupId* knowledge_group_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgPopulationFlowKnowledgeDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkCreation_profiles : public ::google::protobuf::Message {
 public:
  MsgFolkCreation_profiles();
  virtual ~MsgFolkCreation_profiles();
  
  MsgFolkCreation_profiles(const MsgFolkCreation_profiles& from);
  
  inline MsgFolkCreation_profiles& operator=(const MsgFolkCreation_profiles& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkCreation_profiles& default_instance();
  void Swap(MsgFolkCreation_profiles* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkCreation_profiles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkCreation_profiles& from);
  void MergeFrom(const MsgFolkCreation_profiles& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_elem();
  inline const ::std::string& elem(int index) const;
  inline ::std::string* mutable_elem(int index);
  inline void set_elem(int index, const ::std::string& value);
  inline void set_elem(int index, const char* value);
  inline void set_elem(int index, const char* value, size_t size);
  inline ::std::string* add_elem();
  inline void add_elem(const ::std::string& value);
  inline void add_elem(const char* value);
  inline void add_elem(const char* value, size_t size);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkCreation_profiles* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkCreation_activities : public ::google::protobuf::Message {
 public:
  MsgFolkCreation_activities();
  virtual ~MsgFolkCreation_activities();
  
  MsgFolkCreation_activities(const MsgFolkCreation_activities& from);
  
  inline MsgFolkCreation_activities& operator=(const MsgFolkCreation_activities& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkCreation_activities& default_instance();
  void Swap(MsgFolkCreation_activities* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkCreation_activities* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkCreation_activities& from);
  void MergeFrom(const MsgFolkCreation_activities& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_elem();
  inline const ::std::string& elem(int index) const;
  inline ::std::string* mutable_elem(int index);
  inline void set_elem(int index, const ::std::string& value);
  inline void set_elem(int index, const char* value);
  inline void set_elem(int index, const char* value, size_t size);
  inline ::std::string* add_elem();
  inline void add_elem(const ::std::string& value);
  inline void add_elem(const char* value);
  inline void add_elem(const char* value, size_t size);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkCreation_activities* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkCreation : public ::google::protobuf::Message {
 public:
  MsgFolkCreation();
  virtual ~MsgFolkCreation();
  
  MsgFolkCreation(const MsgFolkCreation& from);
  
  inline MsgFolkCreation& operator=(const MsgFolkCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkCreation& default_instance();
  void Swap(MsgFolkCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkCreation& from);
  void MergeFrom(const MsgFolkCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgFolkCreation_profiles profiles = 1;
  inline bool has_profiles() const;
  inline void clear_profiles();
  static const int kProfilesFieldNumber = 1;
  inline const ::MsgsSimToClient::MsgFolkCreation_profiles& profiles() const;
  inline ::MsgsSimToClient::MsgFolkCreation_profiles* mutable_profiles();
  
  // required .MsgsSimToClient.MsgFolkCreation_activities activities = 2;
  inline bool has_activities() const;
  inline void clear_activities();
  static const int kActivitiesFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgFolkCreation_activities& activities() const;
  inline ::MsgsSimToClient::MsgFolkCreation_activities* mutable_activities();
  
  // optional int32 container_size = 3;
  inline bool has_container_size() const;
  inline void clear_container_size();
  static const int kContainerSizeFieldNumber = 3;
  inline ::google::protobuf::int32 container_size() const;
  inline void set_container_size(::google::protobuf::int32 value);
  
  // optional int32 edge_number = 4;
  inline bool has_edge_number() const;
  inline void clear_edge_number();
  static const int kEdgeNumberFieldNumber = 4;
  inline ::google::protobuf::int32 edge_number() const;
  inline void set_edge_number(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsSimToClient::MsgFolkCreation_profiles* profiles_;
  ::MsgsSimToClient::MsgFolkCreation_activities* activities_;
  ::google::protobuf::int32 container_size_;
  ::google::protobuf::int32 edge_number_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkGraphEdgeUpdate : public ::google::protobuf::Message {
 public:
  MsgFolkGraphEdgeUpdate();
  virtual ~MsgFolkGraphEdgeUpdate();
  
  MsgFolkGraphEdgeUpdate(const MsgFolkGraphEdgeUpdate& from);
  
  inline MsgFolkGraphEdgeUpdate& operator=(const MsgFolkGraphEdgeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkGraphEdgeUpdate& default_instance();
  void Swap(MsgFolkGraphEdgeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkGraphEdgeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkGraphEdgeUpdate& from);
  void MergeFrom(const MsgFolkGraphEdgeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline ::google::protobuf::int32 oid() const;
  inline void set_oid(::google::protobuf::int32 value);
  
  // required int32 shp_oid = 2;
  inline bool has_shp_oid() const;
  inline void clear_shp_oid();
  static const int kShpOidFieldNumber = 2;
  inline ::google::protobuf::int32 shp_oid() const;
  inline void set_shp_oid(::google::protobuf::int32 value);
  
  // repeated int32 population_occupation = 3;
  inline int population_occupation_size() const;
  inline void clear_population_occupation();
  static const int kPopulationOccupationFieldNumber = 3;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >& population_occupation() const
      ;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >* mutable_population_occupation();
  inline ::google::protobuf::int32 population_occupation(int index) const;
  inline void set_population_occupation(int index, ::google::protobuf::int32 value);
  inline void add_population_occupation(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 oid_;
  ::google::protobuf::int32 shp_oid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > population_occupation_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkGraphEdgeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgFolkGraphUpdate : public ::google::protobuf::Message {
 public:
  MsgFolkGraphUpdate();
  virtual ~MsgFolkGraphUpdate();
  
  MsgFolkGraphUpdate(const MsgFolkGraphUpdate& from);
  
  inline MsgFolkGraphUpdate& operator=(const MsgFolkGraphUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFolkGraphUpdate& default_instance();
  void Swap(MsgFolkGraphUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgFolkGraphUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgFolkGraphUpdate& from);
  void MergeFrom(const MsgFolkGraphUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MsgsSimToClient.MsgFolkGraphEdgeUpdate elem = 1;
  inline int elem_size() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate >& elem() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate >* mutable_elem();
  inline const ::MsgsSimToClient::MsgFolkGraphEdgeUpdate& elem(int index) const;
  inline ::MsgsSimToClient::MsgFolkGraphEdgeUpdate* mutable_elem(int index);
  inline ::MsgsSimToClient::MsgFolkGraphEdgeUpdate* add_elem();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate > elem_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgFolkGraphUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSetFrequencyAck : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSetFrequencyAck();
  virtual ~MsgControlCheckPointSetFrequencyAck();
  
  MsgControlCheckPointSetFrequencyAck(const MsgControlCheckPointSetFrequencyAck& from);
  
  inline MsgControlCheckPointSetFrequencyAck& operator=(const MsgControlCheckPointSetFrequencyAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSetFrequencyAck& default_instance();
  void Swap(MsgControlCheckPointSetFrequencyAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSetFrequencyAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSetFrequencyAck& from);
  void MergeFrom(const MsgControlCheckPointSetFrequencyAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSetFrequencyAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSaveNowAck : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSaveNowAck();
  virtual ~MsgControlCheckPointSaveNowAck();
  
  MsgControlCheckPointSaveNowAck(const MsgControlCheckPointSaveNowAck& from);
  
  inline MsgControlCheckPointSaveNowAck& operator=(const MsgControlCheckPointSaveNowAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSaveNowAck& default_instance();
  void Swap(MsgControlCheckPointSaveNowAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSaveNowAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSaveNowAck& from);
  void MergeFrom(const MsgControlCheckPointSaveNowAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSaveNowAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSaveBegin : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSaveBegin();
  virtual ~MsgControlCheckPointSaveBegin();
  
  MsgControlCheckPointSaveBegin(const MsgControlCheckPointSaveBegin& from);
  
  inline MsgControlCheckPointSaveBegin& operator=(const MsgControlCheckPointSaveBegin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSaveBegin& default_instance();
  void Swap(MsgControlCheckPointSaveBegin* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSaveBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSaveBegin& from);
  void MergeFrom(const MsgControlCheckPointSaveBegin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSaveBegin* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSaveBeginAck : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSaveBeginAck();
  virtual ~MsgControlCheckPointSaveBeginAck();
  
  MsgControlCheckPointSaveBeginAck(const MsgControlCheckPointSaveBeginAck& from);
  
  inline MsgControlCheckPointSaveBeginAck& operator=(const MsgControlCheckPointSaveBeginAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSaveBeginAck& default_instance();
  void Swap(MsgControlCheckPointSaveBeginAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSaveBeginAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSaveBeginAck& from);
  void MergeFrom(const MsgControlCheckPointSaveBeginAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSaveBeginAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlCheckPointSaveEnd : public ::google::protobuf::Message {
 public:
  MsgControlCheckPointSaveEnd();
  virtual ~MsgControlCheckPointSaveEnd();
  
  MsgControlCheckPointSaveEnd(const MsgControlCheckPointSaveEnd& from);
  
  inline MsgControlCheckPointSaveEnd& operator=(const MsgControlCheckPointSaveEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlCheckPointSaveEnd& default_instance();
  void Swap(MsgControlCheckPointSaveEnd* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlCheckPointSaveEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlCheckPointSaveEnd& from);
  void MergeFrom(const MsgControlCheckPointSaveEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlCheckPointSaveEnd* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlSendCurrentStateBegin : public ::google::protobuf::Message {
 public:
  MsgControlSendCurrentStateBegin();
  virtual ~MsgControlSendCurrentStateBegin();
  
  MsgControlSendCurrentStateBegin(const MsgControlSendCurrentStateBegin& from);
  
  inline MsgControlSendCurrentStateBegin& operator=(const MsgControlSendCurrentStateBegin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlSendCurrentStateBegin& default_instance();
  void Swap(MsgControlSendCurrentStateBegin* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlSendCurrentStateBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlSendCurrentStateBegin& from);
  void MergeFrom(const MsgControlSendCurrentStateBegin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlSendCurrentStateBegin* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlSendCurrentStateEnd : public ::google::protobuf::Message {
 public:
  MsgControlSendCurrentStateEnd();
  virtual ~MsgControlSendCurrentStateEnd();
  
  MsgControlSendCurrentStateEnd(const MsgControlSendCurrentStateEnd& from);
  
  inline MsgControlSendCurrentStateEnd& operator=(const MsgControlSendCurrentStateEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlSendCurrentStateEnd& default_instance();
  void Swap(MsgControlSendCurrentStateEnd* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlSendCurrentStateEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlSendCurrentStateEnd& from);
  void MergeFrom(const MsgControlSendCurrentStateEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlSendCurrentStateEnd* default_instance_;
};
// -------------------------------------------------------------------

class MagicActionCreateUrban : public ::google::protobuf::Message {
 public:
  MagicActionCreateUrban();
  virtual ~MagicActionCreateUrban();
  
  MagicActionCreateUrban(const MagicActionCreateUrban& from);
  
  inline MagicActionCreateUrban& operator=(const MagicActionCreateUrban& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MagicActionCreateUrban& default_instance();
  void Swap(MagicActionCreateUrban* other);
  
  // implements Message ----------------------------------------------
  
  MagicActionCreateUrban* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MagicActionCreateUrban& from);
  void MergeFrom(const MagicActionCreateUrban& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .Common.MsgLocation location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::Common::MsgLocation* location_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MagicActionCreateUrban* default_instance_;
};
// -------------------------------------------------------------------

class MagicActionUpdateUrban : public ::google::protobuf::Message {
 public:
  MagicActionUpdateUrban();
  virtual ~MagicActionUpdateUrban();
  
  MagicActionUpdateUrban(const MagicActionUpdateUrban& from);
  
  inline MagicActionUpdateUrban& operator=(const MagicActionUpdateUrban& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MagicActionUpdateUrban& default_instance();
  void Swap(MagicActionUpdateUrban* other);
  
  // implements Message ----------------------------------------------
  
  MagicActionUpdateUrban* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MagicActionUpdateUrban& from);
  void MergeFrom(const MagicActionUpdateUrban& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline ::google::protobuf::uint32 oid() const;
  inline void set_oid(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 oid_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MagicActionUpdateUrban* default_instance_;
};
// -------------------------------------------------------------------

class MagicActionDestroyUrban : public ::google::protobuf::Message {
 public:
  MagicActionDestroyUrban();
  virtual ~MagicActionDestroyUrban();
  
  MagicActionDestroyUrban(const MagicActionDestroyUrban& from);
  
  inline MagicActionDestroyUrban& operator=(const MagicActionDestroyUrban& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MagicActionDestroyUrban& default_instance();
  void Swap(MagicActionDestroyUrban* other);
  
  // implements Message ----------------------------------------------
  
  MagicActionDestroyUrban* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MagicActionDestroyUrban& from);
  void MergeFrom(const MagicActionDestroyUrban& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline ::google::protobuf::uint32 oid() const;
  inline void set_oid(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 oid_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MagicActionDestroyUrban* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanMagicAction : public ::google::protobuf::Message {
 public:
  MsgUrbanMagicAction();
  virtual ~MsgUrbanMagicAction();
  
  MsgUrbanMagicAction(const MsgUrbanMagicAction& from);
  
  inline MsgUrbanMagicAction& operator=(const MsgUrbanMagicAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanMagicAction& default_instance();
  void Swap(MsgUrbanMagicAction* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanMagicAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanMagicAction& from);
  void MergeFrom(const MsgUrbanMagicAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MagicActionCreateUrban create_urban = 1;
  inline bool has_create_urban() const;
  inline void clear_create_urban();
  static const int kCreateUrbanFieldNumber = 1;
  inline const ::MsgsSimToClient::MagicActionCreateUrban& create_urban() const;
  inline ::MsgsSimToClient::MagicActionCreateUrban* mutable_create_urban();
  
  // optional .MsgsSimToClient.MagicActionUpdateUrban update_urban = 2;
  inline bool has_update_urban() const;
  inline void clear_update_urban();
  static const int kUpdateUrbanFieldNumber = 2;
  inline const ::MsgsSimToClient::MagicActionUpdateUrban& update_urban() const;
  inline ::MsgsSimToClient::MagicActionUpdateUrban* mutable_update_urban();
  
  // optional .MsgsSimToClient.MagicActionDestroyUrban destroy_urban = 3;
  inline bool has_destroy_urban() const;
  inline void clear_destroy_urban();
  static const int kDestroyUrbanFieldNumber = 3;
  inline const ::MsgsSimToClient::MagicActionDestroyUrban& destroy_urban() const;
  inline ::MsgsSimToClient::MagicActionDestroyUrban* mutable_destroy_urban();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsSimToClient::MagicActionCreateUrban* create_urban_;
  ::MsgsSimToClient::MagicActionUpdateUrban* update_urban_;
  ::MsgsSimToClient::MagicActionDestroyUrban* destroy_urban_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanMagicAction* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgUrbanMagicActionAck();
  virtual ~MsgUrbanMagicActionAck();
  
  MsgUrbanMagicActionAck(const MsgUrbanMagicActionAck& from);
  
  inline MsgUrbanMagicActionAck& operator=(const MsgUrbanMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanMagicActionAck& default_instance();
  void Swap(MsgUrbanMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanMagicActionAck& from);
  void MergeFrom(const MsgUrbanMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgUrbanMagicActionAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = MsgUrbanMagicActionAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_urban = MsgUrbanMagicActionAck_ErrorCode_error_invalid_urban;
  static const ErrorCode error_invalid_id = MsgUrbanMagicActionAck_ErrorCode_error_invalid_id;
  static const ErrorCode error_invalid_camp = MsgUrbanMagicActionAck_ErrorCode_error_invalid_camp;
  static const ErrorCode error_invalid_localisation = MsgUrbanMagicActionAck_ErrorCode_error_invalid_localisation;
  static const ErrorCode error_missing_specific_attributes = MsgUrbanMagicActionAck_ErrorCode_error_missing_specific_attributes;
  static const ErrorCode error_invalid_specific_attributes = MsgUrbanMagicActionAck_ErrorCode_error_invalid_specific_attributes;
  static inline bool ErrorCode_IsValid(int value) {
    return MsgUrbanMagicActionAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MsgUrbanMagicActionAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MsgUrbanMagicActionAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MsgUrbanMagicActionAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MsgUrbanMagicActionAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MsgUrbanMagicActionAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .MsgsSimToClient.MsgUrbanMagicActionAck.ErrorCode error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanAttributes_Architecture : public ::google::protobuf::Message {
 public:
  MsgUrbanAttributes_Architecture();
  virtual ~MsgUrbanAttributes_Architecture();
  
  MsgUrbanAttributes_Architecture(const MsgUrbanAttributes_Architecture& from);
  
  inline MsgUrbanAttributes_Architecture& operator=(const MsgUrbanAttributes_Architecture& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanAttributes_Architecture& default_instance();
  void Swap(MsgUrbanAttributes_Architecture* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanAttributes_Architecture* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanAttributes_Architecture& from);
  void MergeFrom(const MsgUrbanAttributes_Architecture& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float height = 1;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 1;
  inline float height() const;
  inline void set_height(float value);
  
  // required int32 floor_number = 2;
  inline bool has_floor_number() const;
  inline void clear_floor_number();
  static const int kFloorNumberFieldNumber = 2;
  inline ::google::protobuf::int32 floor_number() const;
  inline void set_floor_number(::google::protobuf::int32 value);
  
  // required string roof_shape = 3;
  inline bool has_roof_shape() const;
  inline void clear_roof_shape();
  static const int kRoofShapeFieldNumber = 3;
  inline const ::std::string& roof_shape() const;
  inline void set_roof_shape(const ::std::string& value);
  inline void set_roof_shape(const char* value);
  inline void set_roof_shape(const char* value, size_t size);
  inline ::std::string* mutable_roof_shape();
  
  // required string material = 4;
  inline bool has_material() const;
  inline void clear_material();
  static const int kMaterialFieldNumber = 4;
  inline const ::std::string& material() const;
  inline void set_material(const ::std::string& value);
  inline void set_material(const char* value);
  inline void set_material(const char* value, size_t size);
  inline ::std::string* mutable_material();
  
  // required float occupation = 5;
  inline bool has_occupation() const;
  inline void clear_occupation();
  static const int kOccupationFieldNumber = 5;
  inline float occupation() const;
  inline void set_occupation(float value);
  
  // required float trafficability = 6;
  inline bool has_trafficability() const;
  inline void clear_trafficability();
  static const int kTrafficabilityFieldNumber = 6;
  inline float trafficability() const;
  inline void set_trafficability(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float height_;
  ::google::protobuf::int32 floor_number_;
  ::std::string* roof_shape_;
  static const ::std::string _default_roof_shape_;
  ::std::string* material_;
  static const ::std::string _default_material_;
  float occupation_;
  float trafficability_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanAttributes_Architecture* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanAttributes_Structure : public ::google::protobuf::Message {
 public:
  MsgUrbanAttributes_Structure();
  virtual ~MsgUrbanAttributes_Structure();
  
  MsgUrbanAttributes_Structure(const MsgUrbanAttributes_Structure& from);
  
  inline MsgUrbanAttributes_Structure& operator=(const MsgUrbanAttributes_Structure& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanAttributes_Structure& default_instance();
  void Swap(MsgUrbanAttributes_Structure* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanAttributes_Structure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanAttributes_Structure& from);
  void MergeFrom(const MsgUrbanAttributes_Structure& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 state_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanAttributes_Structure* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanAttributes_Infrastructures : public ::google::protobuf::Message {
 public:
  MsgUrbanAttributes_Infrastructures();
  virtual ~MsgUrbanAttributes_Infrastructures();
  
  MsgUrbanAttributes_Infrastructures(const MsgUrbanAttributes_Infrastructures& from);
  
  inline MsgUrbanAttributes_Infrastructures& operator=(const MsgUrbanAttributes_Infrastructures& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanAttributes_Infrastructures& default_instance();
  void Swap(MsgUrbanAttributes_Infrastructures* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanAttributes_Infrastructures* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanAttributes_Infrastructures& from);
  void MergeFrom(const MsgUrbanAttributes_Infrastructures& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Common.ResourceNetwork resource_network = 1;
  inline int resource_network_size() const;
  inline void clear_resource_network();
  static const int kResourceNetworkFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork >& resource_network() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork >* mutable_resource_network();
  inline const ::Common::ResourceNetwork& resource_network(int index) const;
  inline ::Common::ResourceNetwork* mutable_resource_network(int index);
  inline ::Common::ResourceNetwork* add_resource_network();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork > resource_network_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanAttributes_Infrastructures* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanAttributes_RgbaColor : public ::google::protobuf::Message {
 public:
  MsgUrbanAttributes_RgbaColor();
  virtual ~MsgUrbanAttributes_RgbaColor();
  
  MsgUrbanAttributes_RgbaColor(const MsgUrbanAttributes_RgbaColor& from);
  
  inline MsgUrbanAttributes_RgbaColor& operator=(const MsgUrbanAttributes_RgbaColor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanAttributes_RgbaColor& default_instance();
  void Swap(MsgUrbanAttributes_RgbaColor* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanAttributes_RgbaColor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanAttributes_RgbaColor& from);
  void MergeFrom(const MsgUrbanAttributes_RgbaColor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 red = 1;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 1;
  inline ::google::protobuf::int32 red() const;
  inline void set_red(::google::protobuf::int32 value);
  
  // required int32 green = 2;
  inline bool has_green() const;
  inline void clear_green();
  static const int kGreenFieldNumber = 2;
  inline ::google::protobuf::int32 green() const;
  inline void set_green(::google::protobuf::int32 value);
  
  // required int32 blue = 3;
  inline bool has_blue() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 3;
  inline ::google::protobuf::int32 blue() const;
  inline void set_blue(::google::protobuf::int32 value);
  
  // required float alpha = 4;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 4;
  inline float alpha() const;
  inline void set_alpha(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 red_;
  ::google::protobuf::int32 green_;
  ::google::protobuf::int32 blue_;
  float alpha_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanAttributes_RgbaColor* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanAttributes : public ::google::protobuf::Message {
 public:
  MsgUrbanAttributes();
  virtual ~MsgUrbanAttributes();
  
  MsgUrbanAttributes(const MsgUrbanAttributes& from);
  
  inline MsgUrbanAttributes& operator=(const MsgUrbanAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanAttributes& default_instance();
  void Swap(MsgUrbanAttributes* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanAttributes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanAttributes& from);
  void MergeFrom(const MsgUrbanAttributes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgUrbanAttributes_Architecture Architecture;
  typedef MsgUrbanAttributes_Structure Structure;
  typedef MsgUrbanAttributes_Infrastructures Infrastructures;
  typedef MsgUrbanAttributes_RgbaColor RgbaColor;
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MsgUrbanAttributes.Architecture architecture = 1;
  inline bool has_architecture() const;
  inline void clear_architecture();
  static const int kArchitectureFieldNumber = 1;
  inline const ::MsgsSimToClient::MsgUrbanAttributes_Architecture& architecture() const;
  inline ::MsgsSimToClient::MsgUrbanAttributes_Architecture* mutable_architecture();
  
  // optional .MsgsSimToClient.MsgUrbanAttributes.Structure structure = 2;
  inline bool has_structure() const;
  inline void clear_structure();
  static const int kStructureFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgUrbanAttributes_Structure& structure() const;
  inline ::MsgsSimToClient::MsgUrbanAttributes_Structure* mutable_structure();
  
  // optional .MsgsSimToClient.MsgUrbanAttributes.RgbaColor color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgUrbanAttributes_RgbaColor& color() const;
  inline ::MsgsSimToClient::MsgUrbanAttributes_RgbaColor* mutable_color();
  
  // optional .MsgsSimToClient.MsgUrbanAttributes.Infrastructures infrastructures = 4;
  inline bool has_infrastructures() const;
  inline void clear_infrastructures();
  static const int kInfrastructuresFieldNumber = 4;
  inline const ::MsgsSimToClient::MsgUrbanAttributes_Infrastructures& infrastructures() const;
  inline ::MsgsSimToClient::MsgUrbanAttributes_Infrastructures* mutable_infrastructures();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsSimToClient::MsgUrbanAttributes_Architecture* architecture_;
  ::MsgsSimToClient::MsgUrbanAttributes_Structure* structure_;
  ::MsgsSimToClient::MsgUrbanAttributes_RgbaColor* color_;
  ::MsgsSimToClient::MsgUrbanAttributes_Infrastructures* infrastructures_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanAttributes* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanCreation : public ::google::protobuf::Message {
 public:
  MsgUrbanCreation();
  virtual ~MsgUrbanCreation();
  
  MsgUrbanCreation(const MsgUrbanCreation& from);
  
  inline MsgUrbanCreation& operator=(const MsgUrbanCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanCreation& default_instance();
  void Swap(MsgUrbanCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanCreation& from);
  void MergeFrom(const MsgUrbanCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline ::google::protobuf::uint32 oid() const;
  inline void set_oid(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .Common.MsgLocation location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // optional .MsgsSimToClient.MsgUrbanAttributes attributes = 4;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  inline const ::MsgsSimToClient::MsgUrbanAttributes& attributes() const;
  inline ::MsgsSimToClient::MsgUrbanAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 oid_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::Common::MsgLocation* location_;
  ::MsgsSimToClient::MsgUrbanAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanDetection : public ::google::protobuf::Message {
 public:
  MsgUrbanDetection();
  virtual ~MsgUrbanDetection();
  
  MsgUrbanDetection(const MsgUrbanDetection& from);
  
  inline MsgUrbanDetection& operator=(const MsgUrbanDetection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanDetection& default_instance();
  void Swap(MsgUrbanDetection* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanDetection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanDetection& from);
  void MergeFrom(const MsgUrbanDetection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline ::google::protobuf::uint32 oid() const;
  inline void set_oid(::google::protobuf::uint32 value);
  
  // required uint32 urban_oid = 2;
  inline bool has_urban_oid() const;
  inline void clear_urban_oid();
  static const int kUrbanOidFieldNumber = 2;
  inline ::google::protobuf::uint32 urban_oid() const;
  inline void set_urban_oid(::google::protobuf::uint32 value);
  
  // required .Common.EnumUnitVisibility visibility = 3;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 3;
  inline Common::EnumUnitVisibility visibility() const;
  inline void set_visibility(Common::EnumUnitVisibility value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 oid_;
  ::google::protobuf::uint32 urban_oid_;
  int visibility_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanDetection* default_instance_;
};
// -------------------------------------------------------------------

class MsgUrbanUpdate : public ::google::protobuf::Message {
 public:
  MsgUrbanUpdate();
  virtual ~MsgUrbanUpdate();
  
  MsgUrbanUpdate(const MsgUrbanUpdate& from);
  
  inline MsgUrbanUpdate& operator=(const MsgUrbanUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgUrbanUpdate& default_instance();
  void Swap(MsgUrbanUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgUrbanUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgUrbanUpdate& from);
  void MergeFrom(const MsgUrbanUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 oid = 1;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 1;
  inline ::google::protobuf::uint32 oid() const;
  inline void set_oid(::google::protobuf::uint32 value);
  
  // optional .Common.MsgLocation location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Common::MsgLocation& location() const;
  inline ::Common::MsgLocation* mutable_location();
  
  // optional .MsgsSimToClient.MsgUrbanAttributes attributes = 3;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgUrbanAttributes& attributes() const;
  inline ::MsgsSimToClient::MsgUrbanAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 oid_;
  ::Common::MsgLocation* location_;
  ::MsgsSimToClient::MsgUrbanAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgUrbanUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupCreation : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupCreation();
  virtual ~MsgKnowledgeGroupCreation();
  
  MsgKnowledgeGroupCreation(const MsgKnowledgeGroupCreation& from);
  
  inline MsgKnowledgeGroupCreation& operator=(const MsgKnowledgeGroupCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupCreation& default_instance();
  void Swap(MsgKnowledgeGroupCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupCreation& from);
  void MergeFrom(const MsgKnowledgeGroupCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& id() const;
  inline ::Common::KnowledgeGroupId* mutable_id();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.KnowledgeGroupId parent = 3;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& parent() const;
  inline ::Common::KnowledgeGroupId* mutable_parent();
  
  // required string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
  // optional bool jam = 5;
  inline bool has_jam() const;
  inline void clear_jam();
  static const int kJamFieldNumber = 5;
  inline bool jam() const;
  inline void set_jam(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* id_;
  ::Common::PartyId* party_;
  ::Common::KnowledgeGroupId* parent_;
  ::std::string* type_;
  static const ::std::string _default_type_;
  bool jam_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupUpdate : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupUpdate();
  virtual ~MsgKnowledgeGroupUpdate();
  
  MsgKnowledgeGroupUpdate(const MsgKnowledgeGroupUpdate& from);
  
  inline MsgKnowledgeGroupUpdate& operator=(const MsgKnowledgeGroupUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupUpdate& default_instance();
  void Swap(MsgKnowledgeGroupUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupUpdate& from);
  void MergeFrom(const MsgKnowledgeGroupUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& id() const;
  inline ::Common::KnowledgeGroupId* mutable_id();
  
  // optional .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
  // optional .Common.KnowledgeGroupId parent = 3;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 3;
  inline const ::Common::KnowledgeGroupId& parent() const;
  inline ::Common::KnowledgeGroupId* mutable_parent();
  
  // optional bool enabled = 4;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 4;
  inline bool enabled() const;
  inline void set_enabled(bool value);
  
  // optional string type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* id_;
  ::Common::PartyId* party_;
  ::Common::KnowledgeGroupId* parent_;
  bool enabled_;
  ::std::string* type_;
  static const ::std::string _default_type_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupUpdate* default_instance_;
};
// -------------------------------------------------------------------

class KnowledgeGroupAck : public ::google::protobuf::Message {
 public:
  KnowledgeGroupAck();
  virtual ~KnowledgeGroupAck();
  
  KnowledgeGroupAck(const KnowledgeGroupAck& from);
  
  inline KnowledgeGroupAck& operator=(const KnowledgeGroupAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KnowledgeGroupAck& default_instance();
  void Swap(KnowledgeGroupAck* other);
  
  // implements Message ----------------------------------------------
  
  KnowledgeGroupAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KnowledgeGroupAck& from);
  void MergeFrom(const KnowledgeGroupAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef KnowledgeGroupAck_ErrorCode ErrorCode;
  static const ErrorCode no_error = KnowledgeGroupAck_ErrorCode_no_error;
  static const ErrorCode error_invalid_unit = KnowledgeGroupAck_ErrorCode_error_invalid_unit;
  static const ErrorCode error_invalid_superior = KnowledgeGroupAck_ErrorCode_error_invalid_superior;
  static const ErrorCode error_invalid_camp = KnowledgeGroupAck_ErrorCode_error_invalid_camp;
  static const ErrorCode error_invalid_knowledgegroup = KnowledgeGroupAck_ErrorCode_error_invalid_knowledgegroup;
  static const ErrorCode error_invalid_type = KnowledgeGroupAck_ErrorCode_error_invalid_type;
  static inline bool ErrorCode_IsValid(int value) {
    return KnowledgeGroupAck_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    KnowledgeGroupAck_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    KnowledgeGroupAck_ErrorCode_ErrorCode_MAX;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return KnowledgeGroupAck_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return KnowledgeGroupAck_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return KnowledgeGroupAck_ErrorCode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static KnowledgeGroupAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupMagicActionAck : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupMagicActionAck();
  virtual ~MsgKnowledgeGroupMagicActionAck();
  
  MsgKnowledgeGroupMagicActionAck(const MsgKnowledgeGroupMagicActionAck& from);
  
  inline MsgKnowledgeGroupMagicActionAck& operator=(const MsgKnowledgeGroupMagicActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupMagicActionAck& default_instance();
  void Swap(MsgKnowledgeGroupMagicActionAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupMagicActionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupMagicActionAck& from);
  void MergeFrom(const MsgKnowledgeGroupMagicActionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& id() const;
  inline ::Common::KnowledgeGroupId* mutable_id();
  
  // required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* id_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupMagicActionAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupCreationAck : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupCreationAck();
  virtual ~MsgKnowledgeGroupCreationAck();
  
  MsgKnowledgeGroupCreationAck(const MsgKnowledgeGroupCreationAck& from);
  
  inline MsgKnowledgeGroupCreationAck& operator=(const MsgKnowledgeGroupCreationAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupCreationAck& default_instance();
  void Swap(MsgKnowledgeGroupCreationAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupCreationAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupCreationAck& from);
  void MergeFrom(const MsgKnowledgeGroupCreationAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& id() const;
  inline ::Common::KnowledgeGroupId* mutable_id();
  
  // required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* id_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupCreationAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupUpdateAck : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupUpdateAck();
  virtual ~MsgKnowledgeGroupUpdateAck();
  
  MsgKnowledgeGroupUpdateAck(const MsgKnowledgeGroupUpdateAck& from);
  
  inline MsgKnowledgeGroupUpdateAck& operator=(const MsgKnowledgeGroupUpdateAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupUpdateAck& default_instance();
  void Swap(MsgKnowledgeGroupUpdateAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupUpdateAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupUpdateAck& from);
  void MergeFrom(const MsgKnowledgeGroupUpdateAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& id() const;
  inline ::Common::KnowledgeGroupId* mutable_id();
  
  // required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode error_code() const;
  inline void set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* id_;
  int error_code_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupUpdateAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgKnowledgeGroupDestruction : public ::google::protobuf::Message {
 public:
  MsgKnowledgeGroupDestruction();
  virtual ~MsgKnowledgeGroupDestruction();
  
  MsgKnowledgeGroupDestruction(const MsgKnowledgeGroupDestruction& from);
  
  inline MsgKnowledgeGroupDestruction& operator=(const MsgKnowledgeGroupDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgKnowledgeGroupDestruction& default_instance();
  void Swap(MsgKnowledgeGroupDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgKnowledgeGroupDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgKnowledgeGroupDestruction& from);
  void MergeFrom(const MsgKnowledgeGroupDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.KnowledgeGroupId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::KnowledgeGroupId& id() const;
  inline ::Common::KnowledgeGroupId* mutable_id();
  
  // required .Common.PartyId party = 2;
  inline bool has_party() const;
  inline void clear_party();
  static const int kPartyFieldNumber = 2;
  inline const ::Common::PartyId& party() const;
  inline ::Common::PartyId* mutable_party();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::KnowledgeGroupId* id_;
  ::Common::PartyId* party_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgKnowledgeGroupDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlGlobalMeteoAck : public ::google::protobuf::Message {
 public:
  MsgControlGlobalMeteoAck();
  virtual ~MsgControlGlobalMeteoAck();
  
  MsgControlGlobalMeteoAck(const MsgControlGlobalMeteoAck& from);
  
  inline MsgControlGlobalMeteoAck& operator=(const MsgControlGlobalMeteoAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlGlobalMeteoAck& default_instance();
  void Swap(MsgControlGlobalMeteoAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlGlobalMeteoAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlGlobalMeteoAck& from);
  void MergeFrom(const MsgControlGlobalMeteoAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlGlobalMeteoAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlLocalMeteoAck : public ::google::protobuf::Message {
 public:
  MsgControlLocalMeteoAck();
  virtual ~MsgControlLocalMeteoAck();
  
  MsgControlLocalMeteoAck(const MsgControlLocalMeteoAck& from);
  
  inline MsgControlLocalMeteoAck& operator=(const MsgControlLocalMeteoAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlLocalMeteoAck& default_instance();
  void Swap(MsgControlLocalMeteoAck* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlLocalMeteoAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlLocalMeteoAck& from);
  void MergeFrom(const MsgControlLocalMeteoAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlLocalMeteoAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlGlobalMeteo : public ::google::protobuf::Message {
 public:
  MsgControlGlobalMeteo();
  virtual ~MsgControlGlobalMeteo();
  
  MsgControlGlobalMeteo(const MsgControlGlobalMeteo& from);
  
  inline MsgControlGlobalMeteo& operator=(const MsgControlGlobalMeteo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlGlobalMeteo& default_instance();
  void Swap(MsgControlGlobalMeteo* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlGlobalMeteo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlGlobalMeteo& from);
  void MergeFrom(const MsgControlGlobalMeteo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.WeatherId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::WeatherId& id() const;
  inline ::Common::WeatherId* mutable_id();
  
  // required .Common.MsgMeteoAttributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::Common::MsgMeteoAttributes& attributes() const;
  inline ::Common::MsgMeteoAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::WeatherId* id_;
  ::Common::MsgMeteoAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlGlobalMeteo* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlLocalMeteoCreation : public ::google::protobuf::Message {
 public:
  MsgControlLocalMeteoCreation();
  virtual ~MsgControlLocalMeteoCreation();
  
  MsgControlLocalMeteoCreation(const MsgControlLocalMeteoCreation& from);
  
  inline MsgControlLocalMeteoCreation& operator=(const MsgControlLocalMeteoCreation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlLocalMeteoCreation& default_instance();
  void Swap(MsgControlLocalMeteoCreation* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlLocalMeteoCreation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlLocalMeteoCreation& from);
  void MergeFrom(const MsgControlLocalMeteoCreation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.WeatherId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::WeatherId& id() const;
  inline ::Common::WeatherId* mutable_id();
  
  // optional .Common.MsgCoordLatLong top_left_coordinate = 2;
  inline bool has_top_left_coordinate() const;
  inline void clear_top_left_coordinate();
  static const int kTopLeftCoordinateFieldNumber = 2;
  inline const ::Common::MsgCoordLatLong& top_left_coordinate() const;
  inline ::Common::MsgCoordLatLong* mutable_top_left_coordinate();
  
  // optional .Common.MsgCoordLatLong bottom_right_coordinate = 3;
  inline bool has_bottom_right_coordinate() const;
  inline void clear_bottom_right_coordinate();
  static const int kBottomRightCoordinateFieldNumber = 3;
  inline const ::Common::MsgCoordLatLong& bottom_right_coordinate() const;
  inline ::Common::MsgCoordLatLong* mutable_bottom_right_coordinate();
  
  // optional .Common.MsgMeteoAttributes attributes = 4;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  inline const ::Common::MsgMeteoAttributes& attributes() const;
  inline ::Common::MsgMeteoAttributes* mutable_attributes();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::WeatherId* id_;
  ::Common::MsgCoordLatLong* top_left_coordinate_;
  ::Common::MsgCoordLatLong* bottom_right_coordinate_;
  ::Common::MsgMeteoAttributes* attributes_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlLocalMeteoCreation* default_instance_;
};
// -------------------------------------------------------------------

class MsgControlLocalMeteoDestruction : public ::google::protobuf::Message {
 public:
  MsgControlLocalMeteoDestruction();
  virtual ~MsgControlLocalMeteoDestruction();
  
  MsgControlLocalMeteoDestruction(const MsgControlLocalMeteoDestruction& from);
  
  inline MsgControlLocalMeteoDestruction& operator=(const MsgControlLocalMeteoDestruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgControlLocalMeteoDestruction& default_instance();
  void Swap(MsgControlLocalMeteoDestruction* other);
  
  // implements Message ----------------------------------------------
  
  MsgControlLocalMeteoDestruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgControlLocalMeteoDestruction& from);
  void MergeFrom(const MsgControlLocalMeteoDestruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Common.WeatherId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Common::WeatherId& id() const;
  inline ::Common::WeatherId* mutable_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Common::WeatherId* id_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgControlLocalMeteoDestruction* default_instance_;
};
// -------------------------------------------------------------------

class MsgSimToClient_Content : public ::google::protobuf::Message {
 public:
  MsgSimToClient_Content();
  virtual ~MsgSimToClient_Content();
  
  MsgSimToClient_Content(const MsgSimToClient_Content& from);
  
  inline MsgSimToClient_Content& operator=(const MsgSimToClient_Content& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgSimToClient_Content& default_instance();
  void Swap(MsgSimToClient_Content* other);
  
  // implements Message ----------------------------------------------
  
  MsgSimToClient_Content* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgSimToClient_Content& from);
  void MergeFrom(const MsgSimToClient_Content& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .MsgsSimToClient.MsgUnitOrderAck unit_order_ack = 1;
  inline bool has_unit_order_ack() const;
  inline void clear_unit_order_ack();
  static const int kUnitOrderAckFieldNumber = 1;
  inline const ::MsgsSimToClient::MsgUnitOrderAck& unit_order_ack() const;
  inline ::MsgsSimToClient::MsgUnitOrderAck* mutable_unit_order_ack();
  
  // optional .MsgsSimToClient.MsgAutomatOrderAck automat_order_ack = 2;
  inline bool has_automat_order_ack() const;
  inline void clear_automat_order_ack();
  static const int kAutomatOrderAckFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgAutomatOrderAck& automat_order_ack() const;
  inline ::MsgsSimToClient::MsgAutomatOrderAck* mutable_automat_order_ack();
  
  // optional .MsgsSimToClient.MsgPopulationOrderAck population_order_ack = 3;
  inline bool has_population_order_ack() const;
  inline void clear_population_order_ack();
  static const int kPopulationOrderAckFieldNumber = 3;
  inline const ::MsgsSimToClient::MsgPopulationOrderAck& population_order_ack() const;
  inline ::MsgsSimToClient::MsgPopulationOrderAck* mutable_population_order_ack();
  
  // optional .MsgsSimToClient.MsgFragOrderAck frag_order_ack = 4;
  inline bool has_frag_order_ack() const;
  inline void clear_frag_order_ack();
  static const int kFragOrderAckFieldNumber = 4;
  inline const ::MsgsSimToClient::MsgFragOrderAck& frag_order_ack() const;
  inline ::MsgsSimToClient::MsgFragOrderAck* mutable_frag_order_ack();
  
  // optional .MsgsSimToClient.MsgSetAutomatModeAck set_automat_mode_ack = 5;
  inline bool has_set_automat_mode_ack() const;
  inline void clear_set_automat_mode_ack();
  static const int kSetAutomatModeAckFieldNumber = 5;
  inline const ::MsgsSimToClient::MsgSetAutomatModeAck& set_automat_mode_ack() const;
  inline ::MsgsSimToClient::MsgSetAutomatModeAck* mutable_set_automat_mode_ack();
  
  // optional .MsgsSimToClient.MsgUnitCreationRequestAck unit_creation_request_ack = 6;
  inline bool has_unit_creation_request_ack() const;
  inline void clear_unit_creation_request_ack();
  static const int kUnitCreationRequestAckFieldNumber = 6;
  inline const ::MsgsSimToClient::MsgUnitCreationRequestAck& unit_creation_request_ack() const;
  inline ::MsgsSimToClient::MsgUnitCreationRequestAck* mutable_unit_creation_request_ack();
  
  // optional .MsgsSimToClient.MsgMagicActionAck magic_action_ack = 7;
  inline bool has_magic_action_ack() const;
  inline void clear_magic_action_ack();
  static const int kMagicActionAckFieldNumber = 7;
  inline const ::MsgsSimToClient::MsgMagicActionAck& magic_action_ack() const;
  inline ::MsgsSimToClient::MsgMagicActionAck* mutable_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgUnitMagicActionAck unit_magic_action_ack = 8;
  inline bool has_unit_magic_action_ack() const;
  inline void clear_unit_magic_action_ack();
  static const int kUnitMagicActionAckFieldNumber = 8;
  inline const ::MsgsSimToClient::MsgUnitMagicActionAck& unit_magic_action_ack() const;
  inline ::MsgsSimToClient::MsgUnitMagicActionAck* mutable_unit_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgObjectMagicActionAck object_magic_action_ack = 9;
  inline bool has_object_magic_action_ack() const;
  inline void clear_object_magic_action_ack();
  static const int kObjectMagicActionAckFieldNumber = 9;
  inline const ::MsgsSimToClient::MsgObjectMagicActionAck& object_magic_action_ack() const;
  inline ::MsgsSimToClient::MsgObjectMagicActionAck* mutable_object_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgPopulationMagicActionAck population_magic_action_ack = 10;
  inline bool has_population_magic_action_ack() const;
  inline void clear_population_magic_action_ack();
  static const int kPopulationMagicActionAckFieldNumber = 10;
  inline const ::MsgsSimToClient::MsgPopulationMagicActionAck& population_magic_action_ack() const;
  inline ::MsgsSimToClient::MsgPopulationMagicActionAck* mutable_population_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgChangeDiplomacyAck change_diplomacy_ack = 11;
  inline bool has_change_diplomacy_ack() const;
  inline void clear_change_diplomacy_ack();
  static const int kChangeDiplomacyAckFieldNumber = 11;
  inline const ::MsgsSimToClient::MsgChangeDiplomacyAck& change_diplomacy_ack() const;
  inline ::MsgsSimToClient::MsgChangeDiplomacyAck* mutable_change_diplomacy_ack();
  
  // optional .MsgsSimToClient.MsgAutomatChangeKnowledgeGroupAck automat_change_knowledge_group_ack = 12;
  inline bool has_automat_change_knowledge_group_ack() const;
  inline void clear_automat_change_knowledge_group_ack();
  static const int kAutomatChangeKnowledgeGroupAckFieldNumber = 12;
  inline const ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck& automat_change_knowledge_group_ack() const;
  inline ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck* mutable_automat_change_knowledge_group_ack();
  
  // optional .MsgsSimToClient.MsgAutomatChangeLogisticLinksAck automat_change_logistic_links_ack = 13;
  inline bool has_automat_change_logistic_links_ack() const;
  inline void clear_automat_change_logistic_links_ack();
  static const int kAutomatChangeLogisticLinksAckFieldNumber = 13;
  inline const ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck& automat_change_logistic_links_ack() const;
  inline ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck* mutable_automat_change_logistic_links_ack();
  
  // optional .MsgsSimToClient.MsgAutomatChangeSuperiorAck automat_change_superior_ack = 14;
  inline bool has_automat_change_superior_ack() const;
  inline void clear_automat_change_superior_ack();
  static const int kAutomatChangeSuperiorAckFieldNumber = 14;
  inline const ::MsgsSimToClient::MsgAutomatChangeSuperiorAck& automat_change_superior_ack() const;
  inline ::MsgsSimToClient::MsgAutomatChangeSuperiorAck* mutable_automat_change_superior_ack();
  
  // optional .MsgsSimToClient.MsgUnitChangeSuperiorAck unit_change_superior_ack = 15;
  inline bool has_unit_change_superior_ack() const;
  inline void clear_unit_change_superior_ack();
  static const int kUnitChangeSuperiorAckFieldNumber = 15;
  inline const ::MsgsSimToClient::MsgUnitChangeSuperiorAck& unit_change_superior_ack() const;
  inline ::MsgsSimToClient::MsgUnitChangeSuperiorAck* mutable_unit_change_superior_ack();
  
  // optional .MsgsSimToClient.MsgLogSupplyPushFlowAck log_supply_push_flow_ack = 16;
  inline bool has_log_supply_push_flow_ack() const;
  inline void clear_log_supply_push_flow_ack();
  static const int kLogSupplyPushFlowAckFieldNumber = 16;
  inline const ::MsgsSimToClient::MsgLogSupplyPushFlowAck& log_supply_push_flow_ack() const;
  inline ::MsgsSimToClient::MsgLogSupplyPushFlowAck* mutable_log_supply_push_flow_ack();
  
  // optional .MsgsSimToClient.MsgLogSupplyChangeQuotasAck log_supply_change_quotas_ack = 17;
  inline bool has_log_supply_change_quotas_ack() const;
  inline void clear_log_supply_change_quotas_ack();
  static const int kLogSupplyChangeQuotasAckFieldNumber = 17;
  inline const ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck& log_supply_change_quotas_ack() const;
  inline ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck* mutable_log_supply_change_quotas_ack();
  
  // optional .MsgsSimToClient.MsgControlInformation control_information = 18;
  inline bool has_control_information() const;
  inline void clear_control_information();
  static const int kControlInformationFieldNumber = 18;
  inline const ::MsgsSimToClient::MsgControlInformation& control_information() const;
  inline ::MsgsSimToClient::MsgControlInformation* mutable_control_information();
  
  // optional .MsgsSimToClient.MsgControlProfilingInformation control_profiling_information = 19;
  inline bool has_control_profiling_information() const;
  inline void clear_control_profiling_information();
  static const int kControlProfilingInformationFieldNumber = 19;
  inline const ::MsgsSimToClient::MsgControlProfilingInformation& control_profiling_information() const;
  inline ::MsgsSimToClient::MsgControlProfilingInformation* mutable_control_profiling_information();
  
  // optional .MsgsSimToClient.MsgControlBeginTick control_begin_tick = 20;
  inline bool has_control_begin_tick() const;
  inline void clear_control_begin_tick();
  static const int kControlBeginTickFieldNumber = 20;
  inline const ::MsgsSimToClient::MsgControlBeginTick& control_begin_tick() const;
  inline ::MsgsSimToClient::MsgControlBeginTick* mutable_control_begin_tick();
  
  // optional .MsgsSimToClient.MsgControlEndTick control_end_tick = 21;
  inline bool has_control_end_tick() const;
  inline void clear_control_end_tick();
  static const int kControlEndTickFieldNumber = 21;
  inline const ::MsgsSimToClient::MsgControlEndTick& control_end_tick() const;
  inline ::MsgsSimToClient::MsgControlEndTick* mutable_control_end_tick();
  
  // optional .MsgsSimToClient.MsgControlStopAck control_stop_ack = 22;
  inline bool has_control_stop_ack() const;
  inline void clear_control_stop_ack();
  static const int kControlStopAckFieldNumber = 22;
  inline const ::MsgsSimToClient::MsgControlStopAck& control_stop_ack() const;
  inline ::MsgsSimToClient::MsgControlStopAck* mutable_control_stop_ack();
  
  // optional .MsgsSimToClient.MsgControlPauseAck control_pause_ack = 23;
  inline bool has_control_pause_ack() const;
  inline void clear_control_pause_ack();
  static const int kControlPauseAckFieldNumber = 23;
  inline const ::MsgsSimToClient::MsgControlPauseAck& control_pause_ack() const;
  inline ::MsgsSimToClient::MsgControlPauseAck* mutable_control_pause_ack();
  
  // optional .MsgsSimToClient.MsgControlResumeAck control_resume_ack = 24;
  inline bool has_control_resume_ack() const;
  inline void clear_control_resume_ack();
  static const int kControlResumeAckFieldNumber = 24;
  inline const ::MsgsSimToClient::MsgControlResumeAck& control_resume_ack() const;
  inline ::MsgsSimToClient::MsgControlResumeAck* mutable_control_resume_ack();
  
  // optional .MsgsSimToClient.MsgControlChangeTimeFactorAck control_change_time_factor_ack = 25;
  inline bool has_control_change_time_factor_ack() const;
  inline void clear_control_change_time_factor_ack();
  static const int kControlChangeTimeFactorAckFieldNumber = 25;
  inline const ::MsgsSimToClient::MsgControlChangeTimeFactorAck& control_change_time_factor_ack() const;
  inline ::MsgsSimToClient::MsgControlChangeTimeFactorAck* mutable_control_change_time_factor_ack();
  
  // optional .MsgsSimToClient.MsgControlDatetimeChangeAck control_date_time_change_ack = 26;
  inline bool has_control_date_time_change_ack() const;
  inline void clear_control_date_time_change_ack();
  static const int kControlDateTimeChangeAckFieldNumber = 26;
  inline const ::MsgsSimToClient::MsgControlDatetimeChangeAck& control_date_time_change_ack() const;
  inline ::MsgsSimToClient::MsgControlDatetimeChangeAck* mutable_control_date_time_change_ack();
  
  // optional .MsgsSimToClient.MsgControlCheckPointSaveEnd control_checkpoint_save_end = 27;
  inline bool has_control_checkpoint_save_end() const;
  inline void clear_control_checkpoint_save_end();
  static const int kControlCheckpointSaveEndFieldNumber = 27;
  inline const ::MsgsSimToClient::MsgControlCheckPointSaveEnd& control_checkpoint_save_end() const;
  inline ::MsgsSimToClient::MsgControlCheckPointSaveEnd* mutable_control_checkpoint_save_end();
  
  // optional .Common.MsgFormationCreation formation_creation = 28;
  inline bool has_formation_creation() const;
  inline void clear_formation_creation();
  static const int kFormationCreationFieldNumber = 28;
  inline const ::Common::MsgFormationCreation& formation_creation() const;
  inline ::Common::MsgFormationCreation* mutable_formation_creation();
  
  // optional .MsgsSimToClient.MsgTeamCreation side_creation = 29;
  inline bool has_side_creation() const;
  inline void clear_side_creation();
  static const int kSideCreationFieldNumber = 29;
  inline const ::MsgsSimToClient::MsgTeamCreation& side_creation() const;
  inline ::MsgsSimToClient::MsgTeamCreation* mutable_side_creation();
  
  // optional .MsgsSimToClient.MsgAutomatCreation automat_creation = 30;
  inline bool has_automat_creation() const;
  inline void clear_automat_creation();
  static const int kAutomatCreationFieldNumber = 30;
  inline const ::MsgsSimToClient::MsgAutomatCreation& automat_creation() const;
  inline ::MsgsSimToClient::MsgAutomatCreation* mutable_automat_creation();
  
  // optional .MsgsSimToClient.MsgAutomatAttributes automat_attributes = 31;
  inline bool has_automat_attributes() const;
  inline void clear_automat_attributes();
  static const int kAutomatAttributesFieldNumber = 31;
  inline const ::MsgsSimToClient::MsgAutomatAttributes& automat_attributes() const;
  inline ::MsgsSimToClient::MsgAutomatAttributes* mutable_automat_attributes();
  
  // optional .MsgsSimToClient.MsgUnitCreation unit_creation = 32;
  inline bool has_unit_creation() const;
  inline void clear_unit_creation();
  static const int kUnitCreationFieldNumber = 32;
  inline const ::MsgsSimToClient::MsgUnitCreation& unit_creation() const;
  inline ::MsgsSimToClient::MsgUnitCreation* mutable_unit_creation();
  
  // optional .MsgsSimToClient.MsgUnitAttributes unit_attributes = 33;
  inline bool has_unit_attributes() const;
  inline void clear_unit_attributes();
  static const int kUnitAttributesFieldNumber = 33;
  inline const ::MsgsSimToClient::MsgUnitAttributes& unit_attributes() const;
  inline ::MsgsSimToClient::MsgUnitAttributes* mutable_unit_attributes();
  
  // optional .MsgsSimToClient.MsgUnitPathFind unit_pathfind = 34;
  inline bool has_unit_pathfind() const;
  inline void clear_unit_pathfind();
  static const int kUnitPathfindFieldNumber = 34;
  inline const ::MsgsSimToClient::MsgUnitPathFind& unit_pathfind() const;
  inline ::MsgsSimToClient::MsgUnitPathFind* mutable_unit_pathfind();
  
  // optional .MsgsSimToClient.MsgUnitDestruction unit_destruction = 35;
  inline bool has_unit_destruction() const;
  inline void clear_unit_destruction();
  static const int kUnitDestructionFieldNumber = 35;
  inline const ::MsgsSimToClient::MsgUnitDestruction& unit_destruction() const;
  inline ::MsgsSimToClient::MsgUnitDestruction* mutable_unit_destruction();
  
  // optional .MsgsSimToClient.MsgUnitEnvironmentType unit_environment_type = 36;
  inline bool has_unit_environment_type() const;
  inline void clear_unit_environment_type();
  static const int kUnitEnvironmentTypeFieldNumber = 36;
  inline const ::MsgsSimToClient::MsgUnitEnvironmentType& unit_environment_type() const;
  inline ::MsgsSimToClient::MsgUnitEnvironmentType* mutable_unit_environment_type();
  
  // optional .Common.MsgChangeDiplomacy change_diplomacy = 37;
  inline bool has_change_diplomacy() const;
  inline void clear_change_diplomacy();
  static const int kChangeDiplomacyFieldNumber = 37;
  inline const ::Common::MsgChangeDiplomacy& change_diplomacy() const;
  inline ::Common::MsgChangeDiplomacy* mutable_change_diplomacy();
  
  // optional .Common.MsgUnitChangeSuperior unit_change_superior = 38;
  inline bool has_unit_change_superior() const;
  inline void clear_unit_change_superior();
  static const int kUnitChangeSuperiorFieldNumber = 38;
  inline const ::Common::MsgUnitChangeSuperior& unit_change_superior() const;
  inline ::Common::MsgUnitChangeSuperior* mutable_unit_change_superior();
  
  // optional .Common.MsgAutomatChangeLogisticLinks automat_change_logistic_links = 39;
  inline bool has_automat_change_logistic_links() const;
  inline void clear_automat_change_logistic_links();
  static const int kAutomatChangeLogisticLinksFieldNumber = 39;
  inline const ::Common::MsgAutomatChangeLogisticLinks& automat_change_logistic_links() const;
  inline ::Common::MsgAutomatChangeLogisticLinks* mutable_automat_change_logistic_links();
  
  // optional .Common.MsgAutomatChangeKnowledgeGroup automat_change_knowledge_group = 40;
  inline bool has_automat_change_knowledge_group() const;
  inline void clear_automat_change_knowledge_group();
  static const int kAutomatChangeKnowledgeGroupFieldNumber = 40;
  inline const ::Common::MsgAutomatChangeKnowledgeGroup& automat_change_knowledge_group() const;
  inline ::Common::MsgAutomatChangeKnowledgeGroup* mutable_automat_change_knowledge_group();
  
  // optional .Common.MsgAutomatChangeSuperior automat_change_superior = 41;
  inline bool has_automat_change_superior() const;
  inline void clear_automat_change_superior();
  static const int kAutomatChangeSuperiorFieldNumber = 41;
  inline const ::Common::MsgAutomatChangeSuperior& automat_change_superior() const;
  inline ::Common::MsgAutomatChangeSuperior* mutable_automat_change_superior();
  
  // optional .MsgsSimToClient.MsgUnitKnowledgeCreation unit_knowledge_creation = 42;
  inline bool has_unit_knowledge_creation() const;
  inline void clear_unit_knowledge_creation();
  static const int kUnitKnowledgeCreationFieldNumber = 42;
  inline const ::MsgsSimToClient::MsgUnitKnowledgeCreation& unit_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgUnitKnowledgeCreation* mutable_unit_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgUnitKnowledgeUpdate unit_knowledge_update = 43;
  inline bool has_unit_knowledge_update() const;
  inline void clear_unit_knowledge_update();
  static const int kUnitKnowledgeUpdateFieldNumber = 43;
  inline const ::MsgsSimToClient::MsgUnitKnowledgeUpdate& unit_knowledge_update() const;
  inline ::MsgsSimToClient::MsgUnitKnowledgeUpdate* mutable_unit_knowledge_update();
  
  // optional .MsgsSimToClient.MsgUnitKnowledgeDestruction unit_knowledge_destruction = 44;
  inline bool has_unit_knowledge_destruction() const;
  inline void clear_unit_knowledge_destruction();
  static const int kUnitKnowledgeDestructionFieldNumber = 44;
  inline const ::MsgsSimToClient::MsgUnitKnowledgeDestruction& unit_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgUnitKnowledgeDestruction* mutable_unit_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgStartUnitFire start_unit_fire = 45;
  inline bool has_start_unit_fire() const;
  inline void clear_start_unit_fire();
  static const int kStartUnitFireFieldNumber = 45;
  inline const ::MsgsSimToClient::MsgStartUnitFire& start_unit_fire() const;
  inline ::MsgsSimToClient::MsgStartUnitFire* mutable_start_unit_fire();
  
  // optional .MsgsSimToClient.MsgStopUnitFire stop_unit_fire = 46;
  inline bool has_stop_unit_fire() const;
  inline void clear_stop_unit_fire();
  static const int kStopUnitFireFieldNumber = 46;
  inline const ::MsgsSimToClient::MsgStopUnitFire& stop_unit_fire() const;
  inline ::MsgsSimToClient::MsgStopUnitFire* mutable_stop_unit_fire();
  
  // optional .MsgsSimToClient.MsgStartPopulationFire start_population_fire = 47;
  inline bool has_start_population_fire() const;
  inline void clear_start_population_fire();
  static const int kStartPopulationFireFieldNumber = 47;
  inline const ::MsgsSimToClient::MsgStartPopulationFire& start_population_fire() const;
  inline ::MsgsSimToClient::MsgStartPopulationFire* mutable_start_population_fire();
  
  // optional .MsgsSimToClient.MsgStopPopulationFire stop_population_fire = 48;
  inline bool has_stop_population_fire() const;
  inline void clear_stop_population_fire();
  static const int kStopPopulationFireFieldNumber = 48;
  inline const ::MsgsSimToClient::MsgStopPopulationFire& stop_population_fire() const;
  inline ::MsgsSimToClient::MsgStopPopulationFire* mutable_stop_population_fire();
  
  // optional .MsgsSimToClient.MsgExplosion explosion = 49;
  inline bool has_explosion() const;
  inline void clear_explosion();
  static const int kExplosionFieldNumber = 49;
  inline const ::MsgsSimToClient::MsgExplosion& explosion() const;
  inline ::MsgsSimToClient::MsgExplosion* mutable_explosion();
  
  // optional .MsgsSimToClient.MsgStartFireEffect start_fire_effect = 50;
  inline bool has_start_fire_effect() const;
  inline void clear_start_fire_effect();
  static const int kStartFireEffectFieldNumber = 50;
  inline const ::MsgsSimToClient::MsgStartFireEffect& start_fire_effect() const;
  inline ::MsgsSimToClient::MsgStartFireEffect* mutable_start_fire_effect();
  
  // optional .MsgsSimToClient.MsgStopFireEffect stop_fire_effect = 51;
  inline bool has_stop_fire_effect() const;
  inline void clear_stop_fire_effect();
  static const int kStopFireEffectFieldNumber = 51;
  inline const ::MsgsSimToClient::MsgStopFireEffect& stop_fire_effect() const;
  inline ::MsgsSimToClient::MsgStopFireEffect* mutable_stop_fire_effect();
  
  // optional .MsgsSimToClient.MsgReport report = 52;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 52;
  inline const ::MsgsSimToClient::MsgReport& report() const;
  inline ::MsgsSimToClient::MsgReport* mutable_report();
  
  // optional .MsgsSimToClient.MsgInvalidateReport invalidate_report = 53;
  inline bool has_invalidate_report() const;
  inline void clear_invalidate_report();
  static const int kInvalidateReportFieldNumber = 53;
  inline const ::MsgsSimToClient::MsgInvalidateReport& invalidate_report() const;
  inline ::MsgsSimToClient::MsgInvalidateReport* mutable_invalidate_report();
  
  // optional .MsgsSimToClient.MsgTrace trace = 54;
  inline bool has_trace() const;
  inline void clear_trace();
  static const int kTraceFieldNumber = 54;
  inline const ::MsgsSimToClient::MsgTrace& trace() const;
  inline ::MsgsSimToClient::MsgTrace* mutable_trace();
  
  // optional .MsgsSimToClient.MsgDecisionalState decisional_state = 55;
  inline bool has_decisional_state() const;
  inline void clear_decisional_state();
  static const int kDecisionalStateFieldNumber = 55;
  inline const ::MsgsSimToClient::MsgDecisionalState& decisional_state() const;
  inline ::MsgsSimToClient::MsgDecisionalState* mutable_decisional_state();
  
  // optional .MsgsSimToClient.MsgDebugPoints debug_points = 56;
  inline bool has_debug_points() const;
  inline void clear_debug_points();
  static const int kDebugPointsFieldNumber = 56;
  inline const ::MsgsSimToClient::MsgDebugPoints& debug_points() const;
  inline ::MsgsSimToClient::MsgDebugPoints* mutable_debug_points();
  
  // optional .MsgsSimToClient.MsgUnitVisionCones unit_vision_cones = 57;
  inline bool has_unit_vision_cones() const;
  inline void clear_unit_vision_cones();
  static const int kUnitVisionConesFieldNumber = 57;
  inline const ::MsgsSimToClient::MsgUnitVisionCones& unit_vision_cones() const;
  inline ::MsgsSimToClient::MsgUnitVisionCones* mutable_unit_vision_cones();
  
  // optional .MsgsSimToClient.MsgUnitDetection unit_detection = 58;
  inline bool has_unit_detection() const;
  inline void clear_unit_detection();
  static const int kUnitDetectionFieldNumber = 58;
  inline const ::MsgsSimToClient::MsgUnitDetection& unit_detection() const;
  inline ::MsgsSimToClient::MsgUnitDetection* mutable_unit_detection();
  
  // optional .MsgsSimToClient.MsgObjectDetection object_detection = 59;
  inline bool has_object_detection() const;
  inline void clear_object_detection();
  static const int kObjectDetectionFieldNumber = 59;
  inline const ::MsgsSimToClient::MsgObjectDetection& object_detection() const;
  inline ::MsgsSimToClient::MsgObjectDetection* mutable_object_detection();
  
  // optional .MsgsSimToClient.MsgPopulationConcentrationDetection population_concentration_detection = 60;
  inline bool has_population_concentration_detection() const;
  inline void clear_population_concentration_detection();
  static const int kPopulationConcentrationDetectionFieldNumber = 60;
  inline const ::MsgsSimToClient::MsgPopulationConcentrationDetection& population_concentration_detection() const;
  inline ::MsgsSimToClient::MsgPopulationConcentrationDetection* mutable_population_concentration_detection();
  
  // optional .MsgsSimToClient.MsgPopulationFlowDetection population_flow_detection = 61;
  inline bool has_population_flow_detection() const;
  inline void clear_population_flow_detection();
  static const int kPopulationFlowDetectionFieldNumber = 61;
  inline const ::MsgsSimToClient::MsgPopulationFlowDetection& population_flow_detection() const;
  inline ::MsgsSimToClient::MsgPopulationFlowDetection* mutable_population_flow_detection();
  
  // optional .Common.MsgUnitOrder unit_order = 62;
  inline bool has_unit_order() const;
  inline void clear_unit_order();
  static const int kUnitOrderFieldNumber = 62;
  inline const ::Common::MsgUnitOrder& unit_order() const;
  inline ::Common::MsgUnitOrder* mutable_unit_order();
  
  // optional .Common.MsgAutomatOrder automat_order = 63;
  inline bool has_automat_order() const;
  inline void clear_automat_order();
  static const int kAutomatOrderFieldNumber = 63;
  inline const ::Common::MsgAutomatOrder& automat_order() const;
  inline ::Common::MsgAutomatOrder* mutable_automat_order();
  
  // optional .Common.MsgPopulationOrder population_order = 64;
  inline bool has_population_order() const;
  inline void clear_population_order();
  static const int kPopulationOrderFieldNumber = 64;
  inline const ::Common::MsgPopulationOrder& population_order() const;
  inline ::Common::MsgPopulationOrder* mutable_population_order();
  
  // optional .MsgsSimToClient.MsgObjectCreation object_creation = 65;
  inline bool has_object_creation() const;
  inline void clear_object_creation();
  static const int kObjectCreationFieldNumber = 65;
  inline const ::MsgsSimToClient::MsgObjectCreation& object_creation() const;
  inline ::MsgsSimToClient::MsgObjectCreation* mutable_object_creation();
  
  // optional .MsgsSimToClient.MsgObjectDestruction object_destruction = 66;
  inline bool has_object_destruction() const;
  inline void clear_object_destruction();
  static const int kObjectDestructionFieldNumber = 66;
  inline const ::MsgsSimToClient::MsgObjectDestruction& object_destruction() const;
  inline ::MsgsSimToClient::MsgObjectDestruction* mutable_object_destruction();
  
  // optional .MsgsSimToClient.MsgObjectUpdate object_update = 67;
  inline bool has_object_update() const;
  inline void clear_object_update();
  static const int kObjectUpdateFieldNumber = 67;
  inline const ::MsgsSimToClient::MsgObjectUpdate& object_update() const;
  inline ::MsgsSimToClient::MsgObjectUpdate* mutable_object_update();
  
  // optional .MsgsSimToClient.MsgObjectKnowledgeCreation object_knowledge_creation = 68;
  inline bool has_object_knowledge_creation() const;
  inline void clear_object_knowledge_creation();
  static const int kObjectKnowledgeCreationFieldNumber = 68;
  inline const ::MsgsSimToClient::MsgObjectKnowledgeCreation& object_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgObjectKnowledgeCreation* mutable_object_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgObjectKnowledgeUpdate object_knowledge_update = 69;
  inline bool has_object_knowledge_update() const;
  inline void clear_object_knowledge_update();
  static const int kObjectKnowledgeUpdateFieldNumber = 69;
  inline const ::MsgsSimToClient::MsgObjectKnowledgeUpdate& object_knowledge_update() const;
  inline ::MsgsSimToClient::MsgObjectKnowledgeUpdate* mutable_object_knowledge_update();
  
  // optional .MsgsSimToClient.MsgObjectKnowledgeDestruction object_knowledge_destruction = 70;
  inline bool has_object_knowledge_destruction() const;
  inline void clear_object_knowledge_destruction();
  static const int kObjectKnowledgeDestructionFieldNumber = 70;
  inline const ::MsgsSimToClient::MsgObjectKnowledgeDestruction& object_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgObjectKnowledgeDestruction* mutable_object_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgLogMedicalHandlingCreation log_medical_handling_creation = 71;
  inline bool has_log_medical_handling_creation() const;
  inline void clear_log_medical_handling_creation();
  static const int kLogMedicalHandlingCreationFieldNumber = 71;
  inline const ::MsgsSimToClient::MsgLogMedicalHandlingCreation& log_medical_handling_creation() const;
  inline ::MsgsSimToClient::MsgLogMedicalHandlingCreation* mutable_log_medical_handling_creation();
  
  // optional .MsgsSimToClient.MsgLogMedicalHandlingUpdate log_medical_handling_update = 72;
  inline bool has_log_medical_handling_update() const;
  inline void clear_log_medical_handling_update();
  static const int kLogMedicalHandlingUpdateFieldNumber = 72;
  inline const ::MsgsSimToClient::MsgLogMedicalHandlingUpdate& log_medical_handling_update() const;
  inline ::MsgsSimToClient::MsgLogMedicalHandlingUpdate* mutable_log_medical_handling_update();
  
  // optional .MsgsSimToClient.MsgLogMedicalHandlingDestruction log_medical_handling_destruction = 73;
  inline bool has_log_medical_handling_destruction() const;
  inline void clear_log_medical_handling_destruction();
  static const int kLogMedicalHandlingDestructionFieldNumber = 73;
  inline const ::MsgsSimToClient::MsgLogMedicalHandlingDestruction& log_medical_handling_destruction() const;
  inline ::MsgsSimToClient::MsgLogMedicalHandlingDestruction* mutable_log_medical_handling_destruction();
  
  // optional .MsgsSimToClient.MsgLogMedicalState log_medical_state = 74;
  inline bool has_log_medical_state() const;
  inline void clear_log_medical_state();
  static const int kLogMedicalStateFieldNumber = 74;
  inline const ::MsgsSimToClient::MsgLogMedicalState& log_medical_state() const;
  inline ::MsgsSimToClient::MsgLogMedicalState* mutable_log_medical_state();
  
  // optional .MsgsSimToClient.MsgLogMaintenanceHandlingCreation log_maintenance_handling_creation = 75;
  inline bool has_log_maintenance_handling_creation() const;
  inline void clear_log_maintenance_handling_creation();
  static const int kLogMaintenanceHandlingCreationFieldNumber = 75;
  inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation& log_maintenance_handling_creation() const;
  inline ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation* mutable_log_maintenance_handling_creation();
  
  // optional .MsgsSimToClient.MsgLogMaintenanceHandlingUpdate log_maintenance_handling_update = 76;
  inline bool has_log_maintenance_handling_update() const;
  inline void clear_log_maintenance_handling_update();
  static const int kLogMaintenanceHandlingUpdateFieldNumber = 76;
  inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate& log_maintenance_handling_update() const;
  inline ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate* mutable_log_maintenance_handling_update();
  
  // optional .MsgsSimToClient.MsgLogMaintenanceHandlingDestruction log_maintenance_handling_destruction = 77;
  inline bool has_log_maintenance_handling_destruction() const;
  inline void clear_log_maintenance_handling_destruction();
  static const int kLogMaintenanceHandlingDestructionFieldNumber = 77;
  inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction& log_maintenance_handling_destruction() const;
  inline ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction* mutable_log_maintenance_handling_destruction();
  
  // optional .MsgsSimToClient.MsgLogMaintenanceState log_maintenance_state = 78;
  inline bool has_log_maintenance_state() const;
  inline void clear_log_maintenance_state();
  static const int kLogMaintenanceStateFieldNumber = 78;
  inline const ::MsgsSimToClient::MsgLogMaintenanceState& log_maintenance_state() const;
  inline ::MsgsSimToClient::MsgLogMaintenanceState* mutable_log_maintenance_state();
  
  // optional .MsgsSimToClient.MsgLogSupplyHandlingCreation log_supply_handling_creation = 79;
  inline bool has_log_supply_handling_creation() const;
  inline void clear_log_supply_handling_creation();
  static const int kLogSupplyHandlingCreationFieldNumber = 79;
  inline const ::MsgsSimToClient::MsgLogSupplyHandlingCreation& log_supply_handling_creation() const;
  inline ::MsgsSimToClient::MsgLogSupplyHandlingCreation* mutable_log_supply_handling_creation();
  
  // optional .MsgsSimToClient.MsgLogSupplyHandlingUpdate log_supply_handling_update = 80;
  inline bool has_log_supply_handling_update() const;
  inline void clear_log_supply_handling_update();
  static const int kLogSupplyHandlingUpdateFieldNumber = 80;
  inline const ::MsgsSimToClient::MsgLogSupplyHandlingUpdate& log_supply_handling_update() const;
  inline ::MsgsSimToClient::MsgLogSupplyHandlingUpdate* mutable_log_supply_handling_update();
  
  // optional .MsgsSimToClient.MsgLogSupplyHandlingDestruction log_supply_handling_destruction = 81;
  inline bool has_log_supply_handling_destruction() const;
  inline void clear_log_supply_handling_destruction();
  static const int kLogSupplyHandlingDestructionFieldNumber = 81;
  inline const ::MsgsSimToClient::MsgLogSupplyHandlingDestruction& log_supply_handling_destruction() const;
  inline ::MsgsSimToClient::MsgLogSupplyHandlingDestruction* mutable_log_supply_handling_destruction();
  
  // optional .MsgsSimToClient.MsgLogSupplyState log_supply_state = 82;
  inline bool has_log_supply_state() const;
  inline void clear_log_supply_state();
  static const int kLogSupplyStateFieldNumber = 82;
  inline const ::MsgsSimToClient::MsgLogSupplyState& log_supply_state() const;
  inline ::MsgsSimToClient::MsgLogSupplyState* mutable_log_supply_state();
  
  // optional .MsgsSimToClient.MsgLogSupplyQuotas log_supply_quotas = 83;
  inline bool has_log_supply_quotas() const;
  inline void clear_log_supply_quotas();
  static const int kLogSupplyQuotasFieldNumber = 83;
  inline const ::MsgsSimToClient::MsgLogSupplyQuotas& log_supply_quotas() const;
  inline ::MsgsSimToClient::MsgLogSupplyQuotas* mutable_log_supply_quotas();
  
  // optional .MsgsSimToClient.MsgPopulationCreation population_creation = 84;
  inline bool has_population_creation() const;
  inline void clear_population_creation();
  static const int kPopulationCreationFieldNumber = 84;
  inline const ::MsgsSimToClient::MsgPopulationCreation& population_creation() const;
  inline ::MsgsSimToClient::MsgPopulationCreation* mutable_population_creation();
  
  // optional .MsgsSimToClient.MsgPopulationUpdate population_update = 85;
  inline bool has_population_update() const;
  inline void clear_population_update();
  static const int kPopulationUpdateFieldNumber = 85;
  inline const ::MsgsSimToClient::MsgPopulationUpdate& population_update() const;
  inline ::MsgsSimToClient::MsgPopulationUpdate* mutable_population_update();
  
  // optional .MsgsSimToClient.MsgPopulationConcentrationCreation population_concentration_creation = 86;
  inline bool has_population_concentration_creation() const;
  inline void clear_population_concentration_creation();
  static const int kPopulationConcentrationCreationFieldNumber = 86;
  inline const ::MsgsSimToClient::MsgPopulationConcentrationCreation& population_concentration_creation() const;
  inline ::MsgsSimToClient::MsgPopulationConcentrationCreation* mutable_population_concentration_creation();
  
  // optional .MsgsSimToClient.MsgPopulationConcentrationDestruction population_concentration_destruction = 87;
  inline bool has_population_concentration_destruction() const;
  inline void clear_population_concentration_destruction();
  static const int kPopulationConcentrationDestructionFieldNumber = 87;
  inline const ::MsgsSimToClient::MsgPopulationConcentrationDestruction& population_concentration_destruction() const;
  inline ::MsgsSimToClient::MsgPopulationConcentrationDestruction* mutable_population_concentration_destruction();
  
  // optional .MsgsSimToClient.MsgPopulationConcentrationUpdate population_concentration_update = 88;
  inline bool has_population_concentration_update() const;
  inline void clear_population_concentration_update();
  static const int kPopulationConcentrationUpdateFieldNumber = 88;
  inline const ::MsgsSimToClient::MsgPopulationConcentrationUpdate& population_concentration_update() const;
  inline ::MsgsSimToClient::MsgPopulationConcentrationUpdate* mutable_population_concentration_update();
  
  // optional .MsgsSimToClient.MsgPopulationFlowCreation population_flow_creation = 89;
  inline bool has_population_flow_creation() const;
  inline void clear_population_flow_creation();
  static const int kPopulationFlowCreationFieldNumber = 89;
  inline const ::MsgsSimToClient::MsgPopulationFlowCreation& population_flow_creation() const;
  inline ::MsgsSimToClient::MsgPopulationFlowCreation* mutable_population_flow_creation();
  
  // optional .MsgsSimToClient.MsgPopulationFlowDestruction population_flow_destruction = 90;
  inline bool has_population_flow_destruction() const;
  inline void clear_population_flow_destruction();
  static const int kPopulationFlowDestructionFieldNumber = 90;
  inline const ::MsgsSimToClient::MsgPopulationFlowDestruction& population_flow_destruction() const;
  inline ::MsgsSimToClient::MsgPopulationFlowDestruction* mutable_population_flow_destruction();
  
  // optional .MsgsSimToClient.MsgPopulationFlowUpdate population_flow_update = 91;
  inline bool has_population_flow_update() const;
  inline void clear_population_flow_update();
  static const int kPopulationFlowUpdateFieldNumber = 91;
  inline const ::MsgsSimToClient::MsgPopulationFlowUpdate& population_flow_update() const;
  inline ::MsgsSimToClient::MsgPopulationFlowUpdate* mutable_population_flow_update();
  
  // optional .MsgsSimToClient.MsgPopulationKnowledgeCreation population_knowledge_creation = 92;
  inline bool has_population_knowledge_creation() const;
  inline void clear_population_knowledge_creation();
  static const int kPopulationKnowledgeCreationFieldNumber = 92;
  inline const ::MsgsSimToClient::MsgPopulationKnowledgeCreation& population_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgPopulationKnowledgeCreation* mutable_population_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgPopulationKnowledgeUpdate population_knowledge_update = 93;
  inline bool has_population_knowledge_update() const;
  inline void clear_population_knowledge_update();
  static const int kPopulationKnowledgeUpdateFieldNumber = 93;
  inline const ::MsgsSimToClient::MsgPopulationKnowledgeUpdate& population_knowledge_update() const;
  inline ::MsgsSimToClient::MsgPopulationKnowledgeUpdate* mutable_population_knowledge_update();
  
  // optional .MsgsSimToClient.MsgPopulationKnowledgeDestruction population_knowledge_destruction = 94;
  inline bool has_population_knowledge_destruction() const;
  inline void clear_population_knowledge_destruction();
  static const int kPopulationKnowledgeDestructionFieldNumber = 94;
  inline const ::MsgsSimToClient::MsgPopulationKnowledgeDestruction& population_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgPopulationKnowledgeDestruction* mutable_population_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgPopulationConcentrationKnowledgeCreation population_concentration_knowledge_creation = 95;
  inline bool has_population_concentration_knowledge_creation() const;
  inline void clear_population_concentration_knowledge_creation();
  static const int kPopulationConcentrationKnowledgeCreationFieldNumber = 95;
  inline const ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeCreation& population_concentration_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeCreation* mutable_population_concentration_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgPopulationConcentrationKnowledgeDestruction population_concentration_knowledge_destruction = 96;
  inline bool has_population_concentration_knowledge_destruction() const;
  inline void clear_population_concentration_knowledge_destruction();
  static const int kPopulationConcentrationKnowledgeDestructionFieldNumber = 96;
  inline const ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeDestruction& population_concentration_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeDestruction* mutable_population_concentration_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgPopulationConcentrationKnowledgeUpdate population_concentration_knowledge_update = 97;
  inline bool has_population_concentration_knowledge_update() const;
  inline void clear_population_concentration_knowledge_update();
  static const int kPopulationConcentrationKnowledgeUpdateFieldNumber = 97;
  inline const ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeUpdate& population_concentration_knowledge_update() const;
  inline ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeUpdate* mutable_population_concentration_knowledge_update();
  
  // optional .MsgsSimToClient.MsgPopulationFlowKnowledgeCreation population_flow_knowledge_creation = 98;
  inline bool has_population_flow_knowledge_creation() const;
  inline void clear_population_flow_knowledge_creation();
  static const int kPopulationFlowKnowledgeCreationFieldNumber = 98;
  inline const ::MsgsSimToClient::MsgPopulationFlowKnowledgeCreation& population_flow_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgPopulationFlowKnowledgeCreation* mutable_population_flow_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgPopulationFlowKnowledgeDestruction population_flow_knowledge_destruction = 99;
  inline bool has_population_flow_knowledge_destruction() const;
  inline void clear_population_flow_knowledge_destruction();
  static const int kPopulationFlowKnowledgeDestructionFieldNumber = 99;
  inline const ::MsgsSimToClient::MsgPopulationFlowKnowledgeDestruction& population_flow_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgPopulationFlowKnowledgeDestruction* mutable_population_flow_knowledge_destruction();
  
  // optional .MsgsSimToClient.MsgPopulationFlowKnowledgeUpdate population_flow_knowledge_update = 100;
  inline bool has_population_flow_knowledge_update() const;
  inline void clear_population_flow_knowledge_update();
  static const int kPopulationFlowKnowledgeUpdateFieldNumber = 100;
  inline const ::MsgsSimToClient::MsgPopulationFlowKnowledgeUpdate& population_flow_knowledge_update() const;
  inline ::MsgsSimToClient::MsgPopulationFlowKnowledgeUpdate* mutable_population_flow_knowledge_update();
  
  // optional .MsgsSimToClient.MsgFolkCreation folk_creation = 101;
  inline bool has_folk_creation() const;
  inline void clear_folk_creation();
  static const int kFolkCreationFieldNumber = 101;
  inline const ::MsgsSimToClient::MsgFolkCreation& folk_creation() const;
  inline ::MsgsSimToClient::MsgFolkCreation* mutable_folk_creation();
  
  // optional .MsgsSimToClient.MsgFolkGraphUpdate folk_graph_update = 102;
  inline bool has_folk_graph_update() const;
  inline void clear_folk_graph_update();
  static const int kFolkGraphUpdateFieldNumber = 102;
  inline const ::MsgsSimToClient::MsgFolkGraphUpdate& folk_graph_update() const;
  inline ::MsgsSimToClient::MsgFolkGraphUpdate* mutable_folk_graph_update();
  
  // optional .MsgsSimToClient.MsgControlGlobalMeteoAck control_global_meteo_ack = 103;
  inline bool has_control_global_meteo_ack() const;
  inline void clear_control_global_meteo_ack();
  static const int kControlGlobalMeteoAckFieldNumber = 103;
  inline const ::MsgsSimToClient::MsgControlGlobalMeteoAck& control_global_meteo_ack() const;
  inline ::MsgsSimToClient::MsgControlGlobalMeteoAck* mutable_control_global_meteo_ack();
  
  // optional .MsgsSimToClient.MsgControlLocalMeteoAck control_local_meteo_ack = 104;
  inline bool has_control_local_meteo_ack() const;
  inline void clear_control_local_meteo_ack();
  static const int kControlLocalMeteoAckFieldNumber = 104;
  inline const ::MsgsSimToClient::MsgControlLocalMeteoAck& control_local_meteo_ack() const;
  inline ::MsgsSimToClient::MsgControlLocalMeteoAck* mutable_control_local_meteo_ack();
  
  // optional .MsgsSimToClient.MsgControlCheckPointSaveBegin control_checkpoint_save_begin = 105;
  inline bool has_control_checkpoint_save_begin() const;
  inline void clear_control_checkpoint_save_begin();
  static const int kControlCheckpointSaveBeginFieldNumber = 105;
  inline const ::MsgsSimToClient::MsgControlCheckPointSaveBegin& control_checkpoint_save_begin() const;
  inline ::MsgsSimToClient::MsgControlCheckPointSaveBegin* mutable_control_checkpoint_save_begin();
  
  // optional .MsgsSimToClient.MsgControlCheckPointSetFrequencyAck control_checkpoint_set_frequency_ack = 106;
  inline bool has_control_checkpoint_set_frequency_ack() const;
  inline void clear_control_checkpoint_set_frequency_ack();
  static const int kControlCheckpointSetFrequencyAckFieldNumber = 106;
  inline const ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck& control_checkpoint_set_frequency_ack() const;
  inline ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck* mutable_control_checkpoint_set_frequency_ack();
  
  // optional .MsgsSimToClient.MsgControlCheckPointSaveNowAck control_checkpoint_save_now_ack = 107;
  inline bool has_control_checkpoint_save_now_ack() const;
  inline void clear_control_checkpoint_save_now_ack();
  static const int kControlCheckpointSaveNowAckFieldNumber = 107;
  inline const ::MsgsSimToClient::MsgControlCheckPointSaveNowAck& control_checkpoint_save_now_ack() const;
  inline ::MsgsSimToClient::MsgControlCheckPointSaveNowAck* mutable_control_checkpoint_save_now_ack();
  
  // optional .MsgsSimToClient.MsgControlSendCurrentStateBegin control_send_current_state_begin = 108;
  inline bool has_control_send_current_state_begin() const;
  inline void clear_control_send_current_state_begin();
  static const int kControlSendCurrentStateBeginFieldNumber = 108;
  inline const ::MsgsSimToClient::MsgControlSendCurrentStateBegin& control_send_current_state_begin() const;
  inline ::MsgsSimToClient::MsgControlSendCurrentStateBegin* mutable_control_send_current_state_begin();
  
  // optional .MsgsSimToClient.MsgControlSendCurrentStateEnd control_send_current_state_end = 109;
  inline bool has_control_send_current_state_end() const;
  inline void clear_control_send_current_state_end();
  static const int kControlSendCurrentStateEndFieldNumber = 109;
  inline const ::MsgsSimToClient::MsgControlSendCurrentStateEnd& control_send_current_state_end() const;
  inline ::MsgsSimToClient::MsgControlSendCurrentStateEnd* mutable_control_send_current_state_end();
  
  // optional .MsgsSimToClient.MsgUrbanCreation urban_creation = 110;
  inline bool has_urban_creation() const;
  inline void clear_urban_creation();
  static const int kUrbanCreationFieldNumber = 110;
  inline const ::MsgsSimToClient::MsgUrbanCreation& urban_creation() const;
  inline ::MsgsSimToClient::MsgUrbanCreation* mutable_urban_creation();
  
  // optional .MsgsSimToClient.MsgUrbanUpdate urban_update = 111;
  inline bool has_urban_update() const;
  inline void clear_urban_update();
  static const int kUrbanUpdateFieldNumber = 111;
  inline const ::MsgsSimToClient::MsgUrbanUpdate& urban_update() const;
  inline ::MsgsSimToClient::MsgUrbanUpdate* mutable_urban_update();
  
  // optional .MsgsSimToClient.MsgUrbanKnowledgeCreation urban_knowledge_creation = 112;
  inline bool has_urban_knowledge_creation() const;
  inline void clear_urban_knowledge_creation();
  static const int kUrbanKnowledgeCreationFieldNumber = 112;
  inline const ::MsgsSimToClient::MsgUrbanKnowledgeCreation& urban_knowledge_creation() const;
  inline ::MsgsSimToClient::MsgUrbanKnowledgeCreation* mutable_urban_knowledge_creation();
  
  // optional .MsgsSimToClient.MsgUrbanKnowledgeUpdate urban_knowledge_update = 113;
  inline bool has_urban_knowledge_update() const;
  inline void clear_urban_knowledge_update();
  static const int kUrbanKnowledgeUpdateFieldNumber = 113;
  inline const ::MsgsSimToClient::MsgUrbanKnowledgeUpdate& urban_knowledge_update() const;
  inline ::MsgsSimToClient::MsgUrbanKnowledgeUpdate* mutable_urban_knowledge_update();
  
  // optional .MsgsSimToClient.MsgUrbanKnowledgeDestruction urban_knowledge_destruction = 114;
  inline bool has_urban_knowledge_destruction() const;
  inline void clear_urban_knowledge_destruction();
  static const int kUrbanKnowledgeDestructionFieldNumber = 114;
  inline const ::MsgsSimToClient::MsgUrbanKnowledgeDestruction& urban_knowledge_destruction() const;
  inline ::MsgsSimToClient::MsgUrbanKnowledgeDestruction* mutable_urban_knowledge_destruction();
  
  // optional .Common.StockResource stock_resource = 115;
  inline bool has_stock_resource() const;
  inline void clear_stock_resource();
  static const int kStockResourceFieldNumber = 115;
  inline const ::Common::StockResource& stock_resource() const;
  inline ::Common::StockResource* mutable_stock_resource();
  
  // optional .MsgsSimToClient.MsgUrbanDetection urban_detection = 116;
  inline bool has_urban_detection() const;
  inline void clear_urban_detection();
  static const int kUrbanDetectionFieldNumber = 116;
  inline const ::MsgsSimToClient::MsgUrbanDetection& urban_detection() const;
  inline ::MsgsSimToClient::MsgUrbanDetection* mutable_urban_detection();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupMagicActionAck knowledge_group_magic_action_ack = 117;
  inline bool has_knowledge_group_magic_action_ack() const;
  inline void clear_knowledge_group_magic_action_ack();
  static const int kKnowledgeGroupMagicActionAckFieldNumber = 117;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck& knowledge_group_magic_action_ack() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck* mutable_knowledge_group_magic_action_ack();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupCreation knowledge_group_creation = 118;
  inline bool has_knowledge_group_creation() const;
  inline void clear_knowledge_group_creation();
  static const int kKnowledgeGroupCreationFieldNumber = 118;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupCreation& knowledge_group_creation() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupCreation* mutable_knowledge_group_creation();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupUpdate knowledge_group_update = 119;
  inline bool has_knowledge_group_update() const;
  inline void clear_knowledge_group_update();
  static const int kKnowledgeGroupUpdateFieldNumber = 119;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupUpdate& knowledge_group_update() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupUpdate* mutable_knowledge_group_update();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupCreationAck knowledge_group_creation_ack = 120;
  inline bool has_knowledge_group_creation_ack() const;
  inline void clear_knowledge_group_creation_ack();
  static const int kKnowledgeGroupCreationAckFieldNumber = 120;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupCreationAck& knowledge_group_creation_ack() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupCreationAck* mutable_knowledge_group_creation_ack();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupUpdateAck knowledge_group_update_ack = 121;
  inline bool has_knowledge_group_update_ack() const;
  inline void clear_knowledge_group_update_ack();
  static const int kKnowledgeGroupUpdateAckFieldNumber = 121;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck& knowledge_group_update_ack() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck* mutable_knowledge_group_update_ack();
  
  // optional .MsgsSimToClient.MsgKnowledgeGroupDestruction knowledge_group_destruction = 122;
  inline bool has_knowledge_group_destruction() const;
  inline void clear_knowledge_group_destruction();
  static const int kKnowledgeGroupDestructionFieldNumber = 122;
  inline const ::MsgsSimToClient::MsgKnowledgeGroupDestruction& knowledge_group_destruction() const;
  inline ::MsgsSimToClient::MsgKnowledgeGroupDestruction* mutable_knowledge_group_destruction();
  
  // optional .MsgsSimToClient.MsgActionCreateFireOrderAck action_create_fire_order_ack = 123;
  inline bool has_action_create_fire_order_ack() const;
  inline void clear_action_create_fire_order_ack();
  static const int kActionCreateFireOrderAckFieldNumber = 123;
  inline const ::MsgsSimToClient::MsgActionCreateFireOrderAck& action_create_fire_order_ack() const;
  inline ::MsgsSimToClient::MsgActionCreateFireOrderAck* mutable_action_create_fire_order_ack();
  
  // optional .MsgsSimToClient.MsgControlGlobalMeteo control_global_meteo = 124;
  inline bool has_control_global_meteo() const;
  inline void clear_control_global_meteo();
  static const int kControlGlobalMeteoFieldNumber = 124;
  inline const ::MsgsSimToClient::MsgControlGlobalMeteo& control_global_meteo() const;
  inline ::MsgsSimToClient::MsgControlGlobalMeteo* mutable_control_global_meteo();
  
  // optional .MsgsSimToClient.MsgControlLocalMeteoCreation control_local_meteo_creation = 125;
  inline bool has_control_local_meteo_creation() const;
  inline void clear_control_local_meteo_creation();
  static const int kControlLocalMeteoCreationFieldNumber = 125;
  inline const ::MsgsSimToClient::MsgControlLocalMeteoCreation& control_local_meteo_creation() const;
  inline ::MsgsSimToClient::MsgControlLocalMeteoCreation* mutable_control_local_meteo_creation();
  
  // optional .MsgsSimToClient.MsgControlLocalMeteoDestruction control_local_meteo_destruction = 126;
  inline bool has_control_local_meteo_destruction() const;
  inline void clear_control_local_meteo_destruction();
  static const int kControlLocalMeteoDestructionFieldNumber = 126;
  inline const ::MsgsSimToClient::MsgControlLocalMeteoDestruction& control_local_meteo_destruction() const;
  inline ::MsgsSimToClient::MsgControlLocalMeteoDestruction* mutable_control_local_meteo_destruction();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::MsgsSimToClient::MsgUnitOrderAck* unit_order_ack_;
  ::MsgsSimToClient::MsgAutomatOrderAck* automat_order_ack_;
  ::MsgsSimToClient::MsgPopulationOrderAck* population_order_ack_;
  ::MsgsSimToClient::MsgFragOrderAck* frag_order_ack_;
  ::MsgsSimToClient::MsgSetAutomatModeAck* set_automat_mode_ack_;
  ::MsgsSimToClient::MsgUnitCreationRequestAck* unit_creation_request_ack_;
  ::MsgsSimToClient::MsgMagicActionAck* magic_action_ack_;
  ::MsgsSimToClient::MsgUnitMagicActionAck* unit_magic_action_ack_;
  ::MsgsSimToClient::MsgObjectMagicActionAck* object_magic_action_ack_;
  ::MsgsSimToClient::MsgPopulationMagicActionAck* population_magic_action_ack_;
  ::MsgsSimToClient::MsgChangeDiplomacyAck* change_diplomacy_ack_;
  ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck* automat_change_knowledge_group_ack_;
  ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck* automat_change_logistic_links_ack_;
  ::MsgsSimToClient::MsgAutomatChangeSuperiorAck* automat_change_superior_ack_;
  ::MsgsSimToClient::MsgUnitChangeSuperiorAck* unit_change_superior_ack_;
  ::MsgsSimToClient::MsgLogSupplyPushFlowAck* log_supply_push_flow_ack_;
  ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck* log_supply_change_quotas_ack_;
  ::MsgsSimToClient::MsgControlInformation* control_information_;
  ::MsgsSimToClient::MsgControlProfilingInformation* control_profiling_information_;
  ::MsgsSimToClient::MsgControlBeginTick* control_begin_tick_;
  ::MsgsSimToClient::MsgControlEndTick* control_end_tick_;
  ::MsgsSimToClient::MsgControlStopAck* control_stop_ack_;
  ::MsgsSimToClient::MsgControlPauseAck* control_pause_ack_;
  ::MsgsSimToClient::MsgControlResumeAck* control_resume_ack_;
  ::MsgsSimToClient::MsgControlChangeTimeFactorAck* control_change_time_factor_ack_;
  ::MsgsSimToClient::MsgControlDatetimeChangeAck* control_date_time_change_ack_;
  ::MsgsSimToClient::MsgControlCheckPointSaveEnd* control_checkpoint_save_end_;
  ::Common::MsgFormationCreation* formation_creation_;
  ::MsgsSimToClient::MsgTeamCreation* side_creation_;
  ::MsgsSimToClient::MsgAutomatCreation* automat_creation_;
  ::MsgsSimToClient::MsgAutomatAttributes* automat_attributes_;
  ::MsgsSimToClient::MsgUnitCreation* unit_creation_;
  ::MsgsSimToClient::MsgUnitAttributes* unit_attributes_;
  ::MsgsSimToClient::MsgUnitPathFind* unit_pathfind_;
  ::MsgsSimToClient::MsgUnitDestruction* unit_destruction_;
  ::MsgsSimToClient::MsgUnitEnvironmentType* unit_environment_type_;
  ::Common::MsgChangeDiplomacy* change_diplomacy_;
  ::Common::MsgUnitChangeSuperior* unit_change_superior_;
  ::Common::MsgAutomatChangeLogisticLinks* automat_change_logistic_links_;
  ::Common::MsgAutomatChangeKnowledgeGroup* automat_change_knowledge_group_;
  ::Common::MsgAutomatChangeSuperior* automat_change_superior_;
  ::MsgsSimToClient::MsgUnitKnowledgeCreation* unit_knowledge_creation_;
  ::MsgsSimToClient::MsgUnitKnowledgeUpdate* unit_knowledge_update_;
  ::MsgsSimToClient::MsgUnitKnowledgeDestruction* unit_knowledge_destruction_;
  ::MsgsSimToClient::MsgStartUnitFire* start_unit_fire_;
  ::MsgsSimToClient::MsgStopUnitFire* stop_unit_fire_;
  ::MsgsSimToClient::MsgStartPopulationFire* start_population_fire_;
  ::MsgsSimToClient::MsgStopPopulationFire* stop_population_fire_;
  ::MsgsSimToClient::MsgExplosion* explosion_;
  ::MsgsSimToClient::MsgStartFireEffect* start_fire_effect_;
  ::MsgsSimToClient::MsgStopFireEffect* stop_fire_effect_;
  ::MsgsSimToClient::MsgReport* report_;
  ::MsgsSimToClient::MsgInvalidateReport* invalidate_report_;
  ::MsgsSimToClient::MsgTrace* trace_;
  ::MsgsSimToClient::MsgDecisionalState* decisional_state_;
  ::MsgsSimToClient::MsgDebugPoints* debug_points_;
  ::MsgsSimToClient::MsgUnitVisionCones* unit_vision_cones_;
  ::MsgsSimToClient::MsgUnitDetection* unit_detection_;
  ::MsgsSimToClient::MsgObjectDetection* object_detection_;
  ::MsgsSimToClient::MsgPopulationConcentrationDetection* population_concentration_detection_;
  ::MsgsSimToClient::MsgPopulationFlowDetection* population_flow_detection_;
  ::Common::MsgUnitOrder* unit_order_;
  ::Common::MsgAutomatOrder* automat_order_;
  ::Common::MsgPopulationOrder* population_order_;
  ::MsgsSimToClient::MsgObjectCreation* object_creation_;
  ::MsgsSimToClient::MsgObjectDestruction* object_destruction_;
  ::MsgsSimToClient::MsgObjectUpdate* object_update_;
  ::MsgsSimToClient::MsgObjectKnowledgeCreation* object_knowledge_creation_;
  ::MsgsSimToClient::MsgObjectKnowledgeUpdate* object_knowledge_update_;
  ::MsgsSimToClient::MsgObjectKnowledgeDestruction* object_knowledge_destruction_;
  ::MsgsSimToClient::MsgLogMedicalHandlingCreation* log_medical_handling_creation_;
  ::MsgsSimToClient::MsgLogMedicalHandlingUpdate* log_medical_handling_update_;
  ::MsgsSimToClient::MsgLogMedicalHandlingDestruction* log_medical_handling_destruction_;
  ::MsgsSimToClient::MsgLogMedicalState* log_medical_state_;
  ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation* log_maintenance_handling_creation_;
  ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate* log_maintenance_handling_update_;
  ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction* log_maintenance_handling_destruction_;
  ::MsgsSimToClient::MsgLogMaintenanceState* log_maintenance_state_;
  ::MsgsSimToClient::MsgLogSupplyHandlingCreation* log_supply_handling_creation_;
  ::MsgsSimToClient::MsgLogSupplyHandlingUpdate* log_supply_handling_update_;
  ::MsgsSimToClient::MsgLogSupplyHandlingDestruction* log_supply_handling_destruction_;
  ::MsgsSimToClient::MsgLogSupplyState* log_supply_state_;
  ::MsgsSimToClient::MsgLogSupplyQuotas* log_supply_quotas_;
  ::MsgsSimToClient::MsgPopulationCreation* population_creation_;
  ::MsgsSimToClient::MsgPopulationUpdate* population_update_;
  ::MsgsSimToClient::MsgPopulationConcentrationCreation* population_concentration_creation_;
  ::MsgsSimToClient::MsgPopulationConcentrationDestruction* population_concentration_destruction_;
  ::MsgsSimToClient::MsgPopulationConcentrationUpdate* population_concentration_update_;
  ::MsgsSimToClient::MsgPopulationFlowCreation* population_flow_creation_;
  ::MsgsSimToClient::MsgPopulationFlowDestruction* population_flow_destruction_;
  ::MsgsSimToClient::MsgPopulationFlowUpdate* population_flow_update_;
  ::MsgsSimToClient::MsgPopulationKnowledgeCreation* population_knowledge_creation_;
  ::MsgsSimToClient::MsgPopulationKnowledgeUpdate* population_knowledge_update_;
  ::MsgsSimToClient::MsgPopulationKnowledgeDestruction* population_knowledge_destruction_;
  ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeCreation* population_concentration_knowledge_creation_;
  ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeDestruction* population_concentration_knowledge_destruction_;
  ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeUpdate* population_concentration_knowledge_update_;
  ::MsgsSimToClient::MsgPopulationFlowKnowledgeCreation* population_flow_knowledge_creation_;
  ::MsgsSimToClient::MsgPopulationFlowKnowledgeDestruction* population_flow_knowledge_destruction_;
  ::MsgsSimToClient::MsgPopulationFlowKnowledgeUpdate* population_flow_knowledge_update_;
  ::MsgsSimToClient::MsgFolkCreation* folk_creation_;
  ::MsgsSimToClient::MsgFolkGraphUpdate* folk_graph_update_;
  ::MsgsSimToClient::MsgControlGlobalMeteoAck* control_global_meteo_ack_;
  ::MsgsSimToClient::MsgControlLocalMeteoAck* control_local_meteo_ack_;
  ::MsgsSimToClient::MsgControlCheckPointSaveBegin* control_checkpoint_save_begin_;
  ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck* control_checkpoint_set_frequency_ack_;
  ::MsgsSimToClient::MsgControlCheckPointSaveNowAck* control_checkpoint_save_now_ack_;
  ::MsgsSimToClient::MsgControlSendCurrentStateBegin* control_send_current_state_begin_;
  ::MsgsSimToClient::MsgControlSendCurrentStateEnd* control_send_current_state_end_;
  ::MsgsSimToClient::MsgUrbanCreation* urban_creation_;
  ::MsgsSimToClient::MsgUrbanUpdate* urban_update_;
  ::MsgsSimToClient::MsgUrbanKnowledgeCreation* urban_knowledge_creation_;
  ::MsgsSimToClient::MsgUrbanKnowledgeUpdate* urban_knowledge_update_;
  ::MsgsSimToClient::MsgUrbanKnowledgeDestruction* urban_knowledge_destruction_;
  ::Common::StockResource* stock_resource_;
  ::MsgsSimToClient::MsgUrbanDetection* urban_detection_;
  ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck* knowledge_group_magic_action_ack_;
  ::MsgsSimToClient::MsgKnowledgeGroupCreation* knowledge_group_creation_;
  ::MsgsSimToClient::MsgKnowledgeGroupUpdate* knowledge_group_update_;
  ::MsgsSimToClient::MsgKnowledgeGroupCreationAck* knowledge_group_creation_ack_;
  ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck* knowledge_group_update_ack_;
  ::MsgsSimToClient::MsgKnowledgeGroupDestruction* knowledge_group_destruction_;
  ::MsgsSimToClient::MsgActionCreateFireOrderAck* action_create_fire_order_ack_;
  ::MsgsSimToClient::MsgControlGlobalMeteo* control_global_meteo_;
  ::MsgsSimToClient::MsgControlLocalMeteoCreation* control_local_meteo_creation_;
  ::MsgsSimToClient::MsgControlLocalMeteoDestruction* control_local_meteo_destruction_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(126 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgSimToClient_Content* default_instance_;
};
// -------------------------------------------------------------------

class MsgSimToClient : public ::google::protobuf::Message {
 public:
  MsgSimToClient();
  virtual ~MsgSimToClient();
  
  MsgSimToClient(const MsgSimToClient& from);
  
  inline MsgSimToClient& operator=(const MsgSimToClient& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgSimToClient& default_instance();
  void Swap(MsgSimToClient* other);
  
  // implements Message ----------------------------------------------
  
  MsgSimToClient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgSimToClient& from);
  void MergeFrom(const MsgSimToClient& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MsgSimToClient_Content Content;
  
  // accessors -------------------------------------------------------
  
  // optional int32 context = 1;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 1;
  inline ::google::protobuf::int32 context() const;
  inline void set_context(::google::protobuf::int32 value);
  
  // required .MsgsSimToClient.MsgSimToClient.Content message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::MsgsSimToClient::MsgSimToClient_Content& message() const;
  inline ::MsgsSimToClient::MsgSimToClient_Content* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 context_;
  ::MsgsSimToClient::MsgSimToClient_Content* message_;
  friend void  protobuf_AddDesc_SimToClient_2eproto();
  friend void protobuf_AssignDesc_SimToClient_2eproto();
  friend void protobuf_ShutdownFile_SimToClient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MsgSimToClient* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// OrderAck

// -------------------------------------------------------------------

// MsgUnitOrderAck

// required .Common.UnitId tasker = 1;
inline bool MsgUnitOrderAck::has_tasker() const {
  return _has_bit(0);
}
inline void MsgUnitOrderAck::clear_tasker() {
  if (tasker_ != NULL) tasker_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitOrderAck::tasker() const {
  return tasker_ != NULL ? *tasker_ : *default_instance_->tasker_;
}
inline ::Common::UnitId* MsgUnitOrderAck::mutable_tasker() {
  _set_bit(0);
  if (tasker_ == NULL) tasker_ = new ::Common::UnitId;
  return tasker_;
}

// required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
inline bool MsgUnitOrderAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgUnitOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::OrderAck_ErrorCode MsgUnitOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::OrderAck_ErrorCode >(error_code_);
}
inline void MsgUnitOrderAck::set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::OrderAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgAutomatOrderAck

// required .Common.AutomatId tasker = 1;
inline bool MsgAutomatOrderAck::has_tasker() const {
  return _has_bit(0);
}
inline void MsgAutomatOrderAck::clear_tasker() {
  if (tasker_ != NULL) tasker_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgAutomatOrderAck::tasker() const {
  return tasker_ != NULL ? *tasker_ : *default_instance_->tasker_;
}
inline ::Common::AutomatId* MsgAutomatOrderAck::mutable_tasker() {
  _set_bit(0);
  if (tasker_ == NULL) tasker_ = new ::Common::AutomatId;
  return tasker_;
}

// required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
inline bool MsgAutomatOrderAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgAutomatOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::OrderAck_ErrorCode MsgAutomatOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::OrderAck_ErrorCode >(error_code_);
}
inline void MsgAutomatOrderAck::set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::OrderAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationOrderAck

// required .Common.PopulationId tasker = 1;
inline bool MsgPopulationOrderAck::has_tasker() const {
  return _has_bit(0);
}
inline void MsgPopulationOrderAck::clear_tasker() {
  if (tasker_ != NULL) tasker_->::Common::PopulationId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationId& MsgPopulationOrderAck::tasker() const {
  return tasker_ != NULL ? *tasker_ : *default_instance_->tasker_;
}
inline ::Common::PopulationId* MsgPopulationOrderAck::mutable_tasker() {
  _set_bit(0);
  if (tasker_ == NULL) tasker_ = new ::Common::PopulationId;
  return tasker_;
}

// required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
inline bool MsgPopulationOrderAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgPopulationOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::OrderAck_ErrorCode MsgPopulationOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::OrderAck_ErrorCode >(error_code_);
}
inline void MsgPopulationOrderAck::set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::OrderAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgFragOrderAck

// required .Common.Tasker tasker = 1;
inline bool MsgFragOrderAck::has_tasker() const {
  return _has_bit(0);
}
inline void MsgFragOrderAck::clear_tasker() {
  if (tasker_ != NULL) tasker_->::Common::Tasker::Clear();
  _clear_bit(0);
}
inline const ::Common::Tasker& MsgFragOrderAck::tasker() const {
  return tasker_ != NULL ? *tasker_ : *default_instance_->tasker_;
}
inline ::Common::Tasker* MsgFragOrderAck::mutable_tasker() {
  _set_bit(0);
  if (tasker_ == NULL) tasker_ = new ::Common::Tasker;
  return tasker_;
}

// required .MsgsSimToClient.OrderAck.ErrorCode error_code = 2;
inline bool MsgFragOrderAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgFragOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::OrderAck_ErrorCode MsgFragOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::OrderAck_ErrorCode >(error_code_);
}
inline void MsgFragOrderAck::set_error_code(::MsgsSimToClient::OrderAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::OrderAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgSetAutomatModeAck

// required .Common.AutomatId id = 1;
inline bool MsgSetAutomatModeAck::has_id() const {
  return _has_bit(0);
}
inline void MsgSetAutomatModeAck::clear_id() {
  if (id_ != NULL) id_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgSetAutomatModeAck::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::AutomatId* MsgSetAutomatModeAck::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::AutomatId;
  return id_;
}

// required .MsgsSimToClient.MsgSetAutomatModeAck.ErrorCode error_code = 2;
inline bool MsgSetAutomatModeAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgSetAutomatModeAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode MsgSetAutomatModeAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode >(error_code_);
}
inline void MsgSetAutomatModeAck::set_error_code(::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// UnitActionAck

// -------------------------------------------------------------------

// MsgUnitCreationRequestAck

// required .MsgsSimToClient.UnitActionAck.ErrorCode error = 1;
inline bool MsgUnitCreationRequestAck::has_error() const {
  return _has_bit(0);
}
inline void MsgUnitCreationRequestAck::clear_error() {
  error_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::UnitActionAck_ErrorCode MsgUnitCreationRequestAck::error() const {
  return static_cast< ::MsgsSimToClient::UnitActionAck_ErrorCode >(error_);
}
inline void MsgUnitCreationRequestAck::set_error(::MsgsSimToClient::UnitActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::UnitActionAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_ = value;
}

// -------------------------------------------------------------------

// MsgMagicActionAck

// required .MsgsSimToClient.MsgMagicActionAck.ErrorCode error_code = 1;
inline bool MsgMagicActionAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgMagicActionAck_ErrorCode MsgMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgMagicActionAck_ErrorCode >(error_code_);
}
inline void MsgMagicActionAck::set_error_code(::MsgsSimToClient::MsgMagicActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgMagicActionAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgUnitMagicActionAck

// required .Common.UnitId id = 1;
inline bool MsgUnitMagicActionAck::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitMagicActionAck::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitMagicActionAck::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgUnitMagicActionAck::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// required .MsgsSimToClient.UnitActionAck.ErrorCode error_code = 2;
inline bool MsgUnitMagicActionAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgUnitMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::UnitActionAck_ErrorCode MsgUnitMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::UnitActionAck_ErrorCode >(error_code_);
}
inline void MsgUnitMagicActionAck::set_error_code(::MsgsSimToClient::UnitActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::UnitActionAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgObjectMagicActionAck

// required .MsgsSimToClient.MsgObjectMagicActionAck.ErrorCode error_code = 1;
inline bool MsgObjectMagicActionAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgObjectMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode MsgObjectMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode >(error_code_);
}
inline void MsgObjectMagicActionAck::set_error_code(::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationMagicActionAck

// required .Common.PopulationId id = 1;
inline bool MsgPopulationMagicActionAck::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationMagicActionAck::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationId& MsgPopulationMagicActionAck::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationId* MsgPopulationMagicActionAck::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationId;
  return id_;
}

// required .MsgsSimToClient.MsgPopulationMagicActionAck.ErrorCode error_code = 2;
inline bool MsgPopulationMagicActionAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgPopulationMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::MsgPopulationMagicActionAck_ErrorCode MsgPopulationMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgPopulationMagicActionAck_ErrorCode >(error_code_);
}
inline void MsgPopulationMagicActionAck::set_error_code(::MsgsSimToClient::MsgPopulationMagicActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgPopulationMagicActionAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgChangeDiplomacyAck

// required .Common.PartyId party1 = 1;
inline bool MsgChangeDiplomacyAck::has_party1() const {
  return _has_bit(0);
}
inline void MsgChangeDiplomacyAck::clear_party1() {
  if (party1_ != NULL) party1_->::Common::PartyId::Clear();
  _clear_bit(0);
}
inline const ::Common::PartyId& MsgChangeDiplomacyAck::party1() const {
  return party1_ != NULL ? *party1_ : *default_instance_->party1_;
}
inline ::Common::PartyId* MsgChangeDiplomacyAck::mutable_party1() {
  _set_bit(0);
  if (party1_ == NULL) party1_ = new ::Common::PartyId;
  return party1_;
}

// required .Common.PartyId party2 = 2;
inline bool MsgChangeDiplomacyAck::has_party2() const {
  return _has_bit(1);
}
inline void MsgChangeDiplomacyAck::clear_party2() {
  if (party2_ != NULL) party2_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgChangeDiplomacyAck::party2() const {
  return party2_ != NULL ? *party2_ : *default_instance_->party2_;
}
inline ::Common::PartyId* MsgChangeDiplomacyAck::mutable_party2() {
  _set_bit(1);
  if (party2_ == NULL) party2_ = new ::Common::PartyId;
  return party2_;
}

// required .Common.EnumDiplomacy diplomatie = 3;
inline bool MsgChangeDiplomacyAck::has_diplomatie() const {
  return _has_bit(2);
}
inline void MsgChangeDiplomacyAck::clear_diplomatie() {
  diplomatie_ = 0;
  _clear_bit(2);
}
inline Common::EnumDiplomacy MsgChangeDiplomacyAck::diplomatie() const {
  return static_cast< Common::EnumDiplomacy >(diplomatie_);
}
inline void MsgChangeDiplomacyAck::set_diplomatie(Common::EnumDiplomacy value) {
  GOOGLE_DCHECK(Common::EnumDiplomacy_IsValid(value));
  _set_bit(2);
  diplomatie_ = value;
}

// required .MsgsSimToClient.MsgChangeDiplomacyAck.EnumChangeDiplomacyErrorCode error_code = 4;
inline bool MsgChangeDiplomacyAck::has_error_code() const {
  return _has_bit(3);
}
inline void MsgChangeDiplomacyAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(3);
}
inline ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode MsgChangeDiplomacyAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode >(error_code_);
}
inline void MsgChangeDiplomacyAck::set_error_code(::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_IsValid(value));
  _set_bit(3);
  error_code_ = value;
}

// -------------------------------------------------------------------

// HierarchyModificationAck

// -------------------------------------------------------------------

// MsgAutomatChangeKnowledgeGroupAck

// required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
inline bool MsgAutomatChangeKnowledgeGroupAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgAutomatChangeKnowledgeGroupAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode MsgAutomatChangeKnowledgeGroupAck::error_code() const {
  return static_cast< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode >(error_code_);
}
inline void MsgAutomatChangeKnowledgeGroupAck::set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::HierarchyModificationAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgAutomatChangeLogisticLinksAck

// required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
inline bool MsgAutomatChangeLogisticLinksAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgAutomatChangeLogisticLinksAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode MsgAutomatChangeLogisticLinksAck::error_code() const {
  return static_cast< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode >(error_code_);
}
inline void MsgAutomatChangeLogisticLinksAck::set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::HierarchyModificationAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgAutomatChangeSuperiorAck

// required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
inline bool MsgAutomatChangeSuperiorAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgAutomatChangeSuperiorAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode MsgAutomatChangeSuperiorAck::error_code() const {
  return static_cast< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode >(error_code_);
}
inline void MsgAutomatChangeSuperiorAck::set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::HierarchyModificationAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgUnitChangeSuperiorAck

// required .MsgsSimToClient.HierarchyModificationAck.ErrorCode error_code = 1;
inline bool MsgUnitChangeSuperiorAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgUnitChangeSuperiorAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::HierarchyModificationAck_ErrorCode MsgUnitChangeSuperiorAck::error_code() const {
  return static_cast< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode >(error_code_);
}
inline void MsgUnitChangeSuperiorAck::set_error_code(::MsgsSimToClient::HierarchyModificationAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::HierarchyModificationAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgLogSupplyPushFlowAck

// optional .MsgsSimToClient.MsgLogSupplyPushFlowAck.EnumLogSupplyPushFlow ack = 1;
inline bool MsgLogSupplyPushFlowAck::has_ack() const {
  return _has_bit(0);
}
inline void MsgLogSupplyPushFlowAck::clear_ack() {
  ack_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow MsgLogSupplyPushFlowAck::ack() const {
  return static_cast< ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow >(ack_);
}
inline void MsgLogSupplyPushFlowAck::set_ack(::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_IsValid(value));
  _set_bit(0);
  ack_ = value;
}

// -------------------------------------------------------------------

// MsgLogSupplyChangeQuotasAck

// optional .MsgsSimToClient.MsgLogSupplyChangeQuotasAck.LogSupplyChangeQuotas ack = 1;
inline bool MsgLogSupplyChangeQuotasAck::has_ack() const {
  return _has_bit(0);
}
inline void MsgLogSupplyChangeQuotasAck::clear_ack() {
  ack_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas MsgLogSupplyChangeQuotasAck::ack() const {
  return static_cast< ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas >(ack_);
}
inline void MsgLogSupplyChangeQuotasAck::set_ack(::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_IsValid(value));
  _set_bit(0);
  ack_ = value;
}

// -------------------------------------------------------------------

// MsgActionCreateFireOrderAck

// required .MsgsSimToClient.MsgActionCreateFireOrderAck.EnumActionCreateFireOrderErrorCode error_code = 2;
inline bool MsgActionCreateFireOrderAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgActionCreateFireOrderAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode MsgActionCreateFireOrderAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode >(error_code_);
}
inline void MsgActionCreateFireOrderAck::set_error_code(::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlInformation

// required int32 current_tick = 1;
inline bool MsgControlInformation::has_current_tick() const {
  return _has_bit(0);
}
inline void MsgControlInformation::clear_current_tick() {
  current_tick_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlInformation::current_tick() const {
  return current_tick_;
}
inline void MsgControlInformation::set_current_tick(::google::protobuf::int32 value) {
  _set_bit(0);
  current_tick_ = value;
}

// required .Common.MsgDateTime initial_date_time = 2;
inline bool MsgControlInformation::has_initial_date_time() const {
  return _has_bit(1);
}
inline void MsgControlInformation::clear_initial_date_time() {
  if (initial_date_time_ != NULL) initial_date_time_->::Common::MsgDateTime::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgDateTime& MsgControlInformation::initial_date_time() const {
  return initial_date_time_ != NULL ? *initial_date_time_ : *default_instance_->initial_date_time_;
}
inline ::Common::MsgDateTime* MsgControlInformation::mutable_initial_date_time() {
  _set_bit(1);
  if (initial_date_time_ == NULL) initial_date_time_ = new ::Common::MsgDateTime;
  return initial_date_time_;
}

// required .Common.MsgDateTime date_time = 3;
inline bool MsgControlInformation::has_date_time() const {
  return _has_bit(2);
}
inline void MsgControlInformation::clear_date_time() {
  if (date_time_ != NULL) date_time_->::Common::MsgDateTime::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgDateTime& MsgControlInformation::date_time() const {
  return date_time_ != NULL ? *date_time_ : *default_instance_->date_time_;
}
inline ::Common::MsgDateTime* MsgControlInformation::mutable_date_time() {
  _set_bit(2);
  if (date_time_ == NULL) date_time_ = new ::Common::MsgDateTime;
  return date_time_;
}

// required int32 tick_duration = 4;
inline bool MsgControlInformation::has_tick_duration() const {
  return _has_bit(3);
}
inline void MsgControlInformation::clear_tick_duration() {
  tick_duration_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgControlInformation::tick_duration() const {
  return tick_duration_;
}
inline void MsgControlInformation::set_tick_duration(::google::protobuf::int32 value) {
  _set_bit(3);
  tick_duration_ = value;
}

// required int32 time_factor = 5;
inline bool MsgControlInformation::has_time_factor() const {
  return _has_bit(4);
}
inline void MsgControlInformation::clear_time_factor() {
  time_factor_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgControlInformation::time_factor() const {
  return time_factor_;
}
inline void MsgControlInformation::set_time_factor(::google::protobuf::int32 value) {
  _set_bit(4);
  time_factor_ = value;
}

// required int32 checkpoint_frequency = 6;
inline bool MsgControlInformation::has_checkpoint_frequency() const {
  return _has_bit(5);
}
inline void MsgControlInformation::clear_checkpoint_frequency() {
  checkpoint_frequency_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgControlInformation::checkpoint_frequency() const {
  return checkpoint_frequency_;
}
inline void MsgControlInformation::set_checkpoint_frequency(::google::protobuf::int32 value) {
  _set_bit(5);
  checkpoint_frequency_ = value;
}

// required .Common.EnumSimulationState status = 7;
inline bool MsgControlInformation::has_status() const {
  return _has_bit(6);
}
inline void MsgControlInformation::clear_status() {
  status_ = 0;
  _clear_bit(6);
}
inline Common::EnumSimulationState MsgControlInformation::status() const {
  return static_cast< Common::EnumSimulationState >(status_);
}
inline void MsgControlInformation::set_status(Common::EnumSimulationState value) {
  GOOGLE_DCHECK(Common::EnumSimulationState_IsValid(value));
  _set_bit(6);
  status_ = value;
}

// required bool send_vision_cones = 8;
inline bool MsgControlInformation::has_send_vision_cones() const {
  return _has_bit(7);
}
inline void MsgControlInformation::clear_send_vision_cones() {
  send_vision_cones_ = false;
  _clear_bit(7);
}
inline bool MsgControlInformation::send_vision_cones() const {
  return send_vision_cones_;
}
inline void MsgControlInformation::set_send_vision_cones(bool value) {
  _set_bit(7);
  send_vision_cones_ = value;
}

// required bool profiling_enabled = 9;
inline bool MsgControlInformation::has_profiling_enabled() const {
  return _has_bit(8);
}
inline void MsgControlInformation::clear_profiling_enabled() {
  profiling_enabled_ = false;
  _clear_bit(8);
}
inline bool MsgControlInformation::profiling_enabled() const {
  return profiling_enabled_;
}
inline void MsgControlInformation::set_profiling_enabled(bool value) {
  _set_bit(8);
  profiling_enabled_ = value;
}

// -------------------------------------------------------------------

// MsgControlProfilingInformation

// required float perception = 1;
inline bool MsgControlProfilingInformation::has_perception() const {
  return _has_bit(0);
}
inline void MsgControlProfilingInformation::clear_perception() {
  perception_ = 0;
  _clear_bit(0);
}
inline float MsgControlProfilingInformation::perception() const {
  return perception_;
}
inline void MsgControlProfilingInformation::set_perception(float value) {
  _set_bit(0);
  perception_ = value;
}

// required float decision = 2;
inline bool MsgControlProfilingInformation::has_decision() const {
  return _has_bit(1);
}
inline void MsgControlProfilingInformation::clear_decision() {
  decision_ = 0;
  _clear_bit(1);
}
inline float MsgControlProfilingInformation::decision() const {
  return decision_;
}
inline void MsgControlProfilingInformation::set_decision(float value) {
  _set_bit(1);
  decision_ = value;
}

// required float action = 3;
inline bool MsgControlProfilingInformation::has_action() const {
  return _has_bit(2);
}
inline void MsgControlProfilingInformation::clear_action() {
  action_ = 0;
  _clear_bit(2);
}
inline float MsgControlProfilingInformation::action() const {
  return action_;
}
inline void MsgControlProfilingInformation::set_action(float value) {
  _set_bit(2);
  action_ = value;
}

// required float main_loop = 4;
inline bool MsgControlProfilingInformation::has_main_loop() const {
  return _has_bit(3);
}
inline void MsgControlProfilingInformation::clear_main_loop() {
  main_loop_ = 0;
  _clear_bit(3);
}
inline float MsgControlProfilingInformation::main_loop() const {
  return main_loop_;
}
inline void MsgControlProfilingInformation::set_main_loop(float value) {
  _set_bit(3);
  main_loop_ = value;
}

// -------------------------------------------------------------------

// MsgControlBeginTick

// required int32 current_tick = 1;
inline bool MsgControlBeginTick::has_current_tick() const {
  return _has_bit(0);
}
inline void MsgControlBeginTick::clear_current_tick() {
  current_tick_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlBeginTick::current_tick() const {
  return current_tick_;
}
inline void MsgControlBeginTick::set_current_tick(::google::protobuf::int32 value) {
  _set_bit(0);
  current_tick_ = value;
}

// required .Common.MsgDateTime date_time = 2;
inline bool MsgControlBeginTick::has_date_time() const {
  return _has_bit(1);
}
inline void MsgControlBeginTick::clear_date_time() {
  if (date_time_ != NULL) date_time_->::Common::MsgDateTime::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgDateTime& MsgControlBeginTick::date_time() const {
  return date_time_ != NULL ? *date_time_ : *default_instance_->date_time_;
}
inline ::Common::MsgDateTime* MsgControlBeginTick::mutable_date_time() {
  _set_bit(1);
  if (date_time_ == NULL) date_time_ = new ::Common::MsgDateTime;
  return date_time_;
}

// -------------------------------------------------------------------

// MsgControlEndTick

// required int32 current_tick = 1;
inline bool MsgControlEndTick::has_current_tick() const {
  return _has_bit(0);
}
inline void MsgControlEndTick::clear_current_tick() {
  current_tick_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlEndTick::current_tick() const {
  return current_tick_;
}
inline void MsgControlEndTick::set_current_tick(::google::protobuf::int32 value) {
  _set_bit(0);
  current_tick_ = value;
}

// required int32 tick_duration = 2;
inline bool MsgControlEndTick::has_tick_duration() const {
  return _has_bit(1);
}
inline void MsgControlEndTick::clear_tick_duration() {
  tick_duration_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgControlEndTick::tick_duration() const {
  return tick_duration_;
}
inline void MsgControlEndTick::set_tick_duration(::google::protobuf::int32 value) {
  _set_bit(1);
  tick_duration_ = value;
}

// required int32 long_pathfinds = 3;
inline bool MsgControlEndTick::has_long_pathfinds() const {
  return _has_bit(2);
}
inline void MsgControlEndTick::clear_long_pathfinds() {
  long_pathfinds_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgControlEndTick::long_pathfinds() const {
  return long_pathfinds_;
}
inline void MsgControlEndTick::set_long_pathfinds(::google::protobuf::int32 value) {
  _set_bit(2);
  long_pathfinds_ = value;
}

// required int32 short_pathfinds = 4;
inline bool MsgControlEndTick::has_short_pathfinds() const {
  return _has_bit(3);
}
inline void MsgControlEndTick::clear_short_pathfinds() {
  short_pathfinds_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgControlEndTick::short_pathfinds() const {
  return short_pathfinds_;
}
inline void MsgControlEndTick::set_short_pathfinds(::google::protobuf::int32 value) {
  _set_bit(3);
  short_pathfinds_ = value;
}

// required int32 memory = 5;
inline bool MsgControlEndTick::has_memory() const {
  return _has_bit(4);
}
inline void MsgControlEndTick::clear_memory() {
  memory_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgControlEndTick::memory() const {
  return memory_;
}
inline void MsgControlEndTick::set_memory(::google::protobuf::int32 value) {
  _set_bit(4);
  memory_ = value;
}

// required int32 virtual_memory = 6;
inline bool MsgControlEndTick::has_virtual_memory() const {
  return _has_bit(5);
}
inline void MsgControlEndTick::clear_virtual_memory() {
  virtual_memory_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgControlEndTick::virtual_memory() const {
  return virtual_memory_;
}
inline void MsgControlEndTick::set_virtual_memory(::google::protobuf::int32 value) {
  _set_bit(5);
  virtual_memory_ = value;
}

// -------------------------------------------------------------------

// ControlAck

// -------------------------------------------------------------------

// MsgControlDatetimeChangeAck

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
inline bool MsgControlDatetimeChangeAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgControlDatetimeChangeAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlDatetimeChangeAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlDatetimeChangeAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlChangeTimeFactorAck

// required int32 time_factor = 1;
inline bool MsgControlChangeTimeFactorAck::has_time_factor() const {
  return _has_bit(0);
}
inline void MsgControlChangeTimeFactorAck::clear_time_factor() {
  time_factor_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgControlChangeTimeFactorAck::time_factor() const {
  return time_factor_;
}
inline void MsgControlChangeTimeFactorAck::set_time_factor(::google::protobuf::int32 value) {
  _set_bit(0);
  time_factor_ = value;
}

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 2;
inline bool MsgControlChangeTimeFactorAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgControlChangeTimeFactorAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlChangeTimeFactorAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlChangeTimeFactorAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlStopAck

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
inline bool MsgControlStopAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgControlStopAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlStopAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlStopAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlPauseAck

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
inline bool MsgControlPauseAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgControlPauseAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlPauseAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlPauseAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgControlResumeAck

// required .MsgsSimToClient.ControlAck.ErrorCode error_code = 1;
inline bool MsgControlResumeAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgControlResumeAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::ControlAck_ErrorCode MsgControlResumeAck::error_code() const {
  return static_cast< ::MsgsSimToClient::ControlAck_ErrorCode >(error_code_);
}
inline void MsgControlResumeAck::set_error_code(::MsgsSimToClient::ControlAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ControlAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgTeamCreation

// required .Common.PartyId id = 1;
inline bool MsgTeamCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgTeamCreation::clear_id() {
  if (id_ != NULL) id_->::Common::PartyId::Clear();
  _clear_bit(0);
}
inline const ::Common::PartyId& MsgTeamCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PartyId* MsgTeamCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PartyId;
  return id_;
}

// required string nom = 2;
inline bool MsgTeamCreation::has_nom() const {
  return _has_bit(1);
}
inline void MsgTeamCreation::clear_nom() {
  if (nom_ != &_default_nom_) {
    nom_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgTeamCreation::nom() const {
  return *nom_;
}
inline void MsgTeamCreation::set_nom(const ::std::string& value) {
  _set_bit(1);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgTeamCreation::set_nom(const char* value) {
  _set_bit(1);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgTeamCreation::set_nom(const char* value, size_t size) {
  _set_bit(1);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgTeamCreation::mutable_nom() {
  _set_bit(1);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  return nom_;
}

// required .Common.EnumDiplomacy type = 3;
inline bool MsgTeamCreation::has_type() const {
  return _has_bit(2);
}
inline void MsgTeamCreation::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline Common::EnumDiplomacy MsgTeamCreation::type() const {
  return static_cast< Common::EnumDiplomacy >(type_);
}
inline void MsgTeamCreation::set_type(Common::EnumDiplomacy value) {
  GOOGLE_DCHECK(Common::EnumDiplomacy_IsValid(value));
  _set_bit(2);
  type_ = value;
}

// -------------------------------------------------------------------

// MsgAutomatCreation_oid_parent

// optional .Common.FormationId formation = 1;
inline bool MsgAutomatCreation_oid_parent::has_formation() const {
  return _has_bit(0);
}
inline void MsgAutomatCreation_oid_parent::clear_formation() {
  if (formation_ != NULL) formation_->::Common::FormationId::Clear();
  _clear_bit(0);
}
inline const ::Common::FormationId& MsgAutomatCreation_oid_parent::formation() const {
  return formation_ != NULL ? *formation_ : *default_instance_->formation_;
}
inline ::Common::FormationId* MsgAutomatCreation_oid_parent::mutable_formation() {
  _set_bit(0);
  if (formation_ == NULL) formation_ = new ::Common::FormationId;
  return formation_;
}

// optional .Common.AutomatId automat = 2;
inline bool MsgAutomatCreation_oid_parent::has_automat() const {
  return _has_bit(1);
}
inline void MsgAutomatCreation_oid_parent::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatId& MsgAutomatCreation_oid_parent::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* MsgAutomatCreation_oid_parent::mutable_automat() {
  _set_bit(1);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// -------------------------------------------------------------------

// MsgAutomatCreation

// optional .Common.AutomatId id = 1;
inline bool MsgAutomatCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgAutomatCreation::clear_id() {
  if (id_ != NULL) id_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgAutomatCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::AutomatId* MsgAutomatCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::AutomatId;
  return id_;
}

// optional .Common.AutomatType type = 2;
inline bool MsgAutomatCreation::has_type() const {
  return _has_bit(1);
}
inline void MsgAutomatCreation::clear_type() {
  if (type_ != NULL) type_->::Common::AutomatType::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatType& MsgAutomatCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::AutomatType* MsgAutomatCreation::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::AutomatType;
  return type_;
}

// optional string nom = 3;
inline bool MsgAutomatCreation::has_nom() const {
  return _has_bit(2);
}
inline void MsgAutomatCreation::clear_nom() {
  if (nom_ != &_default_nom_) {
    nom_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgAutomatCreation::nom() const {
  return *nom_;
}
inline void MsgAutomatCreation::set_nom(const ::std::string& value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgAutomatCreation::set_nom(const char* value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgAutomatCreation::set_nom(const char* value, size_t size) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgAutomatCreation::mutable_nom() {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  return nom_;
}

// optional .MsgsSimToClient.MsgAutomatCreation_oid_parent oid_parent = 4;
inline bool MsgAutomatCreation::has_oid_parent() const {
  return _has_bit(3);
}
inline void MsgAutomatCreation::clear_oid_parent() {
  if (oid_parent_ != NULL) oid_parent_->::MsgsSimToClient::MsgAutomatCreation_oid_parent::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::MsgAutomatCreation_oid_parent& MsgAutomatCreation::oid_parent() const {
  return oid_parent_ != NULL ? *oid_parent_ : *default_instance_->oid_parent_;
}
inline ::MsgsSimToClient::MsgAutomatCreation_oid_parent* MsgAutomatCreation::mutable_oid_parent() {
  _set_bit(3);
  if (oid_parent_ == NULL) oid_parent_ = new ::MsgsSimToClient::MsgAutomatCreation_oid_parent;
  return oid_parent_;
}

// optional .Common.PartyId party = 5;
inline bool MsgAutomatCreation::has_party() const {
  return _has_bit(4);
}
inline void MsgAutomatCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(4);
}
inline const ::Common::PartyId& MsgAutomatCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgAutomatCreation::mutable_party() {
  _set_bit(4);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.KnowledgeGroupId knowledge_group = 6;
inline bool MsgAutomatCreation::has_knowledge_group() const {
  return _has_bit(5);
}
inline void MsgAutomatCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(5);
}
inline const ::Common::KnowledgeGroupId& MsgAutomatCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgAutomatCreation::mutable_knowledge_group() {
  _set_bit(5);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// RulesOfEngagement

// -------------------------------------------------------------------

// ForceRatio

// -------------------------------------------------------------------

// MsgAutomatAttributes

// required .Common.AutomatId id = 1;
inline bool MsgAutomatAttributes::has_id() const {
  return _has_bit(0);
}
inline void MsgAutomatAttributes::clear_id() {
  if (id_ != NULL) id_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgAutomatAttributes::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::AutomatId* MsgAutomatAttributes::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::AutomatId;
  return id_;
}

// optional .Common.EnumAutomatMode etat_automate = 2;
inline bool MsgAutomatAttributes::has_etat_automate() const {
  return _has_bit(1);
}
inline void MsgAutomatAttributes::clear_etat_automate() {
  etat_automate_ = 0;
  _clear_bit(1);
}
inline Common::EnumAutomatMode MsgAutomatAttributes::etat_automate() const {
  return static_cast< Common::EnumAutomatMode >(etat_automate_);
}
inline void MsgAutomatAttributes::set_etat_automate(Common::EnumAutomatMode value) {
  GOOGLE_DCHECK(Common::EnumAutomatMode_IsValid(value));
  _set_bit(1);
  etat_automate_ = value;
}

// optional .MsgsSimToClient.ForceRatio.Value rapport_de_force = 3;
inline bool MsgAutomatAttributes::has_rapport_de_force() const {
  return _has_bit(2);
}
inline void MsgAutomatAttributes::clear_rapport_de_force() {
  rapport_de_force_ = 0;
  _clear_bit(2);
}
inline ::MsgsSimToClient::ForceRatio_Value MsgAutomatAttributes::rapport_de_force() const {
  return static_cast< ::MsgsSimToClient::ForceRatio_Value >(rapport_de_force_);
}
inline void MsgAutomatAttributes::set_rapport_de_force(::MsgsSimToClient::ForceRatio_Value value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ForceRatio_Value_IsValid(value));
  _set_bit(2);
  rapport_de_force_ = value;
}

// optional .Common.EnumMeetingEngagementStatus combat_de_rencontre = 4;
inline bool MsgAutomatAttributes::has_combat_de_rencontre() const {
  return _has_bit(3);
}
inline void MsgAutomatAttributes::clear_combat_de_rencontre() {
  combat_de_rencontre_ = 0;
  _clear_bit(3);
}
inline Common::EnumMeetingEngagementStatus MsgAutomatAttributes::combat_de_rencontre() const {
  return static_cast< Common::EnumMeetingEngagementStatus >(combat_de_rencontre_);
}
inline void MsgAutomatAttributes::set_combat_de_rencontre(Common::EnumMeetingEngagementStatus value) {
  GOOGLE_DCHECK(Common::EnumMeetingEngagementStatus_IsValid(value));
  _set_bit(3);
  combat_de_rencontre_ = value;
}

// optional .Common.EnumOperationalStatus etat_operationnel = 5;
inline bool MsgAutomatAttributes::has_etat_operationnel() const {
  return _has_bit(4);
}
inline void MsgAutomatAttributes::clear_etat_operationnel() {
  etat_operationnel_ = 0;
  _clear_bit(4);
}
inline Common::EnumOperationalStatus MsgAutomatAttributes::etat_operationnel() const {
  return static_cast< Common::EnumOperationalStatus >(etat_operationnel_);
}
inline void MsgAutomatAttributes::set_etat_operationnel(Common::EnumOperationalStatus value) {
  GOOGLE_DCHECK(Common::EnumOperationalStatus_IsValid(value));
  _set_bit(4);
  etat_operationnel_ = value;
}

// optional .MsgsSimToClient.RulesOfEngagement.Value roe = 6;
inline bool MsgAutomatAttributes::has_roe() const {
  return _has_bit(5);
}
inline void MsgAutomatAttributes::clear_roe() {
  roe_ = 0;
  _clear_bit(5);
}
inline ::MsgsSimToClient::RulesOfEngagement_Value MsgAutomatAttributes::roe() const {
  return static_cast< ::MsgsSimToClient::RulesOfEngagement_Value >(roe_);
}
inline void MsgAutomatAttributes::set_roe(::MsgsSimToClient::RulesOfEngagement_Value value) {
  GOOGLE_DCHECK(::MsgsSimToClient::RulesOfEngagement_Value_IsValid(value));
  _set_bit(5);
  roe_ = value;
}

// -------------------------------------------------------------------

// MsgUnitCreation

// required .Common.UnitId id = 1;
inline bool MsgUnitCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitCreation::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgUnitCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// required .Common.UnitType type = 2;
inline bool MsgUnitCreation::has_type() const {
  return _has_bit(1);
}
inline void MsgUnitCreation::clear_type() {
  if (type_ != NULL) type_->::Common::UnitType::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitType& MsgUnitCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::UnitType* MsgUnitCreation::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::UnitType;
  return type_;
}

// required string nom = 3;
inline bool MsgUnitCreation::has_nom() const {
  return _has_bit(2);
}
inline void MsgUnitCreation::clear_nom() {
  if (nom_ != &_default_nom_) {
    nom_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgUnitCreation::nom() const {
  return *nom_;
}
inline void MsgUnitCreation::set_nom(const ::std::string& value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgUnitCreation::set_nom(const char* value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgUnitCreation::set_nom(const char* value, size_t size) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgUnitCreation::mutable_nom() {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  return nom_;
}

// required .Common.AutomatId automat = 4;
inline bool MsgUnitCreation::has_automat() const {
  return _has_bit(3);
}
inline void MsgUnitCreation::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(3);
}
inline const ::Common::AutomatId& MsgUnitCreation::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* MsgUnitCreation::mutable_automat() {
  _set_bit(3);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// required bool pc = 5;
inline bool MsgUnitCreation::has_pc() const {
  return _has_bit(4);
}
inline void MsgUnitCreation::clear_pc() {
  pc_ = false;
  _clear_bit(4);
}
inline bool MsgUnitCreation::pc() const {
  return pc_;
}
inline void MsgUnitCreation::set_pc(bool value) {
  _set_bit(4);
  pc_ = value;
}

// -------------------------------------------------------------------

// BorrowedEquipments_BorrowedEquipment

// required .Common.UnitId owner = 1;
inline bool BorrowedEquipments_BorrowedEquipment::has_owner() const {
  return _has_bit(0);
}
inline void BorrowedEquipments_BorrowedEquipment::clear_owner() {
  if (owner_ != NULL) owner_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& BorrowedEquipments_BorrowedEquipment::owner() const {
  return owner_ != NULL ? *owner_ : *default_instance_->owner_;
}
inline ::Common::UnitId* BorrowedEquipments_BorrowedEquipment::mutable_owner() {
  _set_bit(0);
  if (owner_ == NULL) owner_ = new ::Common::UnitId;
  return owner_;
}

// required .Common.EquipmentType type = 2;
inline bool BorrowedEquipments_BorrowedEquipment::has_type() const {
  return _has_bit(1);
}
inline void BorrowedEquipments_BorrowedEquipment::clear_type() {
  if (type_ != NULL) type_->::Common::EquipmentType::Clear();
  _clear_bit(1);
}
inline const ::Common::EquipmentType& BorrowedEquipments_BorrowedEquipment::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::EquipmentType* BorrowedEquipments_BorrowedEquipment::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::EquipmentType;
  return type_;
}

// required int32 nombre = 3;
inline bool BorrowedEquipments_BorrowedEquipment::has_nombre() const {
  return _has_bit(2);
}
inline void BorrowedEquipments_BorrowedEquipment::clear_nombre() {
  nombre_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 BorrowedEquipments_BorrowedEquipment::nombre() const {
  return nombre_;
}
inline void BorrowedEquipments_BorrowedEquipment::set_nombre(::google::protobuf::int32 value) {
  _set_bit(2);
  nombre_ = value;
}

// -------------------------------------------------------------------

// BorrowedEquipments

// repeated .MsgsSimToClient.BorrowedEquipments.BorrowedEquipment elem = 1;
inline int BorrowedEquipments::elem_size() const {
  return elem_.size();
}
inline void BorrowedEquipments::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment >&
BorrowedEquipments::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment >*
BorrowedEquipments::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment& BorrowedEquipments::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment* BorrowedEquipments::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::BorrowedEquipments_BorrowedEquipment* BorrowedEquipments::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// LentEquipments_LentEquipment

// required .Common.UnitId borrower = 1;
inline bool LentEquipments_LentEquipment::has_borrower() const {
  return _has_bit(0);
}
inline void LentEquipments_LentEquipment::clear_borrower() {
  if (borrower_ != NULL) borrower_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& LentEquipments_LentEquipment::borrower() const {
  return borrower_ != NULL ? *borrower_ : *default_instance_->borrower_;
}
inline ::Common::UnitId* LentEquipments_LentEquipment::mutable_borrower() {
  _set_bit(0);
  if (borrower_ == NULL) borrower_ = new ::Common::UnitId;
  return borrower_;
}

// required .Common.EquipmentType type = 2;
inline bool LentEquipments_LentEquipment::has_type() const {
  return _has_bit(1);
}
inline void LentEquipments_LentEquipment::clear_type() {
  if (type_ != NULL) type_->::Common::EquipmentType::Clear();
  _clear_bit(1);
}
inline const ::Common::EquipmentType& LentEquipments_LentEquipment::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::EquipmentType* LentEquipments_LentEquipment::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::EquipmentType;
  return type_;
}

// required int32 nombre = 3;
inline bool LentEquipments_LentEquipment::has_nombre() const {
  return _has_bit(2);
}
inline void LentEquipments_LentEquipment::clear_nombre() {
  nombre_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 LentEquipments_LentEquipment::nombre() const {
  return nombre_;
}
inline void LentEquipments_LentEquipment::set_nombre(::google::protobuf::int32 value) {
  _set_bit(2);
  nombre_ = value;
}

// -------------------------------------------------------------------

// LentEquipments

// repeated .MsgsSimToClient.LentEquipments.LentEquipment elem = 1;
inline int LentEquipments::elem_size() const {
  return elem_.size();
}
inline void LentEquipments::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment >&
LentEquipments::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::LentEquipments_LentEquipment >*
LentEquipments::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::LentEquipments_LentEquipment& LentEquipments::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::LentEquipments_LentEquipment* LentEquipments::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::LentEquipments_LentEquipment* LentEquipments::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// ResourceDotations_ResourceDotation

// required .Common.ResourceType type = 1;
inline bool ResourceDotations_ResourceDotation::has_type() const {
  return _has_bit(0);
}
inline void ResourceDotations_ResourceDotation::clear_type() {
  if (type_ != NULL) type_->::Common::ResourceType::Clear();
  _clear_bit(0);
}
inline const ::Common::ResourceType& ResourceDotations_ResourceDotation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::ResourceType* ResourceDotations_ResourceDotation::mutable_type() {
  _set_bit(0);
  if (type_ == NULL) type_ = new ::Common::ResourceType;
  return type_;
}

// required int32 quantite_disponible = 2;
inline bool ResourceDotations_ResourceDotation::has_quantite_disponible() const {
  return _has_bit(1);
}
inline void ResourceDotations_ResourceDotation::clear_quantite_disponible() {
  quantite_disponible_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 ResourceDotations_ResourceDotation::quantite_disponible() const {
  return quantite_disponible_;
}
inline void ResourceDotations_ResourceDotation::set_quantite_disponible(::google::protobuf::int32 value) {
  _set_bit(1);
  quantite_disponible_ = value;
}

// -------------------------------------------------------------------

// ResourceDotations

// repeated .MsgsSimToClient.ResourceDotations.ResourceDotation elem = 1;
inline int ResourceDotations::elem_size() const {
  return elem_.size();
}
inline void ResourceDotations::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation >&
ResourceDotations::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::ResourceDotations_ResourceDotation >*
ResourceDotations::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::ResourceDotations_ResourceDotation& ResourceDotations::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::ResourceDotations_ResourceDotation* ResourceDotations::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::ResourceDotations_ResourceDotation* ResourceDotations::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// EquipmentDotations_EquipmentDotation

// required .Common.EquipmentType type = 1;
inline bool EquipmentDotations_EquipmentDotation::has_type() const {
  return _has_bit(0);
}
inline void EquipmentDotations_EquipmentDotation::clear_type() {
  if (type_ != NULL) type_->::Common::EquipmentType::Clear();
  _clear_bit(0);
}
inline const ::Common::EquipmentType& EquipmentDotations_EquipmentDotation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::EquipmentType* EquipmentDotations_EquipmentDotation::mutable_type() {
  _set_bit(0);
  if (type_ == NULL) type_ = new ::Common::EquipmentType;
  return type_;
}

// required int32 nb_disponibles = 2;
inline bool EquipmentDotations_EquipmentDotation::has_nb_disponibles() const {
  return _has_bit(1);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_disponibles() {
  nb_disponibles_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_disponibles() const {
  return nb_disponibles_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_disponibles(::google::protobuf::int32 value) {
  _set_bit(1);
  nb_disponibles_ = value;
}

// required int32 nb_indisponibles = 3;
inline bool EquipmentDotations_EquipmentDotation::has_nb_indisponibles() const {
  return _has_bit(2);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_indisponibles() {
  nb_indisponibles_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_indisponibles() const {
  return nb_indisponibles_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_indisponibles(::google::protobuf::int32 value) {
  _set_bit(2);
  nb_indisponibles_ = value;
}

// required int32 nb_reparables = 4;
inline bool EquipmentDotations_EquipmentDotation::has_nb_reparables() const {
  return _has_bit(3);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_reparables() {
  nb_reparables_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_reparables() const {
  return nb_reparables_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_reparables(::google::protobuf::int32 value) {
  _set_bit(3);
  nb_reparables_ = value;
}

// required int32 nb_dans_chaine_maintenance = 5;
inline bool EquipmentDotations_EquipmentDotation::has_nb_dans_chaine_maintenance() const {
  return _has_bit(4);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_dans_chaine_maintenance() {
  nb_dans_chaine_maintenance_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_dans_chaine_maintenance() const {
  return nb_dans_chaine_maintenance_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_dans_chaine_maintenance(::google::protobuf::int32 value) {
  _set_bit(4);
  nb_dans_chaine_maintenance_ = value;
}

// required int32 nb_prisonniers = 6;
inline bool EquipmentDotations_EquipmentDotation::has_nb_prisonniers() const {
  return _has_bit(5);
}
inline void EquipmentDotations_EquipmentDotation::clear_nb_prisonniers() {
  nb_prisonniers_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 EquipmentDotations_EquipmentDotation::nb_prisonniers() const {
  return nb_prisonniers_;
}
inline void EquipmentDotations_EquipmentDotation::set_nb_prisonniers(::google::protobuf::int32 value) {
  _set_bit(5);
  nb_prisonniers_ = value;
}

// -------------------------------------------------------------------

// EquipmentDotations

// repeated .MsgsSimToClient.EquipmentDotations.EquipmentDotation elem = 1;
inline int EquipmentDotations::elem_size() const {
  return elem_.size();
}
inline void EquipmentDotations::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation >&
EquipmentDotations::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::EquipmentDotations_EquipmentDotation >*
EquipmentDotations::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::EquipmentDotations_EquipmentDotation& EquipmentDotations::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::EquipmentDotations_EquipmentDotation* EquipmentDotations::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::EquipmentDotations_EquipmentDotation* EquipmentDotations::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// HumanDotations_HumanDotation

// required .Common.EnumHumanRank rang = 1;
inline bool HumanDotations_HumanDotation::has_rang() const {
  return _has_bit(0);
}
inline void HumanDotations_HumanDotation::clear_rang() {
  rang_ = 0;
  _clear_bit(0);
}
inline Common::EnumHumanRank HumanDotations_HumanDotation::rang() const {
  return static_cast< Common::EnumHumanRank >(rang_);
}
inline void HumanDotations_HumanDotation::set_rang(Common::EnumHumanRank value) {
  GOOGLE_DCHECK(Common::EnumHumanRank_IsValid(value));
  _set_bit(0);
  rang_ = value;
}

// required int32 nb_total = 2;
inline bool HumanDotations_HumanDotation::has_nb_total() const {
  return _has_bit(1);
}
inline void HumanDotations_HumanDotation::clear_nb_total() {
  nb_total_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_total() const {
  return nb_total_;
}
inline void HumanDotations_HumanDotation::set_nb_total(::google::protobuf::int32 value) {
  _set_bit(1);
  nb_total_ = value;
}

// required int32 nb_operationnels = 3;
inline bool HumanDotations_HumanDotation::has_nb_operationnels() const {
  return _has_bit(2);
}
inline void HumanDotations_HumanDotation::clear_nb_operationnels() {
  nb_operationnels_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_operationnels() const {
  return nb_operationnels_;
}
inline void HumanDotations_HumanDotation::set_nb_operationnels(::google::protobuf::int32 value) {
  _set_bit(2);
  nb_operationnels_ = value;
}

// required int32 nb_morts = 4;
inline bool HumanDotations_HumanDotation::has_nb_morts() const {
  return _has_bit(3);
}
inline void HumanDotations_HumanDotation::clear_nb_morts() {
  nb_morts_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_morts() const {
  return nb_morts_;
}
inline void HumanDotations_HumanDotation::set_nb_morts(::google::protobuf::int32 value) {
  _set_bit(3);
  nb_morts_ = value;
}

// required int32 nb_blesses = 5;
inline bool HumanDotations_HumanDotation::has_nb_blesses() const {
  return _has_bit(4);
}
inline void HumanDotations_HumanDotation::clear_nb_blesses() {
  nb_blesses_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_blesses() const {
  return nb_blesses_;
}
inline void HumanDotations_HumanDotation::set_nb_blesses(::google::protobuf::int32 value) {
  _set_bit(4);
  nb_blesses_ = value;
}

// required int32 nb_blesses_mentaux = 6;
inline bool HumanDotations_HumanDotation::has_nb_blesses_mentaux() const {
  return _has_bit(5);
}
inline void HumanDotations_HumanDotation::clear_nb_blesses_mentaux() {
  nb_blesses_mentaux_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_blesses_mentaux() const {
  return nb_blesses_mentaux_;
}
inline void HumanDotations_HumanDotation::set_nb_blesses_mentaux(::google::protobuf::int32 value) {
  _set_bit(5);
  nb_blesses_mentaux_ = value;
}

// required int32 nb_contamines_nbc = 7;
inline bool HumanDotations_HumanDotation::has_nb_contamines_nbc() const {
  return _has_bit(6);
}
inline void HumanDotations_HumanDotation::clear_nb_contamines_nbc() {
  nb_contamines_nbc_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_contamines_nbc() const {
  return nb_contamines_nbc_;
}
inline void HumanDotations_HumanDotation::set_nb_contamines_nbc(::google::protobuf::int32 value) {
  _set_bit(6);
  nb_contamines_nbc_ = value;
}

// required int32 nb_dans_chaine_sante = 8;
inline bool HumanDotations_HumanDotation::has_nb_dans_chaine_sante() const {
  return _has_bit(7);
}
inline void HumanDotations_HumanDotation::clear_nb_dans_chaine_sante() {
  nb_dans_chaine_sante_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_dans_chaine_sante() const {
  return nb_dans_chaine_sante_;
}
inline void HumanDotations_HumanDotation::set_nb_dans_chaine_sante(::google::protobuf::int32 value) {
  _set_bit(7);
  nb_dans_chaine_sante_ = value;
}

// required int32 nb_utilises_pour_maintenance = 9;
inline bool HumanDotations_HumanDotation::has_nb_utilises_pour_maintenance() const {
  return _has_bit(8);
}
inline void HumanDotations_HumanDotation::clear_nb_utilises_pour_maintenance() {
  nb_utilises_pour_maintenance_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 HumanDotations_HumanDotation::nb_utilises_pour_maintenance() const {
  return nb_utilises_pour_maintenance_;
}
inline void HumanDotations_HumanDotation::set_nb_utilises_pour_maintenance(::google::protobuf::int32 value) {
  _set_bit(8);
  nb_utilises_pour_maintenance_ = value;
}

// -------------------------------------------------------------------

// HumanDotations

// repeated .MsgsSimToClient.HumanDotations.HumanDotation elem = 1;
inline int HumanDotations::elem_size() const {
  return elem_.size();
}
inline void HumanDotations::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation >&
HumanDotations::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::HumanDotations_HumanDotation >*
HumanDotations::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::HumanDotations_HumanDotation& HumanDotations::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::HumanDotations_HumanDotation* HumanDotations::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::HumanDotations_HumanDotation* HumanDotations::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// ContaminationState

// optional int32 percentage = 1;
inline bool ContaminationState::has_percentage() const {
  return _has_bit(0);
}
inline void ContaminationState::clear_percentage() {
  percentage_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ContaminationState::percentage() const {
  return percentage_;
}
inline void ContaminationState::set_percentage(::google::protobuf::int32 value) {
  _set_bit(0);
  percentage_ = value;
}

// optional float quantity = 2;
inline bool ContaminationState::has_quantity() const {
  return _has_bit(1);
}
inline void ContaminationState::clear_quantity() {
  quantity_ = 0;
  _clear_bit(1);
}
inline float ContaminationState::quantity() const {
  return quantity_;
}
inline void ContaminationState::set_quantity(float value) {
  _set_bit(1);
  quantity_ = value;
}

// -------------------------------------------------------------------

// NBCAgents

// repeated .Common.NBCAgentType elem = 1;
inline int NBCAgents::elem_size() const {
  return elem_.size();
}
inline void NBCAgents::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType >&
NBCAgents::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NBCAgentType >*
NBCAgents::mutable_elem() {
  return &elem_;
}
inline const ::Common::NBCAgentType& NBCAgents::elem(int index) const {
  return elem_.Get(index);
}
inline ::Common::NBCAgentType* NBCAgents::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::Common::NBCAgentType* NBCAgents::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// Communication

// optional bool jammed = 1 [default = false];
inline bool Communication::has_jammed() const {
  return _has_bit(0);
}
inline void Communication::clear_jammed() {
  jammed_ = false;
  _clear_bit(0);
}
inline bool Communication::jammed() const {
  return jammed_;
}
inline void Communication::set_jammed(bool value) {
  _set_bit(0);
  jammed_ = value;
}

// optional .Common.KnowledgeGroupId knowledge_group = 2;
inline bool Communication::has_knowledge_group() const {
  return _has_bit(1);
}
inline void Communication::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& Communication::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* Communication::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgUnitAttributes

// required .Common.UnitId id = 1;
inline bool MsgUnitAttributes::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitAttributes::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitAttributes::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgUnitAttributes::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// optional .MsgsSimToClient.HumanDotations dotation_eff_personnel = 2;
inline bool MsgUnitAttributes::has_dotation_eff_personnel() const {
  return _has_bit(1);
}
inline void MsgUnitAttributes::clear_dotation_eff_personnel() {
  if (dotation_eff_personnel_ != NULL) dotation_eff_personnel_->::MsgsSimToClient::HumanDotations::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::HumanDotations& MsgUnitAttributes::dotation_eff_personnel() const {
  return dotation_eff_personnel_ != NULL ? *dotation_eff_personnel_ : *default_instance_->dotation_eff_personnel_;
}
inline ::MsgsSimToClient::HumanDotations* MsgUnitAttributes::mutable_dotation_eff_personnel() {
  _set_bit(1);
  if (dotation_eff_personnel_ == NULL) dotation_eff_personnel_ = new ::MsgsSimToClient::HumanDotations;
  return dotation_eff_personnel_;
}

// optional .MsgsSimToClient.EquipmentDotations dotation_eff_materiel = 3;
inline bool MsgUnitAttributes::has_dotation_eff_materiel() const {
  return _has_bit(2);
}
inline void MsgUnitAttributes::clear_dotation_eff_materiel() {
  if (dotation_eff_materiel_ != NULL) dotation_eff_materiel_->::MsgsSimToClient::EquipmentDotations::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::EquipmentDotations& MsgUnitAttributes::dotation_eff_materiel() const {
  return dotation_eff_materiel_ != NULL ? *dotation_eff_materiel_ : *default_instance_->dotation_eff_materiel_;
}
inline ::MsgsSimToClient::EquipmentDotations* MsgUnitAttributes::mutable_dotation_eff_materiel() {
  _set_bit(2);
  if (dotation_eff_materiel_ == NULL) dotation_eff_materiel_ = new ::MsgsSimToClient::EquipmentDotations;
  return dotation_eff_materiel_;
}

// optional .MsgsSimToClient.ResourceDotations dotation_eff_ressource = 4;
inline bool MsgUnitAttributes::has_dotation_eff_ressource() const {
  return _has_bit(3);
}
inline void MsgUnitAttributes::clear_dotation_eff_ressource() {
  if (dotation_eff_ressource_ != NULL) dotation_eff_ressource_->::MsgsSimToClient::ResourceDotations::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::ResourceDotations& MsgUnitAttributes::dotation_eff_ressource() const {
  return dotation_eff_ressource_ != NULL ? *dotation_eff_ressource_ : *default_instance_->dotation_eff_ressource_;
}
inline ::MsgsSimToClient::ResourceDotations* MsgUnitAttributes::mutable_dotation_eff_ressource() {
  _set_bit(3);
  if (dotation_eff_ressource_ == NULL) dotation_eff_ressource_ = new ::MsgsSimToClient::ResourceDotations;
  return dotation_eff_ressource_;
}

// optional .MsgsSimToClient.LentEquipments equipements_pretes = 5;
inline bool MsgUnitAttributes::has_equipements_pretes() const {
  return _has_bit(4);
}
inline void MsgUnitAttributes::clear_equipements_pretes() {
  if (equipements_pretes_ != NULL) equipements_pretes_->::MsgsSimToClient::LentEquipments::Clear();
  _clear_bit(4);
}
inline const ::MsgsSimToClient::LentEquipments& MsgUnitAttributes::equipements_pretes() const {
  return equipements_pretes_ != NULL ? *equipements_pretes_ : *default_instance_->equipements_pretes_;
}
inline ::MsgsSimToClient::LentEquipments* MsgUnitAttributes::mutable_equipements_pretes() {
  _set_bit(4);
  if (equipements_pretes_ == NULL) equipements_pretes_ = new ::MsgsSimToClient::LentEquipments;
  return equipements_pretes_;
}

// optional .MsgsSimToClient.BorrowedEquipments equipements_empruntes = 6;
inline bool MsgUnitAttributes::has_equipements_empruntes() const {
  return _has_bit(5);
}
inline void MsgUnitAttributes::clear_equipements_empruntes() {
  if (equipements_empruntes_ != NULL) equipements_empruntes_->::MsgsSimToClient::BorrowedEquipments::Clear();
  _clear_bit(5);
}
inline const ::MsgsSimToClient::BorrowedEquipments& MsgUnitAttributes::equipements_empruntes() const {
  return equipements_empruntes_ != NULL ? *equipements_empruntes_ : *default_instance_->equipements_empruntes_;
}
inline ::MsgsSimToClient::BorrowedEquipments* MsgUnitAttributes::mutable_equipements_empruntes() {
  _set_bit(5);
  if (equipements_empruntes_ == NULL) equipements_empruntes_ = new ::MsgsSimToClient::BorrowedEquipments;
  return equipements_empruntes_;
}

// optional .Common.MsgCoordLatLong position = 7;
inline bool MsgUnitAttributes::has_position() const {
  return _has_bit(6);
}
inline void MsgUnitAttributes::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(6);
}
inline const ::Common::MsgCoordLatLong& MsgUnitAttributes::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgUnitAttributes::mutable_position() {
  _set_bit(6);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// optional .Common.MsgHeading direction = 8;
inline bool MsgUnitAttributes::has_direction() const {
  return _has_bit(7);
}
inline void MsgUnitAttributes::clear_direction() {
  if (direction_ != NULL) direction_->::Common::MsgHeading::Clear();
  _clear_bit(7);
}
inline const ::Common::MsgHeading& MsgUnitAttributes::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Common::MsgHeading* MsgUnitAttributes::mutable_direction() {
  _set_bit(7);
  if (direction_ == NULL) direction_ = new ::Common::MsgHeading;
  return direction_;
}

// optional int32 hauteur = 9 [default = 0];
inline bool MsgUnitAttributes::has_hauteur() const {
  return _has_bit(8);
}
inline void MsgUnitAttributes::clear_hauteur() {
  hauteur_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 MsgUnitAttributes::hauteur() const {
  return hauteur_;
}
inline void MsgUnitAttributes::set_hauteur(::google::protobuf::int32 value) {
  _set_bit(8);
  hauteur_ = value;
}

// optional int32 altitude = 10 [default = 0];
inline bool MsgUnitAttributes::has_altitude() const {
  return _has_bit(9);
}
inline void MsgUnitAttributes::clear_altitude() {
  altitude_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 MsgUnitAttributes::altitude() const {
  return altitude_;
}
inline void MsgUnitAttributes::set_altitude(::google::protobuf::int32 value) {
  _set_bit(9);
  altitude_ = value;
}

// optional int32 vitesse = 11 [default = 0];
inline bool MsgUnitAttributes::has_vitesse() const {
  return _has_bit(10);
}
inline void MsgUnitAttributes::clear_vitesse() {
  vitesse_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 MsgUnitAttributes::vitesse() const {
  return vitesse_;
}
inline void MsgUnitAttributes::set_vitesse(::google::protobuf::int32 value) {
  _set_bit(10);
  vitesse_ = value;
}

// optional int32 etat_operationnel_brut = 12 [default = 0];
inline bool MsgUnitAttributes::has_etat_operationnel_brut() const {
  return _has_bit(11);
}
inline void MsgUnitAttributes::clear_etat_operationnel_brut() {
  etat_operationnel_brut_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 MsgUnitAttributes::etat_operationnel_brut() const {
  return etat_operationnel_brut_;
}
inline void MsgUnitAttributes::set_etat_operationnel_brut(::google::protobuf::int32 value) {
  _set_bit(11);
  etat_operationnel_brut_ = value;
}

// optional .Common.UnitIdList reinforcements = 13;
inline bool MsgUnitAttributes::has_reinforcements() const {
  return _has_bit(12);
}
inline void MsgUnitAttributes::clear_reinforcements() {
  if (reinforcements_ != NULL) reinforcements_->::Common::UnitIdList::Clear();
  _clear_bit(12);
}
inline const ::Common::UnitIdList& MsgUnitAttributes::reinforcements() const {
  return reinforcements_ != NULL ? *reinforcements_ : *default_instance_->reinforcements_;
}
inline ::Common::UnitIdList* MsgUnitAttributes::mutable_reinforcements() {
  _set_bit(12);
  if (reinforcements_ == NULL) reinforcements_ = new ::Common::UnitIdList;
  return reinforcements_;
}

// optional .Common.UnitId reinforced_unit = 14;
inline bool MsgUnitAttributes::has_reinforced_unit() const {
  return _has_bit(13);
}
inline void MsgUnitAttributes::clear_reinforced_unit() {
  if (reinforced_unit_ != NULL) reinforced_unit_->::Common::UnitId::Clear();
  _clear_bit(13);
}
inline const ::Common::UnitId& MsgUnitAttributes::reinforced_unit() const {
  return reinforced_unit_ != NULL ? *reinforced_unit_ : *default_instance_->reinforced_unit_;
}
inline ::Common::UnitId* MsgUnitAttributes::mutable_reinforced_unit() {
  _set_bit(13);
  if (reinforced_unit_ == NULL) reinforced_unit_ = new ::Common::UnitId;
  return reinforced_unit_;
}

// optional bool mort = 15 [default = false];
inline bool MsgUnitAttributes::has_mort() const {
  return _has_bit(14);
}
inline void MsgUnitAttributes::clear_mort() {
  mort_ = false;
  _clear_bit(14);
}
inline bool MsgUnitAttributes::mort() const {
  return mort_;
}
inline void MsgUnitAttributes::set_mort(bool value) {
  _set_bit(14);
  mort_ = value;
}

// optional bool neutralise = 16 [default = false];
inline bool MsgUnitAttributes::has_neutralise() const {
  return _has_bit(15);
}
inline void MsgUnitAttributes::clear_neutralise() {
  neutralise_ = false;
  _clear_bit(15);
}
inline bool MsgUnitAttributes::neutralise() const {
  return neutralise_;
}
inline void MsgUnitAttributes::set_neutralise(bool value) {
  _set_bit(15);
  neutralise_ = value;
}

// optional bool mode_furtif_actif = 17 [default = false];
inline bool MsgUnitAttributes::has_mode_furtif_actif() const {
  return _has_bit(16);
}
inline void MsgUnitAttributes::clear_mode_furtif_actif() {
  mode_furtif_actif_ = false;
  _clear_bit(16);
}
inline bool MsgUnitAttributes::mode_furtif_actif() const {
  return mode_furtif_actif_;
}
inline void MsgUnitAttributes::set_mode_furtif_actif(bool value) {
  _set_bit(16);
  mode_furtif_actif_ = value;
}

// optional bool embarque = 18 [default = false];
inline bool MsgUnitAttributes::has_embarque() const {
  return _has_bit(17);
}
inline void MsgUnitAttributes::clear_embarque() {
  embarque_ = false;
  _clear_bit(17);
}
inline bool MsgUnitAttributes::embarque() const {
  return embarque_;
}
inline void MsgUnitAttributes::set_embarque(bool value) {
  _set_bit(17);
  embarque_ = value;
}

// optional bool transporteurs_disponibles = 19 [default = false];
inline bool MsgUnitAttributes::has_transporteurs_disponibles() const {
  return _has_bit(18);
}
inline void MsgUnitAttributes::clear_transporteurs_disponibles() {
  transporteurs_disponibles_ = false;
  _clear_bit(18);
}
inline bool MsgUnitAttributes::transporteurs_disponibles() const {
  return transporteurs_disponibles_;
}
inline void MsgUnitAttributes::set_transporteurs_disponibles(bool value) {
  _set_bit(18);
  transporteurs_disponibles_ = value;
}

// optional .MsgsSimToClient.MsgUnitAttributes.Posture posture_old = 20;
inline bool MsgUnitAttributes::has_posture_old() const {
  return _has_bit(19);
}
inline void MsgUnitAttributes::clear_posture_old() {
  posture_old_ = 0;
  _clear_bit(19);
}
inline ::MsgsSimToClient::MsgUnitAttributes_Posture MsgUnitAttributes::posture_old() const {
  return static_cast< ::MsgsSimToClient::MsgUnitAttributes_Posture >(posture_old_);
}
inline void MsgUnitAttributes::set_posture_old(::MsgsSimToClient::MsgUnitAttributes_Posture value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUnitAttributes_Posture_IsValid(value));
  _set_bit(19);
  posture_old_ = value;
}

// optional .MsgsSimToClient.MsgUnitAttributes.Posture posture_new = 21;
inline bool MsgUnitAttributes::has_posture_new() const {
  return _has_bit(20);
}
inline void MsgUnitAttributes::clear_posture_new() {
  posture_new_ = 0;
  _clear_bit(20);
}
inline ::MsgsSimToClient::MsgUnitAttributes_Posture MsgUnitAttributes::posture_new() const {
  return static_cast< ::MsgsSimToClient::MsgUnitAttributes_Posture >(posture_new_);
}
inline void MsgUnitAttributes::set_posture_new(::MsgsSimToClient::MsgUnitAttributes_Posture value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUnitAttributes_Posture_IsValid(value));
  _set_bit(20);
  posture_new_ = value;
}

// optional int32 posture_pourcentage = 22 [default = 0];
inline bool MsgUnitAttributes::has_posture_pourcentage() const {
  return _has_bit(21);
}
inline void MsgUnitAttributes::clear_posture_pourcentage() {
  posture_pourcentage_ = 0;
  _clear_bit(21);
}
inline ::google::protobuf::int32 MsgUnitAttributes::posture_pourcentage() const {
  return posture_pourcentage_;
}
inline void MsgUnitAttributes::set_posture_pourcentage(::google::protobuf::int32 value) {
  _set_bit(21);
  posture_pourcentage_ = value;
}

// optional int32 etat_installation = 23 [default = 0];
inline bool MsgUnitAttributes::has_etat_installation() const {
  return _has_bit(22);
}
inline void MsgUnitAttributes::clear_etat_installation() {
  etat_installation_ = 0;
  _clear_bit(22);
}
inline ::google::protobuf::int32 MsgUnitAttributes::etat_installation() const {
  return etat_installation_;
}
inline void MsgUnitAttributes::set_etat_installation(::google::protobuf::int32 value) {
  _set_bit(22);
  etat_installation_ = value;
}

// optional bool en_tenue_de_protection_nbc = 24 [default = false];
inline bool MsgUnitAttributes::has_en_tenue_de_protection_nbc() const {
  return _has_bit(23);
}
inline void MsgUnitAttributes::clear_en_tenue_de_protection_nbc() {
  en_tenue_de_protection_nbc_ = false;
  _clear_bit(23);
}
inline bool MsgUnitAttributes::en_tenue_de_protection_nbc() const {
  return en_tenue_de_protection_nbc_;
}
inline void MsgUnitAttributes::set_en_tenue_de_protection_nbc(bool value) {
  _set_bit(23);
  en_tenue_de_protection_nbc_ = value;
}

// optional .MsgsSimToClient.NBCAgents contamine_par_agents_nbc = 25;
inline bool MsgUnitAttributes::has_contamine_par_agents_nbc() const {
  return _has_bit(24);
}
inline void MsgUnitAttributes::clear_contamine_par_agents_nbc() {
  if (contamine_par_agents_nbc_ != NULL) contamine_par_agents_nbc_->::MsgsSimToClient::NBCAgents::Clear();
  _clear_bit(24);
}
inline const ::MsgsSimToClient::NBCAgents& MsgUnitAttributes::contamine_par_agents_nbc() const {
  return contamine_par_agents_nbc_ != NULL ? *contamine_par_agents_nbc_ : *default_instance_->contamine_par_agents_nbc_;
}
inline ::MsgsSimToClient::NBCAgents* MsgUnitAttributes::mutable_contamine_par_agents_nbc() {
  _set_bit(24);
  if (contamine_par_agents_nbc_ == NULL) contamine_par_agents_nbc_ = new ::MsgsSimToClient::NBCAgents;
  return contamine_par_agents_nbc_;
}

// optional .MsgsSimToClient.ContaminationState etat_contamination = 26;
inline bool MsgUnitAttributes::has_etat_contamination() const {
  return _has_bit(25);
}
inline void MsgUnitAttributes::clear_etat_contamination() {
  if (etat_contamination_ != NULL) etat_contamination_->::MsgsSimToClient::ContaminationState::Clear();
  _clear_bit(25);
}
inline const ::MsgsSimToClient::ContaminationState& MsgUnitAttributes::etat_contamination() const {
  return etat_contamination_ != NULL ? *etat_contamination_ : *default_instance_->etat_contamination_;
}
inline ::MsgsSimToClient::ContaminationState* MsgUnitAttributes::mutable_etat_contamination() {
  _set_bit(25);
  if (etat_contamination_ == NULL) etat_contamination_ = new ::MsgsSimToClient::ContaminationState;
  return etat_contamination_;
}

// optional .MsgsSimToClient.Communication communications = 27;
inline bool MsgUnitAttributes::has_communications() const {
  return _has_bit(26);
}
inline void MsgUnitAttributes::clear_communications() {
  if (communications_ != NULL) communications_->::MsgsSimToClient::Communication::Clear();
  _clear_bit(26);
}
inline const ::MsgsSimToClient::Communication& MsgUnitAttributes::communications() const {
  return communications_ != NULL ? *communications_ : *default_instance_->communications_;
}
inline ::MsgsSimToClient::Communication* MsgUnitAttributes::mutable_communications() {
  _set_bit(26);
  if (communications_ == NULL) communications_ = new ::MsgsSimToClient::Communication;
  return communications_;
}

// optional bool radio_emitter_disabled = 28 [default = true];
inline bool MsgUnitAttributes::has_radio_emitter_disabled() const {
  return _has_bit(27);
}
inline void MsgUnitAttributes::clear_radio_emitter_disabled() {
  radio_emitter_disabled_ = true;
  _clear_bit(27);
}
inline bool MsgUnitAttributes::radio_emitter_disabled() const {
  return radio_emitter_disabled_;
}
inline void MsgUnitAttributes::set_radio_emitter_disabled(bool value) {
  _set_bit(27);
  radio_emitter_disabled_ = value;
}

// optional bool radio_receiver_disabled = 29 [default = true];
inline bool MsgUnitAttributes::has_radio_receiver_disabled() const {
  return _has_bit(28);
}
inline void MsgUnitAttributes::clear_radio_receiver_disabled() {
  radio_receiver_disabled_ = true;
  _clear_bit(28);
}
inline bool MsgUnitAttributes::radio_receiver_disabled() const {
  return radio_receiver_disabled_;
}
inline void MsgUnitAttributes::set_radio_receiver_disabled(bool value) {
  _set_bit(28);
  radio_receiver_disabled_ = value;
}

// optional bool radar_actif = 30 [default = false];
inline bool MsgUnitAttributes::has_radar_actif() const {
  return _has_bit(29);
}
inline void MsgUnitAttributes::clear_radar_actif() {
  radar_actif_ = false;
  _clear_bit(29);
}
inline bool MsgUnitAttributes::radar_actif() const {
  return radar_actif_;
}
inline void MsgUnitAttributes::set_radar_actif(bool value) {
  _set_bit(29);
  radar_actif_ = value;
}

// optional .Common.UnitIdList transported_units = 31;
inline bool MsgUnitAttributes::has_transported_units() const {
  return _has_bit(30);
}
inline void MsgUnitAttributes::clear_transported_units() {
  if (transported_units_ != NULL) transported_units_->::Common::UnitIdList::Clear();
  _clear_bit(30);
}
inline const ::Common::UnitIdList& MsgUnitAttributes::transported_units() const {
  return transported_units_ != NULL ? *transported_units_ : *default_instance_->transported_units_;
}
inline ::Common::UnitIdList* MsgUnitAttributes::mutable_transported_units() {
  _set_bit(30);
  if (transported_units_ == NULL) transported_units_ = new ::Common::UnitIdList;
  return transported_units_;
}

// optional .Common.UnitId transporting_unit = 32;
inline bool MsgUnitAttributes::has_transporting_unit() const {
  return _has_bit(31);
}
inline void MsgUnitAttributes::clear_transporting_unit() {
  if (transporting_unit_ != NULL) transporting_unit_->::Common::UnitId::Clear();
  _clear_bit(31);
}
inline const ::Common::UnitId& MsgUnitAttributes::transporting_unit() const {
  return transporting_unit_ != NULL ? *transporting_unit_ : *default_instance_->transporting_unit_;
}
inline ::Common::UnitId* MsgUnitAttributes::mutable_transporting_unit() {
  _set_bit(31);
  if (transporting_unit_ == NULL) transporting_unit_ = new ::Common::UnitId;
  return transporting_unit_;
}

// optional .MsgsSimToClient.ForceRatio.Value rapport_de_force = 33;
inline bool MsgUnitAttributes::has_rapport_de_force() const {
  return _has_bit(32);
}
inline void MsgUnitAttributes::clear_rapport_de_force() {
  rapport_de_force_ = 0;
  _clear_bit(32);
}
inline ::MsgsSimToClient::ForceRatio_Value MsgUnitAttributes::rapport_de_force() const {
  return static_cast< ::MsgsSimToClient::ForceRatio_Value >(rapport_de_force_);
}
inline void MsgUnitAttributes::set_rapport_de_force(::MsgsSimToClient::ForceRatio_Value value) {
  GOOGLE_DCHECK(::MsgsSimToClient::ForceRatio_Value_IsValid(value));
  _set_bit(32);
  rapport_de_force_ = value;
}

// optional .Common.EnumMeetingEngagementStatus combat_de_rencontre = 34;
inline bool MsgUnitAttributes::has_combat_de_rencontre() const {
  return _has_bit(33);
}
inline void MsgUnitAttributes::clear_combat_de_rencontre() {
  combat_de_rencontre_ = 0;
  _clear_bit(33);
}
inline Common::EnumMeetingEngagementStatus MsgUnitAttributes::combat_de_rencontre() const {
  return static_cast< Common::EnumMeetingEngagementStatus >(combat_de_rencontre_);
}
inline void MsgUnitAttributes::set_combat_de_rencontre(Common::EnumMeetingEngagementStatus value) {
  GOOGLE_DCHECK(Common::EnumMeetingEngagementStatus_IsValid(value));
  _set_bit(33);
  combat_de_rencontre_ = value;
}

// optional .Common.EnumOperationalStatus etat_operationnel = 35;
inline bool MsgUnitAttributes::has_etat_operationnel() const {
  return _has_bit(34);
}
inline void MsgUnitAttributes::clear_etat_operationnel() {
  etat_operationnel_ = 0;
  _clear_bit(34);
}
inline Common::EnumOperationalStatus MsgUnitAttributes::etat_operationnel() const {
  return static_cast< Common::EnumOperationalStatus >(etat_operationnel_);
}
inline void MsgUnitAttributes::set_etat_operationnel(Common::EnumOperationalStatus value) {
  GOOGLE_DCHECK(Common::EnumOperationalStatus_IsValid(value));
  _set_bit(34);
  etat_operationnel_ = value;
}

// optional .MsgsSimToClient.MsgUnitAttributes.FireAvailability disponibilite_au_tir_indirect = 36;
inline bool MsgUnitAttributes::has_disponibilite_au_tir_indirect() const {
  return _has_bit(35);
}
inline void MsgUnitAttributes::clear_disponibilite_au_tir_indirect() {
  disponibilite_au_tir_indirect_ = 0;
  _clear_bit(35);
}
inline ::MsgsSimToClient::MsgUnitAttributes_FireAvailability MsgUnitAttributes::disponibilite_au_tir_indirect() const {
  return static_cast< ::MsgsSimToClient::MsgUnitAttributes_FireAvailability >(disponibilite_au_tir_indirect_);
}
inline void MsgUnitAttributes::set_disponibilite_au_tir_indirect(::MsgsSimToClient::MsgUnitAttributes_FireAvailability value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUnitAttributes_FireAvailability_IsValid(value));
  _set_bit(35);
  disponibilite_au_tir_indirect_ = value;
}

// optional .MsgsSimToClient.RulesOfEngagement.Value roe = 37;
inline bool MsgUnitAttributes::has_roe() const {
  return _has_bit(36);
}
inline void MsgUnitAttributes::clear_roe() {
  roe_ = 0;
  _clear_bit(36);
}
inline ::MsgsSimToClient::RulesOfEngagement_Value MsgUnitAttributes::roe() const {
  return static_cast< ::MsgsSimToClient::RulesOfEngagement_Value >(roe_);
}
inline void MsgUnitAttributes::set_roe(::MsgsSimToClient::RulesOfEngagement_Value value) {
  GOOGLE_DCHECK(::MsgsSimToClient::RulesOfEngagement_Value_IsValid(value));
  _set_bit(36);
  roe_ = value;
}

// optional .MsgsSimToClient.MsgUnitAttributes.PopulationRoe roe_population = 38;
inline bool MsgUnitAttributes::has_roe_population() const {
  return _has_bit(37);
}
inline void MsgUnitAttributes::clear_roe_population() {
  roe_population_ = 0;
  _clear_bit(37);
}
inline ::MsgsSimToClient::MsgUnitAttributes_PopulationRoe MsgUnitAttributes::roe_population() const {
  return static_cast< ::MsgsSimToClient::MsgUnitAttributes_PopulationRoe >(roe_population_);
}
inline void MsgUnitAttributes::set_roe_population(::MsgsSimToClient::MsgUnitAttributes_PopulationRoe value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUnitAttributes_PopulationRoe_IsValid(value));
  _set_bit(37);
  roe_population_ = value;
}

// optional .Common.EnumUnitTiredness fatigue = 39;
inline bool MsgUnitAttributes::has_fatigue() const {
  return _has_bit(38);
}
inline void MsgUnitAttributes::clear_fatigue() {
  fatigue_ = 0;
  _clear_bit(38);
}
inline Common::EnumUnitTiredness MsgUnitAttributes::fatigue() const {
  return static_cast< Common::EnumUnitTiredness >(fatigue_);
}
inline void MsgUnitAttributes::set_fatigue(Common::EnumUnitTiredness value) {
  GOOGLE_DCHECK(Common::EnumUnitTiredness_IsValid(value));
  _set_bit(38);
  fatigue_ = value;
}

// optional .Common.EnumUnitMorale moral = 40;
inline bool MsgUnitAttributes::has_moral() const {
  return _has_bit(39);
}
inline void MsgUnitAttributes::clear_moral() {
  moral_ = 0;
  _clear_bit(39);
}
inline Common::EnumUnitMorale MsgUnitAttributes::moral() const {
  return static_cast< Common::EnumUnitMorale >(moral_);
}
inline void MsgUnitAttributes::set_moral(Common::EnumUnitMorale value) {
  GOOGLE_DCHECK(Common::EnumUnitMorale_IsValid(value));
  _set_bit(39);
  moral_ = value;
}

// optional .Common.EnumUnitExperience experience = 41;
inline bool MsgUnitAttributes::has_experience() const {
  return _has_bit(40);
}
inline void MsgUnitAttributes::clear_experience() {
  experience_ = 0;
  _clear_bit(40);
}
inline Common::EnumUnitExperience MsgUnitAttributes::experience() const {
  return static_cast< Common::EnumUnitExperience >(experience_);
}
inline void MsgUnitAttributes::set_experience(Common::EnumUnitExperience value) {
  GOOGLE_DCHECK(Common::EnumUnitExperience_IsValid(value));
  _set_bit(40);
  experience_ = value;
}

// optional .Common.UnitId surrendered_unit = 42;
inline bool MsgUnitAttributes::has_surrendered_unit() const {
  return _has_bit(41);
}
inline void MsgUnitAttributes::clear_surrendered_unit() {
  if (surrendered_unit_ != NULL) surrendered_unit_->::Common::UnitId::Clear();
  _clear_bit(41);
}
inline const ::Common::UnitId& MsgUnitAttributes::surrendered_unit() const {
  return surrendered_unit_ != NULL ? *surrendered_unit_ : *default_instance_->surrendered_unit_;
}
inline ::Common::UnitId* MsgUnitAttributes::mutable_surrendered_unit() {
  _set_bit(41);
  if (surrendered_unit_ == NULL) surrendered_unit_ = new ::Common::UnitId;
  return surrendered_unit_;
}

// optional bool prisonnier = 43 [default = false];
inline bool MsgUnitAttributes::has_prisonnier() const {
  return _has_bit(42);
}
inline void MsgUnitAttributes::clear_prisonnier() {
  prisonnier_ = false;
  _clear_bit(42);
}
inline bool MsgUnitAttributes::prisonnier() const {
  return prisonnier_;
}
inline void MsgUnitAttributes::set_prisonnier(bool value) {
  _set_bit(42);
  prisonnier_ = value;
}

// optional bool refugie_pris_en_compte = 44 [default = false];
inline bool MsgUnitAttributes::has_refugie_pris_en_compte() const {
  return _has_bit(43);
}
inline void MsgUnitAttributes::clear_refugie_pris_en_compte() {
  refugie_pris_en_compte_ = false;
  _clear_bit(43);
}
inline bool MsgUnitAttributes::refugie_pris_en_compte() const {
  return refugie_pris_en_compte_;
}
inline void MsgUnitAttributes::set_refugie_pris_en_compte(bool value) {
  _set_bit(43);
  refugie_pris_en_compte_ = value;
}

// -------------------------------------------------------------------

// MsgUnitPathFind

// required .Common.UnitId id = 1;
inline bool MsgUnitPathFind::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitPathFind::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitPathFind::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgUnitPathFind::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// required .Common.MsgPath itineraire = 2;
inline bool MsgUnitPathFind::has_itineraire() const {
  return _has_bit(1);
}
inline void MsgUnitPathFind::clear_itineraire() {
  if (itineraire_ != NULL) itineraire_->::Common::MsgPath::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgPath& MsgUnitPathFind::itineraire() const {
  return itineraire_ != NULL ? *itineraire_ : *default_instance_->itineraire_;
}
inline ::Common::MsgPath* MsgUnitPathFind::mutable_itineraire() {
  _set_bit(1);
  if (itineraire_ == NULL) itineraire_ = new ::Common::MsgPath;
  return itineraire_;
}

// -------------------------------------------------------------------

// MsgUnitDestruction

// required .Common.UnitId id = 1;
inline bool MsgUnitDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgUnitDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// -------------------------------------------------------------------

// MsgUnitEnvironmentType

// required .Common.UnitId id = 1;
inline bool MsgUnitEnvironmentType::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitEnvironmentType::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitEnvironmentType::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgUnitEnvironmentType::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// required int32 area = 2;
inline bool MsgUnitEnvironmentType::has_area() const {
  return _has_bit(1);
}
inline void MsgUnitEnvironmentType::clear_area() {
  area_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgUnitEnvironmentType::area() const {
  return area_;
}
inline void MsgUnitEnvironmentType::set_area(::google::protobuf::int32 value) {
  _set_bit(1);
  area_ = value;
}

// required int32 left = 3;
inline bool MsgUnitEnvironmentType::has_left() const {
  return _has_bit(2);
}
inline void MsgUnitEnvironmentType::clear_left() {
  left_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgUnitEnvironmentType::left() const {
  return left_;
}
inline void MsgUnitEnvironmentType::set_left(::google::protobuf::int32 value) {
  _set_bit(2);
  left_ = value;
}

// required int32 right = 4;
inline bool MsgUnitEnvironmentType::has_right() const {
  return _has_bit(3);
}
inline void MsgUnitEnvironmentType::clear_right() {
  right_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgUnitEnvironmentType::right() const {
  return right_;
}
inline void MsgUnitEnvironmentType::set_right(::google::protobuf::int32 value) {
  _set_bit(3);
  right_ = value;
}

// required int32 linear = 5;
inline bool MsgUnitEnvironmentType::has_linear() const {
  return _has_bit(4);
}
inline void MsgUnitEnvironmentType::clear_linear() {
  linear_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgUnitEnvironmentType::linear() const {
  return linear_;
}
inline void MsgUnitEnvironmentType::set_linear(::google::protobuf::int32 value) {
  _set_bit(4);
  linear_ = value;
}

// -------------------------------------------------------------------

// MsgUnitKnowledgeCreation

// required .Common.UnitKnowledgeId id = 1;
inline bool MsgUnitKnowledgeCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitKnowledgeCreation::clear_id() {
  if (id_ != NULL) id_->::Common::UnitKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitKnowledgeId& MsgUnitKnowledgeCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitKnowledgeId* MsgUnitKnowledgeCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitKnowledgeId;
  return id_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgUnitKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgUnitKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgUnitKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgUnitKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .Common.UnitId unit = 3;
inline bool MsgUnitKnowledgeCreation::has_unit() const {
  return _has_bit(2);
}
inline void MsgUnitKnowledgeCreation::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(2);
}
inline const ::Common::UnitId& MsgUnitKnowledgeCreation::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgUnitKnowledgeCreation::mutable_unit() {
  _set_bit(2);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required .Common.UnitType type = 4;
inline bool MsgUnitKnowledgeCreation::has_type() const {
  return _has_bit(3);
}
inline void MsgUnitKnowledgeCreation::clear_type() {
  if (type_ != NULL) type_->::Common::UnitType::Clear();
  _clear_bit(3);
}
inline const ::Common::UnitType& MsgUnitKnowledgeCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::UnitType* MsgUnitKnowledgeCreation::mutable_type() {
  _set_bit(3);
  if (type_ == NULL) type_ = new ::Common::UnitType;
  return type_;
}

// -------------------------------------------------------------------

// AutomatPerception

// required .Common.AutomatId automat = 1;
inline bool AutomatPerception::has_automat() const {
  return _has_bit(0);
}
inline void AutomatPerception::clear_automat() {
  if (automat_ != NULL) automat_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& AutomatPerception::automat() const {
  return automat_ != NULL ? *automat_ : *default_instance_->automat_;
}
inline ::Common::AutomatId* AutomatPerception::mutable_automat() {
  _set_bit(0);
  if (automat_ == NULL) automat_ = new ::Common::AutomatId;
  return automat_;
}

// required .MsgsSimToClient.EnumUnitIdentificationLevel identification_level = 2;
inline bool AutomatPerception::has_identification_level() const {
  return _has_bit(1);
}
inline void AutomatPerception::clear_identification_level() {
  identification_level_ = 0;
  _clear_bit(1);
}
inline MsgsSimToClient::EnumUnitIdentificationLevel AutomatPerception::identification_level() const {
  return static_cast< MsgsSimToClient::EnumUnitIdentificationLevel >(identification_level_);
}
inline void AutomatPerception::set_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumUnitIdentificationLevel_IsValid(value));
  _set_bit(1);
  identification_level_ = value;
}

// -------------------------------------------------------------------

// SeqOfAutomatPerception

// repeated .MsgsSimToClient.AutomatPerception elem = 1;
inline int SeqOfAutomatPerception::elem_size() const {
  return elem_.size();
}
inline void SeqOfAutomatPerception::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception >&
SeqOfAutomatPerception::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::AutomatPerception >*
SeqOfAutomatPerception::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::AutomatPerception& SeqOfAutomatPerception::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::AutomatPerception* SeqOfAutomatPerception::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::AutomatPerception* SeqOfAutomatPerception::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgUnitKnowledgeUpdate

// required .Common.UnitKnowledgeId id = 1;
inline bool MsgUnitKnowledgeUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitKnowledgeUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::UnitKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitKnowledgeId& MsgUnitKnowledgeUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitKnowledgeId* MsgUnitKnowledgeUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitKnowledgeId;
  return id_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgUnitKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgUnitKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgUnitKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgUnitKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional int32 pertinence = 3 [default = 0];
inline bool MsgUnitKnowledgeUpdate::has_pertinence() const {
  return _has_bit(2);
}
inline void MsgUnitKnowledgeUpdate::clear_pertinence() {
  pertinence_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgUnitKnowledgeUpdate::pertinence() const {
  return pertinence_;
}
inline void MsgUnitKnowledgeUpdate::set_pertinence(::google::protobuf::int32 value) {
  _set_bit(2);
  pertinence_ = value;
}

// optional .MsgsSimToClient.EnumUnitIdentificationLevel identification_level = 4;
inline bool MsgUnitKnowledgeUpdate::has_identification_level() const {
  return _has_bit(3);
}
inline void MsgUnitKnowledgeUpdate::clear_identification_level() {
  identification_level_ = 0;
  _clear_bit(3);
}
inline MsgsSimToClient::EnumUnitIdentificationLevel MsgUnitKnowledgeUpdate::identification_level() const {
  return static_cast< MsgsSimToClient::EnumUnitIdentificationLevel >(identification_level_);
}
inline void MsgUnitKnowledgeUpdate::set_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumUnitIdentificationLevel_IsValid(value));
  _set_bit(3);
  identification_level_ = value;
}

// optional .MsgsSimToClient.EnumUnitIdentificationLevel max_identification_level = 5;
inline bool MsgUnitKnowledgeUpdate::has_max_identification_level() const {
  return _has_bit(4);
}
inline void MsgUnitKnowledgeUpdate::clear_max_identification_level() {
  max_identification_level_ = 0;
  _clear_bit(4);
}
inline MsgsSimToClient::EnumUnitIdentificationLevel MsgUnitKnowledgeUpdate::max_identification_level() const {
  return static_cast< MsgsSimToClient::EnumUnitIdentificationLevel >(max_identification_level_);
}
inline void MsgUnitKnowledgeUpdate::set_max_identification_level(MsgsSimToClient::EnumUnitIdentificationLevel value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumUnitIdentificationLevel_IsValid(value));
  _set_bit(4);
  max_identification_level_ = value;
}

// optional int32 etat_op = 6 [default = 0];
inline bool MsgUnitKnowledgeUpdate::has_etat_op() const {
  return _has_bit(5);
}
inline void MsgUnitKnowledgeUpdate::clear_etat_op() {
  etat_op_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgUnitKnowledgeUpdate::etat_op() const {
  return etat_op_;
}
inline void MsgUnitKnowledgeUpdate::set_etat_op(::google::protobuf::int32 value) {
  _set_bit(5);
  etat_op_ = value;
}

// optional bool mort = 7 [default = false];
inline bool MsgUnitKnowledgeUpdate::has_mort() const {
  return _has_bit(6);
}
inline void MsgUnitKnowledgeUpdate::clear_mort() {
  mort_ = false;
  _clear_bit(6);
}
inline bool MsgUnitKnowledgeUpdate::mort() const {
  return mort_;
}
inline void MsgUnitKnowledgeUpdate::set_mort(bool value) {
  _set_bit(6);
  mort_ = value;
}

// optional .Common.MsgCoordLatLong position = 8;
inline bool MsgUnitKnowledgeUpdate::has_position() const {
  return _has_bit(7);
}
inline void MsgUnitKnowledgeUpdate::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(7);
}
inline const ::Common::MsgCoordLatLong& MsgUnitKnowledgeUpdate::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgUnitKnowledgeUpdate::mutable_position() {
  _set_bit(7);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// optional .Common.MsgHeading direction = 9;
inline bool MsgUnitKnowledgeUpdate::has_direction() const {
  return _has_bit(8);
}
inline void MsgUnitKnowledgeUpdate::clear_direction() {
  if (direction_ != NULL) direction_->::Common::MsgHeading::Clear();
  _clear_bit(8);
}
inline const ::Common::MsgHeading& MsgUnitKnowledgeUpdate::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Common::MsgHeading* MsgUnitKnowledgeUpdate::mutable_direction() {
  _set_bit(8);
  if (direction_ == NULL) direction_ = new ::Common::MsgHeading;
  return direction_;
}

// optional int32 speed = 10 [default = 0];
inline bool MsgUnitKnowledgeUpdate::has_speed() const {
  return _has_bit(9);
}
inline void MsgUnitKnowledgeUpdate::clear_speed() {
  speed_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 MsgUnitKnowledgeUpdate::speed() const {
  return speed_;
}
inline void MsgUnitKnowledgeUpdate::set_speed(::google::protobuf::int32 value) {
  _set_bit(9);
  speed_ = value;
}

// optional .Common.PartyId party = 11;
inline bool MsgUnitKnowledgeUpdate::has_party() const {
  return _has_bit(10);
}
inline void MsgUnitKnowledgeUpdate::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(10);
}
inline const ::Common::PartyId& MsgUnitKnowledgeUpdate::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgUnitKnowledgeUpdate::mutable_party() {
  _set_bit(10);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional bool nature_pc = 12 [default = false];
inline bool MsgUnitKnowledgeUpdate::has_nature_pc() const {
  return _has_bit(11);
}
inline void MsgUnitKnowledgeUpdate::clear_nature_pc() {
  nature_pc_ = false;
  _clear_bit(11);
}
inline bool MsgUnitKnowledgeUpdate::nature_pc() const {
  return nature_pc_;
}
inline void MsgUnitKnowledgeUpdate::set_nature_pc(bool value) {
  _set_bit(11);
  nature_pc_ = value;
}

// optional .MsgsSimToClient.SeqOfAutomatPerception perception_par_compagnie = 13;
inline bool MsgUnitKnowledgeUpdate::has_perception_par_compagnie() const {
  return _has_bit(12);
}
inline void MsgUnitKnowledgeUpdate::clear_perception_par_compagnie() {
  if (perception_par_compagnie_ != NULL) perception_par_compagnie_->::MsgsSimToClient::SeqOfAutomatPerception::Clear();
  _clear_bit(12);
}
inline const ::MsgsSimToClient::SeqOfAutomatPerception& MsgUnitKnowledgeUpdate::perception_par_compagnie() const {
  return perception_par_compagnie_ != NULL ? *perception_par_compagnie_ : *default_instance_->perception_par_compagnie_;
}
inline ::MsgsSimToClient::SeqOfAutomatPerception* MsgUnitKnowledgeUpdate::mutable_perception_par_compagnie() {
  _set_bit(12);
  if (perception_par_compagnie_ == NULL) perception_par_compagnie_ = new ::MsgsSimToClient::SeqOfAutomatPerception;
  return perception_par_compagnie_;
}

// optional .Common.UnitId surrendered_unit = 14;
inline bool MsgUnitKnowledgeUpdate::has_surrendered_unit() const {
  return _has_bit(13);
}
inline void MsgUnitKnowledgeUpdate::clear_surrendered_unit() {
  if (surrendered_unit_ != NULL) surrendered_unit_->::Common::UnitId::Clear();
  _clear_bit(13);
}
inline const ::Common::UnitId& MsgUnitKnowledgeUpdate::surrendered_unit() const {
  return surrendered_unit_ != NULL ? *surrendered_unit_ : *default_instance_->surrendered_unit_;
}
inline ::Common::UnitId* MsgUnitKnowledgeUpdate::mutable_surrendered_unit() {
  _set_bit(13);
  if (surrendered_unit_ == NULL) surrendered_unit_ = new ::Common::UnitId;
  return surrendered_unit_;
}

// optional bool prisonnier = 15 [default = false];
inline bool MsgUnitKnowledgeUpdate::has_prisonnier() const {
  return _has_bit(14);
}
inline void MsgUnitKnowledgeUpdate::clear_prisonnier() {
  prisonnier_ = false;
  _clear_bit(14);
}
inline bool MsgUnitKnowledgeUpdate::prisonnier() const {
  return prisonnier_;
}
inline void MsgUnitKnowledgeUpdate::set_prisonnier(bool value) {
  _set_bit(14);
  prisonnier_ = value;
}

// optional bool refugie_pris_en_compte = 16 [default = false];
inline bool MsgUnitKnowledgeUpdate::has_refugie_pris_en_compte() const {
  return _has_bit(15);
}
inline void MsgUnitKnowledgeUpdate::clear_refugie_pris_en_compte() {
  refugie_pris_en_compte_ = false;
  _clear_bit(15);
}
inline bool MsgUnitKnowledgeUpdate::refugie_pris_en_compte() const {
  return refugie_pris_en_compte_;
}
inline void MsgUnitKnowledgeUpdate::set_refugie_pris_en_compte(bool value) {
  _set_bit(15);
  refugie_pris_en_compte_ = value;
}

// -------------------------------------------------------------------

// MsgUnitKnowledgeDestruction

// required .Common.UnitKnowledgeId id = 1;
inline bool MsgUnitKnowledgeDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitKnowledgeDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::UnitKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitKnowledgeId& MsgUnitKnowledgeDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitKnowledgeId* MsgUnitKnowledgeDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitKnowledgeId;
  return id_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgUnitKnowledgeDestruction::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgUnitKnowledgeDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgUnitKnowledgeDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgUnitKnowledgeDestruction::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgStartUnitFire_target

// optional .Common.UnitId unit = 1;
inline bool MsgStartUnitFire_target::has_unit() const {
  return _has_bit(0);
}
inline void MsgStartUnitFire_target::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgStartUnitFire_target::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgStartUnitFire_target::mutable_unit() {
  _set_bit(0);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// optional .Common.PopulationId population = 2;
inline bool MsgStartUnitFire_target::has_population() const {
  return _has_bit(1);
}
inline void MsgStartUnitFire_target::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgStartUnitFire_target::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationId* MsgStartUnitFire_target::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationId;
  return population_;
}

// optional .Common.MsgCoordLatLong position = 3;
inline bool MsgStartUnitFire_target::has_position() const {
  return _has_bit(2);
}
inline void MsgStartUnitFire_target::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgCoordLatLong& MsgStartUnitFire_target::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgStartUnitFire_target::mutable_position() {
  _set_bit(2);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// -------------------------------------------------------------------

// MsgStartUnitFire

// required .Common.FireId id = 1;
inline bool MsgStartUnitFire::has_id() const {
  return _has_bit(0);
}
inline void MsgStartUnitFire::clear_id() {
  if (id_ != NULL) id_->::Common::FireId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireId& MsgStartUnitFire::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::FireId* MsgStartUnitFire::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::FireId;
  return id_;
}

// required .Common.UnitId firing_unit = 2;
inline bool MsgStartUnitFire::has_firing_unit() const {
  return _has_bit(1);
}
inline void MsgStartUnitFire::clear_firing_unit() {
  if (firing_unit_ != NULL) firing_unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgStartUnitFire::firing_unit() const {
  return firing_unit_ != NULL ? *firing_unit_ : *default_instance_->firing_unit_;
}
inline ::Common::UnitId* MsgStartUnitFire::mutable_firing_unit() {
  _set_bit(1);
  if (firing_unit_ == NULL) firing_unit_ = new ::Common::UnitId;
  return firing_unit_;
}

// required .MsgsSimToClient.MsgStartUnitFire_target target = 3;
inline bool MsgStartUnitFire::has_target() const {
  return _has_bit(2);
}
inline void MsgStartUnitFire::clear_target() {
  if (target_ != NULL) target_->::MsgsSimToClient::MsgStartUnitFire_target::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgStartUnitFire_target& MsgStartUnitFire::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::MsgsSimToClient::MsgStartUnitFire_target* MsgStartUnitFire::mutable_target() {
  _set_bit(2);
  if (target_ == NULL) target_ = new ::MsgsSimToClient::MsgStartUnitFire_target;
  return target_;
}

// required .Common.MsgStartUnitFire_type type = 4;
inline bool MsgStartUnitFire::has_type() const {
  return _has_bit(3);
}
inline void MsgStartUnitFire::clear_type() {
  type_ = 0;
  _clear_bit(3);
}
inline Common::MsgStartUnitFire_type MsgStartUnitFire::type() const {
  return static_cast< Common::MsgStartUnitFire_type >(type_);
}
inline void MsgStartUnitFire::set_type(Common::MsgStartUnitFire_type value) {
  GOOGLE_DCHECK(Common::MsgStartUnitFire_type_IsValid(value));
  _set_bit(3);
  type_ = value;
}

// optional .Common.ResourceType ammunition = 5;
inline bool MsgStartUnitFire::has_ammunition() const {
  return _has_bit(4);
}
inline void MsgStartUnitFire::clear_ammunition() {
  if (ammunition_ != NULL) ammunition_->::Common::ResourceType::Clear();
  _clear_bit(4);
}
inline const ::Common::ResourceType& MsgStartUnitFire::ammunition() const {
  return ammunition_ != NULL ? *ammunition_ : *default_instance_->ammunition_;
}
inline ::Common::ResourceType* MsgStartUnitFire::mutable_ammunition() {
  _set_bit(4);
  if (ammunition_ == NULL) ammunition_ = new ::Common::ResourceType;
  return ammunition_;
}

// -------------------------------------------------------------------

// UnitHumanFireDamage

// required .Common.EnumHumanRank rank = 1;
inline bool UnitHumanFireDamage::has_rank() const {
  return _has_bit(0);
}
inline void UnitHumanFireDamage::clear_rank() {
  rank_ = 0;
  _clear_bit(0);
}
inline Common::EnumHumanRank UnitHumanFireDamage::rank() const {
  return static_cast< Common::EnumHumanRank >(rank_);
}
inline void UnitHumanFireDamage::set_rank(Common::EnumHumanRank value) {
  GOOGLE_DCHECK(Common::EnumHumanRank_IsValid(value));
  _set_bit(0);
  rank_ = value;
}

// required int32 alive_nbr = 2;
inline bool UnitHumanFireDamage::has_alive_nbr() const {
  return _has_bit(1);
}
inline void UnitHumanFireDamage::clear_alive_nbr() {
  alive_nbr_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::alive_nbr() const {
  return alive_nbr_;
}
inline void UnitHumanFireDamage::set_alive_nbr(::google::protobuf::int32 value) {
  _set_bit(1);
  alive_nbr_ = value;
}

// required int32 dead_nbr = 3;
inline bool UnitHumanFireDamage::has_dead_nbr() const {
  return _has_bit(2);
}
inline void UnitHumanFireDamage::clear_dead_nbr() {
  dead_nbr_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::dead_nbr() const {
  return dead_nbr_;
}
inline void UnitHumanFireDamage::set_dead_nbr(::google::protobuf::int32 value) {
  _set_bit(2);
  dead_nbr_ = value;
}

// required int32 wounded_u1_nbr = 4;
inline bool UnitHumanFireDamage::has_wounded_u1_nbr() const {
  return _has_bit(3);
}
inline void UnitHumanFireDamage::clear_wounded_u1_nbr() {
  wounded_u1_nbr_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::wounded_u1_nbr() const {
  return wounded_u1_nbr_;
}
inline void UnitHumanFireDamage::set_wounded_u1_nbr(::google::protobuf::int32 value) {
  _set_bit(3);
  wounded_u1_nbr_ = value;
}

// required int32 wounded_u2_nbr = 5;
inline bool UnitHumanFireDamage::has_wounded_u2_nbr() const {
  return _has_bit(4);
}
inline void UnitHumanFireDamage::clear_wounded_u2_nbr() {
  wounded_u2_nbr_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::wounded_u2_nbr() const {
  return wounded_u2_nbr_;
}
inline void UnitHumanFireDamage::set_wounded_u2_nbr(::google::protobuf::int32 value) {
  _set_bit(4);
  wounded_u2_nbr_ = value;
}

// required int32 wounded_u3_nbr = 6;
inline bool UnitHumanFireDamage::has_wounded_u3_nbr() const {
  return _has_bit(5);
}
inline void UnitHumanFireDamage::clear_wounded_u3_nbr() {
  wounded_u3_nbr_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::wounded_u3_nbr() const {
  return wounded_u3_nbr_;
}
inline void UnitHumanFireDamage::set_wounded_u3_nbr(::google::protobuf::int32 value) {
  _set_bit(5);
  wounded_u3_nbr_ = value;
}

// required int32 wounded_ue_nbr = 7;
inline bool UnitHumanFireDamage::has_wounded_ue_nbr() const {
  return _has_bit(6);
}
inline void UnitHumanFireDamage::clear_wounded_ue_nbr() {
  wounded_ue_nbr_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 UnitHumanFireDamage::wounded_ue_nbr() const {
  return wounded_ue_nbr_;
}
inline void UnitHumanFireDamage::set_wounded_ue_nbr(::google::protobuf::int32 value) {
  _set_bit(6);
  wounded_ue_nbr_ = value;
}

// -------------------------------------------------------------------

// SeqOfUnitHumanFireDamage

// repeated .MsgsSimToClient.UnitHumanFireDamage elem = 1;
inline int SeqOfUnitHumanFireDamage::elem_size() const {
  return elem_.size();
}
inline void SeqOfUnitHumanFireDamage::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage >&
SeqOfUnitHumanFireDamage::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::UnitHumanFireDamage >*
SeqOfUnitHumanFireDamage::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::UnitHumanFireDamage& SeqOfUnitHumanFireDamage::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::UnitHumanFireDamage* SeqOfUnitHumanFireDamage::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::UnitHumanFireDamage* SeqOfUnitHumanFireDamage::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgUnitEquipmentFireDamage

// required .Common.EquipmentType equipement_type = 1;
inline bool MsgUnitEquipmentFireDamage::has_equipement_type() const {
  return _has_bit(0);
}
inline void MsgUnitEquipmentFireDamage::clear_equipement_type() {
  if (equipement_type_ != NULL) equipement_type_->::Common::EquipmentType::Clear();
  _clear_bit(0);
}
inline const ::Common::EquipmentType& MsgUnitEquipmentFireDamage::equipement_type() const {
  return equipement_type_ != NULL ? *equipement_type_ : *default_instance_->equipement_type_;
}
inline ::Common::EquipmentType* MsgUnitEquipmentFireDamage::mutable_equipement_type() {
  _set_bit(0);
  if (equipement_type_ == NULL) equipement_type_ = new ::Common::EquipmentType;
  return equipement_type_;
}

// required uint32 available_nbr = 2;
inline bool MsgUnitEquipmentFireDamage::has_available_nbr() const {
  return _has_bit(1);
}
inline void MsgUnitEquipmentFireDamage::clear_available_nbr() {
  available_nbr_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 MsgUnitEquipmentFireDamage::available_nbr() const {
  return available_nbr_;
}
inline void MsgUnitEquipmentFireDamage::set_available_nbr(::google::protobuf::uint32 value) {
  _set_bit(1);
  available_nbr_ = value;
}

// required uint32 unavailable_nbr = 3;
inline bool MsgUnitEquipmentFireDamage::has_unavailable_nbr() const {
  return _has_bit(2);
}
inline void MsgUnitEquipmentFireDamage::clear_unavailable_nbr() {
  unavailable_nbr_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 MsgUnitEquipmentFireDamage::unavailable_nbr() const {
  return unavailable_nbr_;
}
inline void MsgUnitEquipmentFireDamage::set_unavailable_nbr(::google::protobuf::uint32 value) {
  _set_bit(2);
  unavailable_nbr_ = value;
}

// required uint32 repairable_nbr = 4;
inline bool MsgUnitEquipmentFireDamage::has_repairable_nbr() const {
  return _has_bit(3);
}
inline void MsgUnitEquipmentFireDamage::clear_repairable_nbr() {
  repairable_nbr_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 MsgUnitEquipmentFireDamage::repairable_nbr() const {
  return repairable_nbr_;
}
inline void MsgUnitEquipmentFireDamage::set_repairable_nbr(::google::protobuf::uint32 value) {
  _set_bit(3);
  repairable_nbr_ = value;
}

// -------------------------------------------------------------------

// SeqOfUnitEquipmentFireDamage

// repeated .MsgsSimToClient.MsgUnitEquipmentFireDamage elem = 1;
inline int SeqOfUnitEquipmentFireDamage::elem_size() const {
  return elem_.size();
}
inline void SeqOfUnitEquipmentFireDamage::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage >&
SeqOfUnitEquipmentFireDamage::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitEquipmentFireDamage >*
SeqOfUnitEquipmentFireDamage::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgUnitEquipmentFireDamage& SeqOfUnitEquipmentFireDamage::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgUnitEquipmentFireDamage* SeqOfUnitEquipmentFireDamage::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgUnitEquipmentFireDamage* SeqOfUnitEquipmentFireDamage::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgUnitFireDamages

// required .Common.UnitId target = 1;
inline bool MsgUnitFireDamages::has_target() const {
  return _has_bit(0);
}
inline void MsgUnitFireDamages::clear_target() {
  if (target_ != NULL) target_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitFireDamages::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::Common::UnitId* MsgUnitFireDamages::mutable_target() {
  _set_bit(0);
  if (target_ == NULL) target_ = new ::Common::UnitId;
  return target_;
}

// required .MsgsSimToClient.SeqOfUnitHumanFireDamage humans = 2;
inline bool MsgUnitFireDamages::has_humans() const {
  return _has_bit(1);
}
inline void MsgUnitFireDamages::clear_humans() {
  if (humans_ != NULL) humans_->::MsgsSimToClient::SeqOfUnitHumanFireDamage::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::SeqOfUnitHumanFireDamage& MsgUnitFireDamages::humans() const {
  return humans_ != NULL ? *humans_ : *default_instance_->humans_;
}
inline ::MsgsSimToClient::SeqOfUnitHumanFireDamage* MsgUnitFireDamages::mutable_humans() {
  _set_bit(1);
  if (humans_ == NULL) humans_ = new ::MsgsSimToClient::SeqOfUnitHumanFireDamage;
  return humans_;
}

// required .MsgsSimToClient.SeqOfUnitEquipmentFireDamage equipments = 3;
inline bool MsgUnitFireDamages::has_equipments() const {
  return _has_bit(2);
}
inline void MsgUnitFireDamages::clear_equipments() {
  if (equipments_ != NULL) equipments_->::MsgsSimToClient::SeqOfUnitEquipmentFireDamage::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage& MsgUnitFireDamages::equipments() const {
  return equipments_ != NULL ? *equipments_ : *default_instance_->equipments_;
}
inline ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage* MsgUnitFireDamages::mutable_equipments() {
  _set_bit(2);
  if (equipments_ == NULL) equipments_ = new ::MsgsSimToClient::SeqOfUnitEquipmentFireDamage;
  return equipments_;
}

// -------------------------------------------------------------------

// MsgUnitsFireDamages

// repeated .MsgsSimToClient.MsgUnitFireDamages elem = 1;
inline int MsgUnitsFireDamages::elem_size() const {
  return elem_.size();
}
inline void MsgUnitsFireDamages::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages >&
MsgUnitsFireDamages::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgUnitFireDamages >*
MsgUnitsFireDamages::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgUnitFireDamages& MsgUnitsFireDamages::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgUnitFireDamages* MsgUnitsFireDamages::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgUnitFireDamages* MsgUnitsFireDamages::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgPopulationFireDamages

// required .Common.PopulationId target = 1;
inline bool MsgPopulationFireDamages::has_target() const {
  return _has_bit(0);
}
inline void MsgPopulationFireDamages::clear_target() {
  if (target_ != NULL) target_->::Common::PopulationId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationId& MsgPopulationFireDamages::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::Common::PopulationId* MsgPopulationFireDamages::mutable_target() {
  _set_bit(0);
  if (target_ == NULL) target_ = new ::Common::PopulationId;
  return target_;
}

// required int32 dead_nbr = 2;
inline bool MsgPopulationFireDamages::has_dead_nbr() const {
  return _has_bit(1);
}
inline void MsgPopulationFireDamages::clear_dead_nbr() {
  dead_nbr_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgPopulationFireDamages::dead_nbr() const {
  return dead_nbr_;
}
inline void MsgPopulationFireDamages::set_dead_nbr(::google::protobuf::int32 value) {
  _set_bit(1);
  dead_nbr_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationsFireDamages

// repeated .MsgsSimToClient.MsgPopulationFireDamages elem = 1;
inline int MsgPopulationsFireDamages::elem_size() const {
  return elem_.size();
}
inline void MsgPopulationsFireDamages::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgPopulationFireDamages >&
MsgPopulationsFireDamages::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgPopulationFireDamages >*
MsgPopulationsFireDamages::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgPopulationFireDamages& MsgPopulationsFireDamages::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgPopulationFireDamages* MsgPopulationsFireDamages::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgPopulationFireDamages* MsgPopulationsFireDamages::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgStopUnitFire

// required .Common.FireId id = 1;
inline bool MsgStopUnitFire::has_id() const {
  return _has_bit(0);
}
inline void MsgStopUnitFire::clear_id() {
  if (id_ != NULL) id_->::Common::FireId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireId& MsgStopUnitFire::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::FireId* MsgStopUnitFire::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::FireId;
  return id_;
}

// optional .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
inline bool MsgStopUnitFire::has_units_damages() const {
  return _has_bit(1);
}
inline void MsgStopUnitFire::clear_units_damages() {
  if (units_damages_ != NULL) units_damages_->::MsgsSimToClient::MsgUnitsFireDamages::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgUnitsFireDamages& MsgStopUnitFire::units_damages() const {
  return units_damages_ != NULL ? *units_damages_ : *default_instance_->units_damages_;
}
inline ::MsgsSimToClient::MsgUnitsFireDamages* MsgStopUnitFire::mutable_units_damages() {
  _set_bit(1);
  if (units_damages_ == NULL) units_damages_ = new ::MsgsSimToClient::MsgUnitsFireDamages;
  return units_damages_;
}

// optional .MsgsSimToClient.MsgPopulationsFireDamages populations_damages = 3;
inline bool MsgStopUnitFire::has_populations_damages() const {
  return _has_bit(2);
}
inline void MsgStopUnitFire::clear_populations_damages() {
  if (populations_damages_ != NULL) populations_damages_->::MsgsSimToClient::MsgPopulationsFireDamages::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgPopulationsFireDamages& MsgStopUnitFire::populations_damages() const {
  return populations_damages_ != NULL ? *populations_damages_ : *default_instance_->populations_damages_;
}
inline ::MsgsSimToClient::MsgPopulationsFireDamages* MsgStopUnitFire::mutable_populations_damages() {
  _set_bit(2);
  if (populations_damages_ == NULL) populations_damages_ = new ::MsgsSimToClient::MsgPopulationsFireDamages;
  return populations_damages_;
}

// -------------------------------------------------------------------

// MsgStartPopulationFire

// required .Common.FireId id = 1;
inline bool MsgStartPopulationFire::has_id() const {
  return _has_bit(0);
}
inline void MsgStartPopulationFire::clear_id() {
  if (id_ != NULL) id_->::Common::FireId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireId& MsgStartPopulationFire::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::FireId* MsgStartPopulationFire::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::FireId;
  return id_;
}

// required .Common.PopulationId firing_population = 2;
inline bool MsgStartPopulationFire::has_firing_population() const {
  return _has_bit(1);
}
inline void MsgStartPopulationFire::clear_firing_population() {
  if (firing_population_ != NULL) firing_population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgStartPopulationFire::firing_population() const {
  return firing_population_ != NULL ? *firing_population_ : *default_instance_->firing_population_;
}
inline ::Common::PopulationId* MsgStartPopulationFire::mutable_firing_population() {
  _set_bit(1);
  if (firing_population_ == NULL) firing_population_ = new ::Common::PopulationId;
  return firing_population_;
}

// -------------------------------------------------------------------

// MsgStopPopulationFire

// required .Common.FireId id = 1;
inline bool MsgStopPopulationFire::has_id() const {
  return _has_bit(0);
}
inline void MsgStopPopulationFire::clear_id() {
  if (id_ != NULL) id_->::Common::FireId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireId& MsgStopPopulationFire::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::FireId* MsgStopPopulationFire::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::FireId;
  return id_;
}

// required .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
inline bool MsgStopPopulationFire::has_units_damages() const {
  return _has_bit(1);
}
inline void MsgStopPopulationFire::clear_units_damages() {
  if (units_damages_ != NULL) units_damages_->::MsgsSimToClient::MsgUnitsFireDamages::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgUnitsFireDamages& MsgStopPopulationFire::units_damages() const {
  return units_damages_ != NULL ? *units_damages_ : *default_instance_->units_damages_;
}
inline ::MsgsSimToClient::MsgUnitsFireDamages* MsgStopPopulationFire::mutable_units_damages() {
  _set_bit(1);
  if (units_damages_ == NULL) units_damages_ = new ::MsgsSimToClient::MsgUnitsFireDamages;
  return units_damages_;
}

// -------------------------------------------------------------------

// MsgExplosion

// required .Common.ObjectId id = 1;
inline bool MsgExplosion::has_id() const {
  return _has_bit(0);
}
inline void MsgExplosion::clear_id() {
  if (id_ != NULL) id_->::Common::ObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectId& MsgExplosion::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ObjectId* MsgExplosion::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ObjectId;
  return id_;
}

// optional .MsgsSimToClient.MsgUnitsFireDamages units_damages = 2;
inline bool MsgExplosion::has_units_damages() const {
  return _has_bit(1);
}
inline void MsgExplosion::clear_units_damages() {
  if (units_damages_ != NULL) units_damages_->::MsgsSimToClient::MsgUnitsFireDamages::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgUnitsFireDamages& MsgExplosion::units_damages() const {
  return units_damages_ != NULL ? *units_damages_ : *default_instance_->units_damages_;
}
inline ::MsgsSimToClient::MsgUnitsFireDamages* MsgExplosion::mutable_units_damages() {
  _set_bit(1);
  if (units_damages_ == NULL) units_damages_ = new ::MsgsSimToClient::MsgUnitsFireDamages;
  return units_damages_;
}

// optional .MsgsSimToClient.MsgPopulationsFireDamages populations_damages = 3;
inline bool MsgExplosion::has_populations_damages() const {
  return _has_bit(2);
}
inline void MsgExplosion::clear_populations_damages() {
  if (populations_damages_ != NULL) populations_damages_->::MsgsSimToClient::MsgPopulationsFireDamages::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgPopulationsFireDamages& MsgExplosion::populations_damages() const {
  return populations_damages_ != NULL ? *populations_damages_ : *default_instance_->populations_damages_;
}
inline ::MsgsSimToClient::MsgPopulationsFireDamages* MsgExplosion::mutable_populations_damages() {
  _set_bit(2);
  if (populations_damages_ == NULL) populations_damages_ = new ::MsgsSimToClient::MsgPopulationsFireDamages;
  return populations_damages_;
}

// -------------------------------------------------------------------

// MsgStartFireEffect

// required .Common.FireEffectId id = 1;
inline bool MsgStartFireEffect::has_id() const {
  return _has_bit(0);
}
inline void MsgStartFireEffect::clear_id() {
  if (id_ != NULL) id_->::Common::FireEffectId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireEffectId& MsgStartFireEffect::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::FireEffectId* MsgStartFireEffect::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::FireEffectId;
  return id_;
}

// required .Common.MsgLocation location = 2;
inline bool MsgStartFireEffect::has_location() const {
  return _has_bit(1);
}
inline void MsgStartFireEffect::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgLocation& MsgStartFireEffect::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgStartFireEffect::mutable_location() {
  _set_bit(1);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// required .Common.EnumFireEffectType type = 3;
inline bool MsgStartFireEffect::has_type() const {
  return _has_bit(2);
}
inline void MsgStartFireEffect::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline Common::EnumFireEffectType MsgStartFireEffect::type() const {
  return static_cast< Common::EnumFireEffectType >(type_);
}
inline void MsgStartFireEffect::set_type(Common::EnumFireEffectType value) {
  GOOGLE_DCHECK(Common::EnumFireEffectType_IsValid(value));
  _set_bit(2);
  type_ = value;
}

// -------------------------------------------------------------------

// MsgStopFireEffect

// required .Common.FireEffectId id = 1;
inline bool MsgStopFireEffect::has_id() const {
  return _has_bit(0);
}
inline void MsgStopFireEffect::clear_id() {
  if (id_ != NULL) id_->::Common::FireEffectId::Clear();
  _clear_bit(0);
}
inline const ::Common::FireEffectId& MsgStopFireEffect::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::FireEffectId* MsgStopFireEffect::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::FireEffectId;
  return id_;
}

// -------------------------------------------------------------------

// MsgReport

// required .Common.ReportId id = 1;
inline bool MsgReport::has_id() const {
  return _has_bit(0);
}
inline void MsgReport::clear_id() {
  if (id_ != NULL) id_->::Common::ReportId::Clear();
  _clear_bit(0);
}
inline const ::Common::ReportId& MsgReport::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ReportId* MsgReport::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ReportId;
  return id_;
}

// required .Common.Tasker cr = 2;
inline bool MsgReport::has_cr() const {
  return _has_bit(1);
}
inline void MsgReport::clear_cr() {
  if (cr_ != NULL) cr_->::Common::Tasker::Clear();
  _clear_bit(1);
}
inline const ::Common::Tasker& MsgReport::cr() const {
  return cr_ != NULL ? *cr_ : *default_instance_->cr_;
}
inline ::Common::Tasker* MsgReport::mutable_cr() {
  _set_bit(1);
  if (cr_ == NULL) cr_ = new ::Common::Tasker;
  return cr_;
}

// required .Common.ReportType cr_oid = 3;
inline bool MsgReport::has_cr_oid() const {
  return _has_bit(2);
}
inline void MsgReport::clear_cr_oid() {
  if (cr_oid_ != NULL) cr_oid_->::Common::ReportType::Clear();
  _clear_bit(2);
}
inline const ::Common::ReportType& MsgReport::cr_oid() const {
  return cr_oid_ != NULL ? *cr_oid_ : *default_instance_->cr_oid_;
}
inline ::Common::ReportType* MsgReport::mutable_cr_oid() {
  _set_bit(2);
  if (cr_oid_ == NULL) cr_oid_ = new ::Common::ReportType;
  return cr_oid_;
}

// required .MsgsSimToClient.EnumReportType type = 4;
inline bool MsgReport::has_type() const {
  return _has_bit(3);
}
inline void MsgReport::clear_type() {
  type_ = 0;
  _clear_bit(3);
}
inline MsgsSimToClient::EnumReportType MsgReport::type() const {
  return static_cast< MsgsSimToClient::EnumReportType >(type_);
}
inline void MsgReport::set_type(MsgsSimToClient::EnumReportType value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumReportType_IsValid(value));
  _set_bit(3);
  type_ = value;
}

// required .Common.MsgDateTime time = 5;
inline bool MsgReport::has_time() const {
  return _has_bit(4);
}
inline void MsgReport::clear_time() {
  if (time_ != NULL) time_->::Common::MsgDateTime::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgDateTime& MsgReport::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::Common::MsgDateTime* MsgReport::mutable_time() {
  _set_bit(4);
  if (time_ == NULL) time_ = new ::Common::MsgDateTime;
  return time_;
}

// optional .Common.MsgMissionParameters parametres = 6;
inline bool MsgReport::has_parametres() const {
  return _has_bit(5);
}
inline void MsgReport::clear_parametres() {
  if (parametres_ != NULL) parametres_->::Common::MsgMissionParameters::Clear();
  _clear_bit(5);
}
inline const ::Common::MsgMissionParameters& MsgReport::parametres() const {
  return parametres_ != NULL ? *parametres_ : *default_instance_->parametres_;
}
inline ::Common::MsgMissionParameters* MsgReport::mutable_parametres() {
  _set_bit(5);
  if (parametres_ == NULL) parametres_ = new ::Common::MsgMissionParameters;
  return parametres_;
}

// -------------------------------------------------------------------

// MsgInvalidateReport

// required .Common.ReportId id = 1;
inline bool MsgInvalidateReport::has_id() const {
  return _has_bit(0);
}
inline void MsgInvalidateReport::clear_id() {
  if (id_ != NULL) id_->::Common::ReportId::Clear();
  _clear_bit(0);
}
inline const ::Common::ReportId& MsgInvalidateReport::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ReportId* MsgInvalidateReport::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ReportId;
  return id_;
}

// required .Common.Tasker source = 2;
inline bool MsgInvalidateReport::has_source() const {
  return _has_bit(1);
}
inline void MsgInvalidateReport::clear_source() {
  if (source_ != NULL) source_->::Common::Tasker::Clear();
  _clear_bit(1);
}
inline const ::Common::Tasker& MsgInvalidateReport::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Common::Tasker* MsgInvalidateReport::mutable_source() {
  _set_bit(1);
  if (source_ == NULL) source_ = new ::Common::Tasker;
  return source_;
}

// -------------------------------------------------------------------

// MsgTrace

// required .Common.Tasker source = 1;
inline bool MsgTrace::has_source() const {
  return _has_bit(0);
}
inline void MsgTrace::clear_source() {
  if (source_ != NULL) source_->::Common::Tasker::Clear();
  _clear_bit(0);
}
inline const ::Common::Tasker& MsgTrace::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Common::Tasker* MsgTrace::mutable_source() {
  _set_bit(0);
  if (source_ == NULL) source_ = new ::Common::Tasker;
  return source_;
}

// required string message = 2;
inline bool MsgTrace::has_message() const {
  return _has_bit(1);
}
inline void MsgTrace::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgTrace::message() const {
  return *message_;
}
inline void MsgTrace::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void MsgTrace::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void MsgTrace::set_message(const char* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgTrace::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// MsgDecisionalState

// required .Common.Tasker id = 1;
inline bool MsgDecisionalState::has_id() const {
  return _has_bit(0);
}
inline void MsgDecisionalState::clear_id() {
  if (id_ != NULL) id_->::Common::Tasker::Clear();
  _clear_bit(0);
}
inline const ::Common::Tasker& MsgDecisionalState::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::Tasker* MsgDecisionalState::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::Tasker;
  return id_;
}

// required string key = 2;
inline bool MsgDecisionalState::has_key() const {
  return _has_bit(1);
}
inline void MsgDecisionalState::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgDecisionalState::key() const {
  return *key_;
}
inline void MsgDecisionalState::set_key(const ::std::string& value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MsgDecisionalState::set_key(const char* value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MsgDecisionalState::set_key(const char* value, size_t size) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgDecisionalState::mutable_key() {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required string value = 3;
inline bool MsgDecisionalState::has_value() const {
  return _has_bit(2);
}
inline void MsgDecisionalState::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgDecisionalState::value() const {
  return *value_;
}
inline void MsgDecisionalState::set_value(const ::std::string& value) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void MsgDecisionalState::set_value(const char* value) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void MsgDecisionalState::set_value(const char* value, size_t size) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgDecisionalState::mutable_value() {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// MsgDebugPoints

// required .Common.Tasker id = 1;
inline bool MsgDebugPoints::has_id() const {
  return _has_bit(0);
}
inline void MsgDebugPoints::clear_id() {
  if (id_ != NULL) id_->::Common::Tasker::Clear();
  _clear_bit(0);
}
inline const ::Common::Tasker& MsgDebugPoints::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::Tasker* MsgDebugPoints::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::Tasker;
  return id_;
}

// required .Common.MsgCoordLatLongList coordinates = 2;
inline bool MsgDebugPoints::has_coordinates() const {
  return _has_bit(1);
}
inline void MsgDebugPoints::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::Common::MsgCoordLatLongList::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgCoordLatLongList& MsgDebugPoints::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::Common::MsgCoordLatLongList* MsgDebugPoints::mutable_coordinates() {
  _set_bit(1);
  if (coordinates_ == NULL) coordinates_ = new ::Common::MsgCoordLatLongList;
  return coordinates_;
}

// -------------------------------------------------------------------

// SeqOfHeading

// repeated .Common.MsgHeading elem = 1;
inline int SeqOfHeading::elem_size() const {
  return elem_.size();
}
inline void SeqOfHeading::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading >&
SeqOfHeading::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::MsgHeading >*
SeqOfHeading::mutable_elem() {
  return &elem_;
}
inline const ::Common::MsgHeading& SeqOfHeading::elem(int index) const {
  return elem_.Get(index);
}
inline ::Common::MsgHeading* SeqOfHeading::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::Common::MsgHeading* SeqOfHeading::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgVisionCone

// required .Common.MsgCoordLatLong origin = 1;
inline bool MsgVisionCone::has_origin() const {
  return _has_bit(0);
}
inline void MsgVisionCone::clear_origin() {
  if (origin_ != NULL) origin_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(0);
}
inline const ::Common::MsgCoordLatLong& MsgVisionCone::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::Common::MsgCoordLatLong* MsgVisionCone::mutable_origin() {
  _set_bit(0);
  if (origin_ == NULL) origin_ = new ::Common::MsgCoordLatLong;
  return origin_;
}

// required int32 height = 2;
inline bool MsgVisionCone::has_height() const {
  return _has_bit(1);
}
inline void MsgVisionCone::clear_height() {
  height_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgVisionCone::height() const {
  return height_;
}
inline void MsgVisionCone::set_height(::google::protobuf::int32 value) {
  _set_bit(1);
  height_ = value;
}

// required string sensor = 3;
inline bool MsgVisionCone::has_sensor() const {
  return _has_bit(2);
}
inline void MsgVisionCone::clear_sensor() {
  if (sensor_ != &_default_sensor_) {
    sensor_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgVisionCone::sensor() const {
  return *sensor_;
}
inline void MsgVisionCone::set_sensor(const ::std::string& value) {
  _set_bit(2);
  if (sensor_ == &_default_sensor_) {
    sensor_ = new ::std::string;
  }
  sensor_->assign(value);
}
inline void MsgVisionCone::set_sensor(const char* value) {
  _set_bit(2);
  if (sensor_ == &_default_sensor_) {
    sensor_ = new ::std::string;
  }
  sensor_->assign(value);
}
inline void MsgVisionCone::set_sensor(const char* value, size_t size) {
  _set_bit(2);
  if (sensor_ == &_default_sensor_) {
    sensor_ = new ::std::string;
  }
  sensor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgVisionCone::mutable_sensor() {
  _set_bit(2);
  if (sensor_ == &_default_sensor_) {
    sensor_ = new ::std::string;
  }
  return sensor_;
}

// required .MsgsSimToClient.SeqOfHeading directions = 4;
inline bool MsgVisionCone::has_directions() const {
  return _has_bit(3);
}
inline void MsgVisionCone::clear_directions() {
  if (directions_ != NULL) directions_->::MsgsSimToClient::SeqOfHeading::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::SeqOfHeading& MsgVisionCone::directions() const {
  return directions_ != NULL ? *directions_ : *default_instance_->directions_;
}
inline ::MsgsSimToClient::SeqOfHeading* MsgVisionCone::mutable_directions() {
  _set_bit(3);
  if (directions_ == NULL) directions_ = new ::MsgsSimToClient::SeqOfHeading;
  return directions_;
}

// -------------------------------------------------------------------

// SeqOfVisionCone

// repeated .MsgsSimToClient.MsgVisionCone elem = 1;
inline int SeqOfVisionCone::elem_size() const {
  return elem_.size();
}
inline void SeqOfVisionCone::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone >&
SeqOfVisionCone::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgVisionCone >*
SeqOfVisionCone::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgVisionCone& SeqOfVisionCone::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgVisionCone* SeqOfVisionCone::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgVisionCone* SeqOfVisionCone::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgUnitVisionCones

// required .Common.UnitId id = 1;
inline bool MsgUnitVisionCones::has_id() const {
  return _has_bit(0);
}
inline void MsgUnitVisionCones::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitVisionCones::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgUnitVisionCones::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// required .MsgsSimToClient.SeqOfVisionCone cones = 2;
inline bool MsgUnitVisionCones::has_cones() const {
  return _has_bit(1);
}
inline void MsgUnitVisionCones::clear_cones() {
  if (cones_ != NULL) cones_->::MsgsSimToClient::SeqOfVisionCone::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::SeqOfVisionCone& MsgUnitVisionCones::cones() const {
  return cones_ != NULL ? *cones_ : *default_instance_->cones_;
}
inline ::MsgsSimToClient::SeqOfVisionCone* MsgUnitVisionCones::mutable_cones() {
  _set_bit(1);
  if (cones_ == NULL) cones_ = new ::MsgsSimToClient::SeqOfVisionCone;
  return cones_;
}

// required float elongation = 3;
inline bool MsgUnitVisionCones::has_elongation() const {
  return _has_bit(2);
}
inline void MsgUnitVisionCones::clear_elongation() {
  elongation_ = 0;
  _clear_bit(2);
}
inline float MsgUnitVisionCones::elongation() const {
  return elongation_;
}
inline void MsgUnitVisionCones::set_elongation(float value) {
  _set_bit(2);
  elongation_ = value;
}

// -------------------------------------------------------------------

// MsgUnitDetection

// required .Common.UnitId observer = 1;
inline bool MsgUnitDetection::has_observer() const {
  return _has_bit(0);
}
inline void MsgUnitDetection::clear_observer() {
  if (observer_ != NULL) observer_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgUnitDetection::observer() const {
  return observer_ != NULL ? *observer_ : *default_instance_->observer_;
}
inline ::Common::UnitId* MsgUnitDetection::mutable_observer() {
  _set_bit(0);
  if (observer_ == NULL) observer_ = new ::Common::UnitId;
  return observer_;
}

// required .Common.UnitId detected_unit = 2;
inline bool MsgUnitDetection::has_detected_unit() const {
  return _has_bit(1);
}
inline void MsgUnitDetection::clear_detected_unit() {
  if (detected_unit_ != NULL) detected_unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgUnitDetection::detected_unit() const {
  return detected_unit_ != NULL ? *detected_unit_ : *default_instance_->detected_unit_;
}
inline ::Common::UnitId* MsgUnitDetection::mutable_detected_unit() {
  _set_bit(1);
  if (detected_unit_ == NULL) detected_unit_ = new ::Common::UnitId;
  return detected_unit_;
}

// required .Common.EnumUnitVisibility current_visibility = 3;
inline bool MsgUnitDetection::has_current_visibility() const {
  return _has_bit(2);
}
inline void MsgUnitDetection::clear_current_visibility() {
  current_visibility_ = 0;
  _clear_bit(2);
}
inline Common::EnumUnitVisibility MsgUnitDetection::current_visibility() const {
  return static_cast< Common::EnumUnitVisibility >(current_visibility_);
}
inline void MsgUnitDetection::set_current_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(2);
  current_visibility_ = value;
}

// required .Common.EnumUnitVisibility max_visibility = 4;
inline bool MsgUnitDetection::has_max_visibility() const {
  return _has_bit(3);
}
inline void MsgUnitDetection::clear_max_visibility() {
  max_visibility_ = 0;
  _clear_bit(3);
}
inline Common::EnumUnitVisibility MsgUnitDetection::max_visibility() const {
  return static_cast< Common::EnumUnitVisibility >(max_visibility_);
}
inline void MsgUnitDetection::set_max_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(3);
  max_visibility_ = value;
}

// -------------------------------------------------------------------

// MsgObjectDetection

// required .Common.UnitId observer = 1;
inline bool MsgObjectDetection::has_observer() const {
  return _has_bit(0);
}
inline void MsgObjectDetection::clear_observer() {
  if (observer_ != NULL) observer_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgObjectDetection::observer() const {
  return observer_ != NULL ? *observer_ : *default_instance_->observer_;
}
inline ::Common::UnitId* MsgObjectDetection::mutable_observer() {
  _set_bit(0);
  if (observer_ == NULL) observer_ = new ::Common::UnitId;
  return observer_;
}

// required .Common.ObjectId detected_object = 2;
inline bool MsgObjectDetection::has_detected_object() const {
  return _has_bit(1);
}
inline void MsgObjectDetection::clear_detected_object() {
  if (detected_object_ != NULL) detected_object_->::Common::ObjectId::Clear();
  _clear_bit(1);
}
inline const ::Common::ObjectId& MsgObjectDetection::detected_object() const {
  return detected_object_ != NULL ? *detected_object_ : *default_instance_->detected_object_;
}
inline ::Common::ObjectId* MsgObjectDetection::mutable_detected_object() {
  _set_bit(1);
  if (detected_object_ == NULL) detected_object_ = new ::Common::ObjectId;
  return detected_object_;
}

// required .Common.EnumUnitVisibility visibility = 3;
inline bool MsgObjectDetection::has_visibility() const {
  return _has_bit(2);
}
inline void MsgObjectDetection::clear_visibility() {
  visibility_ = 0;
  _clear_bit(2);
}
inline Common::EnumUnitVisibility MsgObjectDetection::visibility() const {
  return static_cast< Common::EnumUnitVisibility >(visibility_);
}
inline void MsgObjectDetection::set_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(2);
  visibility_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationConcentrationDetection

// required .Common.UnitId id = 1;
inline bool MsgPopulationConcentrationDetection::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationConcentrationDetection::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgPopulationConcentrationDetection::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgPopulationConcentrationDetection::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// required .Common.PopulationId detected_population = 2;
inline bool MsgPopulationConcentrationDetection::has_detected_population() const {
  return _has_bit(1);
}
inline void MsgPopulationConcentrationDetection::clear_detected_population() {
  if (detected_population_ != NULL) detected_population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgPopulationConcentrationDetection::detected_population() const {
  return detected_population_ != NULL ? *detected_population_ : *default_instance_->detected_population_;
}
inline ::Common::PopulationId* MsgPopulationConcentrationDetection::mutable_detected_population() {
  _set_bit(1);
  if (detected_population_ == NULL) detected_population_ = new ::Common::PopulationId;
  return detected_population_;
}

// required .Common.PopulationConcentrationId detected_concentration = 3;
inline bool MsgPopulationConcentrationDetection::has_detected_concentration() const {
  return _has_bit(2);
}
inline void MsgPopulationConcentrationDetection::clear_detected_concentration() {
  if (detected_concentration_ != NULL) detected_concentration_->::Common::PopulationConcentrationId::Clear();
  _clear_bit(2);
}
inline const ::Common::PopulationConcentrationId& MsgPopulationConcentrationDetection::detected_concentration() const {
  return detected_concentration_ != NULL ? *detected_concentration_ : *default_instance_->detected_concentration_;
}
inline ::Common::PopulationConcentrationId* MsgPopulationConcentrationDetection::mutable_detected_concentration() {
  _set_bit(2);
  if (detected_concentration_ == NULL) detected_concentration_ = new ::Common::PopulationConcentrationId;
  return detected_concentration_;
}

// required .Common.EnumUnitVisibility visibility = 4;
inline bool MsgPopulationConcentrationDetection::has_visibility() const {
  return _has_bit(3);
}
inline void MsgPopulationConcentrationDetection::clear_visibility() {
  visibility_ = 0;
  _clear_bit(3);
}
inline Common::EnumUnitVisibility MsgPopulationConcentrationDetection::visibility() const {
  return static_cast< Common::EnumUnitVisibility >(visibility_);
}
inline void MsgPopulationConcentrationDetection::set_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(3);
  visibility_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationFlowDetection

// required .Common.UnitId id = 1;
inline bool MsgPopulationFlowDetection::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationFlowDetection::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgPopulationFlowDetection::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgPopulationFlowDetection::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// required .Common.PopulationId detected_population = 2;
inline bool MsgPopulationFlowDetection::has_detected_population() const {
  return _has_bit(1);
}
inline void MsgPopulationFlowDetection::clear_detected_population() {
  if (detected_population_ != NULL) detected_population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgPopulationFlowDetection::detected_population() const {
  return detected_population_ != NULL ? *detected_population_ : *default_instance_->detected_population_;
}
inline ::Common::PopulationId* MsgPopulationFlowDetection::mutable_detected_population() {
  _set_bit(1);
  if (detected_population_ == NULL) detected_population_ = new ::Common::PopulationId;
  return detected_population_;
}

// required .Common.PopulationFlowId detected_flow = 3;
inline bool MsgPopulationFlowDetection::has_detected_flow() const {
  return _has_bit(2);
}
inline void MsgPopulationFlowDetection::clear_detected_flow() {
  if (detected_flow_ != NULL) detected_flow_->::Common::PopulationFlowId::Clear();
  _clear_bit(2);
}
inline const ::Common::PopulationFlowId& MsgPopulationFlowDetection::detected_flow() const {
  return detected_flow_ != NULL ? *detected_flow_ : *default_instance_->detected_flow_;
}
inline ::Common::PopulationFlowId* MsgPopulationFlowDetection::mutable_detected_flow() {
  _set_bit(2);
  if (detected_flow_ == NULL) detected_flow_ = new ::Common::PopulationFlowId;
  return detected_flow_;
}

// required .Common.MsgPath visible_flow = 4;
inline bool MsgPopulationFlowDetection::has_visible_flow() const {
  return _has_bit(3);
}
inline void MsgPopulationFlowDetection::clear_visible_flow() {
  if (visible_flow_ != NULL) visible_flow_->::Common::MsgPath::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgPath& MsgPopulationFlowDetection::visible_flow() const {
  return visible_flow_ != NULL ? *visible_flow_ : *default_instance_->visible_flow_;
}
inline ::Common::MsgPath* MsgPopulationFlowDetection::mutable_visible_flow() {
  _set_bit(3);
  if (visible_flow_ == NULL) visible_flow_ = new ::Common::MsgPath;
  return visible_flow_;
}

// -------------------------------------------------------------------

// MsgObjectCreation

// required .Common.ObjectId id = 1;
inline bool MsgObjectCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgObjectCreation::clear_id() {
  if (id_ != NULL) id_->::Common::ObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectId& MsgObjectCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ObjectId* MsgObjectCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ObjectId;
  return id_;
}

// required .Common.ObjectType type = 2;
inline bool MsgObjectCreation::has_type() const {
  return _has_bit(1);
}
inline void MsgObjectCreation::clear_type() {
  if (type_ != NULL) type_->::Common::ObjectType::Clear();
  _clear_bit(1);
}
inline const ::Common::ObjectType& MsgObjectCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::ObjectType* MsgObjectCreation::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::ObjectType;
  return type_;
}

// required string name = 3;
inline bool MsgObjectCreation::has_name() const {
  return _has_bit(2);
}
inline void MsgObjectCreation::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgObjectCreation::name() const {
  return *name_;
}
inline void MsgObjectCreation::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgObjectCreation::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgObjectCreation::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgObjectCreation::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .Common.PartyId party = 4;
inline bool MsgObjectCreation::has_party() const {
  return _has_bit(3);
}
inline void MsgObjectCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(3);
}
inline const ::Common::PartyId& MsgObjectCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgObjectCreation::mutable_party() {
  _set_bit(3);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required .Common.MsgLocation location = 5;
inline bool MsgObjectCreation::has_location() const {
  return _has_bit(4);
}
inline void MsgObjectCreation::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgLocation& MsgObjectCreation::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgObjectCreation::mutable_location() {
  _set_bit(4);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// required .Common.MsgObjectAttributes attributes = 6;
inline bool MsgObjectCreation::has_attributes() const {
  return _has_bit(5);
}
inline void MsgObjectCreation::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::MsgObjectAttributes::Clear();
  _clear_bit(5);
}
inline const ::Common::MsgObjectAttributes& MsgObjectCreation::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::MsgObjectAttributes* MsgObjectCreation::mutable_attributes() {
  _set_bit(5);
  if (attributes_ == NULL) attributes_ = new ::Common::MsgObjectAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgObjectDestruction

// required .Common.ObjectId id = 1;
inline bool MsgObjectDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgObjectDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::ObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectId& MsgObjectDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ObjectId* MsgObjectDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ObjectId;
  return id_;
}

// -------------------------------------------------------------------

// MsgObjectUpdate

// required .Common.ObjectId id = 1;
inline bool MsgObjectUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgObjectUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::ObjectId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectId& MsgObjectUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ObjectId* MsgObjectUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ObjectId;
  return id_;
}

// optional .Common.MsgLocation location = 2;
inline bool MsgObjectUpdate::has_location() const {
  return _has_bit(1);
}
inline void MsgObjectUpdate::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgLocation& MsgObjectUpdate::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgObjectUpdate::mutable_location() {
  _set_bit(1);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// required .Common.MsgObjectAttributes attributes = 3;
inline bool MsgObjectUpdate::has_attributes() const {
  return _has_bit(2);
}
inline void MsgObjectUpdate::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::MsgObjectAttributes::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgObjectAttributes& MsgObjectUpdate::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::MsgObjectAttributes* MsgObjectUpdate::mutable_attributes() {
  _set_bit(2);
  if (attributes_ == NULL) attributes_ = new ::Common::MsgObjectAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgObjectKnowledgeCreation

// required .Common.ObjectKnowledgeId id = 1;
inline bool MsgObjectKnowledgeCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgObjectKnowledgeCreation::clear_id() {
  if (id_ != NULL) id_->::Common::ObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectKnowledgeId& MsgObjectKnowledgeCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ObjectKnowledgeId* MsgObjectKnowledgeCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ObjectKnowledgeId;
  return id_;
}

// required .Common.PartyId party = 2;
inline bool MsgObjectKnowledgeCreation::has_party() const {
  return _has_bit(1);
}
inline void MsgObjectKnowledgeCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgObjectKnowledgeCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgObjectKnowledgeCreation::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required .Common.ObjectId object = 3;
inline bool MsgObjectKnowledgeCreation::has_object() const {
  return _has_bit(2);
}
inline void MsgObjectKnowledgeCreation::clear_object() {
  if (object_ != NULL) object_->::Common::ObjectId::Clear();
  _clear_bit(2);
}
inline const ::Common::ObjectId& MsgObjectKnowledgeCreation::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Common::ObjectId* MsgObjectKnowledgeCreation::mutable_object() {
  _set_bit(2);
  if (object_ == NULL) object_ = new ::Common::ObjectId;
  return object_;
}

// required .Common.ObjectType type = 4;
inline bool MsgObjectKnowledgeCreation::has_type() const {
  return _has_bit(3);
}
inline void MsgObjectKnowledgeCreation::clear_type() {
  if (type_ != NULL) type_->::Common::ObjectType::Clear();
  _clear_bit(3);
}
inline const ::Common::ObjectType& MsgObjectKnowledgeCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::ObjectType* MsgObjectKnowledgeCreation::mutable_type() {
  _set_bit(3);
  if (type_ == NULL) type_ = new ::Common::ObjectType;
  return type_;
}

// required .Common.MsgObjectAttributes attributes = 5;
inline bool MsgObjectKnowledgeCreation::has_attributes() const {
  return _has_bit(4);
}
inline void MsgObjectKnowledgeCreation::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::MsgObjectAttributes::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgObjectAttributes& MsgObjectKnowledgeCreation::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::MsgObjectAttributes* MsgObjectKnowledgeCreation::mutable_attributes() {
  _set_bit(4);
  if (attributes_ == NULL) attributes_ = new ::Common::MsgObjectAttributes;
  return attributes_;
}

// optional .Common.KnowledgeGroupId knowledge_group = 6;
inline bool MsgObjectKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(5);
}
inline void MsgObjectKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(5);
}
inline const ::Common::KnowledgeGroupId& MsgObjectKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgObjectKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(5);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgObjectKnowledgeUpdate

// required .Common.ObjectKnowledgeId id = 1;
inline bool MsgObjectKnowledgeUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgObjectKnowledgeUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::ObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectKnowledgeId& MsgObjectKnowledgeUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ObjectKnowledgeId* MsgObjectKnowledgeUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ObjectKnowledgeId;
  return id_;
}

// required .Common.PartyId party = 2;
inline bool MsgObjectKnowledgeUpdate::has_party() const {
  return _has_bit(1);
}
inline void MsgObjectKnowledgeUpdate::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgObjectKnowledgeUpdate::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgObjectKnowledgeUpdate::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.ObjectId object = 3;
inline bool MsgObjectKnowledgeUpdate::has_object() const {
  return _has_bit(2);
}
inline void MsgObjectKnowledgeUpdate::clear_object() {
  if (object_ != NULL) object_->::Common::ObjectId::Clear();
  _clear_bit(2);
}
inline const ::Common::ObjectId& MsgObjectKnowledgeUpdate::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::Common::ObjectId* MsgObjectKnowledgeUpdate::mutable_object() {
  _set_bit(2);
  if (object_ == NULL) object_ = new ::Common::ObjectId;
  return object_;
}

// optional int32 relevance = 4 [default = 0];
inline bool MsgObjectKnowledgeUpdate::has_relevance() const {
  return _has_bit(3);
}
inline void MsgObjectKnowledgeUpdate::clear_relevance() {
  relevance_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgObjectKnowledgeUpdate::relevance() const {
  return relevance_;
}
inline void MsgObjectKnowledgeUpdate::set_relevance(::google::protobuf::int32 value) {
  _set_bit(3);
  relevance_ = value;
}

// optional .Common.MsgLocation location = 5;
inline bool MsgObjectKnowledgeUpdate::has_location() const {
  return _has_bit(4);
}
inline void MsgObjectKnowledgeUpdate::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgLocation& MsgObjectKnowledgeUpdate::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgObjectKnowledgeUpdate::mutable_location() {
  _set_bit(4);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// optional .Common.MsgObjectAttributes attributes = 6;
inline bool MsgObjectKnowledgeUpdate::has_attributes() const {
  return _has_bit(5);
}
inline void MsgObjectKnowledgeUpdate::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::MsgObjectAttributes::Clear();
  _clear_bit(5);
}
inline const ::Common::MsgObjectAttributes& MsgObjectKnowledgeUpdate::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::MsgObjectAttributes* MsgObjectKnowledgeUpdate::mutable_attributes() {
  _set_bit(5);
  if (attributes_ == NULL) attributes_ = new ::Common::MsgObjectAttributes;
  return attributes_;
}

// optional bool perceived = 7 [default = false];
inline bool MsgObjectKnowledgeUpdate::has_perceived() const {
  return _has_bit(6);
}
inline void MsgObjectKnowledgeUpdate::clear_perceived() {
  perceived_ = false;
  _clear_bit(6);
}
inline bool MsgObjectKnowledgeUpdate::perceived() const {
  return perceived_;
}
inline void MsgObjectKnowledgeUpdate::set_perceived(bool value) {
  _set_bit(6);
  perceived_ = value;
}

// optional .Common.AutomatIdList perceiving_automats = 8;
inline bool MsgObjectKnowledgeUpdate::has_perceiving_automats() const {
  return _has_bit(7);
}
inline void MsgObjectKnowledgeUpdate::clear_perceiving_automats() {
  if (perceiving_automats_ != NULL) perceiving_automats_->::Common::AutomatIdList::Clear();
  _clear_bit(7);
}
inline const ::Common::AutomatIdList& MsgObjectKnowledgeUpdate::perceiving_automats() const {
  return perceiving_automats_ != NULL ? *perceiving_automats_ : *default_instance_->perceiving_automats_;
}
inline ::Common::AutomatIdList* MsgObjectKnowledgeUpdate::mutable_perceiving_automats() {
  _set_bit(7);
  if (perceiving_automats_ == NULL) perceiving_automats_ = new ::Common::AutomatIdList;
  return perceiving_automats_;
}

// optional .Common.KnowledgeGroupId knowledge_group = 9;
inline bool MsgObjectKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(8);
}
inline void MsgObjectKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(8);
}
inline const ::Common::KnowledgeGroupId& MsgObjectKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgObjectKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(8);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgObjectKnowledgeDestruction

// required .Common.ObjectKnowledgeId id = 1;
inline bool MsgObjectKnowledgeDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgObjectKnowledgeDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::ObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::ObjectKnowledgeId& MsgObjectKnowledgeDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::ObjectKnowledgeId* MsgObjectKnowledgeDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::ObjectKnowledgeId;
  return id_;
}

// required .Common.PartyId party = 2;
inline bool MsgObjectKnowledgeDestruction::has_party() const {
  return _has_bit(1);
}
inline void MsgObjectKnowledgeDestruction::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgObjectKnowledgeDestruction::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgObjectKnowledgeDestruction::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgUrbanKnowledgeCreation

// required .Common.UrbanObjectKnowledgeId id = 1;
inline bool MsgUrbanKnowledgeCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgUrbanKnowledgeCreation::clear_id() {
  if (id_ != NULL) id_->::Common::UrbanObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UrbanObjectKnowledgeId& MsgUrbanKnowledgeCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UrbanObjectKnowledgeId* MsgUrbanKnowledgeCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UrbanObjectKnowledgeId;
  return id_;
}

// required .Common.PartyId party = 2;
inline bool MsgUrbanKnowledgeCreation::has_party() const {
  return _has_bit(1);
}
inline void MsgUrbanKnowledgeCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgUrbanKnowledgeCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgUrbanKnowledgeCreation::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required .Common.UrbanObjectId urban_block = 3;
inline bool MsgUrbanKnowledgeCreation::has_urban_block() const {
  return _has_bit(2);
}
inline void MsgUrbanKnowledgeCreation::clear_urban_block() {
  if (urban_block_ != NULL) urban_block_->::Common::UrbanObjectId::Clear();
  _clear_bit(2);
}
inline const ::Common::UrbanObjectId& MsgUrbanKnowledgeCreation::urban_block() const {
  return urban_block_ != NULL ? *urban_block_ : *default_instance_->urban_block_;
}
inline ::Common::UrbanObjectId* MsgUrbanKnowledgeCreation::mutable_urban_block() {
  _set_bit(2);
  if (urban_block_ == NULL) urban_block_ = new ::Common::UrbanObjectId;
  return urban_block_;
}

// -------------------------------------------------------------------

// MsgUrbanKnowledgeUpdate

// required .Common.UrbanObjectKnowledgeId id = 1;
inline bool MsgUrbanKnowledgeUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgUrbanKnowledgeUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::UrbanObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UrbanObjectKnowledgeId& MsgUrbanKnowledgeUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UrbanObjectKnowledgeId* MsgUrbanKnowledgeUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UrbanObjectKnowledgeId;
  return id_;
}

// required .Common.PartyId party = 2;
inline bool MsgUrbanKnowledgeUpdate::has_party() const {
  return _has_bit(1);
}
inline void MsgUrbanKnowledgeUpdate::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgUrbanKnowledgeUpdate::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgUrbanKnowledgeUpdate::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// required .Common.UrbanObjectId urban_block = 3;
inline bool MsgUrbanKnowledgeUpdate::has_urban_block() const {
  return _has_bit(2);
}
inline void MsgUrbanKnowledgeUpdate::clear_urban_block() {
  if (urban_block_ != NULL) urban_block_->::Common::UrbanObjectId::Clear();
  _clear_bit(2);
}
inline const ::Common::UrbanObjectId& MsgUrbanKnowledgeUpdate::urban_block() const {
  return urban_block_ != NULL ? *urban_block_ : *default_instance_->urban_block_;
}
inline ::Common::UrbanObjectId* MsgUrbanKnowledgeUpdate::mutable_urban_block() {
  _set_bit(2);
  if (urban_block_ == NULL) urban_block_ = new ::Common::UrbanObjectId;
  return urban_block_;
}

// optional int32 progress = 4;
inline bool MsgUrbanKnowledgeUpdate::has_progress() const {
  return _has_bit(3);
}
inline void MsgUrbanKnowledgeUpdate::clear_progress() {
  progress_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgUrbanKnowledgeUpdate::progress() const {
  return progress_;
}
inline void MsgUrbanKnowledgeUpdate::set_progress(::google::protobuf::int32 value) {
  _set_bit(3);
  progress_ = value;
}

// optional int32 max_progress = 5;
inline bool MsgUrbanKnowledgeUpdate::has_max_progress() const {
  return _has_bit(4);
}
inline void MsgUrbanKnowledgeUpdate::clear_max_progress() {
  max_progress_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgUrbanKnowledgeUpdate::max_progress() const {
  return max_progress_;
}
inline void MsgUrbanKnowledgeUpdate::set_max_progress(::google::protobuf::int32 value) {
  _set_bit(4);
  max_progress_ = value;
}

// optional bool perceived = 6;
inline bool MsgUrbanKnowledgeUpdate::has_perceived() const {
  return _has_bit(5);
}
inline void MsgUrbanKnowledgeUpdate::clear_perceived() {
  perceived_ = false;
  _clear_bit(5);
}
inline bool MsgUrbanKnowledgeUpdate::perceived() const {
  return perceived_;
}
inline void MsgUrbanKnowledgeUpdate::set_perceived(bool value) {
  _set_bit(5);
  perceived_ = value;
}

// optional .Common.AutomatIdList automat_perceptions = 7;
inline bool MsgUrbanKnowledgeUpdate::has_automat_perceptions() const {
  return _has_bit(6);
}
inline void MsgUrbanKnowledgeUpdate::clear_automat_perceptions() {
  if (automat_perceptions_ != NULL) automat_perceptions_->::Common::AutomatIdList::Clear();
  _clear_bit(6);
}
inline const ::Common::AutomatIdList& MsgUrbanKnowledgeUpdate::automat_perceptions() const {
  return automat_perceptions_ != NULL ? *automat_perceptions_ : *default_instance_->automat_perceptions_;
}
inline ::Common::AutomatIdList* MsgUrbanKnowledgeUpdate::mutable_automat_perceptions() {
  _set_bit(6);
  if (automat_perceptions_ == NULL) automat_perceptions_ = new ::Common::AutomatIdList;
  return automat_perceptions_;
}

// -------------------------------------------------------------------

// MsgUrbanKnowledgeDestruction

// required .Common.UrbanObjectKnowledgeId id = 1;
inline bool MsgUrbanKnowledgeDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgUrbanKnowledgeDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::UrbanObjectKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::UrbanObjectKnowledgeId& MsgUrbanKnowledgeDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UrbanObjectKnowledgeId* MsgUrbanKnowledgeDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UrbanObjectKnowledgeId;
  return id_;
}

// required .Common.PartyId party = 2;
inline bool MsgUrbanKnowledgeDestruction::has_party() const {
  return _has_bit(1);
}
inline void MsgUrbanKnowledgeDestruction::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgUrbanKnowledgeDestruction::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgUrbanKnowledgeDestruction::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgLogMedicalHandlingCreation

// required .Common.MedicalRequestId id = 1;
inline bool MsgLogMedicalHandlingCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgLogMedicalHandlingCreation::clear_id() {
  if (id_ != NULL) id_->::Common::MedicalRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MedicalRequestId& MsgLogMedicalHandlingCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::MedicalRequestId* MsgLogMedicalHandlingCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::MedicalRequestId;
  return id_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMedicalHandlingCreation::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMedicalHandlingCreation::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMedicalHandlingCreation::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMedicalHandlingCreation::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required int32 tick_creation = 3;
inline bool MsgLogMedicalHandlingCreation::has_tick_creation() const {
  return _has_bit(2);
}
inline void MsgLogMedicalHandlingCreation::clear_tick_creation() {
  tick_creation_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogMedicalHandlingCreation::tick_creation() const {
  return tick_creation_;
}
inline void MsgLogMedicalHandlingCreation::set_tick_creation(::google::protobuf::int32 value) {
  _set_bit(2);
  tick_creation_ = value;
}

// required .Common.EnumHumanRank rang = 4;
inline bool MsgLogMedicalHandlingCreation::has_rang() const {
  return _has_bit(3);
}
inline void MsgLogMedicalHandlingCreation::clear_rang() {
  rang_ = 0;
  _clear_bit(3);
}
inline Common::EnumHumanRank MsgLogMedicalHandlingCreation::rang() const {
  return static_cast< Common::EnumHumanRank >(rang_);
}
inline void MsgLogMedicalHandlingCreation::set_rang(Common::EnumHumanRank value) {
  GOOGLE_DCHECK(Common::EnumHumanRank_IsValid(value));
  _set_bit(3);
  rang_ = value;
}

// required .Common.EnumHumanWound blessure = 5;
inline bool MsgLogMedicalHandlingCreation::has_blessure() const {
  return _has_bit(4);
}
inline void MsgLogMedicalHandlingCreation::clear_blessure() {
  blessure_ = 0;
  _clear_bit(4);
}
inline Common::EnumHumanWound MsgLogMedicalHandlingCreation::blessure() const {
  return static_cast< Common::EnumHumanWound >(blessure_);
}
inline void MsgLogMedicalHandlingCreation::set_blessure(Common::EnumHumanWound value) {
  GOOGLE_DCHECK(Common::EnumHumanWound_IsValid(value));
  _set_bit(4);
  blessure_ = value;
}

// optional bool blesse_mental = 6 [default = false];
inline bool MsgLogMedicalHandlingCreation::has_blesse_mental() const {
  return _has_bit(5);
}
inline void MsgLogMedicalHandlingCreation::clear_blesse_mental() {
  blesse_mental_ = false;
  _clear_bit(5);
}
inline bool MsgLogMedicalHandlingCreation::blesse_mental() const {
  return blesse_mental_;
}
inline void MsgLogMedicalHandlingCreation::set_blesse_mental(bool value) {
  _set_bit(5);
  blesse_mental_ = value;
}

// optional bool contamine_nbc = 7 [default = false];
inline bool MsgLogMedicalHandlingCreation::has_contamine_nbc() const {
  return _has_bit(6);
}
inline void MsgLogMedicalHandlingCreation::clear_contamine_nbc() {
  contamine_nbc_ = false;
  _clear_bit(6);
}
inline bool MsgLogMedicalHandlingCreation::contamine_nbc() const {
  return contamine_nbc_;
}
inline void MsgLogMedicalHandlingCreation::set_contamine_nbc(bool value) {
  _set_bit(6);
  contamine_nbc_ = value;
}

// -------------------------------------------------------------------

// MsgLogMedicalHandlingUpdate

// required .Common.MedicalRequestId id = 1;
inline bool MsgLogMedicalHandlingUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgLogMedicalHandlingUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::MedicalRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MedicalRequestId& MsgLogMedicalHandlingUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::MedicalRequestId* MsgLogMedicalHandlingUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::MedicalRequestId;
  return id_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMedicalHandlingUpdate::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMedicalHandlingUpdate::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMedicalHandlingUpdate::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMedicalHandlingUpdate::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// optional .Common.UnitId provider = 3;
inline bool MsgLogMedicalHandlingUpdate::has_provider() const {
  return _has_bit(2);
}
inline void MsgLogMedicalHandlingUpdate::clear_provider() {
  if (provider_ != NULL) provider_->::Common::UnitId::Clear();
  _clear_bit(2);
}
inline const ::Common::UnitId& MsgLogMedicalHandlingUpdate::provider() const {
  return provider_ != NULL ? *provider_ : *default_instance_->provider_;
}
inline ::Common::UnitId* MsgLogMedicalHandlingUpdate::mutable_provider() {
  _set_bit(2);
  if (provider_ == NULL) provider_ = new ::Common::UnitId;
  return provider_;
}

// optional .Common.EnumHumanWound blessure = 4;
inline bool MsgLogMedicalHandlingUpdate::has_blessure() const {
  return _has_bit(3);
}
inline void MsgLogMedicalHandlingUpdate::clear_blessure() {
  blessure_ = 0;
  _clear_bit(3);
}
inline Common::EnumHumanWound MsgLogMedicalHandlingUpdate::blessure() const {
  return static_cast< Common::EnumHumanWound >(blessure_);
}
inline void MsgLogMedicalHandlingUpdate::set_blessure(Common::EnumHumanWound value) {
  GOOGLE_DCHECK(Common::EnumHumanWound_IsValid(value));
  _set_bit(3);
  blessure_ = value;
}

// optional bool blesse_mental = 5 [default = false];
inline bool MsgLogMedicalHandlingUpdate::has_blesse_mental() const {
  return _has_bit(4);
}
inline void MsgLogMedicalHandlingUpdate::clear_blesse_mental() {
  blesse_mental_ = false;
  _clear_bit(4);
}
inline bool MsgLogMedicalHandlingUpdate::blesse_mental() const {
  return blesse_mental_;
}
inline void MsgLogMedicalHandlingUpdate::set_blesse_mental(bool value) {
  _set_bit(4);
  blesse_mental_ = value;
}

// optional bool contamine_nbc = 6 [default = false];
inline bool MsgLogMedicalHandlingUpdate::has_contamine_nbc() const {
  return _has_bit(5);
}
inline void MsgLogMedicalHandlingUpdate::clear_contamine_nbc() {
  contamine_nbc_ = false;
  _clear_bit(5);
}
inline bool MsgLogMedicalHandlingUpdate::contamine_nbc() const {
  return contamine_nbc_;
}
inline void MsgLogMedicalHandlingUpdate::set_contamine_nbc(bool value) {
  _set_bit(5);
  contamine_nbc_ = value;
}

// optional .Common.EnumLogMedicalHandlingStatus etat = 7;
inline bool MsgLogMedicalHandlingUpdate::has_etat() const {
  return _has_bit(6);
}
inline void MsgLogMedicalHandlingUpdate::clear_etat() {
  etat_ = 0;
  _clear_bit(6);
}
inline Common::EnumLogMedicalHandlingStatus MsgLogMedicalHandlingUpdate::etat() const {
  return static_cast< Common::EnumLogMedicalHandlingStatus >(etat_);
}
inline void MsgLogMedicalHandlingUpdate::set_etat(Common::EnumLogMedicalHandlingStatus value) {
  GOOGLE_DCHECK(Common::EnumLogMedicalHandlingStatus_IsValid(value));
  _set_bit(6);
  etat_ = value;
}

// optional bool diagnostique_effectue = 8 [default = false];
inline bool MsgLogMedicalHandlingUpdate::has_diagnostique_effectue() const {
  return _has_bit(7);
}
inline void MsgLogMedicalHandlingUpdate::clear_diagnostique_effectue() {
  diagnostique_effectue_ = false;
  _clear_bit(7);
}
inline bool MsgLogMedicalHandlingUpdate::diagnostique_effectue() const {
  return diagnostique_effectue_;
}
inline void MsgLogMedicalHandlingUpdate::set_diagnostique_effectue(bool value) {
  _set_bit(7);
  diagnostique_effectue_ = value;
}

// -------------------------------------------------------------------

// MsgLogMedicalHandlingDestruction

// required .Common.MedicalRequestId id = 1;
inline bool MsgLogMedicalHandlingDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgLogMedicalHandlingDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::MedicalRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MedicalRequestId& MsgLogMedicalHandlingDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::MedicalRequestId* MsgLogMedicalHandlingDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::MedicalRequestId;
  return id_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMedicalHandlingDestruction::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMedicalHandlingDestruction::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMedicalHandlingDestruction::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMedicalHandlingDestruction::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// -------------------------------------------------------------------

// MsgLogMedicalEquipmentAvailability

// required int32 type_equipement = 1;
inline bool MsgLogMedicalEquipmentAvailability::has_type_equipement() const {
  return _has_bit(0);
}
inline void MsgLogMedicalEquipmentAvailability::clear_type_equipement() {
  type_equipement_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::type_equipement() const {
  return type_equipement_;
}
inline void MsgLogMedicalEquipmentAvailability::set_type_equipement(::google::protobuf::int32 value) {
  _set_bit(0);
  type_equipement_ = value;
}

// required int32 nbr_total = 2;
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_total() const {
  return _has_bit(1);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_total() {
  nbr_total_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_total() const {
  return nbr_total_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_total(::google::protobuf::int32 value) {
  _set_bit(1);
  nbr_total_ = value;
}

// required int32 nbr_disponibles = 3;
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_disponibles() const {
  return _has_bit(2);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_disponibles() {
  nbr_disponibles_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_disponibles() const {
  return nbr_disponibles_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_disponibles(::google::protobuf::int32 value) {
  _set_bit(2);
  nbr_disponibles_ = value;
}

// required int32 nbr_au_travail = 4;
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_au_travail() const {
  return _has_bit(3);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_au_travail() {
  nbr_au_travail_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_au_travail() const {
  return nbr_au_travail_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_au_travail(::google::protobuf::int32 value) {
  _set_bit(3);
  nbr_au_travail_ = value;
}

// optional int32 nbr_pretes = 5 [default = 0];
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_pretes() const {
  return _has_bit(4);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_pretes() {
  nbr_pretes_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_pretes() const {
  return nbr_pretes_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_pretes(::google::protobuf::int32 value) {
  _set_bit(4);
  nbr_pretes_ = value;
}

// optional int32 nbr_au_repos = 6 [default = 0];
inline bool MsgLogMedicalEquipmentAvailability::has_nbr_au_repos() const {
  return _has_bit(5);
}
inline void MsgLogMedicalEquipmentAvailability::clear_nbr_au_repos() {
  nbr_au_repos_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgLogMedicalEquipmentAvailability::nbr_au_repos() const {
  return nbr_au_repos_;
}
inline void MsgLogMedicalEquipmentAvailability::set_nbr_au_repos(::google::protobuf::int32 value) {
  _set_bit(5);
  nbr_au_repos_ = value;
}

// -------------------------------------------------------------------

// SeqOfLogMedicalEquipmentAvailability

// repeated .MsgsSimToClient.MsgLogMedicalEquipmentAvailability elem = 1;
inline int SeqOfLogMedicalEquipmentAvailability::elem_size() const {
  return elem_.size();
}
inline void SeqOfLogMedicalEquipmentAvailability::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability >&
SeqOfLogMedicalEquipmentAvailability::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability >*
SeqOfLogMedicalEquipmentAvailability::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability& SeqOfLogMedicalEquipmentAvailability::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability* SeqOfLogMedicalEquipmentAvailability::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgLogMedicalEquipmentAvailability* SeqOfLogMedicalEquipmentAvailability::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgLogMedicalState

// required .Common.UnitId id = 1;
inline bool MsgLogMedicalState::has_id() const {
  return _has_bit(0);
}
inline void MsgLogMedicalState::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgLogMedicalState::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgLogMedicalState::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// optional bool chaine_activee = 2 [default = false];
inline bool MsgLogMedicalState::has_chaine_activee() const {
  return _has_bit(1);
}
inline void MsgLogMedicalState::clear_chaine_activee() {
  chaine_activee_ = false;
  _clear_bit(1);
}
inline bool MsgLogMedicalState::chaine_activee() const {
  return chaine_activee_;
}
inline void MsgLogMedicalState::set_chaine_activee(bool value) {
  _set_bit(1);
  chaine_activee_ = value;
}

// optional .Common.MsgLogMedicalPriorities priorites = 3;
inline bool MsgLogMedicalState::has_priorites() const {
  return _has_bit(2);
}
inline void MsgLogMedicalState::clear_priorites() {
  if (priorites_ != NULL) priorites_->::Common::MsgLogMedicalPriorities::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgLogMedicalPriorities& MsgLogMedicalState::priorites() const {
  return priorites_ != NULL ? *priorites_ : *default_instance_->priorites_;
}
inline ::Common::MsgLogMedicalPriorities* MsgLogMedicalState::mutable_priorites() {
  _set_bit(2);
  if (priorites_ == NULL) priorites_ = new ::Common::MsgLogMedicalPriorities;
  return priorites_;
}

// optional .Common.AutomatIdList tactical_priorities = 4;
inline bool MsgLogMedicalState::has_tactical_priorities() const {
  return _has_bit(3);
}
inline void MsgLogMedicalState::clear_tactical_priorities() {
  if (tactical_priorities_ != NULL) tactical_priorities_->::Common::AutomatIdList::Clear();
  _clear_bit(3);
}
inline const ::Common::AutomatIdList& MsgLogMedicalState::tactical_priorities() const {
  return tactical_priorities_ != NULL ? *tactical_priorities_ : *default_instance_->tactical_priorities_;
}
inline ::Common::AutomatIdList* MsgLogMedicalState::mutable_tactical_priorities() {
  _set_bit(3);
  if (tactical_priorities_ == NULL) tactical_priorities_ = new ::Common::AutomatIdList;
  return tactical_priorities_;
}

// optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_releve = 5;
inline bool MsgLogMedicalState::has_disponibilites_ambulances_releve() const {
  return _has_bit(4);
}
inline void MsgLogMedicalState::clear_disponibilites_ambulances_releve() {
  if (disponibilites_ambulances_releve_ != NULL) disponibilites_ambulances_releve_->::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability::Clear();
  _clear_bit(4);
}
inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& MsgLogMedicalState::disponibilites_ambulances_releve() const {
  return disponibilites_ambulances_releve_ != NULL ? *disponibilites_ambulances_releve_ : *default_instance_->disponibilites_ambulances_releve_;
}
inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* MsgLogMedicalState::mutable_disponibilites_ambulances_releve() {
  _set_bit(4);
  if (disponibilites_ambulances_releve_ == NULL) disponibilites_ambulances_releve_ = new ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability;
  return disponibilites_ambulances_releve_;
}

// optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_ambulances_ramassage = 6;
inline bool MsgLogMedicalState::has_disponibilites_ambulances_ramassage() const {
  return _has_bit(5);
}
inline void MsgLogMedicalState::clear_disponibilites_ambulances_ramassage() {
  if (disponibilites_ambulances_ramassage_ != NULL) disponibilites_ambulances_ramassage_->::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability::Clear();
  _clear_bit(5);
}
inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& MsgLogMedicalState::disponibilites_ambulances_ramassage() const {
  return disponibilites_ambulances_ramassage_ != NULL ? *disponibilites_ambulances_ramassage_ : *default_instance_->disponibilites_ambulances_ramassage_;
}
inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* MsgLogMedicalState::mutable_disponibilites_ambulances_ramassage() {
  _set_bit(5);
  if (disponibilites_ambulances_ramassage_ == NULL) disponibilites_ambulances_ramassage_ = new ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability;
  return disponibilites_ambulances_ramassage_;
}

// optional .MsgsSimToClient.SeqOfLogMedicalEquipmentAvailability disponibilites_medecins = 7;
inline bool MsgLogMedicalState::has_disponibilites_medecins() const {
  return _has_bit(6);
}
inline void MsgLogMedicalState::clear_disponibilites_medecins() {
  if (disponibilites_medecins_ != NULL) disponibilites_medecins_->::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability::Clear();
  _clear_bit(6);
}
inline const ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability& MsgLogMedicalState::disponibilites_medecins() const {
  return disponibilites_medecins_ != NULL ? *disponibilites_medecins_ : *default_instance_->disponibilites_medecins_;
}
inline ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability* MsgLogMedicalState::mutable_disponibilites_medecins() {
  _set_bit(6);
  if (disponibilites_medecins_ == NULL) disponibilites_medecins_ = new ::MsgsSimToClient::SeqOfLogMedicalEquipmentAvailability;
  return disponibilites_medecins_;
}

// -------------------------------------------------------------------

// MsgLogMaintenanceHandlingCreation

// required .Common.MaintenanceRequestId id = 1;
inline bool MsgLogMaintenanceHandlingCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceHandlingCreation::clear_id() {
  if (id_ != NULL) id_->::Common::MaintenanceRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MaintenanceRequestId& MsgLogMaintenanceHandlingCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::MaintenanceRequestId* MsgLogMaintenanceHandlingCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::MaintenanceRequestId;
  return id_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMaintenanceHandlingCreation::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceHandlingCreation::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMaintenanceHandlingCreation::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMaintenanceHandlingCreation::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required int32 tick_creation = 3;
inline bool MsgLogMaintenanceHandlingCreation::has_tick_creation() const {
  return _has_bit(2);
}
inline void MsgLogMaintenanceHandlingCreation::clear_tick_creation() {
  tick_creation_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogMaintenanceHandlingCreation::tick_creation() const {
  return tick_creation_;
}
inline void MsgLogMaintenanceHandlingCreation::set_tick_creation(::google::protobuf::int32 value) {
  _set_bit(2);
  tick_creation_ = value;
}

// required .Common.EquipmentType equipement = 4;
inline bool MsgLogMaintenanceHandlingCreation::has_equipement() const {
  return _has_bit(3);
}
inline void MsgLogMaintenanceHandlingCreation::clear_equipement() {
  if (equipement_ != NULL) equipement_->::Common::EquipmentType::Clear();
  _clear_bit(3);
}
inline const ::Common::EquipmentType& MsgLogMaintenanceHandlingCreation::equipement() const {
  return equipement_ != NULL ? *equipement_ : *default_instance_->equipement_;
}
inline ::Common::EquipmentType* MsgLogMaintenanceHandlingCreation::mutable_equipement() {
  _set_bit(3);
  if (equipement_ == NULL) equipement_ = new ::Common::EquipmentType;
  return equipement_;
}

// required .Common.BreakdownType breakdown = 5;
inline bool MsgLogMaintenanceHandlingCreation::has_breakdown() const {
  return _has_bit(4);
}
inline void MsgLogMaintenanceHandlingCreation::clear_breakdown() {
  if (breakdown_ != NULL) breakdown_->::Common::BreakdownType::Clear();
  _clear_bit(4);
}
inline const ::Common::BreakdownType& MsgLogMaintenanceHandlingCreation::breakdown() const {
  return breakdown_ != NULL ? *breakdown_ : *default_instance_->breakdown_;
}
inline ::Common::BreakdownType* MsgLogMaintenanceHandlingCreation::mutable_breakdown() {
  _set_bit(4);
  if (breakdown_ == NULL) breakdown_ = new ::Common::BreakdownType;
  return breakdown_;
}

// -------------------------------------------------------------------

// MsgLogMaintenanceHandlingUpdate

// required .Common.MaintenanceRequestId id = 1;
inline bool MsgLogMaintenanceHandlingUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::MaintenanceRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MaintenanceRequestId& MsgLogMaintenanceHandlingUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::MaintenanceRequestId* MsgLogMaintenanceHandlingUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::MaintenanceRequestId;
  return id_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMaintenanceHandlingUpdate::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMaintenanceHandlingUpdate::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMaintenanceHandlingUpdate::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// required .Common.UnitId provider = 3;
inline bool MsgLogMaintenanceHandlingUpdate::has_provider() const {
  return _has_bit(2);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_provider() {
  if (provider_ != NULL) provider_->::Common::UnitId::Clear();
  _clear_bit(2);
}
inline const ::Common::UnitId& MsgLogMaintenanceHandlingUpdate::provider() const {
  return provider_ != NULL ? *provider_ : *default_instance_->provider_;
}
inline ::Common::UnitId* MsgLogMaintenanceHandlingUpdate::mutable_provider() {
  _set_bit(2);
  if (provider_ == NULL) provider_ = new ::Common::UnitId;
  return provider_;
}

// optional .Common.EnumLogMaintenanceHandlingStatus etat = 4;
inline bool MsgLogMaintenanceHandlingUpdate::has_etat() const {
  return _has_bit(3);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_etat() {
  etat_ = 0;
  _clear_bit(3);
}
inline Common::EnumLogMaintenanceHandlingStatus MsgLogMaintenanceHandlingUpdate::etat() const {
  return static_cast< Common::EnumLogMaintenanceHandlingStatus >(etat_);
}
inline void MsgLogMaintenanceHandlingUpdate::set_etat(Common::EnumLogMaintenanceHandlingStatus value) {
  GOOGLE_DCHECK(Common::EnumLogMaintenanceHandlingStatus_IsValid(value));
  _set_bit(3);
  etat_ = value;
}

// optional bool diagnostique_effectue = 5 [default = false];
inline bool MsgLogMaintenanceHandlingUpdate::has_diagnostique_effectue() const {
  return _has_bit(4);
}
inline void MsgLogMaintenanceHandlingUpdate::clear_diagnostique_effectue() {
  diagnostique_effectue_ = false;
  _clear_bit(4);
}
inline bool MsgLogMaintenanceHandlingUpdate::diagnostique_effectue() const {
  return diagnostique_effectue_;
}
inline void MsgLogMaintenanceHandlingUpdate::set_diagnostique_effectue(bool value) {
  _set_bit(4);
  diagnostique_effectue_ = value;
}

// -------------------------------------------------------------------

// MsgLogMaintenanceHandlingDestruction

// required .Common.MaintenanceRequestId id = 1;
inline bool MsgLogMaintenanceHandlingDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceHandlingDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::MaintenanceRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::MaintenanceRequestId& MsgLogMaintenanceHandlingDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::MaintenanceRequestId* MsgLogMaintenanceHandlingDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::MaintenanceRequestId;
  return id_;
}

// required .Common.UnitId unit = 2;
inline bool MsgLogMaintenanceHandlingDestruction::has_unit() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceHandlingDestruction::clear_unit() {
  if (unit_ != NULL) unit_->::Common::UnitId::Clear();
  _clear_bit(1);
}
inline const ::Common::UnitId& MsgLogMaintenanceHandlingDestruction::unit() const {
  return unit_ != NULL ? *unit_ : *default_instance_->unit_;
}
inline ::Common::UnitId* MsgLogMaintenanceHandlingDestruction::mutable_unit() {
  _set_bit(1);
  if (unit_ == NULL) unit_ = new ::Common::UnitId;
  return unit_;
}

// -------------------------------------------------------------------

// MsgLogMaintenanceEquipmentAvailability

// required int32 type_equipement = 1;
inline bool MsgLogMaintenanceEquipmentAvailability::has_type_equipement() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_type_equipement() {
  type_equipement_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::type_equipement() const {
  return type_equipement_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_type_equipement(::google::protobuf::int32 value) {
  _set_bit(0);
  type_equipement_ = value;
}

// required int32 nbr_total = 2;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_total() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_total() {
  nbr_total_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_total() const {
  return nbr_total_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_total(::google::protobuf::int32 value) {
  _set_bit(1);
  nbr_total_ = value;
}

// required int32 nbr_disponibles = 3;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_disponibles() const {
  return _has_bit(2);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_disponibles() {
  nbr_disponibles_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_disponibles() const {
  return nbr_disponibles_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_disponibles(::google::protobuf::int32 value) {
  _set_bit(2);
  nbr_disponibles_ = value;
}

// required int32 nbr_au_travail = 4;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_au_travail() const {
  return _has_bit(3);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_au_travail() {
  nbr_au_travail_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_au_travail() const {
  return nbr_au_travail_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_au_travail(::google::protobuf::int32 value) {
  _set_bit(3);
  nbr_au_travail_ = value;
}

// optional int32 nbr_pretes = 5 [default = 0];
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_pretes() const {
  return _has_bit(4);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_pretes() {
  nbr_pretes_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_pretes() const {
  return nbr_pretes_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_pretes(::google::protobuf::int32 value) {
  _set_bit(4);
  nbr_pretes_ = value;
}

// optional int32 nbr_au_repos = 6;
inline bool MsgLogMaintenanceEquipmentAvailability::has_nbr_au_repos() const {
  return _has_bit(5);
}
inline void MsgLogMaintenanceEquipmentAvailability::clear_nbr_au_repos() {
  nbr_au_repos_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgLogMaintenanceEquipmentAvailability::nbr_au_repos() const {
  return nbr_au_repos_;
}
inline void MsgLogMaintenanceEquipmentAvailability::set_nbr_au_repos(::google::protobuf::int32 value) {
  _set_bit(5);
  nbr_au_repos_ = value;
}

// -------------------------------------------------------------------

// SeqOfLogMaintenanceEquipmentAvailability

// repeated .MsgsSimToClient.MsgLogMaintenanceEquipmentAvailability elem = 1;
inline int SeqOfLogMaintenanceEquipmentAvailability::elem_size() const {
  return elem_.size();
}
inline void SeqOfLogMaintenanceEquipmentAvailability::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability >&
SeqOfLogMaintenanceEquipmentAvailability::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability >*
SeqOfLogMaintenanceEquipmentAvailability::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability& SeqOfLogMaintenanceEquipmentAvailability::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability* SeqOfLogMaintenanceEquipmentAvailability::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgLogMaintenanceEquipmentAvailability* SeqOfLogMaintenanceEquipmentAvailability::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgLogMaintenanceState

// required .Common.UnitId id = 1;
inline bool MsgLogMaintenanceState::has_id() const {
  return _has_bit(0);
}
inline void MsgLogMaintenanceState::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgLogMaintenanceState::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgLogMaintenanceState::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// optional bool chaine_activee = 2;
inline bool MsgLogMaintenanceState::has_chaine_activee() const {
  return _has_bit(1);
}
inline void MsgLogMaintenanceState::clear_chaine_activee() {
  chaine_activee_ = false;
  _clear_bit(1);
}
inline bool MsgLogMaintenanceState::chaine_activee() const {
  return chaine_activee_;
}
inline void MsgLogMaintenanceState::set_chaine_activee(bool value) {
  _set_bit(1);
  chaine_activee_ = value;
}

// optional .Common.EnumLogMaintenanceRegimeTravail regime_travail = 3;
inline bool MsgLogMaintenanceState::has_regime_travail() const {
  return _has_bit(2);
}
inline void MsgLogMaintenanceState::clear_regime_travail() {
  regime_travail_ = 0;
  _clear_bit(2);
}
inline Common::EnumLogMaintenanceRegimeTravail MsgLogMaintenanceState::regime_travail() const {
  return static_cast< Common::EnumLogMaintenanceRegimeTravail >(regime_travail_);
}
inline void MsgLogMaintenanceState::set_regime_travail(Common::EnumLogMaintenanceRegimeTravail value) {
  GOOGLE_DCHECK(Common::EnumLogMaintenanceRegimeTravail_IsValid(value));
  _set_bit(2);
  regime_travail_ = value;
}

// optional .Common.MsgLogMaintenancePriorities priorites = 4;
inline bool MsgLogMaintenanceState::has_priorites() const {
  return _has_bit(3);
}
inline void MsgLogMaintenanceState::clear_priorites() {
  if (priorites_ != NULL) priorites_->::Common::MsgLogMaintenancePriorities::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgLogMaintenancePriorities& MsgLogMaintenanceState::priorites() const {
  return priorites_ != NULL ? *priorites_ : *default_instance_->priorites_;
}
inline ::Common::MsgLogMaintenancePriorities* MsgLogMaintenanceState::mutable_priorites() {
  _set_bit(3);
  if (priorites_ == NULL) priorites_ = new ::Common::MsgLogMaintenancePriorities;
  return priorites_;
}

// optional .Common.AutomatIdList priorites_tactiques = 5;
inline bool MsgLogMaintenanceState::has_priorites_tactiques() const {
  return _has_bit(4);
}
inline void MsgLogMaintenanceState::clear_priorites_tactiques() {
  if (priorites_tactiques_ != NULL) priorites_tactiques_->::Common::AutomatIdList::Clear();
  _clear_bit(4);
}
inline const ::Common::AutomatIdList& MsgLogMaintenanceState::priorites_tactiques() const {
  return priorites_tactiques_ != NULL ? *priorites_tactiques_ : *default_instance_->priorites_tactiques_;
}
inline ::Common::AutomatIdList* MsgLogMaintenanceState::mutable_priorites_tactiques() {
  _set_bit(4);
  if (priorites_tactiques_ == NULL) priorites_tactiques_ = new ::Common::AutomatIdList;
  return priorites_tactiques_;
}

// optional .MsgsSimToClient.SeqOfLogMaintenanceEquipmentAvailability disponibilites_remorqueurs = 6;
inline bool MsgLogMaintenanceState::has_disponibilites_remorqueurs() const {
  return _has_bit(5);
}
inline void MsgLogMaintenanceState::clear_disponibilites_remorqueurs() {
  if (disponibilites_remorqueurs_ != NULL) disponibilites_remorqueurs_->::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability::Clear();
  _clear_bit(5);
}
inline const ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability& MsgLogMaintenanceState::disponibilites_remorqueurs() const {
  return disponibilites_remorqueurs_ != NULL ? *disponibilites_remorqueurs_ : *default_instance_->disponibilites_remorqueurs_;
}
inline ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* MsgLogMaintenanceState::mutable_disponibilites_remorqueurs() {
  _set_bit(5);
  if (disponibilites_remorqueurs_ == NULL) disponibilites_remorqueurs_ = new ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability;
  return disponibilites_remorqueurs_;
}

// optional .MsgsSimToClient.SeqOfLogMaintenanceEquipmentAvailability disponibilites_reparateurs = 7;
inline bool MsgLogMaintenanceState::has_disponibilites_reparateurs() const {
  return _has_bit(6);
}
inline void MsgLogMaintenanceState::clear_disponibilites_reparateurs() {
  if (disponibilites_reparateurs_ != NULL) disponibilites_reparateurs_->::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability::Clear();
  _clear_bit(6);
}
inline const ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability& MsgLogMaintenanceState::disponibilites_reparateurs() const {
  return disponibilites_reparateurs_ != NULL ? *disponibilites_reparateurs_ : *default_instance_->disponibilites_reparateurs_;
}
inline ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability* MsgLogMaintenanceState::mutable_disponibilites_reparateurs() {
  _set_bit(6);
  if (disponibilites_reparateurs_ == NULL) disponibilites_reparateurs_ = new ::MsgsSimToClient::SeqOfLogMaintenanceEquipmentAvailability;
  return disponibilites_reparateurs_;
}

// -------------------------------------------------------------------

// MsgLogSupplyHandlingCreation

// optional .Common.SupplyRequestId id = 1;
inline bool MsgLogSupplyHandlingCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgLogSupplyHandlingCreation::clear_id() {
  if (id_ != NULL) id_->::Common::SupplyRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::SupplyRequestId& MsgLogSupplyHandlingCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::SupplyRequestId* MsgLogSupplyHandlingCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::SupplyRequestId;
  return id_;
}

// optional .Common.AutomatId consumer = 2;
inline bool MsgLogSupplyHandlingCreation::has_consumer() const {
  return _has_bit(1);
}
inline void MsgLogSupplyHandlingCreation::clear_consumer() {
  if (consumer_ != NULL) consumer_->::Common::AutomatId::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingCreation::consumer() const {
  return consumer_ != NULL ? *consumer_ : *default_instance_->consumer_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingCreation::mutable_consumer() {
  _set_bit(1);
  if (consumer_ == NULL) consumer_ = new ::Common::AutomatId;
  return consumer_;
}

// optional int32 tick_creation = 3;
inline bool MsgLogSupplyHandlingCreation::has_tick_creation() const {
  return _has_bit(2);
}
inline void MsgLogSupplyHandlingCreation::clear_tick_creation() {
  tick_creation_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogSupplyHandlingCreation::tick_creation() const {
  return tick_creation_;
}
inline void MsgLogSupplyHandlingCreation::set_tick_creation(::google::protobuf::int32 value) {
  _set_bit(2);
  tick_creation_ = value;
}

// optional .MsgsSimToClient.SeqOfDotationQuery dotations = 4;
inline bool MsgLogSupplyHandlingCreation::has_dotations() const {
  return _has_bit(3);
}
inline void MsgLogSupplyHandlingCreation::clear_dotations() {
  if (dotations_ != NULL) dotations_->::MsgsSimToClient::SeqOfDotationQuery::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::SeqOfDotationQuery& MsgLogSupplyHandlingCreation::dotations() const {
  return dotations_ != NULL ? *dotations_ : *default_instance_->dotations_;
}
inline ::MsgsSimToClient::SeqOfDotationQuery* MsgLogSupplyHandlingCreation::mutable_dotations() {
  _set_bit(3);
  if (dotations_ == NULL) dotations_ = new ::MsgsSimToClient::SeqOfDotationQuery;
  return dotations_;
}

// -------------------------------------------------------------------

// MsgDotationQuery

// optional .Common.ResourceType resource = 1;
inline bool MsgDotationQuery::has_resource() const {
  return _has_bit(0);
}
inline void MsgDotationQuery::clear_resource() {
  if (resource_ != NULL) resource_->::Common::ResourceType::Clear();
  _clear_bit(0);
}
inline const ::Common::ResourceType& MsgDotationQuery::resource() const {
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::Common::ResourceType* MsgDotationQuery::mutable_resource() {
  _set_bit(0);
  if (resource_ == NULL) resource_ = new ::Common::ResourceType;
  return resource_;
}

// optional int32 quantite_demandee = 2;
inline bool MsgDotationQuery::has_quantite_demandee() const {
  return _has_bit(1);
}
inline void MsgDotationQuery::clear_quantite_demandee() {
  quantite_demandee_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgDotationQuery::quantite_demandee() const {
  return quantite_demandee_;
}
inline void MsgDotationQuery::set_quantite_demandee(::google::protobuf::int32 value) {
  _set_bit(1);
  quantite_demandee_ = value;
}

// optional int32 quantite_accordee = 3;
inline bool MsgDotationQuery::has_quantite_accordee() const {
  return _has_bit(2);
}
inline void MsgDotationQuery::clear_quantite_accordee() {
  quantite_accordee_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgDotationQuery::quantite_accordee() const {
  return quantite_accordee_;
}
inline void MsgDotationQuery::set_quantite_accordee(::google::protobuf::int32 value) {
  _set_bit(2);
  quantite_accordee_ = value;
}

// optional int32 quantite_en_transit = 4;
inline bool MsgDotationQuery::has_quantite_en_transit() const {
  return _has_bit(3);
}
inline void MsgDotationQuery::clear_quantite_en_transit() {
  quantite_en_transit_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgDotationQuery::quantite_en_transit() const {
  return quantite_en_transit_;
}
inline void MsgDotationQuery::set_quantite_en_transit(::google::protobuf::int32 value) {
  _set_bit(3);
  quantite_en_transit_ = value;
}

// -------------------------------------------------------------------

// SeqOfDotationQuery

// repeated .MsgsSimToClient.MsgDotationQuery elem = 1;
inline int SeqOfDotationQuery::elem_size() const {
  return elem_.size();
}
inline void SeqOfDotationQuery::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery >&
SeqOfDotationQuery::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgDotationQuery >*
SeqOfDotationQuery::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgDotationQuery& SeqOfDotationQuery::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgDotationQuery* SeqOfDotationQuery::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgDotationQuery* SeqOfDotationQuery::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgLogSupplyHandlingUpdate

// optional .Common.SupplyRequestId id = 1;
inline bool MsgLogSupplyHandlingUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgLogSupplyHandlingUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::SupplyRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::SupplyRequestId& MsgLogSupplyHandlingUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::SupplyRequestId* MsgLogSupplyHandlingUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::SupplyRequestId;
  return id_;
}

// optional .Common.AutomatId consumer = 2;
inline bool MsgLogSupplyHandlingUpdate::has_consumer() const {
  return _has_bit(1);
}
inline void MsgLogSupplyHandlingUpdate::clear_consumer() {
  if (consumer_ != NULL) consumer_->::Common::AutomatId::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingUpdate::consumer() const {
  return consumer_ != NULL ? *consumer_ : *default_instance_->consumer_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingUpdate::mutable_consumer() {
  _set_bit(1);
  if (consumer_ == NULL) consumer_ = new ::Common::AutomatId;
  return consumer_;
}

// optional .Common.AutomatId supplier = 3;
inline bool MsgLogSupplyHandlingUpdate::has_supplier() const {
  return _has_bit(2);
}
inline void MsgLogSupplyHandlingUpdate::clear_supplier() {
  if (supplier_ != NULL) supplier_->::Common::AutomatId::Clear();
  _clear_bit(2);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingUpdate::supplier() const {
  return supplier_ != NULL ? *supplier_ : *default_instance_->supplier_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingUpdate::mutable_supplier() {
  _set_bit(2);
  if (supplier_ == NULL) supplier_ = new ::Common::AutomatId;
  return supplier_;
}

// optional .Common.AutomatId convoy_provider = 4;
inline bool MsgLogSupplyHandlingUpdate::has_convoy_provider() const {
  return _has_bit(3);
}
inline void MsgLogSupplyHandlingUpdate::clear_convoy_provider() {
  if (convoy_provider_ != NULL) convoy_provider_->::Common::AutomatId::Clear();
  _clear_bit(3);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingUpdate::convoy_provider() const {
  return convoy_provider_ != NULL ? *convoy_provider_ : *default_instance_->convoy_provider_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingUpdate::mutable_convoy_provider() {
  _set_bit(3);
  if (convoy_provider_ == NULL) convoy_provider_ = new ::Common::AutomatId;
  return convoy_provider_;
}

// optional .Common.UnitId convoying_unit = 5;
inline bool MsgLogSupplyHandlingUpdate::has_convoying_unit() const {
  return _has_bit(4);
}
inline void MsgLogSupplyHandlingUpdate::clear_convoying_unit() {
  if (convoying_unit_ != NULL) convoying_unit_->::Common::UnitId::Clear();
  _clear_bit(4);
}
inline const ::Common::UnitId& MsgLogSupplyHandlingUpdate::convoying_unit() const {
  return convoying_unit_ != NULL ? *convoying_unit_ : *default_instance_->convoying_unit_;
}
inline ::Common::UnitId* MsgLogSupplyHandlingUpdate::mutable_convoying_unit() {
  _set_bit(4);
  if (convoying_unit_ == NULL) convoying_unit_ = new ::Common::UnitId;
  return convoying_unit_;
}

// optional .MsgsSimToClient.EnumLogSupplyHandlingStatus etat = 6;
inline bool MsgLogSupplyHandlingUpdate::has_etat() const {
  return _has_bit(5);
}
inline void MsgLogSupplyHandlingUpdate::clear_etat() {
  etat_ = 1;
  _clear_bit(5);
}
inline MsgsSimToClient::EnumLogSupplyHandlingStatus MsgLogSupplyHandlingUpdate::etat() const {
  return static_cast< MsgsSimToClient::EnumLogSupplyHandlingStatus >(etat_);
}
inline void MsgLogSupplyHandlingUpdate::set_etat(MsgsSimToClient::EnumLogSupplyHandlingStatus value) {
  GOOGLE_DCHECK(MsgsSimToClient::EnumLogSupplyHandlingStatus_IsValid(value));
  _set_bit(5);
  etat_ = value;
}

// optional .MsgsSimToClient.SeqOfDotationQuery dotations = 7;
inline bool MsgLogSupplyHandlingUpdate::has_dotations() const {
  return _has_bit(6);
}
inline void MsgLogSupplyHandlingUpdate::clear_dotations() {
  if (dotations_ != NULL) dotations_->::MsgsSimToClient::SeqOfDotationQuery::Clear();
  _clear_bit(6);
}
inline const ::MsgsSimToClient::SeqOfDotationQuery& MsgLogSupplyHandlingUpdate::dotations() const {
  return dotations_ != NULL ? *dotations_ : *default_instance_->dotations_;
}
inline ::MsgsSimToClient::SeqOfDotationQuery* MsgLogSupplyHandlingUpdate::mutable_dotations() {
  _set_bit(6);
  if (dotations_ == NULL) dotations_ = new ::MsgsSimToClient::SeqOfDotationQuery;
  return dotations_;
}

// -------------------------------------------------------------------

// MsgLogSupplyHandlingDestruction

// required .Common.SupplyRequestId id = 1;
inline bool MsgLogSupplyHandlingDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgLogSupplyHandlingDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::SupplyRequestId::Clear();
  _clear_bit(0);
}
inline const ::Common::SupplyRequestId& MsgLogSupplyHandlingDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::SupplyRequestId* MsgLogSupplyHandlingDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::SupplyRequestId;
  return id_;
}

// required .Common.AutomatId consumer = 2;
inline bool MsgLogSupplyHandlingDestruction::has_consumer() const {
  return _has_bit(1);
}
inline void MsgLogSupplyHandlingDestruction::clear_consumer() {
  if (consumer_ != NULL) consumer_->::Common::AutomatId::Clear();
  _clear_bit(1);
}
inline const ::Common::AutomatId& MsgLogSupplyHandlingDestruction::consumer() const {
  return consumer_ != NULL ? *consumer_ : *default_instance_->consumer_;
}
inline ::Common::AutomatId* MsgLogSupplyHandlingDestruction::mutable_consumer() {
  _set_bit(1);
  if (consumer_ == NULL) consumer_ = new ::Common::AutomatId;
  return consumer_;
}

// -------------------------------------------------------------------

// MsgLogSupplyEquimentAvailability

// optional .Common.EquipmentType equipment = 1;
inline bool MsgLogSupplyEquimentAvailability::has_equipment() const {
  return _has_bit(0);
}
inline void MsgLogSupplyEquimentAvailability::clear_equipment() {
  if (equipment_ != NULL) equipment_->::Common::EquipmentType::Clear();
  _clear_bit(0);
}
inline const ::Common::EquipmentType& MsgLogSupplyEquimentAvailability::equipment() const {
  return equipment_ != NULL ? *equipment_ : *default_instance_->equipment_;
}
inline ::Common::EquipmentType* MsgLogSupplyEquimentAvailability::mutable_equipment() {
  _set_bit(0);
  if (equipment_ == NULL) equipment_ = new ::Common::EquipmentType;
  return equipment_;
}

// optional int32 nbr_total = 2;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_total() const {
  return _has_bit(1);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_total() {
  nbr_total_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_total() const {
  return nbr_total_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_total(::google::protobuf::int32 value) {
  _set_bit(1);
  nbr_total_ = value;
}

// optional int32 nbr_disponibles = 3;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_disponibles() const {
  return _has_bit(2);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_disponibles() {
  nbr_disponibles_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_disponibles() const {
  return nbr_disponibles_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_disponibles(::google::protobuf::int32 value) {
  _set_bit(2);
  nbr_disponibles_ = value;
}

// optional int32 nbr_au_travail = 4;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_au_travail() const {
  return _has_bit(3);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_au_travail() {
  nbr_au_travail_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_au_travail() const {
  return nbr_au_travail_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_au_travail(::google::protobuf::int32 value) {
  _set_bit(3);
  nbr_au_travail_ = value;
}

// optional int32 nbr_pretes = 5 [default = 0];
inline bool MsgLogSupplyEquimentAvailability::has_nbr_pretes() const {
  return _has_bit(4);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_pretes() {
  nbr_pretes_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_pretes() const {
  return nbr_pretes_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_pretes(::google::protobuf::int32 value) {
  _set_bit(4);
  nbr_pretes_ = value;
}

// optional int32 nbr_au_repos = 6;
inline bool MsgLogSupplyEquimentAvailability::has_nbr_au_repos() const {
  return _has_bit(5);
}
inline void MsgLogSupplyEquimentAvailability::clear_nbr_au_repos() {
  nbr_au_repos_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgLogSupplyEquimentAvailability::nbr_au_repos() const {
  return nbr_au_repos_;
}
inline void MsgLogSupplyEquimentAvailability::set_nbr_au_repos(::google::protobuf::int32 value) {
  _set_bit(5);
  nbr_au_repos_ = value;
}

// -------------------------------------------------------------------

// SeqOfLogSupplyEquimentAvailability

// repeated .MsgsSimToClient.MsgLogSupplyEquimentAvailability elem = 1;
inline int SeqOfLogSupplyEquimentAvailability::elem_size() const {
  return elem_.size();
}
inline void SeqOfLogSupplyEquimentAvailability::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability >&
SeqOfLogSupplyEquimentAvailability::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgLogSupplyEquimentAvailability >*
SeqOfLogSupplyEquimentAvailability::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgLogSupplyEquimentAvailability& SeqOfLogSupplyEquimentAvailability::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgLogSupplyEquimentAvailability* SeqOfLogSupplyEquimentAvailability::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgLogSupplyEquimentAvailability* SeqOfLogSupplyEquimentAvailability::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgLogSupplyState

// optional .Common.UnitId id = 1;
inline bool MsgLogSupplyState::has_id() const {
  return _has_bit(0);
}
inline void MsgLogSupplyState::clear_id() {
  if (id_ != NULL) id_->::Common::UnitId::Clear();
  _clear_bit(0);
}
inline const ::Common::UnitId& MsgLogSupplyState::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::UnitId* MsgLogSupplyState::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::UnitId;
  return id_;
}

// optional bool chaine_activee = 2;
inline bool MsgLogSupplyState::has_chaine_activee() const {
  return _has_bit(1);
}
inline void MsgLogSupplyState::clear_chaine_activee() {
  chaine_activee_ = false;
  _clear_bit(1);
}
inline bool MsgLogSupplyState::chaine_activee() const {
  return chaine_activee_;
}
inline void MsgLogSupplyState::set_chaine_activee(bool value) {
  _set_bit(1);
  chaine_activee_ = value;
}

// optional .Common.SeqOfDotationStock stocks = 3;
inline bool MsgLogSupplyState::has_stocks() const {
  return _has_bit(2);
}
inline void MsgLogSupplyState::clear_stocks() {
  if (stocks_ != NULL) stocks_->::Common::SeqOfDotationStock::Clear();
  _clear_bit(2);
}
inline const ::Common::SeqOfDotationStock& MsgLogSupplyState::stocks() const {
  return stocks_ != NULL ? *stocks_ : *default_instance_->stocks_;
}
inline ::Common::SeqOfDotationStock* MsgLogSupplyState::mutable_stocks() {
  _set_bit(2);
  if (stocks_ == NULL) stocks_ = new ::Common::SeqOfDotationStock;
  return stocks_;
}

// optional .MsgsSimToClient.SeqOfLogSupplyEquimentAvailability disponibilites_transporteurs_convois = 4;
inline bool MsgLogSupplyState::has_disponibilites_transporteurs_convois() const {
  return _has_bit(3);
}
inline void MsgLogSupplyState::clear_disponibilites_transporteurs_convois() {
  if (disponibilites_transporteurs_convois_ != NULL) disponibilites_transporteurs_convois_->::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability& MsgLogSupplyState::disponibilites_transporteurs_convois() const {
  return disponibilites_transporteurs_convois_ != NULL ? *disponibilites_transporteurs_convois_ : *default_instance_->disponibilites_transporteurs_convois_;
}
inline ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability* MsgLogSupplyState::mutable_disponibilites_transporteurs_convois() {
  _set_bit(3);
  if (disponibilites_transporteurs_convois_ == NULL) disponibilites_transporteurs_convois_ = new ::MsgsSimToClient::SeqOfLogSupplyEquimentAvailability;
  return disponibilites_transporteurs_convois_;
}

// -------------------------------------------------------------------

// MsgLogSupplyQuotas

// required .Common.AutomatId id = 1;
inline bool MsgLogSupplyQuotas::has_id() const {
  return _has_bit(0);
}
inline void MsgLogSupplyQuotas::clear_id() {
  if (id_ != NULL) id_->::Common::AutomatId::Clear();
  _clear_bit(0);
}
inline const ::Common::AutomatId& MsgLogSupplyQuotas::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::AutomatId* MsgLogSupplyQuotas::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::AutomatId;
  return id_;
}

// required .Common.SeqOfDotationQuota quotas = 2;
inline bool MsgLogSupplyQuotas::has_quotas() const {
  return _has_bit(1);
}
inline void MsgLogSupplyQuotas::clear_quotas() {
  if (quotas_ != NULL) quotas_->::Common::SeqOfDotationQuota::Clear();
  _clear_bit(1);
}
inline const ::Common::SeqOfDotationQuota& MsgLogSupplyQuotas::quotas() const {
  return quotas_ != NULL ? *quotas_ : *default_instance_->quotas_;
}
inline ::Common::SeqOfDotationQuota* MsgLogSupplyQuotas::mutable_quotas() {
  _set_bit(1);
  if (quotas_ == NULL) quotas_ = new ::Common::SeqOfDotationQuota;
  return quotas_;
}

// -------------------------------------------------------------------

// MsgPopulationCreation

// required .Common.PopulationId id = 1;
inline bool MsgPopulationCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationCreation::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationId& MsgPopulationCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationId* MsgPopulationCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationId;
  return id_;
}

// required .Common.PopulationType type = 2;
inline bool MsgPopulationCreation::has_type() const {
  return _has_bit(1);
}
inline void MsgPopulationCreation::clear_type() {
  if (type_ != NULL) type_->::Common::PopulationType::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationType& MsgPopulationCreation::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::Common::PopulationType* MsgPopulationCreation::mutable_type() {
  _set_bit(1);
  if (type_ == NULL) type_ = new ::Common::PopulationType;
  return type_;
}

// optional string nom = 3;
inline bool MsgPopulationCreation::has_nom() const {
  return _has_bit(2);
}
inline void MsgPopulationCreation::clear_nom() {
  if (nom_ != &_default_nom_) {
    nom_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgPopulationCreation::nom() const {
  return *nom_;
}
inline void MsgPopulationCreation::set_nom(const ::std::string& value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgPopulationCreation::set_nom(const char* value) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(value);
}
inline void MsgPopulationCreation::set_nom(const char* value, size_t size) {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  nom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPopulationCreation::mutable_nom() {
  _set_bit(2);
  if (nom_ == &_default_nom_) {
    nom_ = new ::std::string;
  }
  return nom_;
}

// required .Common.PartyId party = 4;
inline bool MsgPopulationCreation::has_party() const {
  return _has_bit(3);
}
inline void MsgPopulationCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(3);
}
inline const ::Common::PartyId& MsgPopulationCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgPopulationCreation::mutable_party() {
  _set_bit(3);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgPopulationUpdate

// required .Common.PopulationId id = 1;
inline bool MsgPopulationUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationId& MsgPopulationUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationId* MsgPopulationUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationId;
  return id_;
}

// optional int32 etat_domination = 2 [default = 0];
inline bool MsgPopulationUpdate::has_etat_domination() const {
  return _has_bit(1);
}
inline void MsgPopulationUpdate::clear_etat_domination() {
  etat_domination_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgPopulationUpdate::etat_domination() const {
  return etat_domination_;
}
inline void MsgPopulationUpdate::set_etat_domination(::google::protobuf::int32 value) {
  _set_bit(1);
  etat_domination_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationConcentrationCreation

// required .Common.PopulationConcentrationId id = 1;
inline bool MsgPopulationConcentrationCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationConcentrationCreation::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationConcentrationId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationConcentrationId& MsgPopulationConcentrationCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationConcentrationId* MsgPopulationConcentrationCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationConcentrationId;
  return id_;
}

// required .Common.PopulationId population = 2;
inline bool MsgPopulationConcentrationCreation::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationConcentrationCreation::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgPopulationConcentrationCreation::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationId* MsgPopulationConcentrationCreation::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationId;
  return population_;
}

// required .Common.MsgCoordLatLong position = 3;
inline bool MsgPopulationConcentrationCreation::has_position() const {
  return _has_bit(2);
}
inline void MsgPopulationConcentrationCreation::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgCoordLatLong& MsgPopulationConcentrationCreation::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgPopulationConcentrationCreation::mutable_position() {
  _set_bit(2);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// -------------------------------------------------------------------

// MsgPopulationConcentrationDestruction

// required .Common.PopulationConcentrationId id = 1;
inline bool MsgPopulationConcentrationDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationConcentrationDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationConcentrationId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationConcentrationId& MsgPopulationConcentrationDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationConcentrationId* MsgPopulationConcentrationDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationConcentrationId;
  return id_;
}

// required .Common.PopulationId population = 2;
inline bool MsgPopulationConcentrationDestruction::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationConcentrationDestruction::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgPopulationConcentrationDestruction::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationId* MsgPopulationConcentrationDestruction::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationId;
  return population_;
}

// -------------------------------------------------------------------

// MsgPopulationConcentrationUpdate

// required .Common.PopulationConcentrationId id = 1;
inline bool MsgPopulationConcentrationUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationConcentrationUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationConcentrationId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationConcentrationId& MsgPopulationConcentrationUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationConcentrationId* MsgPopulationConcentrationUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationConcentrationId;
  return id_;
}

// required .Common.PopulationId population = 2;
inline bool MsgPopulationConcentrationUpdate::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationConcentrationUpdate::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgPopulationConcentrationUpdate::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationId* MsgPopulationConcentrationUpdate::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationId;
  return population_;
}

// optional int32 nb_humains_vivants = 3 [default = 0];
inline bool MsgPopulationConcentrationUpdate::has_nb_humains_vivants() const {
  return _has_bit(2);
}
inline void MsgPopulationConcentrationUpdate::clear_nb_humains_vivants() {
  nb_humains_vivants_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgPopulationConcentrationUpdate::nb_humains_vivants() const {
  return nb_humains_vivants_;
}
inline void MsgPopulationConcentrationUpdate::set_nb_humains_vivants(::google::protobuf::int32 value) {
  _set_bit(2);
  nb_humains_vivants_ = value;
}

// optional int32 nb_humains_morts = 4 [default = 0];
inline bool MsgPopulationConcentrationUpdate::has_nb_humains_morts() const {
  return _has_bit(3);
}
inline void MsgPopulationConcentrationUpdate::clear_nb_humains_morts() {
  nb_humains_morts_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgPopulationConcentrationUpdate::nb_humains_morts() const {
  return nb_humains_morts_;
}
inline void MsgPopulationConcentrationUpdate::set_nb_humains_morts(::google::protobuf::int32 value) {
  _set_bit(3);
  nb_humains_morts_ = value;
}

// optional .Common.EnumPopulationAttitude attitude = 5;
inline bool MsgPopulationConcentrationUpdate::has_attitude() const {
  return _has_bit(4);
}
inline void MsgPopulationConcentrationUpdate::clear_attitude() {
  attitude_ = 0;
  _clear_bit(4);
}
inline Common::EnumPopulationAttitude MsgPopulationConcentrationUpdate::attitude() const {
  return static_cast< Common::EnumPopulationAttitude >(attitude_);
}
inline void MsgPopulationConcentrationUpdate::set_attitude(Common::EnumPopulationAttitude value) {
  GOOGLE_DCHECK(Common::EnumPopulationAttitude_IsValid(value));
  _set_bit(4);
  attitude_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationFlowCreation

// required .Common.PopulationFlowId id = 1;
inline bool MsgPopulationFlowCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationFlowCreation::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationFlowId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationFlowId& MsgPopulationFlowCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationFlowId* MsgPopulationFlowCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationFlowId;
  return id_;
}

// required .Common.PopulationId population = 2;
inline bool MsgPopulationFlowCreation::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationFlowCreation::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgPopulationFlowCreation::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationId* MsgPopulationFlowCreation::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationId;
  return population_;
}

// -------------------------------------------------------------------

// MsgPopulationFlowDestruction

// required .Common.PopulationFlowId id = 1;
inline bool MsgPopulationFlowDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationFlowDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationFlowId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationFlowId& MsgPopulationFlowDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationFlowId* MsgPopulationFlowDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationFlowId;
  return id_;
}

// required .Common.PopulationId population = 2;
inline bool MsgPopulationFlowDestruction::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationFlowDestruction::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgPopulationFlowDestruction::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationId* MsgPopulationFlowDestruction::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationId;
  return population_;
}

// -------------------------------------------------------------------

// MsgPopulationFlowUpdate

// required .Common.PopulationFlowId id = 1;
inline bool MsgPopulationFlowUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationFlowUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationFlowId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationFlowId& MsgPopulationFlowUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationFlowId* MsgPopulationFlowUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationFlowId;
  return id_;
}

// required .Common.PopulationId population = 2;
inline bool MsgPopulationFlowUpdate::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationFlowUpdate::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationId& MsgPopulationFlowUpdate::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationId* MsgPopulationFlowUpdate::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationId;
  return population_;
}

// optional .Common.MsgPath itineraire = 3;
inline bool MsgPopulationFlowUpdate::has_itineraire() const {
  return _has_bit(2);
}
inline void MsgPopulationFlowUpdate::clear_itineraire() {
  if (itineraire_ != NULL) itineraire_->::Common::MsgPath::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgPath& MsgPopulationFlowUpdate::itineraire() const {
  return itineraire_ != NULL ? *itineraire_ : *default_instance_->itineraire_;
}
inline ::Common::MsgPath* MsgPopulationFlowUpdate::mutable_itineraire() {
  _set_bit(2);
  if (itineraire_ == NULL) itineraire_ = new ::Common::MsgPath;
  return itineraire_;
}

// optional .Common.MsgPath flux = 4;
inline bool MsgPopulationFlowUpdate::has_flux() const {
  return _has_bit(3);
}
inline void MsgPopulationFlowUpdate::clear_flux() {
  if (flux_ != NULL) flux_->::Common::MsgPath::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgPath& MsgPopulationFlowUpdate::flux() const {
  return flux_ != NULL ? *flux_ : *default_instance_->flux_;
}
inline ::Common::MsgPath* MsgPopulationFlowUpdate::mutable_flux() {
  _set_bit(3);
  if (flux_ == NULL) flux_ = new ::Common::MsgPath;
  return flux_;
}

// optional .Common.MsgHeading direction = 5;
inline bool MsgPopulationFlowUpdate::has_direction() const {
  return _has_bit(4);
}
inline void MsgPopulationFlowUpdate::clear_direction() {
  if (direction_ != NULL) direction_->::Common::MsgHeading::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgHeading& MsgPopulationFlowUpdate::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Common::MsgHeading* MsgPopulationFlowUpdate::mutable_direction() {
  _set_bit(4);
  if (direction_ == NULL) direction_ = new ::Common::MsgHeading;
  return direction_;
}

// optional int32 vitesse = 6 [default = 0];
inline bool MsgPopulationFlowUpdate::has_vitesse() const {
  return _has_bit(5);
}
inline void MsgPopulationFlowUpdate::clear_vitesse() {
  vitesse_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgPopulationFlowUpdate::vitesse() const {
  return vitesse_;
}
inline void MsgPopulationFlowUpdate::set_vitesse(::google::protobuf::int32 value) {
  _set_bit(5);
  vitesse_ = value;
}

// optional int32 nb_humains_vivants = 7 [default = 0];
inline bool MsgPopulationFlowUpdate::has_nb_humains_vivants() const {
  return _has_bit(6);
}
inline void MsgPopulationFlowUpdate::clear_nb_humains_vivants() {
  nb_humains_vivants_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 MsgPopulationFlowUpdate::nb_humains_vivants() const {
  return nb_humains_vivants_;
}
inline void MsgPopulationFlowUpdate::set_nb_humains_vivants(::google::protobuf::int32 value) {
  _set_bit(6);
  nb_humains_vivants_ = value;
}

// optional int32 nb_humains_morts = 8 [default = 0];
inline bool MsgPopulationFlowUpdate::has_nb_humains_morts() const {
  return _has_bit(7);
}
inline void MsgPopulationFlowUpdate::clear_nb_humains_morts() {
  nb_humains_morts_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MsgPopulationFlowUpdate::nb_humains_morts() const {
  return nb_humains_morts_;
}
inline void MsgPopulationFlowUpdate::set_nb_humains_morts(::google::protobuf::int32 value) {
  _set_bit(7);
  nb_humains_morts_ = value;
}

// optional .Common.EnumPopulationAttitude attitude = 9;
inline bool MsgPopulationFlowUpdate::has_attitude() const {
  return _has_bit(8);
}
inline void MsgPopulationFlowUpdate::clear_attitude() {
  attitude_ = 0;
  _clear_bit(8);
}
inline Common::EnumPopulationAttitude MsgPopulationFlowUpdate::attitude() const {
  return static_cast< Common::EnumPopulationAttitude >(attitude_);
}
inline void MsgPopulationFlowUpdate::set_attitude(Common::EnumPopulationAttitude value) {
  GOOGLE_DCHECK(Common::EnumPopulationAttitude_IsValid(value));
  _set_bit(8);
  attitude_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationKnowledgeCreation

// required .Common.PopulationKnowledgeId id = 1;
inline bool MsgPopulationKnowledgeCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationKnowledgeCreation::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationKnowledgeCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationKnowledgeCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationKnowledgeId;
  return id_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgPopulationKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgPopulationKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional .Common.PopulationId population = 3;
inline bool MsgPopulationKnowledgeCreation::has_population() const {
  return _has_bit(2);
}
inline void MsgPopulationKnowledgeCreation::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationId::Clear();
  _clear_bit(2);
}
inline const ::Common::PopulationId& MsgPopulationKnowledgeCreation::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationId* MsgPopulationKnowledgeCreation::mutable_population() {
  _set_bit(2);
  if (population_ == NULL) population_ = new ::Common::PopulationId;
  return population_;
}

// optional .Common.PartyId party = 4;
inline bool MsgPopulationKnowledgeCreation::has_party() const {
  return _has_bit(3);
}
inline void MsgPopulationKnowledgeCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(3);
}
inline const ::Common::PartyId& MsgPopulationKnowledgeCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgPopulationKnowledgeCreation::mutable_party() {
  _set_bit(3);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgPopulationKnowledgeUpdate

// required .Common.PopulationKnowledgeId id = 1;
inline bool MsgPopulationKnowledgeUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationKnowledgeUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationKnowledgeUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationKnowledgeUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationKnowledgeId;
  return id_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgPopulationKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgPopulationKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional int32 etat_domination = 3 [default = 0];
inline bool MsgPopulationKnowledgeUpdate::has_etat_domination() const {
  return _has_bit(2);
}
inline void MsgPopulationKnowledgeUpdate::clear_etat_domination() {
  etat_domination_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgPopulationKnowledgeUpdate::etat_domination() const {
  return etat_domination_;
}
inline void MsgPopulationKnowledgeUpdate::set_etat_domination(::google::protobuf::int32 value) {
  _set_bit(2);
  etat_domination_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationKnowledgeDestruction

// required .Common.PopulationKnowledgeId id = 1;
inline bool MsgPopulationKnowledgeDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationKnowledgeDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationKnowledgeDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationKnowledgeDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationKnowledgeId;
  return id_;
}

// required .Common.KnowledgeGroupId knowledge_group = 2;
inline bool MsgPopulationKnowledgeDestruction::has_knowledge_group() const {
  return _has_bit(1);
}
inline void MsgPopulationKnowledgeDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(1);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationKnowledgeDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationKnowledgeDestruction::mutable_knowledge_group() {
  _set_bit(1);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgPopulationConcentrationKnowledgeCreation

// required .Common.PopulationConcentrationKnowledgeId id = 1;
inline bool MsgPopulationConcentrationKnowledgeCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationConcentrationKnowledgeCreation::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationConcentrationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationConcentrationKnowledgeId& MsgPopulationConcentrationKnowledgeCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationConcentrationKnowledgeId* MsgPopulationConcentrationKnowledgeCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationConcentrationKnowledgeId;
  return id_;
}

// required .Common.PopulationKnowledgeId population = 2;
inline bool MsgPopulationConcentrationKnowledgeCreation::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationConcentrationKnowledgeCreation::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationConcentrationKnowledgeCreation::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationConcentrationKnowledgeCreation::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationKnowledgeId;
  return population_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgPopulationConcentrationKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgPopulationConcentrationKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationConcentrationKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationConcentrationKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .Common.PopulationConcentrationId concentration = 4;
inline bool MsgPopulationConcentrationKnowledgeCreation::has_concentration() const {
  return _has_bit(3);
}
inline void MsgPopulationConcentrationKnowledgeCreation::clear_concentration() {
  if (concentration_ != NULL) concentration_->::Common::PopulationConcentrationId::Clear();
  _clear_bit(3);
}
inline const ::Common::PopulationConcentrationId& MsgPopulationConcentrationKnowledgeCreation::concentration() const {
  return concentration_ != NULL ? *concentration_ : *default_instance_->concentration_;
}
inline ::Common::PopulationConcentrationId* MsgPopulationConcentrationKnowledgeCreation::mutable_concentration() {
  _set_bit(3);
  if (concentration_ == NULL) concentration_ = new ::Common::PopulationConcentrationId;
  return concentration_;
}

// optional .Common.MsgCoordLatLong position = 5;
inline bool MsgPopulationConcentrationKnowledgeCreation::has_position() const {
  return _has_bit(4);
}
inline void MsgPopulationConcentrationKnowledgeCreation::clear_position() {
  if (position_ != NULL) position_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(4);
}
inline const ::Common::MsgCoordLatLong& MsgPopulationConcentrationKnowledgeCreation::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Common::MsgCoordLatLong* MsgPopulationConcentrationKnowledgeCreation::mutable_position() {
  _set_bit(4);
  if (position_ == NULL) position_ = new ::Common::MsgCoordLatLong;
  return position_;
}

// -------------------------------------------------------------------

// MsgPopulationConcentrationKnowledgeUpdate

// required .Common.PopulationConcentrationKnowledgeId id = 1;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationConcentrationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationConcentrationKnowledgeId& MsgPopulationConcentrationKnowledgeUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationConcentrationKnowledgeId* MsgPopulationConcentrationKnowledgeUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationConcentrationKnowledgeId;
  return id_;
}

// required .Common.PopulationKnowledgeId population = 2;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationConcentrationKnowledgeUpdate::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationConcentrationKnowledgeUpdate::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationKnowledgeId;
  return population_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationConcentrationKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationConcentrationKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional .Common.PopulationConcentrationId concentration = 4;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_concentration() const {
  return _has_bit(3);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_concentration() {
  if (concentration_ != NULL) concentration_->::Common::PopulationConcentrationId::Clear();
  _clear_bit(3);
}
inline const ::Common::PopulationConcentrationId& MsgPopulationConcentrationKnowledgeUpdate::concentration() const {
  return concentration_ != NULL ? *concentration_ : *default_instance_->concentration_;
}
inline ::Common::PopulationConcentrationId* MsgPopulationConcentrationKnowledgeUpdate::mutable_concentration() {
  _set_bit(3);
  if (concentration_ == NULL) concentration_ = new ::Common::PopulationConcentrationId;
  return concentration_;
}

// optional int32 nb_humains_vivants = 5;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_nb_humains_vivants() const {
  return _has_bit(4);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_nb_humains_vivants() {
  nb_humains_vivants_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MsgPopulationConcentrationKnowledgeUpdate::nb_humains_vivants() const {
  return nb_humains_vivants_;
}
inline void MsgPopulationConcentrationKnowledgeUpdate::set_nb_humains_vivants(::google::protobuf::int32 value) {
  _set_bit(4);
  nb_humains_vivants_ = value;
}

// optional int32 nb_humains_morts = 6;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_nb_humains_morts() const {
  return _has_bit(5);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_nb_humains_morts() {
  nb_humains_morts_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MsgPopulationConcentrationKnowledgeUpdate::nb_humains_morts() const {
  return nb_humains_morts_;
}
inline void MsgPopulationConcentrationKnowledgeUpdate::set_nb_humains_morts(::google::protobuf::int32 value) {
  _set_bit(5);
  nb_humains_morts_ = value;
}

// optional .Common.EnumPopulationAttitude attitude = 7;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_attitude() const {
  return _has_bit(6);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_attitude() {
  attitude_ = 0;
  _clear_bit(6);
}
inline Common::EnumPopulationAttitude MsgPopulationConcentrationKnowledgeUpdate::attitude() const {
  return static_cast< Common::EnumPopulationAttitude >(attitude_);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::set_attitude(Common::EnumPopulationAttitude value) {
  GOOGLE_DCHECK(Common::EnumPopulationAttitude_IsValid(value));
  _set_bit(6);
  attitude_ = value;
}

// optional int32 pertinence = 8;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_pertinence() const {
  return _has_bit(7);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_pertinence() {
  pertinence_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MsgPopulationConcentrationKnowledgeUpdate::pertinence() const {
  return pertinence_;
}
inline void MsgPopulationConcentrationKnowledgeUpdate::set_pertinence(::google::protobuf::int32 value) {
  _set_bit(7);
  pertinence_ = value;
}

// optional bool est_percu = 9;
inline bool MsgPopulationConcentrationKnowledgeUpdate::has_est_percu() const {
  return _has_bit(8);
}
inline void MsgPopulationConcentrationKnowledgeUpdate::clear_est_percu() {
  est_percu_ = false;
  _clear_bit(8);
}
inline bool MsgPopulationConcentrationKnowledgeUpdate::est_percu() const {
  return est_percu_;
}
inline void MsgPopulationConcentrationKnowledgeUpdate::set_est_percu(bool value) {
  _set_bit(8);
  est_percu_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationConcentrationKnowledgeDestruction

// required .Common.PopulationConcentrationKnowledgeId id = 1;
inline bool MsgPopulationConcentrationKnowledgeDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationConcentrationKnowledgeDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationConcentrationKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationConcentrationKnowledgeId& MsgPopulationConcentrationKnowledgeDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationConcentrationKnowledgeId* MsgPopulationConcentrationKnowledgeDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationConcentrationKnowledgeId;
  return id_;
}

// required .Common.PopulationKnowledgeId population = 2;
inline bool MsgPopulationConcentrationKnowledgeDestruction::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationConcentrationKnowledgeDestruction::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationConcentrationKnowledgeDestruction::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationConcentrationKnowledgeDestruction::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationKnowledgeId;
  return population_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgPopulationConcentrationKnowledgeDestruction::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgPopulationConcentrationKnowledgeDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationConcentrationKnowledgeDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationConcentrationKnowledgeDestruction::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgPopulationFlowKnowledgeCreation

// required .Common.PopulationFlowKnowledgeId id = 1;
inline bool MsgPopulationFlowKnowledgeCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationFlowKnowledgeCreation::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationFlowKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationFlowKnowledgeId& MsgPopulationFlowKnowledgeCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationFlowKnowledgeId* MsgPopulationFlowKnowledgeCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationFlowKnowledgeId;
  return id_;
}

// required .Common.PopulationKnowledgeId population = 2;
inline bool MsgPopulationFlowKnowledgeCreation::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationFlowKnowledgeCreation::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationFlowKnowledgeCreation::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationFlowKnowledgeCreation::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationKnowledgeId;
  return population_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgPopulationFlowKnowledgeCreation::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgPopulationFlowKnowledgeCreation::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationFlowKnowledgeCreation::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationFlowKnowledgeCreation::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// required .Common.PopulationFlowId flow = 4;
inline bool MsgPopulationFlowKnowledgeCreation::has_flow() const {
  return _has_bit(3);
}
inline void MsgPopulationFlowKnowledgeCreation::clear_flow() {
  if (flow_ != NULL) flow_->::Common::PopulationFlowId::Clear();
  _clear_bit(3);
}
inline const ::Common::PopulationFlowId& MsgPopulationFlowKnowledgeCreation::flow() const {
  return flow_ != NULL ? *flow_ : *default_instance_->flow_;
}
inline ::Common::PopulationFlowId* MsgPopulationFlowKnowledgeCreation::mutable_flow() {
  _set_bit(3);
  if (flow_ == NULL) flow_ = new ::Common::PopulationFlowId;
  return flow_;
}

// -------------------------------------------------------------------

// MsgFlowPart

// required .Common.MsgPath forme = 1;
inline bool MsgFlowPart::has_forme() const {
  return _has_bit(0);
}
inline void MsgFlowPart::clear_forme() {
  if (forme_ != NULL) forme_->::Common::MsgPath::Clear();
  _clear_bit(0);
}
inline const ::Common::MsgPath& MsgFlowPart::forme() const {
  return forme_ != NULL ? *forme_ : *default_instance_->forme_;
}
inline ::Common::MsgPath* MsgFlowPart::mutable_forme() {
  _set_bit(0);
  if (forme_ == NULL) forme_ = new ::Common::MsgPath;
  return forme_;
}

// required int32 pertinence = 2;
inline bool MsgFlowPart::has_pertinence() const {
  return _has_bit(1);
}
inline void MsgFlowPart::clear_pertinence() {
  pertinence_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgFlowPart::pertinence() const {
  return pertinence_;
}
inline void MsgFlowPart::set_pertinence(::google::protobuf::int32 value) {
  _set_bit(1);
  pertinence_ = value;
}

// -------------------------------------------------------------------

// SeqOfFlowPart

// repeated .MsgsSimToClient.MsgFlowPart elem = 1;
inline int SeqOfFlowPart::elem_size() const {
  return elem_.size();
}
inline void SeqOfFlowPart::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart >&
SeqOfFlowPart::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFlowPart >*
SeqOfFlowPart::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgFlowPart& SeqOfFlowPart::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgFlowPart* SeqOfFlowPart::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgFlowPart* SeqOfFlowPart::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgPopulationFlowKnowledgeUpdate

// required .Common.PopulationFlowKnowledgeId id = 1;
inline bool MsgPopulationFlowKnowledgeUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationFlowKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationFlowKnowledgeId& MsgPopulationFlowKnowledgeUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationFlowKnowledgeId* MsgPopulationFlowKnowledgeUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationFlowKnowledgeId;
  return id_;
}

// required .Common.PopulationKnowledgeId population = 2;
inline bool MsgPopulationFlowKnowledgeUpdate::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationFlowKnowledgeUpdate::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationFlowKnowledgeUpdate::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationKnowledgeId;
  return population_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgPopulationFlowKnowledgeUpdate::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationFlowKnowledgeUpdate::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationFlowKnowledgeUpdate::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// optional .Common.PopulationFlowId flow = 4;
inline bool MsgPopulationFlowKnowledgeUpdate::has_flow() const {
  return _has_bit(3);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_flow() {
  if (flow_ != NULL) flow_->::Common::PopulationFlowId::Clear();
  _clear_bit(3);
}
inline const ::Common::PopulationFlowId& MsgPopulationFlowKnowledgeUpdate::flow() const {
  return flow_ != NULL ? *flow_ : *default_instance_->flow_;
}
inline ::Common::PopulationFlowId* MsgPopulationFlowKnowledgeUpdate::mutable_flow() {
  _set_bit(3);
  if (flow_ == NULL) flow_ = new ::Common::PopulationFlowId;
  return flow_;
}

// optional .MsgsSimToClient.SeqOfFlowPart portions_flux = 5;
inline bool MsgPopulationFlowKnowledgeUpdate::has_portions_flux() const {
  return _has_bit(4);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_portions_flux() {
  if (portions_flux_ != NULL) portions_flux_->::MsgsSimToClient::SeqOfFlowPart::Clear();
  _clear_bit(4);
}
inline const ::MsgsSimToClient::SeqOfFlowPart& MsgPopulationFlowKnowledgeUpdate::portions_flux() const {
  return portions_flux_ != NULL ? *portions_flux_ : *default_instance_->portions_flux_;
}
inline ::MsgsSimToClient::SeqOfFlowPart* MsgPopulationFlowKnowledgeUpdate::mutable_portions_flux() {
  _set_bit(4);
  if (portions_flux_ == NULL) portions_flux_ = new ::MsgsSimToClient::SeqOfFlowPart;
  return portions_flux_;
}

// optional .Common.MsgHeading direction = 6;
inline bool MsgPopulationFlowKnowledgeUpdate::has_direction() const {
  return _has_bit(5);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_direction() {
  if (direction_ != NULL) direction_->::Common::MsgHeading::Clear();
  _clear_bit(5);
}
inline const ::Common::MsgHeading& MsgPopulationFlowKnowledgeUpdate::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Common::MsgHeading* MsgPopulationFlowKnowledgeUpdate::mutable_direction() {
  _set_bit(5);
  if (direction_ == NULL) direction_ = new ::Common::MsgHeading;
  return direction_;
}

// optional int32 vitesse = 7;
inline bool MsgPopulationFlowKnowledgeUpdate::has_vitesse() const {
  return _has_bit(6);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_vitesse() {
  vitesse_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 MsgPopulationFlowKnowledgeUpdate::vitesse() const {
  return vitesse_;
}
inline void MsgPopulationFlowKnowledgeUpdate::set_vitesse(::google::protobuf::int32 value) {
  _set_bit(6);
  vitesse_ = value;
}

// optional int32 nb_humains_vivants = 8;
inline bool MsgPopulationFlowKnowledgeUpdate::has_nb_humains_vivants() const {
  return _has_bit(7);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_nb_humains_vivants() {
  nb_humains_vivants_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MsgPopulationFlowKnowledgeUpdate::nb_humains_vivants() const {
  return nb_humains_vivants_;
}
inline void MsgPopulationFlowKnowledgeUpdate::set_nb_humains_vivants(::google::protobuf::int32 value) {
  _set_bit(7);
  nb_humains_vivants_ = value;
}

// optional int32 nb_humains_morts = 9;
inline bool MsgPopulationFlowKnowledgeUpdate::has_nb_humains_morts() const {
  return _has_bit(8);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_nb_humains_morts() {
  nb_humains_morts_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 MsgPopulationFlowKnowledgeUpdate::nb_humains_morts() const {
  return nb_humains_morts_;
}
inline void MsgPopulationFlowKnowledgeUpdate::set_nb_humains_morts(::google::protobuf::int32 value) {
  _set_bit(8);
  nb_humains_morts_ = value;
}

// optional .Common.EnumPopulationAttitude attitude = 10;
inline bool MsgPopulationFlowKnowledgeUpdate::has_attitude() const {
  return _has_bit(9);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_attitude() {
  attitude_ = 0;
  _clear_bit(9);
}
inline Common::EnumPopulationAttitude MsgPopulationFlowKnowledgeUpdate::attitude() const {
  return static_cast< Common::EnumPopulationAttitude >(attitude_);
}
inline void MsgPopulationFlowKnowledgeUpdate::set_attitude(Common::EnumPopulationAttitude value) {
  GOOGLE_DCHECK(Common::EnumPopulationAttitude_IsValid(value));
  _set_bit(9);
  attitude_ = value;
}

// optional bool est_percu = 11;
inline bool MsgPopulationFlowKnowledgeUpdate::has_est_percu() const {
  return _has_bit(10);
}
inline void MsgPopulationFlowKnowledgeUpdate::clear_est_percu() {
  est_percu_ = false;
  _clear_bit(10);
}
inline bool MsgPopulationFlowKnowledgeUpdate::est_percu() const {
  return est_percu_;
}
inline void MsgPopulationFlowKnowledgeUpdate::set_est_percu(bool value) {
  _set_bit(10);
  est_percu_ = value;
}

// -------------------------------------------------------------------

// MsgPopulationFlowKnowledgeDestruction

// required .Common.PopulationFlowKnowledgeId id = 1;
inline bool MsgPopulationFlowKnowledgeDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgPopulationFlowKnowledgeDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::PopulationFlowKnowledgeId::Clear();
  _clear_bit(0);
}
inline const ::Common::PopulationFlowKnowledgeId& MsgPopulationFlowKnowledgeDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::PopulationFlowKnowledgeId* MsgPopulationFlowKnowledgeDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::PopulationFlowKnowledgeId;
  return id_;
}

// required .Common.PopulationKnowledgeId population = 2;
inline bool MsgPopulationFlowKnowledgeDestruction::has_population() const {
  return _has_bit(1);
}
inline void MsgPopulationFlowKnowledgeDestruction::clear_population() {
  if (population_ != NULL) population_->::Common::PopulationKnowledgeId::Clear();
  _clear_bit(1);
}
inline const ::Common::PopulationKnowledgeId& MsgPopulationFlowKnowledgeDestruction::population() const {
  return population_ != NULL ? *population_ : *default_instance_->population_;
}
inline ::Common::PopulationKnowledgeId* MsgPopulationFlowKnowledgeDestruction::mutable_population() {
  _set_bit(1);
  if (population_ == NULL) population_ = new ::Common::PopulationKnowledgeId;
  return population_;
}

// required .Common.KnowledgeGroupId knowledge_group = 3;
inline bool MsgPopulationFlowKnowledgeDestruction::has_knowledge_group() const {
  return _has_bit(2);
}
inline void MsgPopulationFlowKnowledgeDestruction::clear_knowledge_group() {
  if (knowledge_group_ != NULL) knowledge_group_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgPopulationFlowKnowledgeDestruction::knowledge_group() const {
  return knowledge_group_ != NULL ? *knowledge_group_ : *default_instance_->knowledge_group_;
}
inline ::Common::KnowledgeGroupId* MsgPopulationFlowKnowledgeDestruction::mutable_knowledge_group() {
  _set_bit(2);
  if (knowledge_group_ == NULL) knowledge_group_ = new ::Common::KnowledgeGroupId;
  return knowledge_group_;
}

// -------------------------------------------------------------------

// MsgFolkCreation_profiles

// repeated string elem = 1;
inline int MsgFolkCreation_profiles::elem_size() const {
  return elem_.size();
}
inline void MsgFolkCreation_profiles::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MsgFolkCreation_profiles::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MsgFolkCreation_profiles::mutable_elem() {
  return &elem_;
}
inline const ::std::string& MsgFolkCreation_profiles::elem(int index) const {
  return elem_.Get(index);
}
inline ::std::string* MsgFolkCreation_profiles::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline void MsgFolkCreation_profiles::set_elem(int index, const ::std::string& value) {
  elem_.Mutable(index)->assign(value);
}
inline void MsgFolkCreation_profiles::set_elem(int index, const char* value) {
  elem_.Mutable(index)->assign(value);
}
inline void MsgFolkCreation_profiles::set_elem(int index, const char* value, size_t size) {
  elem_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgFolkCreation_profiles::add_elem() {
  return elem_.Add();
}
inline void MsgFolkCreation_profiles::add_elem(const ::std::string& value) {
  elem_.Add()->assign(value);
}
inline void MsgFolkCreation_profiles::add_elem(const char* value) {
  elem_.Add()->assign(value);
}
inline void MsgFolkCreation_profiles::add_elem(const char* value, size_t size) {
  elem_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// -------------------------------------------------------------------

// MsgFolkCreation_activities

// repeated string elem = 1;
inline int MsgFolkCreation_activities::elem_size() const {
  return elem_.size();
}
inline void MsgFolkCreation_activities::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MsgFolkCreation_activities::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MsgFolkCreation_activities::mutable_elem() {
  return &elem_;
}
inline const ::std::string& MsgFolkCreation_activities::elem(int index) const {
  return elem_.Get(index);
}
inline ::std::string* MsgFolkCreation_activities::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline void MsgFolkCreation_activities::set_elem(int index, const ::std::string& value) {
  elem_.Mutable(index)->assign(value);
}
inline void MsgFolkCreation_activities::set_elem(int index, const char* value) {
  elem_.Mutable(index)->assign(value);
}
inline void MsgFolkCreation_activities::set_elem(int index, const char* value, size_t size) {
  elem_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgFolkCreation_activities::add_elem() {
  return elem_.Add();
}
inline void MsgFolkCreation_activities::add_elem(const ::std::string& value) {
  elem_.Add()->assign(value);
}
inline void MsgFolkCreation_activities::add_elem(const char* value) {
  elem_.Add()->assign(value);
}
inline void MsgFolkCreation_activities::add_elem(const char* value, size_t size) {
  elem_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// -------------------------------------------------------------------

// MsgFolkCreation

// required .MsgsSimToClient.MsgFolkCreation_profiles profiles = 1;
inline bool MsgFolkCreation::has_profiles() const {
  return _has_bit(0);
}
inline void MsgFolkCreation::clear_profiles() {
  if (profiles_ != NULL) profiles_->::MsgsSimToClient::MsgFolkCreation_profiles::Clear();
  _clear_bit(0);
}
inline const ::MsgsSimToClient::MsgFolkCreation_profiles& MsgFolkCreation::profiles() const {
  return profiles_ != NULL ? *profiles_ : *default_instance_->profiles_;
}
inline ::MsgsSimToClient::MsgFolkCreation_profiles* MsgFolkCreation::mutable_profiles() {
  _set_bit(0);
  if (profiles_ == NULL) profiles_ = new ::MsgsSimToClient::MsgFolkCreation_profiles;
  return profiles_;
}

// required .MsgsSimToClient.MsgFolkCreation_activities activities = 2;
inline bool MsgFolkCreation::has_activities() const {
  return _has_bit(1);
}
inline void MsgFolkCreation::clear_activities() {
  if (activities_ != NULL) activities_->::MsgsSimToClient::MsgFolkCreation_activities::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgFolkCreation_activities& MsgFolkCreation::activities() const {
  return activities_ != NULL ? *activities_ : *default_instance_->activities_;
}
inline ::MsgsSimToClient::MsgFolkCreation_activities* MsgFolkCreation::mutable_activities() {
  _set_bit(1);
  if (activities_ == NULL) activities_ = new ::MsgsSimToClient::MsgFolkCreation_activities;
  return activities_;
}

// optional int32 container_size = 3;
inline bool MsgFolkCreation::has_container_size() const {
  return _has_bit(2);
}
inline void MsgFolkCreation::clear_container_size() {
  container_size_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgFolkCreation::container_size() const {
  return container_size_;
}
inline void MsgFolkCreation::set_container_size(::google::protobuf::int32 value) {
  _set_bit(2);
  container_size_ = value;
}

// optional int32 edge_number = 4;
inline bool MsgFolkCreation::has_edge_number() const {
  return _has_bit(3);
}
inline void MsgFolkCreation::clear_edge_number() {
  edge_number_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MsgFolkCreation::edge_number() const {
  return edge_number_;
}
inline void MsgFolkCreation::set_edge_number(::google::protobuf::int32 value) {
  _set_bit(3);
  edge_number_ = value;
}

// -------------------------------------------------------------------

// MsgFolkGraphEdgeUpdate

// required int32 oid = 1;
inline bool MsgFolkGraphEdgeUpdate::has_oid() const {
  return _has_bit(0);
}
inline void MsgFolkGraphEdgeUpdate::clear_oid() {
  oid_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgFolkGraphEdgeUpdate::oid() const {
  return oid_;
}
inline void MsgFolkGraphEdgeUpdate::set_oid(::google::protobuf::int32 value) {
  _set_bit(0);
  oid_ = value;
}

// required int32 shp_oid = 2;
inline bool MsgFolkGraphEdgeUpdate::has_shp_oid() const {
  return _has_bit(1);
}
inline void MsgFolkGraphEdgeUpdate::clear_shp_oid() {
  shp_oid_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgFolkGraphEdgeUpdate::shp_oid() const {
  return shp_oid_;
}
inline void MsgFolkGraphEdgeUpdate::set_shp_oid(::google::protobuf::int32 value) {
  _set_bit(1);
  shp_oid_ = value;
}

// repeated int32 population_occupation = 3;
inline int MsgFolkGraphEdgeUpdate::population_occupation_size() const {
  return population_occupation_.size();
}
inline void MsgFolkGraphEdgeUpdate::clear_population_occupation() {
  population_occupation_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MsgFolkGraphEdgeUpdate::population_occupation() const {
  return population_occupation_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MsgFolkGraphEdgeUpdate::mutable_population_occupation() {
  return &population_occupation_;
}
inline ::google::protobuf::int32 MsgFolkGraphEdgeUpdate::population_occupation(int index) const {
  return population_occupation_.Get(index);
}
inline void MsgFolkGraphEdgeUpdate::set_population_occupation(int index, ::google::protobuf::int32 value) {
  population_occupation_.Set(index, value);
}
inline void MsgFolkGraphEdgeUpdate::add_population_occupation(::google::protobuf::int32 value) {
  population_occupation_.Add(value);
}

// -------------------------------------------------------------------

// MsgFolkGraphUpdate

// repeated .MsgsSimToClient.MsgFolkGraphEdgeUpdate elem = 1;
inline int MsgFolkGraphUpdate::elem_size() const {
  return elem_.size();
}
inline void MsgFolkGraphUpdate::clear_elem() {
  elem_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate >&
MsgFolkGraphUpdate::elem() const {
  return elem_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgsSimToClient::MsgFolkGraphEdgeUpdate >*
MsgFolkGraphUpdate::mutable_elem() {
  return &elem_;
}
inline const ::MsgsSimToClient::MsgFolkGraphEdgeUpdate& MsgFolkGraphUpdate::elem(int index) const {
  return elem_.Get(index);
}
inline ::MsgsSimToClient::MsgFolkGraphEdgeUpdate* MsgFolkGraphUpdate::mutable_elem(int index) {
  return elem_.Mutable(index);
}
inline ::MsgsSimToClient::MsgFolkGraphEdgeUpdate* MsgFolkGraphUpdate::add_elem() {
  return elem_.Add();
}

// -------------------------------------------------------------------

// MsgControlCheckPointSetFrequencyAck

// -------------------------------------------------------------------

// MsgControlCheckPointSaveNowAck

// -------------------------------------------------------------------

// MsgControlCheckPointSaveBegin

// -------------------------------------------------------------------

// MsgControlCheckPointSaveBeginAck

// -------------------------------------------------------------------

// MsgControlCheckPointSaveEnd

// optional string name = 1;
inline bool MsgControlCheckPointSaveEnd::has_name() const {
  return _has_bit(0);
}
inline void MsgControlCheckPointSaveEnd::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MsgControlCheckPointSaveEnd::name() const {
  return *name_;
}
inline void MsgControlCheckPointSaveEnd::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgControlCheckPointSaveEnd::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgControlCheckPointSaveEnd::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgControlCheckPointSaveEnd::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// MsgControlSendCurrentStateBegin

// -------------------------------------------------------------------

// MsgControlSendCurrentStateEnd

// -------------------------------------------------------------------

// MagicActionCreateUrban

// required string name = 1;
inline bool MagicActionCreateUrban::has_name() const {
  return _has_bit(0);
}
inline void MagicActionCreateUrban::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MagicActionCreateUrban::name() const {
  return *name_;
}
inline void MagicActionCreateUrban::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MagicActionCreateUrban::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MagicActionCreateUrban::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MagicActionCreateUrban::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .Common.MsgLocation location = 2;
inline bool MagicActionCreateUrban::has_location() const {
  return _has_bit(1);
}
inline void MagicActionCreateUrban::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgLocation& MagicActionCreateUrban::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MagicActionCreateUrban::mutable_location() {
  _set_bit(1);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// -------------------------------------------------------------------

// MagicActionUpdateUrban

// required uint32 oid = 1;
inline bool MagicActionUpdateUrban::has_oid() const {
  return _has_bit(0);
}
inline void MagicActionUpdateUrban::clear_oid() {
  oid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MagicActionUpdateUrban::oid() const {
  return oid_;
}
inline void MagicActionUpdateUrban::set_oid(::google::protobuf::uint32 value) {
  _set_bit(0);
  oid_ = value;
}

// -------------------------------------------------------------------

// MagicActionDestroyUrban

// required uint32 oid = 1;
inline bool MagicActionDestroyUrban::has_oid() const {
  return _has_bit(0);
}
inline void MagicActionDestroyUrban::clear_oid() {
  oid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MagicActionDestroyUrban::oid() const {
  return oid_;
}
inline void MagicActionDestroyUrban::set_oid(::google::protobuf::uint32 value) {
  _set_bit(0);
  oid_ = value;
}

// -------------------------------------------------------------------

// MsgUrbanMagicAction

// optional .MsgsSimToClient.MagicActionCreateUrban create_urban = 1;
inline bool MsgUrbanMagicAction::has_create_urban() const {
  return _has_bit(0);
}
inline void MsgUrbanMagicAction::clear_create_urban() {
  if (create_urban_ != NULL) create_urban_->::MsgsSimToClient::MagicActionCreateUrban::Clear();
  _clear_bit(0);
}
inline const ::MsgsSimToClient::MagicActionCreateUrban& MsgUrbanMagicAction::create_urban() const {
  return create_urban_ != NULL ? *create_urban_ : *default_instance_->create_urban_;
}
inline ::MsgsSimToClient::MagicActionCreateUrban* MsgUrbanMagicAction::mutable_create_urban() {
  _set_bit(0);
  if (create_urban_ == NULL) create_urban_ = new ::MsgsSimToClient::MagicActionCreateUrban;
  return create_urban_;
}

// optional .MsgsSimToClient.MagicActionUpdateUrban update_urban = 2;
inline bool MsgUrbanMagicAction::has_update_urban() const {
  return _has_bit(1);
}
inline void MsgUrbanMagicAction::clear_update_urban() {
  if (update_urban_ != NULL) update_urban_->::MsgsSimToClient::MagicActionUpdateUrban::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MagicActionUpdateUrban& MsgUrbanMagicAction::update_urban() const {
  return update_urban_ != NULL ? *update_urban_ : *default_instance_->update_urban_;
}
inline ::MsgsSimToClient::MagicActionUpdateUrban* MsgUrbanMagicAction::mutable_update_urban() {
  _set_bit(1);
  if (update_urban_ == NULL) update_urban_ = new ::MsgsSimToClient::MagicActionUpdateUrban;
  return update_urban_;
}

// optional .MsgsSimToClient.MagicActionDestroyUrban destroy_urban = 3;
inline bool MsgUrbanMagicAction::has_destroy_urban() const {
  return _has_bit(2);
}
inline void MsgUrbanMagicAction::clear_destroy_urban() {
  if (destroy_urban_ != NULL) destroy_urban_->::MsgsSimToClient::MagicActionDestroyUrban::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MagicActionDestroyUrban& MsgUrbanMagicAction::destroy_urban() const {
  return destroy_urban_ != NULL ? *destroy_urban_ : *default_instance_->destroy_urban_;
}
inline ::MsgsSimToClient::MagicActionDestroyUrban* MsgUrbanMagicAction::mutable_destroy_urban() {
  _set_bit(2);
  if (destroy_urban_ == NULL) destroy_urban_ = new ::MsgsSimToClient::MagicActionDestroyUrban;
  return destroy_urban_;
}

// -------------------------------------------------------------------

// MsgUrbanMagicActionAck

// required .MsgsSimToClient.MsgUrbanMagicActionAck.ErrorCode error_code = 1;
inline bool MsgUrbanMagicActionAck::has_error_code() const {
  return _has_bit(0);
}
inline void MsgUrbanMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode MsgUrbanMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode >(error_code_);
}
inline void MsgUrbanMagicActionAck::set_error_code(::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode_IsValid(value));
  _set_bit(0);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgUrbanAttributes_Architecture

// required float height = 1;
inline bool MsgUrbanAttributes_Architecture::has_height() const {
  return _has_bit(0);
}
inline void MsgUrbanAttributes_Architecture::clear_height() {
  height_ = 0;
  _clear_bit(0);
}
inline float MsgUrbanAttributes_Architecture::height() const {
  return height_;
}
inline void MsgUrbanAttributes_Architecture::set_height(float value) {
  _set_bit(0);
  height_ = value;
}

// required int32 floor_number = 2;
inline bool MsgUrbanAttributes_Architecture::has_floor_number() const {
  return _has_bit(1);
}
inline void MsgUrbanAttributes_Architecture::clear_floor_number() {
  floor_number_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgUrbanAttributes_Architecture::floor_number() const {
  return floor_number_;
}
inline void MsgUrbanAttributes_Architecture::set_floor_number(::google::protobuf::int32 value) {
  _set_bit(1);
  floor_number_ = value;
}

// required string roof_shape = 3;
inline bool MsgUrbanAttributes_Architecture::has_roof_shape() const {
  return _has_bit(2);
}
inline void MsgUrbanAttributes_Architecture::clear_roof_shape() {
  if (roof_shape_ != &_default_roof_shape_) {
    roof_shape_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MsgUrbanAttributes_Architecture::roof_shape() const {
  return *roof_shape_;
}
inline void MsgUrbanAttributes_Architecture::set_roof_shape(const ::std::string& value) {
  _set_bit(2);
  if (roof_shape_ == &_default_roof_shape_) {
    roof_shape_ = new ::std::string;
  }
  roof_shape_->assign(value);
}
inline void MsgUrbanAttributes_Architecture::set_roof_shape(const char* value) {
  _set_bit(2);
  if (roof_shape_ == &_default_roof_shape_) {
    roof_shape_ = new ::std::string;
  }
  roof_shape_->assign(value);
}
inline void MsgUrbanAttributes_Architecture::set_roof_shape(const char* value, size_t size) {
  _set_bit(2);
  if (roof_shape_ == &_default_roof_shape_) {
    roof_shape_ = new ::std::string;
  }
  roof_shape_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgUrbanAttributes_Architecture::mutable_roof_shape() {
  _set_bit(2);
  if (roof_shape_ == &_default_roof_shape_) {
    roof_shape_ = new ::std::string;
  }
  return roof_shape_;
}

// required string material = 4;
inline bool MsgUrbanAttributes_Architecture::has_material() const {
  return _has_bit(3);
}
inline void MsgUrbanAttributes_Architecture::clear_material() {
  if (material_ != &_default_material_) {
    material_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& MsgUrbanAttributes_Architecture::material() const {
  return *material_;
}
inline void MsgUrbanAttributes_Architecture::set_material(const ::std::string& value) {
  _set_bit(3);
  if (material_ == &_default_material_) {
    material_ = new ::std::string;
  }
  material_->assign(value);
}
inline void MsgUrbanAttributes_Architecture::set_material(const char* value) {
  _set_bit(3);
  if (material_ == &_default_material_) {
    material_ = new ::std::string;
  }
  material_->assign(value);
}
inline void MsgUrbanAttributes_Architecture::set_material(const char* value, size_t size) {
  _set_bit(3);
  if (material_ == &_default_material_) {
    material_ = new ::std::string;
  }
  material_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgUrbanAttributes_Architecture::mutable_material() {
  _set_bit(3);
  if (material_ == &_default_material_) {
    material_ = new ::std::string;
  }
  return material_;
}

// required float occupation = 5;
inline bool MsgUrbanAttributes_Architecture::has_occupation() const {
  return _has_bit(4);
}
inline void MsgUrbanAttributes_Architecture::clear_occupation() {
  occupation_ = 0;
  _clear_bit(4);
}
inline float MsgUrbanAttributes_Architecture::occupation() const {
  return occupation_;
}
inline void MsgUrbanAttributes_Architecture::set_occupation(float value) {
  _set_bit(4);
  occupation_ = value;
}

// required float trafficability = 6;
inline bool MsgUrbanAttributes_Architecture::has_trafficability() const {
  return _has_bit(5);
}
inline void MsgUrbanAttributes_Architecture::clear_trafficability() {
  trafficability_ = 0;
  _clear_bit(5);
}
inline float MsgUrbanAttributes_Architecture::trafficability() const {
  return trafficability_;
}
inline void MsgUrbanAttributes_Architecture::set_trafficability(float value) {
  _set_bit(5);
  trafficability_ = value;
}

// -------------------------------------------------------------------

// MsgUrbanAttributes_Structure

// required uint32 state = 1;
inline bool MsgUrbanAttributes_Structure::has_state() const {
  return _has_bit(0);
}
inline void MsgUrbanAttributes_Structure::clear_state() {
  state_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MsgUrbanAttributes_Structure::state() const {
  return state_;
}
inline void MsgUrbanAttributes_Structure::set_state(::google::protobuf::uint32 value) {
  _set_bit(0);
  state_ = value;
}

// -------------------------------------------------------------------

// MsgUrbanAttributes_Infrastructures

// repeated .Common.ResourceNetwork resource_network = 1;
inline int MsgUrbanAttributes_Infrastructures::resource_network_size() const {
  return resource_network_.size();
}
inline void MsgUrbanAttributes_Infrastructures::clear_resource_network() {
  resource_network_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork >&
MsgUrbanAttributes_Infrastructures::resource_network() const {
  return resource_network_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::ResourceNetwork >*
MsgUrbanAttributes_Infrastructures::mutable_resource_network() {
  return &resource_network_;
}
inline const ::Common::ResourceNetwork& MsgUrbanAttributes_Infrastructures::resource_network(int index) const {
  return resource_network_.Get(index);
}
inline ::Common::ResourceNetwork* MsgUrbanAttributes_Infrastructures::mutable_resource_network(int index) {
  return resource_network_.Mutable(index);
}
inline ::Common::ResourceNetwork* MsgUrbanAttributes_Infrastructures::add_resource_network() {
  return resource_network_.Add();
}

// -------------------------------------------------------------------

// MsgUrbanAttributes_RgbaColor

// required int32 red = 1;
inline bool MsgUrbanAttributes_RgbaColor::has_red() const {
  return _has_bit(0);
}
inline void MsgUrbanAttributes_RgbaColor::clear_red() {
  red_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgUrbanAttributes_RgbaColor::red() const {
  return red_;
}
inline void MsgUrbanAttributes_RgbaColor::set_red(::google::protobuf::int32 value) {
  _set_bit(0);
  red_ = value;
}

// required int32 green = 2;
inline bool MsgUrbanAttributes_RgbaColor::has_green() const {
  return _has_bit(1);
}
inline void MsgUrbanAttributes_RgbaColor::clear_green() {
  green_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MsgUrbanAttributes_RgbaColor::green() const {
  return green_;
}
inline void MsgUrbanAttributes_RgbaColor::set_green(::google::protobuf::int32 value) {
  _set_bit(1);
  green_ = value;
}

// required int32 blue = 3;
inline bool MsgUrbanAttributes_RgbaColor::has_blue() const {
  return _has_bit(2);
}
inline void MsgUrbanAttributes_RgbaColor::clear_blue() {
  blue_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MsgUrbanAttributes_RgbaColor::blue() const {
  return blue_;
}
inline void MsgUrbanAttributes_RgbaColor::set_blue(::google::protobuf::int32 value) {
  _set_bit(2);
  blue_ = value;
}

// required float alpha = 4;
inline bool MsgUrbanAttributes_RgbaColor::has_alpha() const {
  return _has_bit(3);
}
inline void MsgUrbanAttributes_RgbaColor::clear_alpha() {
  alpha_ = 0;
  _clear_bit(3);
}
inline float MsgUrbanAttributes_RgbaColor::alpha() const {
  return alpha_;
}
inline void MsgUrbanAttributes_RgbaColor::set_alpha(float value) {
  _set_bit(3);
  alpha_ = value;
}

// -------------------------------------------------------------------

// MsgUrbanAttributes

// optional .MsgsSimToClient.MsgUrbanAttributes.Architecture architecture = 1;
inline bool MsgUrbanAttributes::has_architecture() const {
  return _has_bit(0);
}
inline void MsgUrbanAttributes::clear_architecture() {
  if (architecture_ != NULL) architecture_->::MsgsSimToClient::MsgUrbanAttributes_Architecture::Clear();
  _clear_bit(0);
}
inline const ::MsgsSimToClient::MsgUrbanAttributes_Architecture& MsgUrbanAttributes::architecture() const {
  return architecture_ != NULL ? *architecture_ : *default_instance_->architecture_;
}
inline ::MsgsSimToClient::MsgUrbanAttributes_Architecture* MsgUrbanAttributes::mutable_architecture() {
  _set_bit(0);
  if (architecture_ == NULL) architecture_ = new ::MsgsSimToClient::MsgUrbanAttributes_Architecture;
  return architecture_;
}

// optional .MsgsSimToClient.MsgUrbanAttributes.Structure structure = 2;
inline bool MsgUrbanAttributes::has_structure() const {
  return _has_bit(1);
}
inline void MsgUrbanAttributes::clear_structure() {
  if (structure_ != NULL) structure_->::MsgsSimToClient::MsgUrbanAttributes_Structure::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgUrbanAttributes_Structure& MsgUrbanAttributes::structure() const {
  return structure_ != NULL ? *structure_ : *default_instance_->structure_;
}
inline ::MsgsSimToClient::MsgUrbanAttributes_Structure* MsgUrbanAttributes::mutable_structure() {
  _set_bit(1);
  if (structure_ == NULL) structure_ = new ::MsgsSimToClient::MsgUrbanAttributes_Structure;
  return structure_;
}

// optional .MsgsSimToClient.MsgUrbanAttributes.RgbaColor color = 3;
inline bool MsgUrbanAttributes::has_color() const {
  return _has_bit(2);
}
inline void MsgUrbanAttributes::clear_color() {
  if (color_ != NULL) color_->::MsgsSimToClient::MsgUrbanAttributes_RgbaColor::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgUrbanAttributes_RgbaColor& MsgUrbanAttributes::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::MsgsSimToClient::MsgUrbanAttributes_RgbaColor* MsgUrbanAttributes::mutable_color() {
  _set_bit(2);
  if (color_ == NULL) color_ = new ::MsgsSimToClient::MsgUrbanAttributes_RgbaColor;
  return color_;
}

// optional .MsgsSimToClient.MsgUrbanAttributes.Infrastructures infrastructures = 4;
inline bool MsgUrbanAttributes::has_infrastructures() const {
  return _has_bit(3);
}
inline void MsgUrbanAttributes::clear_infrastructures() {
  if (infrastructures_ != NULL) infrastructures_->::MsgsSimToClient::MsgUrbanAttributes_Infrastructures::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::MsgUrbanAttributes_Infrastructures& MsgUrbanAttributes::infrastructures() const {
  return infrastructures_ != NULL ? *infrastructures_ : *default_instance_->infrastructures_;
}
inline ::MsgsSimToClient::MsgUrbanAttributes_Infrastructures* MsgUrbanAttributes::mutable_infrastructures() {
  _set_bit(3);
  if (infrastructures_ == NULL) infrastructures_ = new ::MsgsSimToClient::MsgUrbanAttributes_Infrastructures;
  return infrastructures_;
}

// -------------------------------------------------------------------

// MsgUrbanCreation

// required uint32 oid = 1;
inline bool MsgUrbanCreation::has_oid() const {
  return _has_bit(0);
}
inline void MsgUrbanCreation::clear_oid() {
  oid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MsgUrbanCreation::oid() const {
  return oid_;
}
inline void MsgUrbanCreation::set_oid(::google::protobuf::uint32 value) {
  _set_bit(0);
  oid_ = value;
}

// required string name = 2;
inline bool MsgUrbanCreation::has_name() const {
  return _has_bit(1);
}
inline void MsgUrbanCreation::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MsgUrbanCreation::name() const {
  return *name_;
}
inline void MsgUrbanCreation::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgUrbanCreation::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MsgUrbanCreation::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgUrbanCreation::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .Common.MsgLocation location = 3;
inline bool MsgUrbanCreation::has_location() const {
  return _has_bit(2);
}
inline void MsgUrbanCreation::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgLocation& MsgUrbanCreation::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgUrbanCreation::mutable_location() {
  _set_bit(2);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// optional .MsgsSimToClient.MsgUrbanAttributes attributes = 4;
inline bool MsgUrbanCreation::has_attributes() const {
  return _has_bit(3);
}
inline void MsgUrbanCreation::clear_attributes() {
  if (attributes_ != NULL) attributes_->::MsgsSimToClient::MsgUrbanAttributes::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::MsgUrbanAttributes& MsgUrbanCreation::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::MsgsSimToClient::MsgUrbanAttributes* MsgUrbanCreation::mutable_attributes() {
  _set_bit(3);
  if (attributes_ == NULL) attributes_ = new ::MsgsSimToClient::MsgUrbanAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgUrbanDetection

// required uint32 oid = 1;
inline bool MsgUrbanDetection::has_oid() const {
  return _has_bit(0);
}
inline void MsgUrbanDetection::clear_oid() {
  oid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MsgUrbanDetection::oid() const {
  return oid_;
}
inline void MsgUrbanDetection::set_oid(::google::protobuf::uint32 value) {
  _set_bit(0);
  oid_ = value;
}

// required uint32 urban_oid = 2;
inline bool MsgUrbanDetection::has_urban_oid() const {
  return _has_bit(1);
}
inline void MsgUrbanDetection::clear_urban_oid() {
  urban_oid_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 MsgUrbanDetection::urban_oid() const {
  return urban_oid_;
}
inline void MsgUrbanDetection::set_urban_oid(::google::protobuf::uint32 value) {
  _set_bit(1);
  urban_oid_ = value;
}

// required .Common.EnumUnitVisibility visibility = 3;
inline bool MsgUrbanDetection::has_visibility() const {
  return _has_bit(2);
}
inline void MsgUrbanDetection::clear_visibility() {
  visibility_ = 0;
  _clear_bit(2);
}
inline Common::EnumUnitVisibility MsgUrbanDetection::visibility() const {
  return static_cast< Common::EnumUnitVisibility >(visibility_);
}
inline void MsgUrbanDetection::set_visibility(Common::EnumUnitVisibility value) {
  GOOGLE_DCHECK(Common::EnumUnitVisibility_IsValid(value));
  _set_bit(2);
  visibility_ = value;
}

// -------------------------------------------------------------------

// MsgUrbanUpdate

// required uint32 oid = 1;
inline bool MsgUrbanUpdate::has_oid() const {
  return _has_bit(0);
}
inline void MsgUrbanUpdate::clear_oid() {
  oid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MsgUrbanUpdate::oid() const {
  return oid_;
}
inline void MsgUrbanUpdate::set_oid(::google::protobuf::uint32 value) {
  _set_bit(0);
  oid_ = value;
}

// optional .Common.MsgLocation location = 2;
inline bool MsgUrbanUpdate::has_location() const {
  return _has_bit(1);
}
inline void MsgUrbanUpdate::clear_location() {
  if (location_ != NULL) location_->::Common::MsgLocation::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgLocation& MsgUrbanUpdate::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Common::MsgLocation* MsgUrbanUpdate::mutable_location() {
  _set_bit(1);
  if (location_ == NULL) location_ = new ::Common::MsgLocation;
  return location_;
}

// optional .MsgsSimToClient.MsgUrbanAttributes attributes = 3;
inline bool MsgUrbanUpdate::has_attributes() const {
  return _has_bit(2);
}
inline void MsgUrbanUpdate::clear_attributes() {
  if (attributes_ != NULL) attributes_->::MsgsSimToClient::MsgUrbanAttributes::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgUrbanAttributes& MsgUrbanUpdate::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::MsgsSimToClient::MsgUrbanAttributes* MsgUrbanUpdate::mutable_attributes() {
  _set_bit(2);
  if (attributes_ == NULL) attributes_ = new ::MsgsSimToClient::MsgUrbanAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupCreation

// required .Common.KnowledgeGroupId id = 1;
inline bool MsgKnowledgeGroupCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupCreation::clear_id() {
  if (id_ != NULL) id_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::KnowledgeGroupId;
  return id_;
}

// required .Common.PartyId party = 2;
inline bool MsgKnowledgeGroupCreation::has_party() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupCreation::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgKnowledgeGroupCreation::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgKnowledgeGroupCreation::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.KnowledgeGroupId parent = 3;
inline bool MsgKnowledgeGroupCreation::has_parent() const {
  return _has_bit(2);
}
inline void MsgKnowledgeGroupCreation::clear_parent() {
  if (parent_ != NULL) parent_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupCreation::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupCreation::mutable_parent() {
  _set_bit(2);
  if (parent_ == NULL) parent_ = new ::Common::KnowledgeGroupId;
  return parent_;
}

// required string type = 4;
inline bool MsgKnowledgeGroupCreation::has_type() const {
  return _has_bit(3);
}
inline void MsgKnowledgeGroupCreation::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& MsgKnowledgeGroupCreation::type() const {
  return *type_;
}
inline void MsgKnowledgeGroupCreation::set_type(const ::std::string& value) {
  _set_bit(3);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MsgKnowledgeGroupCreation::set_type(const char* value) {
  _set_bit(3);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MsgKnowledgeGroupCreation::set_type(const char* value, size_t size) {
  _set_bit(3);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgKnowledgeGroupCreation::mutable_type() {
  _set_bit(3);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// optional bool jam = 5;
inline bool MsgKnowledgeGroupCreation::has_jam() const {
  return _has_bit(4);
}
inline void MsgKnowledgeGroupCreation::clear_jam() {
  jam_ = false;
  _clear_bit(4);
}
inline bool MsgKnowledgeGroupCreation::jam() const {
  return jam_;
}
inline void MsgKnowledgeGroupCreation::set_jam(bool value) {
  _set_bit(4);
  jam_ = value;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupUpdate

// required .Common.KnowledgeGroupId id = 1;
inline bool MsgKnowledgeGroupUpdate::has_id() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupUpdate::clear_id() {
  if (id_ != NULL) id_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupUpdate::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupUpdate::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::KnowledgeGroupId;
  return id_;
}

// optional .Common.PartyId party = 2;
inline bool MsgKnowledgeGroupUpdate::has_party() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupUpdate::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgKnowledgeGroupUpdate::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgKnowledgeGroupUpdate::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// optional .Common.KnowledgeGroupId parent = 3;
inline bool MsgKnowledgeGroupUpdate::has_parent() const {
  return _has_bit(2);
}
inline void MsgKnowledgeGroupUpdate::clear_parent() {
  if (parent_ != NULL) parent_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(2);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupUpdate::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupUpdate::mutable_parent() {
  _set_bit(2);
  if (parent_ == NULL) parent_ = new ::Common::KnowledgeGroupId;
  return parent_;
}

// optional bool enabled = 4;
inline bool MsgKnowledgeGroupUpdate::has_enabled() const {
  return _has_bit(3);
}
inline void MsgKnowledgeGroupUpdate::clear_enabled() {
  enabled_ = false;
  _clear_bit(3);
}
inline bool MsgKnowledgeGroupUpdate::enabled() const {
  return enabled_;
}
inline void MsgKnowledgeGroupUpdate::set_enabled(bool value) {
  _set_bit(3);
  enabled_ = value;
}

// optional string type = 5;
inline bool MsgKnowledgeGroupUpdate::has_type() const {
  return _has_bit(4);
}
inline void MsgKnowledgeGroupUpdate::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MsgKnowledgeGroupUpdate::type() const {
  return *type_;
}
inline void MsgKnowledgeGroupUpdate::set_type(const ::std::string& value) {
  _set_bit(4);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MsgKnowledgeGroupUpdate::set_type(const char* value) {
  _set_bit(4);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MsgKnowledgeGroupUpdate::set_type(const char* value, size_t size) {
  _set_bit(4);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgKnowledgeGroupUpdate::mutable_type() {
  _set_bit(4);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// -------------------------------------------------------------------

// KnowledgeGroupAck

// -------------------------------------------------------------------

// MsgKnowledgeGroupMagicActionAck

// required .Common.KnowledgeGroupId id = 1;
inline bool MsgKnowledgeGroupMagicActionAck::has_id() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupMagicActionAck::clear_id() {
  if (id_ != NULL) id_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupMagicActionAck::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupMagicActionAck::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::KnowledgeGroupId;
  return id_;
}

// required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
inline bool MsgKnowledgeGroupMagicActionAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupMagicActionAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode MsgKnowledgeGroupMagicActionAck::error_code() const {
  return static_cast< ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode >(error_code_);
}
inline void MsgKnowledgeGroupMagicActionAck::set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupCreationAck

// required .Common.KnowledgeGroupId id = 1;
inline bool MsgKnowledgeGroupCreationAck::has_id() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupCreationAck::clear_id() {
  if (id_ != NULL) id_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupCreationAck::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupCreationAck::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::KnowledgeGroupId;
  return id_;
}

// required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
inline bool MsgKnowledgeGroupCreationAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupCreationAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode MsgKnowledgeGroupCreationAck::error_code() const {
  return static_cast< ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode >(error_code_);
}
inline void MsgKnowledgeGroupCreationAck::set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupUpdateAck

// required .Common.KnowledgeGroupId id = 1;
inline bool MsgKnowledgeGroupUpdateAck::has_id() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupUpdateAck::clear_id() {
  if (id_ != NULL) id_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupUpdateAck::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupUpdateAck::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::KnowledgeGroupId;
  return id_;
}

// required .MsgsSimToClient.KnowledgeGroupAck.ErrorCode error_code = 2;
inline bool MsgKnowledgeGroupUpdateAck::has_error_code() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupUpdateAck::clear_error_code() {
  error_code_ = 0;
  _clear_bit(1);
}
inline ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode MsgKnowledgeGroupUpdateAck::error_code() const {
  return static_cast< ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode >(error_code_);
}
inline void MsgKnowledgeGroupUpdateAck::set_error_code(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode value) {
  GOOGLE_DCHECK(::MsgsSimToClient::KnowledgeGroupAck_ErrorCode_IsValid(value));
  _set_bit(1);
  error_code_ = value;
}

// -------------------------------------------------------------------

// MsgKnowledgeGroupDestruction

// required .Common.KnowledgeGroupId id = 1;
inline bool MsgKnowledgeGroupDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgKnowledgeGroupDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::KnowledgeGroupId::Clear();
  _clear_bit(0);
}
inline const ::Common::KnowledgeGroupId& MsgKnowledgeGroupDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::KnowledgeGroupId* MsgKnowledgeGroupDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::KnowledgeGroupId;
  return id_;
}

// required .Common.PartyId party = 2;
inline bool MsgKnowledgeGroupDestruction::has_party() const {
  return _has_bit(1);
}
inline void MsgKnowledgeGroupDestruction::clear_party() {
  if (party_ != NULL) party_->::Common::PartyId::Clear();
  _clear_bit(1);
}
inline const ::Common::PartyId& MsgKnowledgeGroupDestruction::party() const {
  return party_ != NULL ? *party_ : *default_instance_->party_;
}
inline ::Common::PartyId* MsgKnowledgeGroupDestruction::mutable_party() {
  _set_bit(1);
  if (party_ == NULL) party_ = new ::Common::PartyId;
  return party_;
}

// -------------------------------------------------------------------

// MsgControlGlobalMeteoAck

// -------------------------------------------------------------------

// MsgControlLocalMeteoAck

// -------------------------------------------------------------------

// MsgControlGlobalMeteo

// required .Common.WeatherId id = 1;
inline bool MsgControlGlobalMeteo::has_id() const {
  return _has_bit(0);
}
inline void MsgControlGlobalMeteo::clear_id() {
  if (id_ != NULL) id_->::Common::WeatherId::Clear();
  _clear_bit(0);
}
inline const ::Common::WeatherId& MsgControlGlobalMeteo::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::WeatherId* MsgControlGlobalMeteo::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::WeatherId;
  return id_;
}

// required .Common.MsgMeteoAttributes attributes = 2;
inline bool MsgControlGlobalMeteo::has_attributes() const {
  return _has_bit(1);
}
inline void MsgControlGlobalMeteo::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::MsgMeteoAttributes::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgMeteoAttributes& MsgControlGlobalMeteo::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::MsgMeteoAttributes* MsgControlGlobalMeteo::mutable_attributes() {
  _set_bit(1);
  if (attributes_ == NULL) attributes_ = new ::Common::MsgMeteoAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgControlLocalMeteoCreation

// required .Common.WeatherId id = 1;
inline bool MsgControlLocalMeteoCreation::has_id() const {
  return _has_bit(0);
}
inline void MsgControlLocalMeteoCreation::clear_id() {
  if (id_ != NULL) id_->::Common::WeatherId::Clear();
  _clear_bit(0);
}
inline const ::Common::WeatherId& MsgControlLocalMeteoCreation::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::WeatherId* MsgControlLocalMeteoCreation::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::WeatherId;
  return id_;
}

// optional .Common.MsgCoordLatLong top_left_coordinate = 2;
inline bool MsgControlLocalMeteoCreation::has_top_left_coordinate() const {
  return _has_bit(1);
}
inline void MsgControlLocalMeteoCreation::clear_top_left_coordinate() {
  if (top_left_coordinate_ != NULL) top_left_coordinate_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(1);
}
inline const ::Common::MsgCoordLatLong& MsgControlLocalMeteoCreation::top_left_coordinate() const {
  return top_left_coordinate_ != NULL ? *top_left_coordinate_ : *default_instance_->top_left_coordinate_;
}
inline ::Common::MsgCoordLatLong* MsgControlLocalMeteoCreation::mutable_top_left_coordinate() {
  _set_bit(1);
  if (top_left_coordinate_ == NULL) top_left_coordinate_ = new ::Common::MsgCoordLatLong;
  return top_left_coordinate_;
}

// optional .Common.MsgCoordLatLong bottom_right_coordinate = 3;
inline bool MsgControlLocalMeteoCreation::has_bottom_right_coordinate() const {
  return _has_bit(2);
}
inline void MsgControlLocalMeteoCreation::clear_bottom_right_coordinate() {
  if (bottom_right_coordinate_ != NULL) bottom_right_coordinate_->::Common::MsgCoordLatLong::Clear();
  _clear_bit(2);
}
inline const ::Common::MsgCoordLatLong& MsgControlLocalMeteoCreation::bottom_right_coordinate() const {
  return bottom_right_coordinate_ != NULL ? *bottom_right_coordinate_ : *default_instance_->bottom_right_coordinate_;
}
inline ::Common::MsgCoordLatLong* MsgControlLocalMeteoCreation::mutable_bottom_right_coordinate() {
  _set_bit(2);
  if (bottom_right_coordinate_ == NULL) bottom_right_coordinate_ = new ::Common::MsgCoordLatLong;
  return bottom_right_coordinate_;
}

// optional .Common.MsgMeteoAttributes attributes = 4;
inline bool MsgControlLocalMeteoCreation::has_attributes() const {
  return _has_bit(3);
}
inline void MsgControlLocalMeteoCreation::clear_attributes() {
  if (attributes_ != NULL) attributes_->::Common::MsgMeteoAttributes::Clear();
  _clear_bit(3);
}
inline const ::Common::MsgMeteoAttributes& MsgControlLocalMeteoCreation::attributes() const {
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::Common::MsgMeteoAttributes* MsgControlLocalMeteoCreation::mutable_attributes() {
  _set_bit(3);
  if (attributes_ == NULL) attributes_ = new ::Common::MsgMeteoAttributes;
  return attributes_;
}

// -------------------------------------------------------------------

// MsgControlLocalMeteoDestruction

// required .Common.WeatherId id = 1;
inline bool MsgControlLocalMeteoDestruction::has_id() const {
  return _has_bit(0);
}
inline void MsgControlLocalMeteoDestruction::clear_id() {
  if (id_ != NULL) id_->::Common::WeatherId::Clear();
  _clear_bit(0);
}
inline const ::Common::WeatherId& MsgControlLocalMeteoDestruction::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::Common::WeatherId* MsgControlLocalMeteoDestruction::mutable_id() {
  _set_bit(0);
  if (id_ == NULL) id_ = new ::Common::WeatherId;
  return id_;
}

// -------------------------------------------------------------------

// MsgSimToClient_Content

// optional .MsgsSimToClient.MsgUnitOrderAck unit_order_ack = 1;
inline bool MsgSimToClient_Content::has_unit_order_ack() const {
  return _has_bit(0);
}
inline void MsgSimToClient_Content::clear_unit_order_ack() {
  if (unit_order_ack_ != NULL) unit_order_ack_->::MsgsSimToClient::MsgUnitOrderAck::Clear();
  _clear_bit(0);
}
inline const ::MsgsSimToClient::MsgUnitOrderAck& MsgSimToClient_Content::unit_order_ack() const {
  return unit_order_ack_ != NULL ? *unit_order_ack_ : *default_instance_->unit_order_ack_;
}
inline ::MsgsSimToClient::MsgUnitOrderAck* MsgSimToClient_Content::mutable_unit_order_ack() {
  _set_bit(0);
  if (unit_order_ack_ == NULL) unit_order_ack_ = new ::MsgsSimToClient::MsgUnitOrderAck;
  return unit_order_ack_;
}

// optional .MsgsSimToClient.MsgAutomatOrderAck automat_order_ack = 2;
inline bool MsgSimToClient_Content::has_automat_order_ack() const {
  return _has_bit(1);
}
inline void MsgSimToClient_Content::clear_automat_order_ack() {
  if (automat_order_ack_ != NULL) automat_order_ack_->::MsgsSimToClient::MsgAutomatOrderAck::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgAutomatOrderAck& MsgSimToClient_Content::automat_order_ack() const {
  return automat_order_ack_ != NULL ? *automat_order_ack_ : *default_instance_->automat_order_ack_;
}
inline ::MsgsSimToClient::MsgAutomatOrderAck* MsgSimToClient_Content::mutable_automat_order_ack() {
  _set_bit(1);
  if (automat_order_ack_ == NULL) automat_order_ack_ = new ::MsgsSimToClient::MsgAutomatOrderAck;
  return automat_order_ack_;
}

// optional .MsgsSimToClient.MsgPopulationOrderAck population_order_ack = 3;
inline bool MsgSimToClient_Content::has_population_order_ack() const {
  return _has_bit(2);
}
inline void MsgSimToClient_Content::clear_population_order_ack() {
  if (population_order_ack_ != NULL) population_order_ack_->::MsgsSimToClient::MsgPopulationOrderAck::Clear();
  _clear_bit(2);
}
inline const ::MsgsSimToClient::MsgPopulationOrderAck& MsgSimToClient_Content::population_order_ack() const {
  return population_order_ack_ != NULL ? *population_order_ack_ : *default_instance_->population_order_ack_;
}
inline ::MsgsSimToClient::MsgPopulationOrderAck* MsgSimToClient_Content::mutable_population_order_ack() {
  _set_bit(2);
  if (population_order_ack_ == NULL) population_order_ack_ = new ::MsgsSimToClient::MsgPopulationOrderAck;
  return population_order_ack_;
}

// optional .MsgsSimToClient.MsgFragOrderAck frag_order_ack = 4;
inline bool MsgSimToClient_Content::has_frag_order_ack() const {
  return _has_bit(3);
}
inline void MsgSimToClient_Content::clear_frag_order_ack() {
  if (frag_order_ack_ != NULL) frag_order_ack_->::MsgsSimToClient::MsgFragOrderAck::Clear();
  _clear_bit(3);
}
inline const ::MsgsSimToClient::MsgFragOrderAck& MsgSimToClient_Content::frag_order_ack() const {
  return frag_order_ack_ != NULL ? *frag_order_ack_ : *default_instance_->frag_order_ack_;
}
inline ::MsgsSimToClient::MsgFragOrderAck* MsgSimToClient_Content::mutable_frag_order_ack() {
  _set_bit(3);
  if (frag_order_ack_ == NULL) frag_order_ack_ = new ::MsgsSimToClient::MsgFragOrderAck;
  return frag_order_ack_;
}

// optional .MsgsSimToClient.MsgSetAutomatModeAck set_automat_mode_ack = 5;
inline bool MsgSimToClient_Content::has_set_automat_mode_ack() const {
  return _has_bit(4);
}
inline void MsgSimToClient_Content::clear_set_automat_mode_ack() {
  if (set_automat_mode_ack_ != NULL) set_automat_mode_ack_->::MsgsSimToClient::MsgSetAutomatModeAck::Clear();
  _clear_bit(4);
}
inline const ::MsgsSimToClient::MsgSetAutomatModeAck& MsgSimToClient_Content::set_automat_mode_ack() const {
  return set_automat_mode_ack_ != NULL ? *set_automat_mode_ack_ : *default_instance_->set_automat_mode_ack_;
}
inline ::MsgsSimToClient::MsgSetAutomatModeAck* MsgSimToClient_Content::mutable_set_automat_mode_ack() {
  _set_bit(4);
  if (set_automat_mode_ack_ == NULL) set_automat_mode_ack_ = new ::MsgsSimToClient::MsgSetAutomatModeAck;
  return set_automat_mode_ack_;
}

// optional .MsgsSimToClient.MsgUnitCreationRequestAck unit_creation_request_ack = 6;
inline bool MsgSimToClient_Content::has_unit_creation_request_ack() const {
  return _has_bit(5);
}
inline void MsgSimToClient_Content::clear_unit_creation_request_ack() {
  if (unit_creation_request_ack_ != NULL) unit_creation_request_ack_->::MsgsSimToClient::MsgUnitCreationRequestAck::Clear();
  _clear_bit(5);
}
inline const ::MsgsSimToClient::MsgUnitCreationRequestAck& MsgSimToClient_Content::unit_creation_request_ack() const {
  return unit_creation_request_ack_ != NULL ? *unit_creation_request_ack_ : *default_instance_->unit_creation_request_ack_;
}
inline ::MsgsSimToClient::MsgUnitCreationRequestAck* MsgSimToClient_Content::mutable_unit_creation_request_ack() {
  _set_bit(5);
  if (unit_creation_request_ack_ == NULL) unit_creation_request_ack_ = new ::MsgsSimToClient::MsgUnitCreationRequestAck;
  return unit_creation_request_ack_;
}

// optional .MsgsSimToClient.MsgMagicActionAck magic_action_ack = 7;
inline bool MsgSimToClient_Content::has_magic_action_ack() const {
  return _has_bit(6);
}
inline void MsgSimToClient_Content::clear_magic_action_ack() {
  if (magic_action_ack_ != NULL) magic_action_ack_->::MsgsSimToClient::MsgMagicActionAck::Clear();
  _clear_bit(6);
}
inline const ::MsgsSimToClient::MsgMagicActionAck& MsgSimToClient_Content::magic_action_ack() const {
  return magic_action_ack_ != NULL ? *magic_action_ack_ : *default_instance_->magic_action_ack_;
}
inline ::MsgsSimToClient::MsgMagicActionAck* MsgSimToClient_Content::mutable_magic_action_ack() {
  _set_bit(6);
  if (magic_action_ack_ == NULL) magic_action_ack_ = new ::MsgsSimToClient::MsgMagicActionAck;
  return magic_action_ack_;
}

// optional .MsgsSimToClient.MsgUnitMagicActionAck unit_magic_action_ack = 8;
inline bool MsgSimToClient_Content::has_unit_magic_action_ack() const {
  return _has_bit(7);
}
inline void MsgSimToClient_Content::clear_unit_magic_action_ack() {
  if (unit_magic_action_ack_ != NULL) unit_magic_action_ack_->::MsgsSimToClient::MsgUnitMagicActionAck::Clear();
  _clear_bit(7);
}
inline const ::MsgsSimToClient::MsgUnitMagicActionAck& MsgSimToClient_Content::unit_magic_action_ack() const {
  return unit_magic_action_ack_ != NULL ? *unit_magic_action_ack_ : *default_instance_->unit_magic_action_ack_;
}
inline ::MsgsSimToClient::MsgUnitMagicActionAck* MsgSimToClient_Content::mutable_unit_magic_action_ack() {
  _set_bit(7);
  if (unit_magic_action_ack_ == NULL) unit_magic_action_ack_ = new ::MsgsSimToClient::MsgUnitMagicActionAck;
  return unit_magic_action_ack_;
}

// optional .MsgsSimToClient.MsgObjectMagicActionAck object_magic_action_ack = 9;
inline bool MsgSimToClient_Content::has_object_magic_action_ack() const {
  return _has_bit(8);
}
inline void MsgSimToClient_Content::clear_object_magic_action_ack() {
  if (object_magic_action_ack_ != NULL) object_magic_action_ack_->::MsgsSimToClient::MsgObjectMagicActionAck::Clear();
  _clear_bit(8);
}
inline const ::MsgsSimToClient::MsgObjectMagicActionAck& MsgSimToClient_Content::object_magic_action_ack() const {
  return object_magic_action_ack_ != NULL ? *object_magic_action_ack_ : *default_instance_->object_magic_action_ack_;
}
inline ::MsgsSimToClient::MsgObjectMagicActionAck* MsgSimToClient_Content::mutable_object_magic_action_ack() {
  _set_bit(8);
  if (object_magic_action_ack_ == NULL) object_magic_action_ack_ = new ::MsgsSimToClient::MsgObjectMagicActionAck;
  return object_magic_action_ack_;
}

// optional .MsgsSimToClient.MsgPopulationMagicActionAck population_magic_action_ack = 10;
inline bool MsgSimToClient_Content::has_population_magic_action_ack() const {
  return _has_bit(9);
}
inline void MsgSimToClient_Content::clear_population_magic_action_ack() {
  if (population_magic_action_ack_ != NULL) population_magic_action_ack_->::MsgsSimToClient::MsgPopulationMagicActionAck::Clear();
  _clear_bit(9);
}
inline const ::MsgsSimToClient::MsgPopulationMagicActionAck& MsgSimToClient_Content::population_magic_action_ack() const {
  return population_magic_action_ack_ != NULL ? *population_magic_action_ack_ : *default_instance_->population_magic_action_ack_;
}
inline ::MsgsSimToClient::MsgPopulationMagicActionAck* MsgSimToClient_Content::mutable_population_magic_action_ack() {
  _set_bit(9);
  if (population_magic_action_ack_ == NULL) population_magic_action_ack_ = new ::MsgsSimToClient::MsgPopulationMagicActionAck;
  return population_magic_action_ack_;
}

// optional .MsgsSimToClient.MsgChangeDiplomacyAck change_diplomacy_ack = 11;
inline bool MsgSimToClient_Content::has_change_diplomacy_ack() const {
  return _has_bit(10);
}
inline void MsgSimToClient_Content::clear_change_diplomacy_ack() {
  if (change_diplomacy_ack_ != NULL) change_diplomacy_ack_->::MsgsSimToClient::MsgChangeDiplomacyAck::Clear();
  _clear_bit(10);
}
inline const ::MsgsSimToClient::MsgChangeDiplomacyAck& MsgSimToClient_Content::change_diplomacy_ack() const {
  return change_diplomacy_ack_ != NULL ? *change_diplomacy_ack_ : *default_instance_->change_diplomacy_ack_;
}
inline ::MsgsSimToClient::MsgChangeDiplomacyAck* MsgSimToClient_Content::mutable_change_diplomacy_ack() {
  _set_bit(10);
  if (change_diplomacy_ack_ == NULL) change_diplomacy_ack_ = new ::MsgsSimToClient::MsgChangeDiplomacyAck;
  return change_diplomacy_ack_;
}

// optional .MsgsSimToClient.MsgAutomatChangeKnowledgeGroupAck automat_change_knowledge_group_ack = 12;
inline bool MsgSimToClient_Content::has_automat_change_knowledge_group_ack() const {
  return _has_bit(11);
}
inline void MsgSimToClient_Content::clear_automat_change_knowledge_group_ack() {
  if (automat_change_knowledge_group_ack_ != NULL) automat_change_knowledge_group_ack_->::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck::Clear();
  _clear_bit(11);
}
inline const ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck& MsgSimToClient_Content::automat_change_knowledge_group_ack() const {
  return automat_change_knowledge_group_ack_ != NULL ? *automat_change_knowledge_group_ack_ : *default_instance_->automat_change_knowledge_group_ack_;
}
inline ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck* MsgSimToClient_Content::mutable_automat_change_knowledge_group_ack() {
  _set_bit(11);
  if (automat_change_knowledge_group_ack_ == NULL) automat_change_knowledge_group_ack_ = new ::MsgsSimToClient::MsgAutomatChangeKnowledgeGroupAck;
  return automat_change_knowledge_group_ack_;
}

// optional .MsgsSimToClient.MsgAutomatChangeLogisticLinksAck automat_change_logistic_links_ack = 13;
inline bool MsgSimToClient_Content::has_automat_change_logistic_links_ack() const {
  return _has_bit(12);
}
inline void MsgSimToClient_Content::clear_automat_change_logistic_links_ack() {
  if (automat_change_logistic_links_ack_ != NULL) automat_change_logistic_links_ack_->::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck::Clear();
  _clear_bit(12);
}
inline const ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck& MsgSimToClient_Content::automat_change_logistic_links_ack() const {
  return automat_change_logistic_links_ack_ != NULL ? *automat_change_logistic_links_ack_ : *default_instance_->automat_change_logistic_links_ack_;
}
inline ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck* MsgSimToClient_Content::mutable_automat_change_logistic_links_ack() {
  _set_bit(12);
  if (automat_change_logistic_links_ack_ == NULL) automat_change_logistic_links_ack_ = new ::MsgsSimToClient::MsgAutomatChangeLogisticLinksAck;
  return automat_change_logistic_links_ack_;
}

// optional .MsgsSimToClient.MsgAutomatChangeSuperiorAck automat_change_superior_ack = 14;
inline bool MsgSimToClient_Content::has_automat_change_superior_ack() const {
  return _has_bit(13);
}
inline void MsgSimToClient_Content::clear_automat_change_superior_ack() {
  if (automat_change_superior_ack_ != NULL) automat_change_superior_ack_->::MsgsSimToClient::MsgAutomatChangeSuperiorAck::Clear();
  _clear_bit(13);
}
inline const ::MsgsSimToClient::MsgAutomatChangeSuperiorAck& MsgSimToClient_Content::automat_change_superior_ack() const {
  return automat_change_superior_ack_ != NULL ? *automat_change_superior_ack_ : *default_instance_->automat_change_superior_ack_;
}
inline ::MsgsSimToClient::MsgAutomatChangeSuperiorAck* MsgSimToClient_Content::mutable_automat_change_superior_ack() {
  _set_bit(13);
  if (automat_change_superior_ack_ == NULL) automat_change_superior_ack_ = new ::MsgsSimToClient::MsgAutomatChangeSuperiorAck;
  return automat_change_superior_ack_;
}

// optional .MsgsSimToClient.MsgUnitChangeSuperiorAck unit_change_superior_ack = 15;
inline bool MsgSimToClient_Content::has_unit_change_superior_ack() const {
  return _has_bit(14);
}
inline void MsgSimToClient_Content::clear_unit_change_superior_ack() {
  if (unit_change_superior_ack_ != NULL) unit_change_superior_ack_->::MsgsSimToClient::MsgUnitChangeSuperiorAck::Clear();
  _clear_bit(14);
}
inline const ::MsgsSimToClient::MsgUnitChangeSuperiorAck& MsgSimToClient_Content::unit_change_superior_ack() const {
  return unit_change_superior_ack_ != NULL ? *unit_change_superior_ack_ : *default_instance_->unit_change_superior_ack_;
}
inline ::MsgsSimToClient::MsgUnitChangeSuperiorAck* MsgSimToClient_Content::mutable_unit_change_superior_ack() {
  _set_bit(14);
  if (unit_change_superior_ack_ == NULL) unit_change_superior_ack_ = new ::MsgsSimToClient::MsgUnitChangeSuperiorAck;
  return unit_change_superior_ack_;
}

// optional .MsgsSimToClient.MsgLogSupplyPushFlowAck log_supply_push_flow_ack = 16;
inline bool MsgSimToClient_Content::has_log_supply_push_flow_ack() const {
  return _has_bit(15);
}
inline void MsgSimToClient_Content::clear_log_supply_push_flow_ack() {
  if (log_supply_push_flow_ack_ != NULL) log_supply_push_flow_ack_->::MsgsSimToClient::MsgLogSupplyPushFlowAck::Clear();
  _clear_bit(15);
}
inline const ::MsgsSimToClient::MsgLogSupplyPushFlowAck& MsgSimToClient_Content::log_supply_push_flow_ack() const {
  return log_supply_push_flow_ack_ != NULL ? *log_supply_push_flow_ack_ : *default_instance_->log_supply_push_flow_ack_;
}
inline ::MsgsSimToClient::MsgLogSupplyPushFlowAck* MsgSimToClient_Content::mutable_log_supply_push_flow_ack() {
  _set_bit(15);
  if (log_supply_push_flow_ack_ == NULL) log_supply_push_flow_ack_ = new ::MsgsSimToClient::MsgLogSupplyPushFlowAck;
  return log_supply_push_flow_ack_;
}

// optional .MsgsSimToClient.MsgLogSupplyChangeQuotasAck log_supply_change_quotas_ack = 17;
inline bool MsgSimToClient_Content::has_log_supply_change_quotas_ack() const {
  return _has_bit(16);
}
inline void MsgSimToClient_Content::clear_log_supply_change_quotas_ack() {
  if (log_supply_change_quotas_ack_ != NULL) log_supply_change_quotas_ack_->::MsgsSimToClient::MsgLogSupplyChangeQuotasAck::Clear();
  _clear_bit(16);
}
inline const ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck& MsgSimToClient_Content::log_supply_change_quotas_ack() const {
  return log_supply_change_quotas_ack_ != NULL ? *log_supply_change_quotas_ack_ : *default_instance_->log_supply_change_quotas_ack_;
}
inline ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck* MsgSimToClient_Content::mutable_log_supply_change_quotas_ack() {
  _set_bit(16);
  if (log_supply_change_quotas_ack_ == NULL) log_supply_change_quotas_ack_ = new ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck;
  return log_supply_change_quotas_ack_;
}

// optional .MsgsSimToClient.MsgControlInformation control_information = 18;
inline bool MsgSimToClient_Content::has_control_information() const {
  return _has_bit(17);
}
inline void MsgSimToClient_Content::clear_control_information() {
  if (control_information_ != NULL) control_information_->::MsgsSimToClient::MsgControlInformation::Clear();
  _clear_bit(17);
}
inline const ::MsgsSimToClient::MsgControlInformation& MsgSimToClient_Content::control_information() const {
  return control_information_ != NULL ? *control_information_ : *default_instance_->control_information_;
}
inline ::MsgsSimToClient::MsgControlInformation* MsgSimToClient_Content::mutable_control_information() {
  _set_bit(17);
  if (control_information_ == NULL) control_information_ = new ::MsgsSimToClient::MsgControlInformation;
  return control_information_;
}

// optional .MsgsSimToClient.MsgControlProfilingInformation control_profiling_information = 19;
inline bool MsgSimToClient_Content::has_control_profiling_information() const {
  return _has_bit(18);
}
inline void MsgSimToClient_Content::clear_control_profiling_information() {
  if (control_profiling_information_ != NULL) control_profiling_information_->::MsgsSimToClient::MsgControlProfilingInformation::Clear();
  _clear_bit(18);
}
inline const ::MsgsSimToClient::MsgControlProfilingInformation& MsgSimToClient_Content::control_profiling_information() const {
  return control_profiling_information_ != NULL ? *control_profiling_information_ : *default_instance_->control_profiling_information_;
}
inline ::MsgsSimToClient::MsgControlProfilingInformation* MsgSimToClient_Content::mutable_control_profiling_information() {
  _set_bit(18);
  if (control_profiling_information_ == NULL) control_profiling_information_ = new ::MsgsSimToClient::MsgControlProfilingInformation;
  return control_profiling_information_;
}

// optional .MsgsSimToClient.MsgControlBeginTick control_begin_tick = 20;
inline bool MsgSimToClient_Content::has_control_begin_tick() const {
  return _has_bit(19);
}
inline void MsgSimToClient_Content::clear_control_begin_tick() {
  if (control_begin_tick_ != NULL) control_begin_tick_->::MsgsSimToClient::MsgControlBeginTick::Clear();
  _clear_bit(19);
}
inline const ::MsgsSimToClient::MsgControlBeginTick& MsgSimToClient_Content::control_begin_tick() const {
  return control_begin_tick_ != NULL ? *control_begin_tick_ : *default_instance_->control_begin_tick_;
}
inline ::MsgsSimToClient::MsgControlBeginTick* MsgSimToClient_Content::mutable_control_begin_tick() {
  _set_bit(19);
  if (control_begin_tick_ == NULL) control_begin_tick_ = new ::MsgsSimToClient::MsgControlBeginTick;
  return control_begin_tick_;
}

// optional .MsgsSimToClient.MsgControlEndTick control_end_tick = 21;
inline bool MsgSimToClient_Content::has_control_end_tick() const {
  return _has_bit(20);
}
inline void MsgSimToClient_Content::clear_control_end_tick() {
  if (control_end_tick_ != NULL) control_end_tick_->::MsgsSimToClient::MsgControlEndTick::Clear();
  _clear_bit(20);
}
inline const ::MsgsSimToClient::MsgControlEndTick& MsgSimToClient_Content::control_end_tick() const {
  return control_end_tick_ != NULL ? *control_end_tick_ : *default_instance_->control_end_tick_;
}
inline ::MsgsSimToClient::MsgControlEndTick* MsgSimToClient_Content::mutable_control_end_tick() {
  _set_bit(20);
  if (control_end_tick_ == NULL) control_end_tick_ = new ::MsgsSimToClient::MsgControlEndTick;
  return control_end_tick_;
}

// optional .MsgsSimToClient.MsgControlStopAck control_stop_ack = 22;
inline bool MsgSimToClient_Content::has_control_stop_ack() const {
  return _has_bit(21);
}
inline void MsgSimToClient_Content::clear_control_stop_ack() {
  if (control_stop_ack_ != NULL) control_stop_ack_->::MsgsSimToClient::MsgControlStopAck::Clear();
  _clear_bit(21);
}
inline const ::MsgsSimToClient::MsgControlStopAck& MsgSimToClient_Content::control_stop_ack() const {
  return control_stop_ack_ != NULL ? *control_stop_ack_ : *default_instance_->control_stop_ack_;
}
inline ::MsgsSimToClient::MsgControlStopAck* MsgSimToClient_Content::mutable_control_stop_ack() {
  _set_bit(21);
  if (control_stop_ack_ == NULL) control_stop_ack_ = new ::MsgsSimToClient::MsgControlStopAck;
  return control_stop_ack_;
}

// optional .MsgsSimToClient.MsgControlPauseAck control_pause_ack = 23;
inline bool MsgSimToClient_Content::has_control_pause_ack() const {
  return _has_bit(22);
}
inline void MsgSimToClient_Content::clear_control_pause_ack() {
  if (control_pause_ack_ != NULL) control_pause_ack_->::MsgsSimToClient::MsgControlPauseAck::Clear();
  _clear_bit(22);
}
inline const ::MsgsSimToClient::MsgControlPauseAck& MsgSimToClient_Content::control_pause_ack() const {
  return control_pause_ack_ != NULL ? *control_pause_ack_ : *default_instance_->control_pause_ack_;
}
inline ::MsgsSimToClient::MsgControlPauseAck* MsgSimToClient_Content::mutable_control_pause_ack() {
  _set_bit(22);
  if (control_pause_ack_ == NULL) control_pause_ack_ = new ::MsgsSimToClient::MsgControlPauseAck;
  return control_pause_ack_;
}

// optional .MsgsSimToClient.MsgControlResumeAck control_resume_ack = 24;
inline bool MsgSimToClient_Content::has_control_resume_ack() const {
  return _has_bit(23);
}
inline void MsgSimToClient_Content::clear_control_resume_ack() {
  if (control_resume_ack_ != NULL) control_resume_ack_->::MsgsSimToClient::MsgControlResumeAck::Clear();
  _clear_bit(23);
}
inline const ::MsgsSimToClient::MsgControlResumeAck& MsgSimToClient_Content::control_resume_ack() const {
  return control_resume_ack_ != NULL ? *control_resume_ack_ : *default_instance_->control_resume_ack_;
}
inline ::MsgsSimToClient::MsgControlResumeAck* MsgSimToClient_Content::mutable_control_resume_ack() {
  _set_bit(23);
  if (control_resume_ack_ == NULL) control_resume_ack_ = new ::MsgsSimToClient::MsgControlResumeAck;
  return control_resume_ack_;
}

// optional .MsgsSimToClient.MsgControlChangeTimeFactorAck control_change_time_factor_ack = 25;
inline bool MsgSimToClient_Content::has_control_change_time_factor_ack() const {
  return _has_bit(24);
}
inline void MsgSimToClient_Content::clear_control_change_time_factor_ack() {
  if (control_change_time_factor_ack_ != NULL) control_change_time_factor_ack_->::MsgsSimToClient::MsgControlChangeTimeFactorAck::Clear();
  _clear_bit(24);
}
inline const ::MsgsSimToClient::MsgControlChangeTimeFactorAck& MsgSimToClient_Content::control_change_time_factor_ack() const {
  return control_change_time_factor_ack_ != NULL ? *control_change_time_factor_ack_ : *default_instance_->control_change_time_factor_ack_;
}
inline ::MsgsSimToClient::MsgControlChangeTimeFactorAck* MsgSimToClient_Content::mutable_control_change_time_factor_ack() {
  _set_bit(24);
  if (control_change_time_factor_ack_ == NULL) control_change_time_factor_ack_ = new ::MsgsSimToClient::MsgControlChangeTimeFactorAck;
  return control_change_time_factor_ack_;
}

// optional .MsgsSimToClient.MsgControlDatetimeChangeAck control_date_time_change_ack = 26;
inline bool MsgSimToClient_Content::has_control_date_time_change_ack() const {
  return _has_bit(25);
}
inline void MsgSimToClient_Content::clear_control_date_time_change_ack() {
  if (control_date_time_change_ack_ != NULL) control_date_time_change_ack_->::MsgsSimToClient::MsgControlDatetimeChangeAck::Clear();
  _clear_bit(25);
}
inline const ::MsgsSimToClient::MsgControlDatetimeChangeAck& MsgSimToClient_Content::control_date_time_change_ack() const {
  return control_date_time_change_ack_ != NULL ? *control_date_time_change_ack_ : *default_instance_->control_date_time_change_ack_;
}
inline ::MsgsSimToClient::MsgControlDatetimeChangeAck* MsgSimToClient_Content::mutable_control_date_time_change_ack() {
  _set_bit(25);
  if (control_date_time_change_ack_ == NULL) control_date_time_change_ack_ = new ::MsgsSimToClient::MsgControlDatetimeChangeAck;
  return control_date_time_change_ack_;
}

// optional .MsgsSimToClient.MsgControlCheckPointSaveEnd control_checkpoint_save_end = 27;
inline bool MsgSimToClient_Content::has_control_checkpoint_save_end() const {
  return _has_bit(26);
}
inline void MsgSimToClient_Content::clear_control_checkpoint_save_end() {
  if (control_checkpoint_save_end_ != NULL) control_checkpoint_save_end_->::MsgsSimToClient::MsgControlCheckPointSaveEnd::Clear();
  _clear_bit(26);
}
inline const ::MsgsSimToClient::MsgControlCheckPointSaveEnd& MsgSimToClient_Content::control_checkpoint_save_end() const {
  return control_checkpoint_save_end_ != NULL ? *control_checkpoint_save_end_ : *default_instance_->control_checkpoint_save_end_;
}
inline ::MsgsSimToClient::MsgControlCheckPointSaveEnd* MsgSimToClient_Content::mutable_control_checkpoint_save_end() {
  _set_bit(26);
  if (control_checkpoint_save_end_ == NULL) control_checkpoint_save_end_ = new ::MsgsSimToClient::MsgControlCheckPointSaveEnd;
  return control_checkpoint_save_end_;
}

// optional .Common.MsgFormationCreation formation_creation = 28;
inline bool MsgSimToClient_Content::has_formation_creation() const {
  return _has_bit(27);
}
inline void MsgSimToClient_Content::clear_formation_creation() {
  if (formation_creation_ != NULL) formation_creation_->::Common::MsgFormationCreation::Clear();
  _clear_bit(27);
}
inline const ::Common::MsgFormationCreation& MsgSimToClient_Content::formation_creation() const {
  return formation_creation_ != NULL ? *formation_creation_ : *default_instance_->formation_creation_;
}
inline ::Common::MsgFormationCreation* MsgSimToClient_Content::mutable_formation_creation() {
  _set_bit(27);
  if (formation_creation_ == NULL) formation_creation_ = new ::Common::MsgFormationCreation;
  return formation_creation_;
}

// optional .MsgsSimToClient.MsgTeamCreation side_creation = 29;
inline bool MsgSimToClient_Content::has_side_creation() const {
  return _has_bit(28);
}
inline void MsgSimToClient_Content::clear_side_creation() {
  if (side_creation_ != NULL) side_creation_->::MsgsSimToClient::MsgTeamCreation::Clear();
  _clear_bit(28);
}
inline const ::MsgsSimToClient::MsgTeamCreation& MsgSimToClient_Content::side_creation() const {
  return side_creation_ != NULL ? *side_creation_ : *default_instance_->side_creation_;
}
inline ::MsgsSimToClient::MsgTeamCreation* MsgSimToClient_Content::mutable_side_creation() {
  _set_bit(28);
  if (side_creation_ == NULL) side_creation_ = new ::MsgsSimToClient::MsgTeamCreation;
  return side_creation_;
}

// optional .MsgsSimToClient.MsgAutomatCreation automat_creation = 30;
inline bool MsgSimToClient_Content::has_automat_creation() const {
  return _has_bit(29);
}
inline void MsgSimToClient_Content::clear_automat_creation() {
  if (automat_creation_ != NULL) automat_creation_->::MsgsSimToClient::MsgAutomatCreation::Clear();
  _clear_bit(29);
}
inline const ::MsgsSimToClient::MsgAutomatCreation& MsgSimToClient_Content::automat_creation() const {
  return automat_creation_ != NULL ? *automat_creation_ : *default_instance_->automat_creation_;
}
inline ::MsgsSimToClient::MsgAutomatCreation* MsgSimToClient_Content::mutable_automat_creation() {
  _set_bit(29);
  if (automat_creation_ == NULL) automat_creation_ = new ::MsgsSimToClient::MsgAutomatCreation;
  return automat_creation_;
}

// optional .MsgsSimToClient.MsgAutomatAttributes automat_attributes = 31;
inline bool MsgSimToClient_Content::has_automat_attributes() const {
  return _has_bit(30);
}
inline void MsgSimToClient_Content::clear_automat_attributes() {
  if (automat_attributes_ != NULL) automat_attributes_->::MsgsSimToClient::MsgAutomatAttributes::Clear();
  _clear_bit(30);
}
inline const ::MsgsSimToClient::MsgAutomatAttributes& MsgSimToClient_Content::automat_attributes() const {
  return automat_attributes_ != NULL ? *automat_attributes_ : *default_instance_->automat_attributes_;
}
inline ::MsgsSimToClient::MsgAutomatAttributes* MsgSimToClient_Content::mutable_automat_attributes() {
  _set_bit(30);
  if (automat_attributes_ == NULL) automat_attributes_ = new ::MsgsSimToClient::MsgAutomatAttributes;
  return automat_attributes_;
}

// optional .MsgsSimToClient.MsgUnitCreation unit_creation = 32;
inline bool MsgSimToClient_Content::has_unit_creation() const {
  return _has_bit(31);
}
inline void MsgSimToClient_Content::clear_unit_creation() {
  if (unit_creation_ != NULL) unit_creation_->::MsgsSimToClient::MsgUnitCreation::Clear();
  _clear_bit(31);
}
inline const ::MsgsSimToClient::MsgUnitCreation& MsgSimToClient_Content::unit_creation() const {
  return unit_creation_ != NULL ? *unit_creation_ : *default_instance_->unit_creation_;
}
inline ::MsgsSimToClient::MsgUnitCreation* MsgSimToClient_Content::mutable_unit_creation() {
  _set_bit(31);
  if (unit_creation_ == NULL) unit_creation_ = new ::MsgsSimToClient::MsgUnitCreation;
  return unit_creation_;
}

// optional .MsgsSimToClient.MsgUnitAttributes unit_attributes = 33;
inline bool MsgSimToClient_Content::has_unit_attributes() const {
  return _has_bit(32);
}
inline void MsgSimToClient_Content::clear_unit_attributes() {
  if (unit_attributes_ != NULL) unit_attributes_->::MsgsSimToClient::MsgUnitAttributes::Clear();
  _clear_bit(32);
}
inline const ::MsgsSimToClient::MsgUnitAttributes& MsgSimToClient_Content::unit_attributes() const {
  return unit_attributes_ != NULL ? *unit_attributes_ : *default_instance_->unit_attributes_;
}
inline ::MsgsSimToClient::MsgUnitAttributes* MsgSimToClient_Content::mutable_unit_attributes() {
  _set_bit(32);
  if (unit_attributes_ == NULL) unit_attributes_ = new ::MsgsSimToClient::MsgUnitAttributes;
  return unit_attributes_;
}

// optional .MsgsSimToClient.MsgUnitPathFind unit_pathfind = 34;
inline bool MsgSimToClient_Content::has_unit_pathfind() const {
  return _has_bit(33);
}
inline void MsgSimToClient_Content::clear_unit_pathfind() {
  if (unit_pathfind_ != NULL) unit_pathfind_->::MsgsSimToClient::MsgUnitPathFind::Clear();
  _clear_bit(33);
}
inline const ::MsgsSimToClient::MsgUnitPathFind& MsgSimToClient_Content::unit_pathfind() const {
  return unit_pathfind_ != NULL ? *unit_pathfind_ : *default_instance_->unit_pathfind_;
}
inline ::MsgsSimToClient::MsgUnitPathFind* MsgSimToClient_Content::mutable_unit_pathfind() {
  _set_bit(33);
  if (unit_pathfind_ == NULL) unit_pathfind_ = new ::MsgsSimToClient::MsgUnitPathFind;
  return unit_pathfind_;
}

// optional .MsgsSimToClient.MsgUnitDestruction unit_destruction = 35;
inline bool MsgSimToClient_Content::has_unit_destruction() const {
  return _has_bit(34);
}
inline void MsgSimToClient_Content::clear_unit_destruction() {
  if (unit_destruction_ != NULL) unit_destruction_->::MsgsSimToClient::MsgUnitDestruction::Clear();
  _clear_bit(34);
}
inline const ::MsgsSimToClient::MsgUnitDestruction& MsgSimToClient_Content::unit_destruction() const {
  return unit_destruction_ != NULL ? *unit_destruction_ : *default_instance_->unit_destruction_;
}
inline ::MsgsSimToClient::MsgUnitDestruction* MsgSimToClient_Content::mutable_unit_destruction() {
  _set_bit(34);
  if (unit_destruction_ == NULL) unit_destruction_ = new ::MsgsSimToClient::MsgUnitDestruction;
  return unit_destruction_;
}

// optional .MsgsSimToClient.MsgUnitEnvironmentType unit_environment_type = 36;
inline bool MsgSimToClient_Content::has_unit_environment_type() const {
  return _has_bit(35);
}
inline void MsgSimToClient_Content::clear_unit_environment_type() {
  if (unit_environment_type_ != NULL) unit_environment_type_->::MsgsSimToClient::MsgUnitEnvironmentType::Clear();
  _clear_bit(35);
}
inline const ::MsgsSimToClient::MsgUnitEnvironmentType& MsgSimToClient_Content::unit_environment_type() const {
  return unit_environment_type_ != NULL ? *unit_environment_type_ : *default_instance_->unit_environment_type_;
}
inline ::MsgsSimToClient::MsgUnitEnvironmentType* MsgSimToClient_Content::mutable_unit_environment_type() {
  _set_bit(35);
  if (unit_environment_type_ == NULL) unit_environment_type_ = new ::MsgsSimToClient::MsgUnitEnvironmentType;
  return unit_environment_type_;
}

// optional .Common.MsgChangeDiplomacy change_diplomacy = 37;
inline bool MsgSimToClient_Content::has_change_diplomacy() const {
  return _has_bit(36);
}
inline void MsgSimToClient_Content::clear_change_diplomacy() {
  if (change_diplomacy_ != NULL) change_diplomacy_->::Common::MsgChangeDiplomacy::Clear();
  _clear_bit(36);
}
inline const ::Common::MsgChangeDiplomacy& MsgSimToClient_Content::change_diplomacy() const {
  return change_diplomacy_ != NULL ? *change_diplomacy_ : *default_instance_->change_diplomacy_;
}
inline ::Common::MsgChangeDiplomacy* MsgSimToClient_Content::mutable_change_diplomacy() {
  _set_bit(36);
  if (change_diplomacy_ == NULL) change_diplomacy_ = new ::Common::MsgChangeDiplomacy;
  return change_diplomacy_;
}

// optional .Common.MsgUnitChangeSuperior unit_change_superior = 38;
inline bool MsgSimToClient_Content::has_unit_change_superior() const {
  return _has_bit(37);
}
inline void MsgSimToClient_Content::clear_unit_change_superior() {
  if (unit_change_superior_ != NULL) unit_change_superior_->::Common::MsgUnitChangeSuperior::Clear();
  _clear_bit(37);
}
inline const ::Common::MsgUnitChangeSuperior& MsgSimToClient_Content::unit_change_superior() const {
  return unit_change_superior_ != NULL ? *unit_change_superior_ : *default_instance_->unit_change_superior_;
}
inline ::Common::MsgUnitChangeSuperior* MsgSimToClient_Content::mutable_unit_change_superior() {
  _set_bit(37);
  if (unit_change_superior_ == NULL) unit_change_superior_ = new ::Common::MsgUnitChangeSuperior;
  return unit_change_superior_;
}

// optional .Common.MsgAutomatChangeLogisticLinks automat_change_logistic_links = 39;
inline bool MsgSimToClient_Content::has_automat_change_logistic_links() const {
  return _has_bit(38);
}
inline void MsgSimToClient_Content::clear_automat_change_logistic_links() {
  if (automat_change_logistic_links_ != NULL) automat_change_logistic_links_->::Common::MsgAutomatChangeLogisticLinks::Clear();
  _clear_bit(38);
}
inline const ::Common::MsgAutomatChangeLogisticLinks& MsgSimToClient_Content::automat_change_logistic_links() const {
  return automat_change_logistic_links_ != NULL ? *automat_change_logistic_links_ : *default_instance_->automat_change_logistic_links_;
}
inline ::Common::MsgAutomatChangeLogisticLinks* MsgSimToClient_Content::mutable_automat_change_logistic_links() {
  _set_bit(38);
  if (automat_change_logistic_links_ == NULL) automat_change_logistic_links_ = new ::Common::MsgAutomatChangeLogisticLinks;
  return automat_change_logistic_links_;
}

// optional .Common.MsgAutomatChangeKnowledgeGroup automat_change_knowledge_group = 40;
inline bool MsgSimToClient_Content::has_automat_change_knowledge_group() const {
  return _has_bit(39);
}
inline void MsgSimToClient_Content::clear_automat_change_knowledge_group() {
  if (automat_change_knowledge_group_ != NULL) automat_change_knowledge_group_->::Common::MsgAutomatChangeKnowledgeGroup::Clear();
  _clear_bit(39);
}
inline const ::Common::MsgAutomatChangeKnowledgeGroup& MsgSimToClient_Content::automat_change_knowledge_group() const {
  return automat_change_knowledge_group_ != NULL ? *automat_change_knowledge_group_ : *default_instance_->automat_change_knowledge_group_;
}
inline ::Common::MsgAutomatChangeKnowledgeGroup* MsgSimToClient_Content::mutable_automat_change_knowledge_group() {
  _set_bit(39);
  if (automat_change_knowledge_group_ == NULL) automat_change_knowledge_group_ = new ::Common::MsgAutomatChangeKnowledgeGroup;
  return automat_change_knowledge_group_;
}

// optional .Common.MsgAutomatChangeSuperior automat_change_superior = 41;
inline bool MsgSimToClient_Content::has_automat_change_superior() const {
  return _has_bit(40);
}
inline void MsgSimToClient_Content::clear_automat_change_superior() {
  if (automat_change_superior_ != NULL) automat_change_superior_->::Common::MsgAutomatChangeSuperior::Clear();
  _clear_bit(40);
}
inline const ::Common::MsgAutomatChangeSuperior& MsgSimToClient_Content::automat_change_superior() const {
  return automat_change_superior_ != NULL ? *automat_change_superior_ : *default_instance_->automat_change_superior_;
}
inline ::Common::MsgAutomatChangeSuperior* MsgSimToClient_Content::mutable_automat_change_superior() {
  _set_bit(40);
  if (automat_change_superior_ == NULL) automat_change_superior_ = new ::Common::MsgAutomatChangeSuperior;
  return automat_change_superior_;
}

// optional .MsgsSimToClient.MsgUnitKnowledgeCreation unit_knowledge_creation = 42;
inline bool MsgSimToClient_Content::has_unit_knowledge_creation() const {
  return _has_bit(41);
}
inline void MsgSimToClient_Content::clear_unit_knowledge_creation() {
  if (unit_knowledge_creation_ != NULL) unit_knowledge_creation_->::MsgsSimToClient::MsgUnitKnowledgeCreation::Clear();
  _clear_bit(41);
}
inline const ::MsgsSimToClient::MsgUnitKnowledgeCreation& MsgSimToClient_Content::unit_knowledge_creation() const {
  return unit_knowledge_creation_ != NULL ? *unit_knowledge_creation_ : *default_instance_->unit_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgUnitKnowledgeCreation* MsgSimToClient_Content::mutable_unit_knowledge_creation() {
  _set_bit(41);
  if (unit_knowledge_creation_ == NULL) unit_knowledge_creation_ = new ::MsgsSimToClient::MsgUnitKnowledgeCreation;
  return unit_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgUnitKnowledgeUpdate unit_knowledge_update = 43;
inline bool MsgSimToClient_Content::has_unit_knowledge_update() const {
  return _has_bit(42);
}
inline void MsgSimToClient_Content::clear_unit_knowledge_update() {
  if (unit_knowledge_update_ != NULL) unit_knowledge_update_->::MsgsSimToClient::MsgUnitKnowledgeUpdate::Clear();
  _clear_bit(42);
}
inline const ::MsgsSimToClient::MsgUnitKnowledgeUpdate& MsgSimToClient_Content::unit_knowledge_update() const {
  return unit_knowledge_update_ != NULL ? *unit_knowledge_update_ : *default_instance_->unit_knowledge_update_;
}
inline ::MsgsSimToClient::MsgUnitKnowledgeUpdate* MsgSimToClient_Content::mutable_unit_knowledge_update() {
  _set_bit(42);
  if (unit_knowledge_update_ == NULL) unit_knowledge_update_ = new ::MsgsSimToClient::MsgUnitKnowledgeUpdate;
  return unit_knowledge_update_;
}

// optional .MsgsSimToClient.MsgUnitKnowledgeDestruction unit_knowledge_destruction = 44;
inline bool MsgSimToClient_Content::has_unit_knowledge_destruction() const {
  return _has_bit(43);
}
inline void MsgSimToClient_Content::clear_unit_knowledge_destruction() {
  if (unit_knowledge_destruction_ != NULL) unit_knowledge_destruction_->::MsgsSimToClient::MsgUnitKnowledgeDestruction::Clear();
  _clear_bit(43);
}
inline const ::MsgsSimToClient::MsgUnitKnowledgeDestruction& MsgSimToClient_Content::unit_knowledge_destruction() const {
  return unit_knowledge_destruction_ != NULL ? *unit_knowledge_destruction_ : *default_instance_->unit_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgUnitKnowledgeDestruction* MsgSimToClient_Content::mutable_unit_knowledge_destruction() {
  _set_bit(43);
  if (unit_knowledge_destruction_ == NULL) unit_knowledge_destruction_ = new ::MsgsSimToClient::MsgUnitKnowledgeDestruction;
  return unit_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgStartUnitFire start_unit_fire = 45;
inline bool MsgSimToClient_Content::has_start_unit_fire() const {
  return _has_bit(44);
}
inline void MsgSimToClient_Content::clear_start_unit_fire() {
  if (start_unit_fire_ != NULL) start_unit_fire_->::MsgsSimToClient::MsgStartUnitFire::Clear();
  _clear_bit(44);
}
inline const ::MsgsSimToClient::MsgStartUnitFire& MsgSimToClient_Content::start_unit_fire() const {
  return start_unit_fire_ != NULL ? *start_unit_fire_ : *default_instance_->start_unit_fire_;
}
inline ::MsgsSimToClient::MsgStartUnitFire* MsgSimToClient_Content::mutable_start_unit_fire() {
  _set_bit(44);
  if (start_unit_fire_ == NULL) start_unit_fire_ = new ::MsgsSimToClient::MsgStartUnitFire;
  return start_unit_fire_;
}

// optional .MsgsSimToClient.MsgStopUnitFire stop_unit_fire = 46;
inline bool MsgSimToClient_Content::has_stop_unit_fire() const {
  return _has_bit(45);
}
inline void MsgSimToClient_Content::clear_stop_unit_fire() {
  if (stop_unit_fire_ != NULL) stop_unit_fire_->::MsgsSimToClient::MsgStopUnitFire::Clear();
  _clear_bit(45);
}
inline const ::MsgsSimToClient::MsgStopUnitFire& MsgSimToClient_Content::stop_unit_fire() const {
  return stop_unit_fire_ != NULL ? *stop_unit_fire_ : *default_instance_->stop_unit_fire_;
}
inline ::MsgsSimToClient::MsgStopUnitFire* MsgSimToClient_Content::mutable_stop_unit_fire() {
  _set_bit(45);
  if (stop_unit_fire_ == NULL) stop_unit_fire_ = new ::MsgsSimToClient::MsgStopUnitFire;
  return stop_unit_fire_;
}

// optional .MsgsSimToClient.MsgStartPopulationFire start_population_fire = 47;
inline bool MsgSimToClient_Content::has_start_population_fire() const {
  return _has_bit(46);
}
inline void MsgSimToClient_Content::clear_start_population_fire() {
  if (start_population_fire_ != NULL) start_population_fire_->::MsgsSimToClient::MsgStartPopulationFire::Clear();
  _clear_bit(46);
}
inline const ::MsgsSimToClient::MsgStartPopulationFire& MsgSimToClient_Content::start_population_fire() const {
  return start_population_fire_ != NULL ? *start_population_fire_ : *default_instance_->start_population_fire_;
}
inline ::MsgsSimToClient::MsgStartPopulationFire* MsgSimToClient_Content::mutable_start_population_fire() {
  _set_bit(46);
  if (start_population_fire_ == NULL) start_population_fire_ = new ::MsgsSimToClient::MsgStartPopulationFire;
  return start_population_fire_;
}

// optional .MsgsSimToClient.MsgStopPopulationFire stop_population_fire = 48;
inline bool MsgSimToClient_Content::has_stop_population_fire() const {
  return _has_bit(47);
}
inline void MsgSimToClient_Content::clear_stop_population_fire() {
  if (stop_population_fire_ != NULL) stop_population_fire_->::MsgsSimToClient::MsgStopPopulationFire::Clear();
  _clear_bit(47);
}
inline const ::MsgsSimToClient::MsgStopPopulationFire& MsgSimToClient_Content::stop_population_fire() const {
  return stop_population_fire_ != NULL ? *stop_population_fire_ : *default_instance_->stop_population_fire_;
}
inline ::MsgsSimToClient::MsgStopPopulationFire* MsgSimToClient_Content::mutable_stop_population_fire() {
  _set_bit(47);
  if (stop_population_fire_ == NULL) stop_population_fire_ = new ::MsgsSimToClient::MsgStopPopulationFire;
  return stop_population_fire_;
}

// optional .MsgsSimToClient.MsgExplosion explosion = 49;
inline bool MsgSimToClient_Content::has_explosion() const {
  return _has_bit(48);
}
inline void MsgSimToClient_Content::clear_explosion() {
  if (explosion_ != NULL) explosion_->::MsgsSimToClient::MsgExplosion::Clear();
  _clear_bit(48);
}
inline const ::MsgsSimToClient::MsgExplosion& MsgSimToClient_Content::explosion() const {
  return explosion_ != NULL ? *explosion_ : *default_instance_->explosion_;
}
inline ::MsgsSimToClient::MsgExplosion* MsgSimToClient_Content::mutable_explosion() {
  _set_bit(48);
  if (explosion_ == NULL) explosion_ = new ::MsgsSimToClient::MsgExplosion;
  return explosion_;
}

// optional .MsgsSimToClient.MsgStartFireEffect start_fire_effect = 50;
inline bool MsgSimToClient_Content::has_start_fire_effect() const {
  return _has_bit(49);
}
inline void MsgSimToClient_Content::clear_start_fire_effect() {
  if (start_fire_effect_ != NULL) start_fire_effect_->::MsgsSimToClient::MsgStartFireEffect::Clear();
  _clear_bit(49);
}
inline const ::MsgsSimToClient::MsgStartFireEffect& MsgSimToClient_Content::start_fire_effect() const {
  return start_fire_effect_ != NULL ? *start_fire_effect_ : *default_instance_->start_fire_effect_;
}
inline ::MsgsSimToClient::MsgStartFireEffect* MsgSimToClient_Content::mutable_start_fire_effect() {
  _set_bit(49);
  if (start_fire_effect_ == NULL) start_fire_effect_ = new ::MsgsSimToClient::MsgStartFireEffect;
  return start_fire_effect_;
}

// optional .MsgsSimToClient.MsgStopFireEffect stop_fire_effect = 51;
inline bool MsgSimToClient_Content::has_stop_fire_effect() const {
  return _has_bit(50);
}
inline void MsgSimToClient_Content::clear_stop_fire_effect() {
  if (stop_fire_effect_ != NULL) stop_fire_effect_->::MsgsSimToClient::MsgStopFireEffect::Clear();
  _clear_bit(50);
}
inline const ::MsgsSimToClient::MsgStopFireEffect& MsgSimToClient_Content::stop_fire_effect() const {
  return stop_fire_effect_ != NULL ? *stop_fire_effect_ : *default_instance_->stop_fire_effect_;
}
inline ::MsgsSimToClient::MsgStopFireEffect* MsgSimToClient_Content::mutable_stop_fire_effect() {
  _set_bit(50);
  if (stop_fire_effect_ == NULL) stop_fire_effect_ = new ::MsgsSimToClient::MsgStopFireEffect;
  return stop_fire_effect_;
}

// optional .MsgsSimToClient.MsgReport report = 52;
inline bool MsgSimToClient_Content::has_report() const {
  return _has_bit(51);
}
inline void MsgSimToClient_Content::clear_report() {
  if (report_ != NULL) report_->::MsgsSimToClient::MsgReport::Clear();
  _clear_bit(51);
}
inline const ::MsgsSimToClient::MsgReport& MsgSimToClient_Content::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::MsgsSimToClient::MsgReport* MsgSimToClient_Content::mutable_report() {
  _set_bit(51);
  if (report_ == NULL) report_ = new ::MsgsSimToClient::MsgReport;
  return report_;
}

// optional .MsgsSimToClient.MsgInvalidateReport invalidate_report = 53;
inline bool MsgSimToClient_Content::has_invalidate_report() const {
  return _has_bit(52);
}
inline void MsgSimToClient_Content::clear_invalidate_report() {
  if (invalidate_report_ != NULL) invalidate_report_->::MsgsSimToClient::MsgInvalidateReport::Clear();
  _clear_bit(52);
}
inline const ::MsgsSimToClient::MsgInvalidateReport& MsgSimToClient_Content::invalidate_report() const {
  return invalidate_report_ != NULL ? *invalidate_report_ : *default_instance_->invalidate_report_;
}
inline ::MsgsSimToClient::MsgInvalidateReport* MsgSimToClient_Content::mutable_invalidate_report() {
  _set_bit(52);
  if (invalidate_report_ == NULL) invalidate_report_ = new ::MsgsSimToClient::MsgInvalidateReport;
  return invalidate_report_;
}

// optional .MsgsSimToClient.MsgTrace trace = 54;
inline bool MsgSimToClient_Content::has_trace() const {
  return _has_bit(53);
}
inline void MsgSimToClient_Content::clear_trace() {
  if (trace_ != NULL) trace_->::MsgsSimToClient::MsgTrace::Clear();
  _clear_bit(53);
}
inline const ::MsgsSimToClient::MsgTrace& MsgSimToClient_Content::trace() const {
  return trace_ != NULL ? *trace_ : *default_instance_->trace_;
}
inline ::MsgsSimToClient::MsgTrace* MsgSimToClient_Content::mutable_trace() {
  _set_bit(53);
  if (trace_ == NULL) trace_ = new ::MsgsSimToClient::MsgTrace;
  return trace_;
}

// optional .MsgsSimToClient.MsgDecisionalState decisional_state = 55;
inline bool MsgSimToClient_Content::has_decisional_state() const {
  return _has_bit(54);
}
inline void MsgSimToClient_Content::clear_decisional_state() {
  if (decisional_state_ != NULL) decisional_state_->::MsgsSimToClient::MsgDecisionalState::Clear();
  _clear_bit(54);
}
inline const ::MsgsSimToClient::MsgDecisionalState& MsgSimToClient_Content::decisional_state() const {
  return decisional_state_ != NULL ? *decisional_state_ : *default_instance_->decisional_state_;
}
inline ::MsgsSimToClient::MsgDecisionalState* MsgSimToClient_Content::mutable_decisional_state() {
  _set_bit(54);
  if (decisional_state_ == NULL) decisional_state_ = new ::MsgsSimToClient::MsgDecisionalState;
  return decisional_state_;
}

// optional .MsgsSimToClient.MsgDebugPoints debug_points = 56;
inline bool MsgSimToClient_Content::has_debug_points() const {
  return _has_bit(55);
}
inline void MsgSimToClient_Content::clear_debug_points() {
  if (debug_points_ != NULL) debug_points_->::MsgsSimToClient::MsgDebugPoints::Clear();
  _clear_bit(55);
}
inline const ::MsgsSimToClient::MsgDebugPoints& MsgSimToClient_Content::debug_points() const {
  return debug_points_ != NULL ? *debug_points_ : *default_instance_->debug_points_;
}
inline ::MsgsSimToClient::MsgDebugPoints* MsgSimToClient_Content::mutable_debug_points() {
  _set_bit(55);
  if (debug_points_ == NULL) debug_points_ = new ::MsgsSimToClient::MsgDebugPoints;
  return debug_points_;
}

// optional .MsgsSimToClient.MsgUnitVisionCones unit_vision_cones = 57;
inline bool MsgSimToClient_Content::has_unit_vision_cones() const {
  return _has_bit(56);
}
inline void MsgSimToClient_Content::clear_unit_vision_cones() {
  if (unit_vision_cones_ != NULL) unit_vision_cones_->::MsgsSimToClient::MsgUnitVisionCones::Clear();
  _clear_bit(56);
}
inline const ::MsgsSimToClient::MsgUnitVisionCones& MsgSimToClient_Content::unit_vision_cones() const {
  return unit_vision_cones_ != NULL ? *unit_vision_cones_ : *default_instance_->unit_vision_cones_;
}
inline ::MsgsSimToClient::MsgUnitVisionCones* MsgSimToClient_Content::mutable_unit_vision_cones() {
  _set_bit(56);
  if (unit_vision_cones_ == NULL) unit_vision_cones_ = new ::MsgsSimToClient::MsgUnitVisionCones;
  return unit_vision_cones_;
}

// optional .MsgsSimToClient.MsgUnitDetection unit_detection = 58;
inline bool MsgSimToClient_Content::has_unit_detection() const {
  return _has_bit(57);
}
inline void MsgSimToClient_Content::clear_unit_detection() {
  if (unit_detection_ != NULL) unit_detection_->::MsgsSimToClient::MsgUnitDetection::Clear();
  _clear_bit(57);
}
inline const ::MsgsSimToClient::MsgUnitDetection& MsgSimToClient_Content::unit_detection() const {
  return unit_detection_ != NULL ? *unit_detection_ : *default_instance_->unit_detection_;
}
inline ::MsgsSimToClient::MsgUnitDetection* MsgSimToClient_Content::mutable_unit_detection() {
  _set_bit(57);
  if (unit_detection_ == NULL) unit_detection_ = new ::MsgsSimToClient::MsgUnitDetection;
  return unit_detection_;
}

// optional .MsgsSimToClient.MsgObjectDetection object_detection = 59;
inline bool MsgSimToClient_Content::has_object_detection() const {
  return _has_bit(58);
}
inline void MsgSimToClient_Content::clear_object_detection() {
  if (object_detection_ != NULL) object_detection_->::MsgsSimToClient::MsgObjectDetection::Clear();
  _clear_bit(58);
}
inline const ::MsgsSimToClient::MsgObjectDetection& MsgSimToClient_Content::object_detection() const {
  return object_detection_ != NULL ? *object_detection_ : *default_instance_->object_detection_;
}
inline ::MsgsSimToClient::MsgObjectDetection* MsgSimToClient_Content::mutable_object_detection() {
  _set_bit(58);
  if (object_detection_ == NULL) object_detection_ = new ::MsgsSimToClient::MsgObjectDetection;
  return object_detection_;
}

// optional .MsgsSimToClient.MsgPopulationConcentrationDetection population_concentration_detection = 60;
inline bool MsgSimToClient_Content::has_population_concentration_detection() const {
  return _has_bit(59);
}
inline void MsgSimToClient_Content::clear_population_concentration_detection() {
  if (population_concentration_detection_ != NULL) population_concentration_detection_->::MsgsSimToClient::MsgPopulationConcentrationDetection::Clear();
  _clear_bit(59);
}
inline const ::MsgsSimToClient::MsgPopulationConcentrationDetection& MsgSimToClient_Content::population_concentration_detection() const {
  return population_concentration_detection_ != NULL ? *population_concentration_detection_ : *default_instance_->population_concentration_detection_;
}
inline ::MsgsSimToClient::MsgPopulationConcentrationDetection* MsgSimToClient_Content::mutable_population_concentration_detection() {
  _set_bit(59);
  if (population_concentration_detection_ == NULL) population_concentration_detection_ = new ::MsgsSimToClient::MsgPopulationConcentrationDetection;
  return population_concentration_detection_;
}

// optional .MsgsSimToClient.MsgPopulationFlowDetection population_flow_detection = 61;
inline bool MsgSimToClient_Content::has_population_flow_detection() const {
  return _has_bit(60);
}
inline void MsgSimToClient_Content::clear_population_flow_detection() {
  if (population_flow_detection_ != NULL) population_flow_detection_->::MsgsSimToClient::MsgPopulationFlowDetection::Clear();
  _clear_bit(60);
}
inline const ::MsgsSimToClient::MsgPopulationFlowDetection& MsgSimToClient_Content::population_flow_detection() const {
  return population_flow_detection_ != NULL ? *population_flow_detection_ : *default_instance_->population_flow_detection_;
}
inline ::MsgsSimToClient::MsgPopulationFlowDetection* MsgSimToClient_Content::mutable_population_flow_detection() {
  _set_bit(60);
  if (population_flow_detection_ == NULL) population_flow_detection_ = new ::MsgsSimToClient::MsgPopulationFlowDetection;
  return population_flow_detection_;
}

// optional .Common.MsgUnitOrder unit_order = 62;
inline bool MsgSimToClient_Content::has_unit_order() const {
  return _has_bit(61);
}
inline void MsgSimToClient_Content::clear_unit_order() {
  if (unit_order_ != NULL) unit_order_->::Common::MsgUnitOrder::Clear();
  _clear_bit(61);
}
inline const ::Common::MsgUnitOrder& MsgSimToClient_Content::unit_order() const {
  return unit_order_ != NULL ? *unit_order_ : *default_instance_->unit_order_;
}
inline ::Common::MsgUnitOrder* MsgSimToClient_Content::mutable_unit_order() {
  _set_bit(61);
  if (unit_order_ == NULL) unit_order_ = new ::Common::MsgUnitOrder;
  return unit_order_;
}

// optional .Common.MsgAutomatOrder automat_order = 63;
inline bool MsgSimToClient_Content::has_automat_order() const {
  return _has_bit(62);
}
inline void MsgSimToClient_Content::clear_automat_order() {
  if (automat_order_ != NULL) automat_order_->::Common::MsgAutomatOrder::Clear();
  _clear_bit(62);
}
inline const ::Common::MsgAutomatOrder& MsgSimToClient_Content::automat_order() const {
  return automat_order_ != NULL ? *automat_order_ : *default_instance_->automat_order_;
}
inline ::Common::MsgAutomatOrder* MsgSimToClient_Content::mutable_automat_order() {
  _set_bit(62);
  if (automat_order_ == NULL) automat_order_ = new ::Common::MsgAutomatOrder;
  return automat_order_;
}

// optional .Common.MsgPopulationOrder population_order = 64;
inline bool MsgSimToClient_Content::has_population_order() const {
  return _has_bit(63);
}
inline void MsgSimToClient_Content::clear_population_order() {
  if (population_order_ != NULL) population_order_->::Common::MsgPopulationOrder::Clear();
  _clear_bit(63);
}
inline const ::Common::MsgPopulationOrder& MsgSimToClient_Content::population_order() const {
  return population_order_ != NULL ? *population_order_ : *default_instance_->population_order_;
}
inline ::Common::MsgPopulationOrder* MsgSimToClient_Content::mutable_population_order() {
  _set_bit(63);
  if (population_order_ == NULL) population_order_ = new ::Common::MsgPopulationOrder;
  return population_order_;
}

// optional .MsgsSimToClient.MsgObjectCreation object_creation = 65;
inline bool MsgSimToClient_Content::has_object_creation() const {
  return _has_bit(64);
}
inline void MsgSimToClient_Content::clear_object_creation() {
  if (object_creation_ != NULL) object_creation_->::MsgsSimToClient::MsgObjectCreation::Clear();
  _clear_bit(64);
}
inline const ::MsgsSimToClient::MsgObjectCreation& MsgSimToClient_Content::object_creation() const {
  return object_creation_ != NULL ? *object_creation_ : *default_instance_->object_creation_;
}
inline ::MsgsSimToClient::MsgObjectCreation* MsgSimToClient_Content::mutable_object_creation() {
  _set_bit(64);
  if (object_creation_ == NULL) object_creation_ = new ::MsgsSimToClient::MsgObjectCreation;
  return object_creation_;
}

// optional .MsgsSimToClient.MsgObjectDestruction object_destruction = 66;
inline bool MsgSimToClient_Content::has_object_destruction() const {
  return _has_bit(65);
}
inline void MsgSimToClient_Content::clear_object_destruction() {
  if (object_destruction_ != NULL) object_destruction_->::MsgsSimToClient::MsgObjectDestruction::Clear();
  _clear_bit(65);
}
inline const ::MsgsSimToClient::MsgObjectDestruction& MsgSimToClient_Content::object_destruction() const {
  return object_destruction_ != NULL ? *object_destruction_ : *default_instance_->object_destruction_;
}
inline ::MsgsSimToClient::MsgObjectDestruction* MsgSimToClient_Content::mutable_object_destruction() {
  _set_bit(65);
  if (object_destruction_ == NULL) object_destruction_ = new ::MsgsSimToClient::MsgObjectDestruction;
  return object_destruction_;
}

// optional .MsgsSimToClient.MsgObjectUpdate object_update = 67;
inline bool MsgSimToClient_Content::has_object_update() const {
  return _has_bit(66);
}
inline void MsgSimToClient_Content::clear_object_update() {
  if (object_update_ != NULL) object_update_->::MsgsSimToClient::MsgObjectUpdate::Clear();
  _clear_bit(66);
}
inline const ::MsgsSimToClient::MsgObjectUpdate& MsgSimToClient_Content::object_update() const {
  return object_update_ != NULL ? *object_update_ : *default_instance_->object_update_;
}
inline ::MsgsSimToClient::MsgObjectUpdate* MsgSimToClient_Content::mutable_object_update() {
  _set_bit(66);
  if (object_update_ == NULL) object_update_ = new ::MsgsSimToClient::MsgObjectUpdate;
  return object_update_;
}

// optional .MsgsSimToClient.MsgObjectKnowledgeCreation object_knowledge_creation = 68;
inline bool MsgSimToClient_Content::has_object_knowledge_creation() const {
  return _has_bit(67);
}
inline void MsgSimToClient_Content::clear_object_knowledge_creation() {
  if (object_knowledge_creation_ != NULL) object_knowledge_creation_->::MsgsSimToClient::MsgObjectKnowledgeCreation::Clear();
  _clear_bit(67);
}
inline const ::MsgsSimToClient::MsgObjectKnowledgeCreation& MsgSimToClient_Content::object_knowledge_creation() const {
  return object_knowledge_creation_ != NULL ? *object_knowledge_creation_ : *default_instance_->object_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgObjectKnowledgeCreation* MsgSimToClient_Content::mutable_object_knowledge_creation() {
  _set_bit(67);
  if (object_knowledge_creation_ == NULL) object_knowledge_creation_ = new ::MsgsSimToClient::MsgObjectKnowledgeCreation;
  return object_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgObjectKnowledgeUpdate object_knowledge_update = 69;
inline bool MsgSimToClient_Content::has_object_knowledge_update() const {
  return _has_bit(68);
}
inline void MsgSimToClient_Content::clear_object_knowledge_update() {
  if (object_knowledge_update_ != NULL) object_knowledge_update_->::MsgsSimToClient::MsgObjectKnowledgeUpdate::Clear();
  _clear_bit(68);
}
inline const ::MsgsSimToClient::MsgObjectKnowledgeUpdate& MsgSimToClient_Content::object_knowledge_update() const {
  return object_knowledge_update_ != NULL ? *object_knowledge_update_ : *default_instance_->object_knowledge_update_;
}
inline ::MsgsSimToClient::MsgObjectKnowledgeUpdate* MsgSimToClient_Content::mutable_object_knowledge_update() {
  _set_bit(68);
  if (object_knowledge_update_ == NULL) object_knowledge_update_ = new ::MsgsSimToClient::MsgObjectKnowledgeUpdate;
  return object_knowledge_update_;
}

// optional .MsgsSimToClient.MsgObjectKnowledgeDestruction object_knowledge_destruction = 70;
inline bool MsgSimToClient_Content::has_object_knowledge_destruction() const {
  return _has_bit(69);
}
inline void MsgSimToClient_Content::clear_object_knowledge_destruction() {
  if (object_knowledge_destruction_ != NULL) object_knowledge_destruction_->::MsgsSimToClient::MsgObjectKnowledgeDestruction::Clear();
  _clear_bit(69);
}
inline const ::MsgsSimToClient::MsgObjectKnowledgeDestruction& MsgSimToClient_Content::object_knowledge_destruction() const {
  return object_knowledge_destruction_ != NULL ? *object_knowledge_destruction_ : *default_instance_->object_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgObjectKnowledgeDestruction* MsgSimToClient_Content::mutable_object_knowledge_destruction() {
  _set_bit(69);
  if (object_knowledge_destruction_ == NULL) object_knowledge_destruction_ = new ::MsgsSimToClient::MsgObjectKnowledgeDestruction;
  return object_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgLogMedicalHandlingCreation log_medical_handling_creation = 71;
inline bool MsgSimToClient_Content::has_log_medical_handling_creation() const {
  return _has_bit(70);
}
inline void MsgSimToClient_Content::clear_log_medical_handling_creation() {
  if (log_medical_handling_creation_ != NULL) log_medical_handling_creation_->::MsgsSimToClient::MsgLogMedicalHandlingCreation::Clear();
  _clear_bit(70);
}
inline const ::MsgsSimToClient::MsgLogMedicalHandlingCreation& MsgSimToClient_Content::log_medical_handling_creation() const {
  return log_medical_handling_creation_ != NULL ? *log_medical_handling_creation_ : *default_instance_->log_medical_handling_creation_;
}
inline ::MsgsSimToClient::MsgLogMedicalHandlingCreation* MsgSimToClient_Content::mutable_log_medical_handling_creation() {
  _set_bit(70);
  if (log_medical_handling_creation_ == NULL) log_medical_handling_creation_ = new ::MsgsSimToClient::MsgLogMedicalHandlingCreation;
  return log_medical_handling_creation_;
}

// optional .MsgsSimToClient.MsgLogMedicalHandlingUpdate log_medical_handling_update = 72;
inline bool MsgSimToClient_Content::has_log_medical_handling_update() const {
  return _has_bit(71);
}
inline void MsgSimToClient_Content::clear_log_medical_handling_update() {
  if (log_medical_handling_update_ != NULL) log_medical_handling_update_->::MsgsSimToClient::MsgLogMedicalHandlingUpdate::Clear();
  _clear_bit(71);
}
inline const ::MsgsSimToClient::MsgLogMedicalHandlingUpdate& MsgSimToClient_Content::log_medical_handling_update() const {
  return log_medical_handling_update_ != NULL ? *log_medical_handling_update_ : *default_instance_->log_medical_handling_update_;
}
inline ::MsgsSimToClient::MsgLogMedicalHandlingUpdate* MsgSimToClient_Content::mutable_log_medical_handling_update() {
  _set_bit(71);
  if (log_medical_handling_update_ == NULL) log_medical_handling_update_ = new ::MsgsSimToClient::MsgLogMedicalHandlingUpdate;
  return log_medical_handling_update_;
}

// optional .MsgsSimToClient.MsgLogMedicalHandlingDestruction log_medical_handling_destruction = 73;
inline bool MsgSimToClient_Content::has_log_medical_handling_destruction() const {
  return _has_bit(72);
}
inline void MsgSimToClient_Content::clear_log_medical_handling_destruction() {
  if (log_medical_handling_destruction_ != NULL) log_medical_handling_destruction_->::MsgsSimToClient::MsgLogMedicalHandlingDestruction::Clear();
  _clear_bit(72);
}
inline const ::MsgsSimToClient::MsgLogMedicalHandlingDestruction& MsgSimToClient_Content::log_medical_handling_destruction() const {
  return log_medical_handling_destruction_ != NULL ? *log_medical_handling_destruction_ : *default_instance_->log_medical_handling_destruction_;
}
inline ::MsgsSimToClient::MsgLogMedicalHandlingDestruction* MsgSimToClient_Content::mutable_log_medical_handling_destruction() {
  _set_bit(72);
  if (log_medical_handling_destruction_ == NULL) log_medical_handling_destruction_ = new ::MsgsSimToClient::MsgLogMedicalHandlingDestruction;
  return log_medical_handling_destruction_;
}

// optional .MsgsSimToClient.MsgLogMedicalState log_medical_state = 74;
inline bool MsgSimToClient_Content::has_log_medical_state() const {
  return _has_bit(73);
}
inline void MsgSimToClient_Content::clear_log_medical_state() {
  if (log_medical_state_ != NULL) log_medical_state_->::MsgsSimToClient::MsgLogMedicalState::Clear();
  _clear_bit(73);
}
inline const ::MsgsSimToClient::MsgLogMedicalState& MsgSimToClient_Content::log_medical_state() const {
  return log_medical_state_ != NULL ? *log_medical_state_ : *default_instance_->log_medical_state_;
}
inline ::MsgsSimToClient::MsgLogMedicalState* MsgSimToClient_Content::mutable_log_medical_state() {
  _set_bit(73);
  if (log_medical_state_ == NULL) log_medical_state_ = new ::MsgsSimToClient::MsgLogMedicalState;
  return log_medical_state_;
}

// optional .MsgsSimToClient.MsgLogMaintenanceHandlingCreation log_maintenance_handling_creation = 75;
inline bool MsgSimToClient_Content::has_log_maintenance_handling_creation() const {
  return _has_bit(74);
}
inline void MsgSimToClient_Content::clear_log_maintenance_handling_creation() {
  if (log_maintenance_handling_creation_ != NULL) log_maintenance_handling_creation_->::MsgsSimToClient::MsgLogMaintenanceHandlingCreation::Clear();
  _clear_bit(74);
}
inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation& MsgSimToClient_Content::log_maintenance_handling_creation() const {
  return log_maintenance_handling_creation_ != NULL ? *log_maintenance_handling_creation_ : *default_instance_->log_maintenance_handling_creation_;
}
inline ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation* MsgSimToClient_Content::mutable_log_maintenance_handling_creation() {
  _set_bit(74);
  if (log_maintenance_handling_creation_ == NULL) log_maintenance_handling_creation_ = new ::MsgsSimToClient::MsgLogMaintenanceHandlingCreation;
  return log_maintenance_handling_creation_;
}

// optional .MsgsSimToClient.MsgLogMaintenanceHandlingUpdate log_maintenance_handling_update = 76;
inline bool MsgSimToClient_Content::has_log_maintenance_handling_update() const {
  return _has_bit(75);
}
inline void MsgSimToClient_Content::clear_log_maintenance_handling_update() {
  if (log_maintenance_handling_update_ != NULL) log_maintenance_handling_update_->::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate::Clear();
  _clear_bit(75);
}
inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate& MsgSimToClient_Content::log_maintenance_handling_update() const {
  return log_maintenance_handling_update_ != NULL ? *log_maintenance_handling_update_ : *default_instance_->log_maintenance_handling_update_;
}
inline ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate* MsgSimToClient_Content::mutable_log_maintenance_handling_update() {
  _set_bit(75);
  if (log_maintenance_handling_update_ == NULL) log_maintenance_handling_update_ = new ::MsgsSimToClient::MsgLogMaintenanceHandlingUpdate;
  return log_maintenance_handling_update_;
}

// optional .MsgsSimToClient.MsgLogMaintenanceHandlingDestruction log_maintenance_handling_destruction = 77;
inline bool MsgSimToClient_Content::has_log_maintenance_handling_destruction() const {
  return _has_bit(76);
}
inline void MsgSimToClient_Content::clear_log_maintenance_handling_destruction() {
  if (log_maintenance_handling_destruction_ != NULL) log_maintenance_handling_destruction_->::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction::Clear();
  _clear_bit(76);
}
inline const ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction& MsgSimToClient_Content::log_maintenance_handling_destruction() const {
  return log_maintenance_handling_destruction_ != NULL ? *log_maintenance_handling_destruction_ : *default_instance_->log_maintenance_handling_destruction_;
}
inline ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction* MsgSimToClient_Content::mutable_log_maintenance_handling_destruction() {
  _set_bit(76);
  if (log_maintenance_handling_destruction_ == NULL) log_maintenance_handling_destruction_ = new ::MsgsSimToClient::MsgLogMaintenanceHandlingDestruction;
  return log_maintenance_handling_destruction_;
}

// optional .MsgsSimToClient.MsgLogMaintenanceState log_maintenance_state = 78;
inline bool MsgSimToClient_Content::has_log_maintenance_state() const {
  return _has_bit(77);
}
inline void MsgSimToClient_Content::clear_log_maintenance_state() {
  if (log_maintenance_state_ != NULL) log_maintenance_state_->::MsgsSimToClient::MsgLogMaintenanceState::Clear();
  _clear_bit(77);
}
inline const ::MsgsSimToClient::MsgLogMaintenanceState& MsgSimToClient_Content::log_maintenance_state() const {
  return log_maintenance_state_ != NULL ? *log_maintenance_state_ : *default_instance_->log_maintenance_state_;
}
inline ::MsgsSimToClient::MsgLogMaintenanceState* MsgSimToClient_Content::mutable_log_maintenance_state() {
  _set_bit(77);
  if (log_maintenance_state_ == NULL) log_maintenance_state_ = new ::MsgsSimToClient::MsgLogMaintenanceState;
  return log_maintenance_state_;
}

// optional .MsgsSimToClient.MsgLogSupplyHandlingCreation log_supply_handling_creation = 79;
inline bool MsgSimToClient_Content::has_log_supply_handling_creation() const {
  return _has_bit(78);
}
inline void MsgSimToClient_Content::clear_log_supply_handling_creation() {
  if (log_supply_handling_creation_ != NULL) log_supply_handling_creation_->::MsgsSimToClient::MsgLogSupplyHandlingCreation::Clear();
  _clear_bit(78);
}
inline const ::MsgsSimToClient::MsgLogSupplyHandlingCreation& MsgSimToClient_Content::log_supply_handling_creation() const {
  return log_supply_handling_creation_ != NULL ? *log_supply_handling_creation_ : *default_instance_->log_supply_handling_creation_;
}
inline ::MsgsSimToClient::MsgLogSupplyHandlingCreation* MsgSimToClient_Content::mutable_log_supply_handling_creation() {
  _set_bit(78);
  if (log_supply_handling_creation_ == NULL) log_supply_handling_creation_ = new ::MsgsSimToClient::MsgLogSupplyHandlingCreation;
  return log_supply_handling_creation_;
}

// optional .MsgsSimToClient.MsgLogSupplyHandlingUpdate log_supply_handling_update = 80;
inline bool MsgSimToClient_Content::has_log_supply_handling_update() const {
  return _has_bit(79);
}
inline void MsgSimToClient_Content::clear_log_supply_handling_update() {
  if (log_supply_handling_update_ != NULL) log_supply_handling_update_->::MsgsSimToClient::MsgLogSupplyHandlingUpdate::Clear();
  _clear_bit(79);
}
inline const ::MsgsSimToClient::MsgLogSupplyHandlingUpdate& MsgSimToClient_Content::log_supply_handling_update() const {
  return log_supply_handling_update_ != NULL ? *log_supply_handling_update_ : *default_instance_->log_supply_handling_update_;
}
inline ::MsgsSimToClient::MsgLogSupplyHandlingUpdate* MsgSimToClient_Content::mutable_log_supply_handling_update() {
  _set_bit(79);
  if (log_supply_handling_update_ == NULL) log_supply_handling_update_ = new ::MsgsSimToClient::MsgLogSupplyHandlingUpdate;
  return log_supply_handling_update_;
}

// optional .MsgsSimToClient.MsgLogSupplyHandlingDestruction log_supply_handling_destruction = 81;
inline bool MsgSimToClient_Content::has_log_supply_handling_destruction() const {
  return _has_bit(80);
}
inline void MsgSimToClient_Content::clear_log_supply_handling_destruction() {
  if (log_supply_handling_destruction_ != NULL) log_supply_handling_destruction_->::MsgsSimToClient::MsgLogSupplyHandlingDestruction::Clear();
  _clear_bit(80);
}
inline const ::MsgsSimToClient::MsgLogSupplyHandlingDestruction& MsgSimToClient_Content::log_supply_handling_destruction() const {
  return log_supply_handling_destruction_ != NULL ? *log_supply_handling_destruction_ : *default_instance_->log_supply_handling_destruction_;
}
inline ::MsgsSimToClient::MsgLogSupplyHandlingDestruction* MsgSimToClient_Content::mutable_log_supply_handling_destruction() {
  _set_bit(80);
  if (log_supply_handling_destruction_ == NULL) log_supply_handling_destruction_ = new ::MsgsSimToClient::MsgLogSupplyHandlingDestruction;
  return log_supply_handling_destruction_;
}

// optional .MsgsSimToClient.MsgLogSupplyState log_supply_state = 82;
inline bool MsgSimToClient_Content::has_log_supply_state() const {
  return _has_bit(81);
}
inline void MsgSimToClient_Content::clear_log_supply_state() {
  if (log_supply_state_ != NULL) log_supply_state_->::MsgsSimToClient::MsgLogSupplyState::Clear();
  _clear_bit(81);
}
inline const ::MsgsSimToClient::MsgLogSupplyState& MsgSimToClient_Content::log_supply_state() const {
  return log_supply_state_ != NULL ? *log_supply_state_ : *default_instance_->log_supply_state_;
}
inline ::MsgsSimToClient::MsgLogSupplyState* MsgSimToClient_Content::mutable_log_supply_state() {
  _set_bit(81);
  if (log_supply_state_ == NULL) log_supply_state_ = new ::MsgsSimToClient::MsgLogSupplyState;
  return log_supply_state_;
}

// optional .MsgsSimToClient.MsgLogSupplyQuotas log_supply_quotas = 83;
inline bool MsgSimToClient_Content::has_log_supply_quotas() const {
  return _has_bit(82);
}
inline void MsgSimToClient_Content::clear_log_supply_quotas() {
  if (log_supply_quotas_ != NULL) log_supply_quotas_->::MsgsSimToClient::MsgLogSupplyQuotas::Clear();
  _clear_bit(82);
}
inline const ::MsgsSimToClient::MsgLogSupplyQuotas& MsgSimToClient_Content::log_supply_quotas() const {
  return log_supply_quotas_ != NULL ? *log_supply_quotas_ : *default_instance_->log_supply_quotas_;
}
inline ::MsgsSimToClient::MsgLogSupplyQuotas* MsgSimToClient_Content::mutable_log_supply_quotas() {
  _set_bit(82);
  if (log_supply_quotas_ == NULL) log_supply_quotas_ = new ::MsgsSimToClient::MsgLogSupplyQuotas;
  return log_supply_quotas_;
}

// optional .MsgsSimToClient.MsgPopulationCreation population_creation = 84;
inline bool MsgSimToClient_Content::has_population_creation() const {
  return _has_bit(83);
}
inline void MsgSimToClient_Content::clear_population_creation() {
  if (population_creation_ != NULL) population_creation_->::MsgsSimToClient::MsgPopulationCreation::Clear();
  _clear_bit(83);
}
inline const ::MsgsSimToClient::MsgPopulationCreation& MsgSimToClient_Content::population_creation() const {
  return population_creation_ != NULL ? *population_creation_ : *default_instance_->population_creation_;
}
inline ::MsgsSimToClient::MsgPopulationCreation* MsgSimToClient_Content::mutable_population_creation() {
  _set_bit(83);
  if (population_creation_ == NULL) population_creation_ = new ::MsgsSimToClient::MsgPopulationCreation;
  return population_creation_;
}

// optional .MsgsSimToClient.MsgPopulationUpdate population_update = 85;
inline bool MsgSimToClient_Content::has_population_update() const {
  return _has_bit(84);
}
inline void MsgSimToClient_Content::clear_population_update() {
  if (population_update_ != NULL) population_update_->::MsgsSimToClient::MsgPopulationUpdate::Clear();
  _clear_bit(84);
}
inline const ::MsgsSimToClient::MsgPopulationUpdate& MsgSimToClient_Content::population_update() const {
  return population_update_ != NULL ? *population_update_ : *default_instance_->population_update_;
}
inline ::MsgsSimToClient::MsgPopulationUpdate* MsgSimToClient_Content::mutable_population_update() {
  _set_bit(84);
  if (population_update_ == NULL) population_update_ = new ::MsgsSimToClient::MsgPopulationUpdate;
  return population_update_;
}

// optional .MsgsSimToClient.MsgPopulationConcentrationCreation population_concentration_creation = 86;
inline bool MsgSimToClient_Content::has_population_concentration_creation() const {
  return _has_bit(85);
}
inline void MsgSimToClient_Content::clear_population_concentration_creation() {
  if (population_concentration_creation_ != NULL) population_concentration_creation_->::MsgsSimToClient::MsgPopulationConcentrationCreation::Clear();
  _clear_bit(85);
}
inline const ::MsgsSimToClient::MsgPopulationConcentrationCreation& MsgSimToClient_Content::population_concentration_creation() const {
  return population_concentration_creation_ != NULL ? *population_concentration_creation_ : *default_instance_->population_concentration_creation_;
}
inline ::MsgsSimToClient::MsgPopulationConcentrationCreation* MsgSimToClient_Content::mutable_population_concentration_creation() {
  _set_bit(85);
  if (population_concentration_creation_ == NULL) population_concentration_creation_ = new ::MsgsSimToClient::MsgPopulationConcentrationCreation;
  return population_concentration_creation_;
}

// optional .MsgsSimToClient.MsgPopulationConcentrationDestruction population_concentration_destruction = 87;
inline bool MsgSimToClient_Content::has_population_concentration_destruction() const {
  return _has_bit(86);
}
inline void MsgSimToClient_Content::clear_population_concentration_destruction() {
  if (population_concentration_destruction_ != NULL) population_concentration_destruction_->::MsgsSimToClient::MsgPopulationConcentrationDestruction::Clear();
  _clear_bit(86);
}
inline const ::MsgsSimToClient::MsgPopulationConcentrationDestruction& MsgSimToClient_Content::population_concentration_destruction() const {
  return population_concentration_destruction_ != NULL ? *population_concentration_destruction_ : *default_instance_->population_concentration_destruction_;
}
inline ::MsgsSimToClient::MsgPopulationConcentrationDestruction* MsgSimToClient_Content::mutable_population_concentration_destruction() {
  _set_bit(86);
  if (population_concentration_destruction_ == NULL) population_concentration_destruction_ = new ::MsgsSimToClient::MsgPopulationConcentrationDestruction;
  return population_concentration_destruction_;
}

// optional .MsgsSimToClient.MsgPopulationConcentrationUpdate population_concentration_update = 88;
inline bool MsgSimToClient_Content::has_population_concentration_update() const {
  return _has_bit(87);
}
inline void MsgSimToClient_Content::clear_population_concentration_update() {
  if (population_concentration_update_ != NULL) population_concentration_update_->::MsgsSimToClient::MsgPopulationConcentrationUpdate::Clear();
  _clear_bit(87);
}
inline const ::MsgsSimToClient::MsgPopulationConcentrationUpdate& MsgSimToClient_Content::population_concentration_update() const {
  return population_concentration_update_ != NULL ? *population_concentration_update_ : *default_instance_->population_concentration_update_;
}
inline ::MsgsSimToClient::MsgPopulationConcentrationUpdate* MsgSimToClient_Content::mutable_population_concentration_update() {
  _set_bit(87);
  if (population_concentration_update_ == NULL) population_concentration_update_ = new ::MsgsSimToClient::MsgPopulationConcentrationUpdate;
  return population_concentration_update_;
}

// optional .MsgsSimToClient.MsgPopulationFlowCreation population_flow_creation = 89;
inline bool MsgSimToClient_Content::has_population_flow_creation() const {
  return _has_bit(88);
}
inline void MsgSimToClient_Content::clear_population_flow_creation() {
  if (population_flow_creation_ != NULL) population_flow_creation_->::MsgsSimToClient::MsgPopulationFlowCreation::Clear();
  _clear_bit(88);
}
inline const ::MsgsSimToClient::MsgPopulationFlowCreation& MsgSimToClient_Content::population_flow_creation() const {
  return population_flow_creation_ != NULL ? *population_flow_creation_ : *default_instance_->population_flow_creation_;
}
inline ::MsgsSimToClient::MsgPopulationFlowCreation* MsgSimToClient_Content::mutable_population_flow_creation() {
  _set_bit(88);
  if (population_flow_creation_ == NULL) population_flow_creation_ = new ::MsgsSimToClient::MsgPopulationFlowCreation;
  return population_flow_creation_;
}

// optional .MsgsSimToClient.MsgPopulationFlowDestruction population_flow_destruction = 90;
inline bool MsgSimToClient_Content::has_population_flow_destruction() const {
  return _has_bit(89);
}
inline void MsgSimToClient_Content::clear_population_flow_destruction() {
  if (population_flow_destruction_ != NULL) population_flow_destruction_->::MsgsSimToClient::MsgPopulationFlowDestruction::Clear();
  _clear_bit(89);
}
inline const ::MsgsSimToClient::MsgPopulationFlowDestruction& MsgSimToClient_Content::population_flow_destruction() const {
  return population_flow_destruction_ != NULL ? *population_flow_destruction_ : *default_instance_->population_flow_destruction_;
}
inline ::MsgsSimToClient::MsgPopulationFlowDestruction* MsgSimToClient_Content::mutable_population_flow_destruction() {
  _set_bit(89);
  if (population_flow_destruction_ == NULL) population_flow_destruction_ = new ::MsgsSimToClient::MsgPopulationFlowDestruction;
  return population_flow_destruction_;
}

// optional .MsgsSimToClient.MsgPopulationFlowUpdate population_flow_update = 91;
inline bool MsgSimToClient_Content::has_population_flow_update() const {
  return _has_bit(90);
}
inline void MsgSimToClient_Content::clear_population_flow_update() {
  if (population_flow_update_ != NULL) population_flow_update_->::MsgsSimToClient::MsgPopulationFlowUpdate::Clear();
  _clear_bit(90);
}
inline const ::MsgsSimToClient::MsgPopulationFlowUpdate& MsgSimToClient_Content::population_flow_update() const {
  return population_flow_update_ != NULL ? *population_flow_update_ : *default_instance_->population_flow_update_;
}
inline ::MsgsSimToClient::MsgPopulationFlowUpdate* MsgSimToClient_Content::mutable_population_flow_update() {
  _set_bit(90);
  if (population_flow_update_ == NULL) population_flow_update_ = new ::MsgsSimToClient::MsgPopulationFlowUpdate;
  return population_flow_update_;
}

// optional .MsgsSimToClient.MsgPopulationKnowledgeCreation population_knowledge_creation = 92;
inline bool MsgSimToClient_Content::has_population_knowledge_creation() const {
  return _has_bit(91);
}
inline void MsgSimToClient_Content::clear_population_knowledge_creation() {
  if (population_knowledge_creation_ != NULL) population_knowledge_creation_->::MsgsSimToClient::MsgPopulationKnowledgeCreation::Clear();
  _clear_bit(91);
}
inline const ::MsgsSimToClient::MsgPopulationKnowledgeCreation& MsgSimToClient_Content::population_knowledge_creation() const {
  return population_knowledge_creation_ != NULL ? *population_knowledge_creation_ : *default_instance_->population_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgPopulationKnowledgeCreation* MsgSimToClient_Content::mutable_population_knowledge_creation() {
  _set_bit(91);
  if (population_knowledge_creation_ == NULL) population_knowledge_creation_ = new ::MsgsSimToClient::MsgPopulationKnowledgeCreation;
  return population_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgPopulationKnowledgeUpdate population_knowledge_update = 93;
inline bool MsgSimToClient_Content::has_population_knowledge_update() const {
  return _has_bit(92);
}
inline void MsgSimToClient_Content::clear_population_knowledge_update() {
  if (population_knowledge_update_ != NULL) population_knowledge_update_->::MsgsSimToClient::MsgPopulationKnowledgeUpdate::Clear();
  _clear_bit(92);
}
inline const ::MsgsSimToClient::MsgPopulationKnowledgeUpdate& MsgSimToClient_Content::population_knowledge_update() const {
  return population_knowledge_update_ != NULL ? *population_knowledge_update_ : *default_instance_->population_knowledge_update_;
}
inline ::MsgsSimToClient::MsgPopulationKnowledgeUpdate* MsgSimToClient_Content::mutable_population_knowledge_update() {
  _set_bit(92);
  if (population_knowledge_update_ == NULL) population_knowledge_update_ = new ::MsgsSimToClient::MsgPopulationKnowledgeUpdate;
  return population_knowledge_update_;
}

// optional .MsgsSimToClient.MsgPopulationKnowledgeDestruction population_knowledge_destruction = 94;
inline bool MsgSimToClient_Content::has_population_knowledge_destruction() const {
  return _has_bit(93);
}
inline void MsgSimToClient_Content::clear_population_knowledge_destruction() {
  if (population_knowledge_destruction_ != NULL) population_knowledge_destruction_->::MsgsSimToClient::MsgPopulationKnowledgeDestruction::Clear();
  _clear_bit(93);
}
inline const ::MsgsSimToClient::MsgPopulationKnowledgeDestruction& MsgSimToClient_Content::population_knowledge_destruction() const {
  return population_knowledge_destruction_ != NULL ? *population_knowledge_destruction_ : *default_instance_->population_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgPopulationKnowledgeDestruction* MsgSimToClient_Content::mutable_population_knowledge_destruction() {
  _set_bit(93);
  if (population_knowledge_destruction_ == NULL) population_knowledge_destruction_ = new ::MsgsSimToClient::MsgPopulationKnowledgeDestruction;
  return population_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgPopulationConcentrationKnowledgeCreation population_concentration_knowledge_creation = 95;
inline bool MsgSimToClient_Content::has_population_concentration_knowledge_creation() const {
  return _has_bit(94);
}
inline void MsgSimToClient_Content::clear_population_concentration_knowledge_creation() {
  if (population_concentration_knowledge_creation_ != NULL) population_concentration_knowledge_creation_->::MsgsSimToClient::MsgPopulationConcentrationKnowledgeCreation::Clear();
  _clear_bit(94);
}
inline const ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeCreation& MsgSimToClient_Content::population_concentration_knowledge_creation() const {
  return population_concentration_knowledge_creation_ != NULL ? *population_concentration_knowledge_creation_ : *default_instance_->population_concentration_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeCreation* MsgSimToClient_Content::mutable_population_concentration_knowledge_creation() {
  _set_bit(94);
  if (population_concentration_knowledge_creation_ == NULL) population_concentration_knowledge_creation_ = new ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeCreation;
  return population_concentration_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgPopulationConcentrationKnowledgeDestruction population_concentration_knowledge_destruction = 96;
inline bool MsgSimToClient_Content::has_population_concentration_knowledge_destruction() const {
  return _has_bit(95);
}
inline void MsgSimToClient_Content::clear_population_concentration_knowledge_destruction() {
  if (population_concentration_knowledge_destruction_ != NULL) population_concentration_knowledge_destruction_->::MsgsSimToClient::MsgPopulationConcentrationKnowledgeDestruction::Clear();
  _clear_bit(95);
}
inline const ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeDestruction& MsgSimToClient_Content::population_concentration_knowledge_destruction() const {
  return population_concentration_knowledge_destruction_ != NULL ? *population_concentration_knowledge_destruction_ : *default_instance_->population_concentration_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeDestruction* MsgSimToClient_Content::mutable_population_concentration_knowledge_destruction() {
  _set_bit(95);
  if (population_concentration_knowledge_destruction_ == NULL) population_concentration_knowledge_destruction_ = new ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeDestruction;
  return population_concentration_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgPopulationConcentrationKnowledgeUpdate population_concentration_knowledge_update = 97;
inline bool MsgSimToClient_Content::has_population_concentration_knowledge_update() const {
  return _has_bit(96);
}
inline void MsgSimToClient_Content::clear_population_concentration_knowledge_update() {
  if (population_concentration_knowledge_update_ != NULL) population_concentration_knowledge_update_->::MsgsSimToClient::MsgPopulationConcentrationKnowledgeUpdate::Clear();
  _clear_bit(96);
}
inline const ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeUpdate& MsgSimToClient_Content::population_concentration_knowledge_update() const {
  return population_concentration_knowledge_update_ != NULL ? *population_concentration_knowledge_update_ : *default_instance_->population_concentration_knowledge_update_;
}
inline ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeUpdate* MsgSimToClient_Content::mutable_population_concentration_knowledge_update() {
  _set_bit(96);
  if (population_concentration_knowledge_update_ == NULL) population_concentration_knowledge_update_ = new ::MsgsSimToClient::MsgPopulationConcentrationKnowledgeUpdate;
  return population_concentration_knowledge_update_;
}

// optional .MsgsSimToClient.MsgPopulationFlowKnowledgeCreation population_flow_knowledge_creation = 98;
inline bool MsgSimToClient_Content::has_population_flow_knowledge_creation() const {
  return _has_bit(97);
}
inline void MsgSimToClient_Content::clear_population_flow_knowledge_creation() {
  if (population_flow_knowledge_creation_ != NULL) population_flow_knowledge_creation_->::MsgsSimToClient::MsgPopulationFlowKnowledgeCreation::Clear();
  _clear_bit(97);
}
inline const ::MsgsSimToClient::MsgPopulationFlowKnowledgeCreation& MsgSimToClient_Content::population_flow_knowledge_creation() const {
  return population_flow_knowledge_creation_ != NULL ? *population_flow_knowledge_creation_ : *default_instance_->population_flow_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgPopulationFlowKnowledgeCreation* MsgSimToClient_Content::mutable_population_flow_knowledge_creation() {
  _set_bit(97);
  if (population_flow_knowledge_creation_ == NULL) population_flow_knowledge_creation_ = new ::MsgsSimToClient::MsgPopulationFlowKnowledgeCreation;
  return population_flow_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgPopulationFlowKnowledgeDestruction population_flow_knowledge_destruction = 99;
inline bool MsgSimToClient_Content::has_population_flow_knowledge_destruction() const {
  return _has_bit(98);
}
inline void MsgSimToClient_Content::clear_population_flow_knowledge_destruction() {
  if (population_flow_knowledge_destruction_ != NULL) population_flow_knowledge_destruction_->::MsgsSimToClient::MsgPopulationFlowKnowledgeDestruction::Clear();
  _clear_bit(98);
}
inline const ::MsgsSimToClient::MsgPopulationFlowKnowledgeDestruction& MsgSimToClient_Content::population_flow_knowledge_destruction() const {
  return population_flow_knowledge_destruction_ != NULL ? *population_flow_knowledge_destruction_ : *default_instance_->population_flow_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgPopulationFlowKnowledgeDestruction* MsgSimToClient_Content::mutable_population_flow_knowledge_destruction() {
  _set_bit(98);
  if (population_flow_knowledge_destruction_ == NULL) population_flow_knowledge_destruction_ = new ::MsgsSimToClient::MsgPopulationFlowKnowledgeDestruction;
  return population_flow_knowledge_destruction_;
}

// optional .MsgsSimToClient.MsgPopulationFlowKnowledgeUpdate population_flow_knowledge_update = 100;
inline bool MsgSimToClient_Content::has_population_flow_knowledge_update() const {
  return _has_bit(99);
}
inline void MsgSimToClient_Content::clear_population_flow_knowledge_update() {
  if (population_flow_knowledge_update_ != NULL) population_flow_knowledge_update_->::MsgsSimToClient::MsgPopulationFlowKnowledgeUpdate::Clear();
  _clear_bit(99);
}
inline const ::MsgsSimToClient::MsgPopulationFlowKnowledgeUpdate& MsgSimToClient_Content::population_flow_knowledge_update() const {
  return population_flow_knowledge_update_ != NULL ? *population_flow_knowledge_update_ : *default_instance_->population_flow_knowledge_update_;
}
inline ::MsgsSimToClient::MsgPopulationFlowKnowledgeUpdate* MsgSimToClient_Content::mutable_population_flow_knowledge_update() {
  _set_bit(99);
  if (population_flow_knowledge_update_ == NULL) population_flow_knowledge_update_ = new ::MsgsSimToClient::MsgPopulationFlowKnowledgeUpdate;
  return population_flow_knowledge_update_;
}

// optional .MsgsSimToClient.MsgFolkCreation folk_creation = 101;
inline bool MsgSimToClient_Content::has_folk_creation() const {
  return _has_bit(100);
}
inline void MsgSimToClient_Content::clear_folk_creation() {
  if (folk_creation_ != NULL) folk_creation_->::MsgsSimToClient::MsgFolkCreation::Clear();
  _clear_bit(100);
}
inline const ::MsgsSimToClient::MsgFolkCreation& MsgSimToClient_Content::folk_creation() const {
  return folk_creation_ != NULL ? *folk_creation_ : *default_instance_->folk_creation_;
}
inline ::MsgsSimToClient::MsgFolkCreation* MsgSimToClient_Content::mutable_folk_creation() {
  _set_bit(100);
  if (folk_creation_ == NULL) folk_creation_ = new ::MsgsSimToClient::MsgFolkCreation;
  return folk_creation_;
}

// optional .MsgsSimToClient.MsgFolkGraphUpdate folk_graph_update = 102;
inline bool MsgSimToClient_Content::has_folk_graph_update() const {
  return _has_bit(101);
}
inline void MsgSimToClient_Content::clear_folk_graph_update() {
  if (folk_graph_update_ != NULL) folk_graph_update_->::MsgsSimToClient::MsgFolkGraphUpdate::Clear();
  _clear_bit(101);
}
inline const ::MsgsSimToClient::MsgFolkGraphUpdate& MsgSimToClient_Content::folk_graph_update() const {
  return folk_graph_update_ != NULL ? *folk_graph_update_ : *default_instance_->folk_graph_update_;
}
inline ::MsgsSimToClient::MsgFolkGraphUpdate* MsgSimToClient_Content::mutable_folk_graph_update() {
  _set_bit(101);
  if (folk_graph_update_ == NULL) folk_graph_update_ = new ::MsgsSimToClient::MsgFolkGraphUpdate;
  return folk_graph_update_;
}

// optional .MsgsSimToClient.MsgControlGlobalMeteoAck control_global_meteo_ack = 103;
inline bool MsgSimToClient_Content::has_control_global_meteo_ack() const {
  return _has_bit(102);
}
inline void MsgSimToClient_Content::clear_control_global_meteo_ack() {
  if (control_global_meteo_ack_ != NULL) control_global_meteo_ack_->::MsgsSimToClient::MsgControlGlobalMeteoAck::Clear();
  _clear_bit(102);
}
inline const ::MsgsSimToClient::MsgControlGlobalMeteoAck& MsgSimToClient_Content::control_global_meteo_ack() const {
  return control_global_meteo_ack_ != NULL ? *control_global_meteo_ack_ : *default_instance_->control_global_meteo_ack_;
}
inline ::MsgsSimToClient::MsgControlGlobalMeteoAck* MsgSimToClient_Content::mutable_control_global_meteo_ack() {
  _set_bit(102);
  if (control_global_meteo_ack_ == NULL) control_global_meteo_ack_ = new ::MsgsSimToClient::MsgControlGlobalMeteoAck;
  return control_global_meteo_ack_;
}

// optional .MsgsSimToClient.MsgControlLocalMeteoAck control_local_meteo_ack = 104;
inline bool MsgSimToClient_Content::has_control_local_meteo_ack() const {
  return _has_bit(103);
}
inline void MsgSimToClient_Content::clear_control_local_meteo_ack() {
  if (control_local_meteo_ack_ != NULL) control_local_meteo_ack_->::MsgsSimToClient::MsgControlLocalMeteoAck::Clear();
  _clear_bit(103);
}
inline const ::MsgsSimToClient::MsgControlLocalMeteoAck& MsgSimToClient_Content::control_local_meteo_ack() const {
  return control_local_meteo_ack_ != NULL ? *control_local_meteo_ack_ : *default_instance_->control_local_meteo_ack_;
}
inline ::MsgsSimToClient::MsgControlLocalMeteoAck* MsgSimToClient_Content::mutable_control_local_meteo_ack() {
  _set_bit(103);
  if (control_local_meteo_ack_ == NULL) control_local_meteo_ack_ = new ::MsgsSimToClient::MsgControlLocalMeteoAck;
  return control_local_meteo_ack_;
}

// optional .MsgsSimToClient.MsgControlCheckPointSaveBegin control_checkpoint_save_begin = 105;
inline bool MsgSimToClient_Content::has_control_checkpoint_save_begin() const {
  return _has_bit(104);
}
inline void MsgSimToClient_Content::clear_control_checkpoint_save_begin() {
  if (control_checkpoint_save_begin_ != NULL) control_checkpoint_save_begin_->::MsgsSimToClient::MsgControlCheckPointSaveBegin::Clear();
  _clear_bit(104);
}
inline const ::MsgsSimToClient::MsgControlCheckPointSaveBegin& MsgSimToClient_Content::control_checkpoint_save_begin() const {
  return control_checkpoint_save_begin_ != NULL ? *control_checkpoint_save_begin_ : *default_instance_->control_checkpoint_save_begin_;
}
inline ::MsgsSimToClient::MsgControlCheckPointSaveBegin* MsgSimToClient_Content::mutable_control_checkpoint_save_begin() {
  _set_bit(104);
  if (control_checkpoint_save_begin_ == NULL) control_checkpoint_save_begin_ = new ::MsgsSimToClient::MsgControlCheckPointSaveBegin;
  return control_checkpoint_save_begin_;
}

// optional .MsgsSimToClient.MsgControlCheckPointSetFrequencyAck control_checkpoint_set_frequency_ack = 106;
inline bool MsgSimToClient_Content::has_control_checkpoint_set_frequency_ack() const {
  return _has_bit(105);
}
inline void MsgSimToClient_Content::clear_control_checkpoint_set_frequency_ack() {
  if (control_checkpoint_set_frequency_ack_ != NULL) control_checkpoint_set_frequency_ack_->::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck::Clear();
  _clear_bit(105);
}
inline const ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck& MsgSimToClient_Content::control_checkpoint_set_frequency_ack() const {
  return control_checkpoint_set_frequency_ack_ != NULL ? *control_checkpoint_set_frequency_ack_ : *default_instance_->control_checkpoint_set_frequency_ack_;
}
inline ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck* MsgSimToClient_Content::mutable_control_checkpoint_set_frequency_ack() {
  _set_bit(105);
  if (control_checkpoint_set_frequency_ack_ == NULL) control_checkpoint_set_frequency_ack_ = new ::MsgsSimToClient::MsgControlCheckPointSetFrequencyAck;
  return control_checkpoint_set_frequency_ack_;
}

// optional .MsgsSimToClient.MsgControlCheckPointSaveNowAck control_checkpoint_save_now_ack = 107;
inline bool MsgSimToClient_Content::has_control_checkpoint_save_now_ack() const {
  return _has_bit(106);
}
inline void MsgSimToClient_Content::clear_control_checkpoint_save_now_ack() {
  if (control_checkpoint_save_now_ack_ != NULL) control_checkpoint_save_now_ack_->::MsgsSimToClient::MsgControlCheckPointSaveNowAck::Clear();
  _clear_bit(106);
}
inline const ::MsgsSimToClient::MsgControlCheckPointSaveNowAck& MsgSimToClient_Content::control_checkpoint_save_now_ack() const {
  return control_checkpoint_save_now_ack_ != NULL ? *control_checkpoint_save_now_ack_ : *default_instance_->control_checkpoint_save_now_ack_;
}
inline ::MsgsSimToClient::MsgControlCheckPointSaveNowAck* MsgSimToClient_Content::mutable_control_checkpoint_save_now_ack() {
  _set_bit(106);
  if (control_checkpoint_save_now_ack_ == NULL) control_checkpoint_save_now_ack_ = new ::MsgsSimToClient::MsgControlCheckPointSaveNowAck;
  return control_checkpoint_save_now_ack_;
}

// optional .MsgsSimToClient.MsgControlSendCurrentStateBegin control_send_current_state_begin = 108;
inline bool MsgSimToClient_Content::has_control_send_current_state_begin() const {
  return _has_bit(107);
}
inline void MsgSimToClient_Content::clear_control_send_current_state_begin() {
  if (control_send_current_state_begin_ != NULL) control_send_current_state_begin_->::MsgsSimToClient::MsgControlSendCurrentStateBegin::Clear();
  _clear_bit(107);
}
inline const ::MsgsSimToClient::MsgControlSendCurrentStateBegin& MsgSimToClient_Content::control_send_current_state_begin() const {
  return control_send_current_state_begin_ != NULL ? *control_send_current_state_begin_ : *default_instance_->control_send_current_state_begin_;
}
inline ::MsgsSimToClient::MsgControlSendCurrentStateBegin* MsgSimToClient_Content::mutable_control_send_current_state_begin() {
  _set_bit(107);
  if (control_send_current_state_begin_ == NULL) control_send_current_state_begin_ = new ::MsgsSimToClient::MsgControlSendCurrentStateBegin;
  return control_send_current_state_begin_;
}

// optional .MsgsSimToClient.MsgControlSendCurrentStateEnd control_send_current_state_end = 109;
inline bool MsgSimToClient_Content::has_control_send_current_state_end() const {
  return _has_bit(108);
}
inline void MsgSimToClient_Content::clear_control_send_current_state_end() {
  if (control_send_current_state_end_ != NULL) control_send_current_state_end_->::MsgsSimToClient::MsgControlSendCurrentStateEnd::Clear();
  _clear_bit(108);
}
inline const ::MsgsSimToClient::MsgControlSendCurrentStateEnd& MsgSimToClient_Content::control_send_current_state_end() const {
  return control_send_current_state_end_ != NULL ? *control_send_current_state_end_ : *default_instance_->control_send_current_state_end_;
}
inline ::MsgsSimToClient::MsgControlSendCurrentStateEnd* MsgSimToClient_Content::mutable_control_send_current_state_end() {
  _set_bit(108);
  if (control_send_current_state_end_ == NULL) control_send_current_state_end_ = new ::MsgsSimToClient::MsgControlSendCurrentStateEnd;
  return control_send_current_state_end_;
}

// optional .MsgsSimToClient.MsgUrbanCreation urban_creation = 110;
inline bool MsgSimToClient_Content::has_urban_creation() const {
  return _has_bit(109);
}
inline void MsgSimToClient_Content::clear_urban_creation() {
  if (urban_creation_ != NULL) urban_creation_->::MsgsSimToClient::MsgUrbanCreation::Clear();
  _clear_bit(109);
}
inline const ::MsgsSimToClient::MsgUrbanCreation& MsgSimToClient_Content::urban_creation() const {
  return urban_creation_ != NULL ? *urban_creation_ : *default_instance_->urban_creation_;
}
inline ::MsgsSimToClient::MsgUrbanCreation* MsgSimToClient_Content::mutable_urban_creation() {
  _set_bit(109);
  if (urban_creation_ == NULL) urban_creation_ = new ::MsgsSimToClient::MsgUrbanCreation;
  return urban_creation_;
}

// optional .MsgsSimToClient.MsgUrbanUpdate urban_update = 111;
inline bool MsgSimToClient_Content::has_urban_update() const {
  return _has_bit(110);
}
inline void MsgSimToClient_Content::clear_urban_update() {
  if (urban_update_ != NULL) urban_update_->::MsgsSimToClient::MsgUrbanUpdate::Clear();
  _clear_bit(110);
}
inline const ::MsgsSimToClient::MsgUrbanUpdate& MsgSimToClient_Content::urban_update() const {
  return urban_update_ != NULL ? *urban_update_ : *default_instance_->urban_update_;
}
inline ::MsgsSimToClient::MsgUrbanUpdate* MsgSimToClient_Content::mutable_urban_update() {
  _set_bit(110);
  if (urban_update_ == NULL) urban_update_ = new ::MsgsSimToClient::MsgUrbanUpdate;
  return urban_update_;
}

// optional .MsgsSimToClient.MsgUrbanKnowledgeCreation urban_knowledge_creation = 112;
inline bool MsgSimToClient_Content::has_urban_knowledge_creation() const {
  return _has_bit(111);
}
inline void MsgSimToClient_Content::clear_urban_knowledge_creation() {
  if (urban_knowledge_creation_ != NULL) urban_knowledge_creation_->::MsgsSimToClient::MsgUrbanKnowledgeCreation::Clear();
  _clear_bit(111);
}
inline const ::MsgsSimToClient::MsgUrbanKnowledgeCreation& MsgSimToClient_Content::urban_knowledge_creation() const {
  return urban_knowledge_creation_ != NULL ? *urban_knowledge_creation_ : *default_instance_->urban_knowledge_creation_;
}
inline ::MsgsSimToClient::MsgUrbanKnowledgeCreation* MsgSimToClient_Content::mutable_urban_knowledge_creation() {
  _set_bit(111);
  if (urban_knowledge_creation_ == NULL) urban_knowledge_creation_ = new ::MsgsSimToClient::MsgUrbanKnowledgeCreation;
  return urban_knowledge_creation_;
}

// optional .MsgsSimToClient.MsgUrbanKnowledgeUpdate urban_knowledge_update = 113;
inline bool MsgSimToClient_Content::has_urban_knowledge_update() const {
  return _has_bit(112);
}
inline void MsgSimToClient_Content::clear_urban_knowledge_update() {
  if (urban_knowledge_update_ != NULL) urban_knowledge_update_->::MsgsSimToClient::MsgUrbanKnowledgeUpdate::Clear();
  _clear_bit(112);
}
inline const ::MsgsSimToClient::MsgUrbanKnowledgeUpdate& MsgSimToClient_Content::urban_knowledge_update() const {
  return urban_knowledge_update_ != NULL ? *urban_knowledge_update_ : *default_instance_->urban_knowledge_update_;
}
inline ::MsgsSimToClient::MsgUrbanKnowledgeUpdate* MsgSimToClient_Content::mutable_urban_knowledge_update() {
  _set_bit(112);
  if (urban_knowledge_update_ == NULL) urban_knowledge_update_ = new ::MsgsSimToClient::MsgUrbanKnowledgeUpdate;
  return urban_knowledge_update_;
}

// optional .MsgsSimToClient.MsgUrbanKnowledgeDestruction urban_knowledge_destruction = 114;
inline bool MsgSimToClient_Content::has_urban_knowledge_destruction() const {
  return _has_bit(113);
}
inline void MsgSimToClient_Content::clear_urban_knowledge_destruction() {
  if (urban_knowledge_destruction_ != NULL) urban_knowledge_destruction_->::MsgsSimToClient::MsgUrbanKnowledgeDestruction::Clear();
  _clear_bit(113);
}
inline const ::MsgsSimToClient::MsgUrbanKnowledgeDestruction& MsgSimToClient_Content::urban_knowledge_destruction() const {
  return urban_knowledge_destruction_ != NULL ? *urban_knowledge_destruction_ : *default_instance_->urban_knowledge_destruction_;
}
inline ::MsgsSimToClient::MsgUrbanKnowledgeDestruction* MsgSimToClient_Content::mutable_urban_knowledge_destruction() {
  _set_bit(113);
  if (urban_knowledge_destruction_ == NULL) urban_knowledge_destruction_ = new ::MsgsSimToClient::MsgUrbanKnowledgeDestruction;
  return urban_knowledge_destruction_;
}

// optional .Common.StockResource stock_resource = 115;
inline bool MsgSimToClient_Content::has_stock_resource() const {
  return _has_bit(114);
}
inline void MsgSimToClient_Content::clear_stock_resource() {
  if (stock_resource_ != NULL) stock_resource_->::Common::StockResource::Clear();
  _clear_bit(114);
}
inline const ::Common::StockResource& MsgSimToClient_Content::stock_resource() const {
  return stock_resource_ != NULL ? *stock_resource_ : *default_instance_->stock_resource_;
}
inline ::Common::StockResource* MsgSimToClient_Content::mutable_stock_resource() {
  _set_bit(114);
  if (stock_resource_ == NULL) stock_resource_ = new ::Common::StockResource;
  return stock_resource_;
}

// optional .MsgsSimToClient.MsgUrbanDetection urban_detection = 116;
inline bool MsgSimToClient_Content::has_urban_detection() const {
  return _has_bit(115);
}
inline void MsgSimToClient_Content::clear_urban_detection() {
  if (urban_detection_ != NULL) urban_detection_->::MsgsSimToClient::MsgUrbanDetection::Clear();
  _clear_bit(115);
}
inline const ::MsgsSimToClient::MsgUrbanDetection& MsgSimToClient_Content::urban_detection() const {
  return urban_detection_ != NULL ? *urban_detection_ : *default_instance_->urban_detection_;
}
inline ::MsgsSimToClient::MsgUrbanDetection* MsgSimToClient_Content::mutable_urban_detection() {
  _set_bit(115);
  if (urban_detection_ == NULL) urban_detection_ = new ::MsgsSimToClient::MsgUrbanDetection;
  return urban_detection_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupMagicActionAck knowledge_group_magic_action_ack = 117;
inline bool MsgSimToClient_Content::has_knowledge_group_magic_action_ack() const {
  return _has_bit(116);
}
inline void MsgSimToClient_Content::clear_knowledge_group_magic_action_ack() {
  if (knowledge_group_magic_action_ack_ != NULL) knowledge_group_magic_action_ack_->::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck::Clear();
  _clear_bit(116);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck& MsgSimToClient_Content::knowledge_group_magic_action_ack() const {
  return knowledge_group_magic_action_ack_ != NULL ? *knowledge_group_magic_action_ack_ : *default_instance_->knowledge_group_magic_action_ack_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck* MsgSimToClient_Content::mutable_knowledge_group_magic_action_ack() {
  _set_bit(116);
  if (knowledge_group_magic_action_ack_ == NULL) knowledge_group_magic_action_ack_ = new ::MsgsSimToClient::MsgKnowledgeGroupMagicActionAck;
  return knowledge_group_magic_action_ack_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupCreation knowledge_group_creation = 118;
inline bool MsgSimToClient_Content::has_knowledge_group_creation() const {
  return _has_bit(117);
}
inline void MsgSimToClient_Content::clear_knowledge_group_creation() {
  if (knowledge_group_creation_ != NULL) knowledge_group_creation_->::MsgsSimToClient::MsgKnowledgeGroupCreation::Clear();
  _clear_bit(117);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupCreation& MsgSimToClient_Content::knowledge_group_creation() const {
  return knowledge_group_creation_ != NULL ? *knowledge_group_creation_ : *default_instance_->knowledge_group_creation_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupCreation* MsgSimToClient_Content::mutable_knowledge_group_creation() {
  _set_bit(117);
  if (knowledge_group_creation_ == NULL) knowledge_group_creation_ = new ::MsgsSimToClient::MsgKnowledgeGroupCreation;
  return knowledge_group_creation_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupUpdate knowledge_group_update = 119;
inline bool MsgSimToClient_Content::has_knowledge_group_update() const {
  return _has_bit(118);
}
inline void MsgSimToClient_Content::clear_knowledge_group_update() {
  if (knowledge_group_update_ != NULL) knowledge_group_update_->::MsgsSimToClient::MsgKnowledgeGroupUpdate::Clear();
  _clear_bit(118);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupUpdate& MsgSimToClient_Content::knowledge_group_update() const {
  return knowledge_group_update_ != NULL ? *knowledge_group_update_ : *default_instance_->knowledge_group_update_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupUpdate* MsgSimToClient_Content::mutable_knowledge_group_update() {
  _set_bit(118);
  if (knowledge_group_update_ == NULL) knowledge_group_update_ = new ::MsgsSimToClient::MsgKnowledgeGroupUpdate;
  return knowledge_group_update_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupCreationAck knowledge_group_creation_ack = 120;
inline bool MsgSimToClient_Content::has_knowledge_group_creation_ack() const {
  return _has_bit(119);
}
inline void MsgSimToClient_Content::clear_knowledge_group_creation_ack() {
  if (knowledge_group_creation_ack_ != NULL) knowledge_group_creation_ack_->::MsgsSimToClient::MsgKnowledgeGroupCreationAck::Clear();
  _clear_bit(119);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupCreationAck& MsgSimToClient_Content::knowledge_group_creation_ack() const {
  return knowledge_group_creation_ack_ != NULL ? *knowledge_group_creation_ack_ : *default_instance_->knowledge_group_creation_ack_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupCreationAck* MsgSimToClient_Content::mutable_knowledge_group_creation_ack() {
  _set_bit(119);
  if (knowledge_group_creation_ack_ == NULL) knowledge_group_creation_ack_ = new ::MsgsSimToClient::MsgKnowledgeGroupCreationAck;
  return knowledge_group_creation_ack_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupUpdateAck knowledge_group_update_ack = 121;
inline bool MsgSimToClient_Content::has_knowledge_group_update_ack() const {
  return _has_bit(120);
}
inline void MsgSimToClient_Content::clear_knowledge_group_update_ack() {
  if (knowledge_group_update_ack_ != NULL) knowledge_group_update_ack_->::MsgsSimToClient::MsgKnowledgeGroupUpdateAck::Clear();
  _clear_bit(120);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck& MsgSimToClient_Content::knowledge_group_update_ack() const {
  return knowledge_group_update_ack_ != NULL ? *knowledge_group_update_ack_ : *default_instance_->knowledge_group_update_ack_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck* MsgSimToClient_Content::mutable_knowledge_group_update_ack() {
  _set_bit(120);
  if (knowledge_group_update_ack_ == NULL) knowledge_group_update_ack_ = new ::MsgsSimToClient::MsgKnowledgeGroupUpdateAck;
  return knowledge_group_update_ack_;
}

// optional .MsgsSimToClient.MsgKnowledgeGroupDestruction knowledge_group_destruction = 122;
inline bool MsgSimToClient_Content::has_knowledge_group_destruction() const {
  return _has_bit(121);
}
inline void MsgSimToClient_Content::clear_knowledge_group_destruction() {
  if (knowledge_group_destruction_ != NULL) knowledge_group_destruction_->::MsgsSimToClient::MsgKnowledgeGroupDestruction::Clear();
  _clear_bit(121);
}
inline const ::MsgsSimToClient::MsgKnowledgeGroupDestruction& MsgSimToClient_Content::knowledge_group_destruction() const {
  return knowledge_group_destruction_ != NULL ? *knowledge_group_destruction_ : *default_instance_->knowledge_group_destruction_;
}
inline ::MsgsSimToClient::MsgKnowledgeGroupDestruction* MsgSimToClient_Content::mutable_knowledge_group_destruction() {
  _set_bit(121);
  if (knowledge_group_destruction_ == NULL) knowledge_group_destruction_ = new ::MsgsSimToClient::MsgKnowledgeGroupDestruction;
  return knowledge_group_destruction_;
}

// optional .MsgsSimToClient.MsgActionCreateFireOrderAck action_create_fire_order_ack = 123;
inline bool MsgSimToClient_Content::has_action_create_fire_order_ack() const {
  return _has_bit(122);
}
inline void MsgSimToClient_Content::clear_action_create_fire_order_ack() {
  if (action_create_fire_order_ack_ != NULL) action_create_fire_order_ack_->::MsgsSimToClient::MsgActionCreateFireOrderAck::Clear();
  _clear_bit(122);
}
inline const ::MsgsSimToClient::MsgActionCreateFireOrderAck& MsgSimToClient_Content::action_create_fire_order_ack() const {
  return action_create_fire_order_ack_ != NULL ? *action_create_fire_order_ack_ : *default_instance_->action_create_fire_order_ack_;
}
inline ::MsgsSimToClient::MsgActionCreateFireOrderAck* MsgSimToClient_Content::mutable_action_create_fire_order_ack() {
  _set_bit(122);
  if (action_create_fire_order_ack_ == NULL) action_create_fire_order_ack_ = new ::MsgsSimToClient::MsgActionCreateFireOrderAck;
  return action_create_fire_order_ack_;
}

// optional .MsgsSimToClient.MsgControlGlobalMeteo control_global_meteo = 124;
inline bool MsgSimToClient_Content::has_control_global_meteo() const {
  return _has_bit(123);
}
inline void MsgSimToClient_Content::clear_control_global_meteo() {
  if (control_global_meteo_ != NULL) control_global_meteo_->::MsgsSimToClient::MsgControlGlobalMeteo::Clear();
  _clear_bit(123);
}
inline const ::MsgsSimToClient::MsgControlGlobalMeteo& MsgSimToClient_Content::control_global_meteo() const {
  return control_global_meteo_ != NULL ? *control_global_meteo_ : *default_instance_->control_global_meteo_;
}
inline ::MsgsSimToClient::MsgControlGlobalMeteo* MsgSimToClient_Content::mutable_control_global_meteo() {
  _set_bit(123);
  if (control_global_meteo_ == NULL) control_global_meteo_ = new ::MsgsSimToClient::MsgControlGlobalMeteo;
  return control_global_meteo_;
}

// optional .MsgsSimToClient.MsgControlLocalMeteoCreation control_local_meteo_creation = 125;
inline bool MsgSimToClient_Content::has_control_local_meteo_creation() const {
  return _has_bit(124);
}
inline void MsgSimToClient_Content::clear_control_local_meteo_creation() {
  if (control_local_meteo_creation_ != NULL) control_local_meteo_creation_->::MsgsSimToClient::MsgControlLocalMeteoCreation::Clear();
  _clear_bit(124);
}
inline const ::MsgsSimToClient::MsgControlLocalMeteoCreation& MsgSimToClient_Content::control_local_meteo_creation() const {
  return control_local_meteo_creation_ != NULL ? *control_local_meteo_creation_ : *default_instance_->control_local_meteo_creation_;
}
inline ::MsgsSimToClient::MsgControlLocalMeteoCreation* MsgSimToClient_Content::mutable_control_local_meteo_creation() {
  _set_bit(124);
  if (control_local_meteo_creation_ == NULL) control_local_meteo_creation_ = new ::MsgsSimToClient::MsgControlLocalMeteoCreation;
  return control_local_meteo_creation_;
}

// optional .MsgsSimToClient.MsgControlLocalMeteoDestruction control_local_meteo_destruction = 126;
inline bool MsgSimToClient_Content::has_control_local_meteo_destruction() const {
  return _has_bit(125);
}
inline void MsgSimToClient_Content::clear_control_local_meteo_destruction() {
  if (control_local_meteo_destruction_ != NULL) control_local_meteo_destruction_->::MsgsSimToClient::MsgControlLocalMeteoDestruction::Clear();
  _clear_bit(125);
}
inline const ::MsgsSimToClient::MsgControlLocalMeteoDestruction& MsgSimToClient_Content::control_local_meteo_destruction() const {
  return control_local_meteo_destruction_ != NULL ? *control_local_meteo_destruction_ : *default_instance_->control_local_meteo_destruction_;
}
inline ::MsgsSimToClient::MsgControlLocalMeteoDestruction* MsgSimToClient_Content::mutable_control_local_meteo_destruction() {
  _set_bit(125);
  if (control_local_meteo_destruction_ == NULL) control_local_meteo_destruction_ = new ::MsgsSimToClient::MsgControlLocalMeteoDestruction;
  return control_local_meteo_destruction_;
}

// -------------------------------------------------------------------

// MsgSimToClient

// optional int32 context = 1;
inline bool MsgSimToClient::has_context() const {
  return _has_bit(0);
}
inline void MsgSimToClient::clear_context() {
  context_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MsgSimToClient::context() const {
  return context_;
}
inline void MsgSimToClient::set_context(::google::protobuf::int32 value) {
  _set_bit(0);
  context_ = value;
}

// required .MsgsSimToClient.MsgSimToClient.Content message = 2;
inline bool MsgSimToClient::has_message() const {
  return _has_bit(1);
}
inline void MsgSimToClient::clear_message() {
  if (message_ != NULL) message_->::MsgsSimToClient::MsgSimToClient_Content::Clear();
  _clear_bit(1);
}
inline const ::MsgsSimToClient::MsgSimToClient_Content& MsgSimToClient::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::MsgsSimToClient::MsgSimToClient_Content* MsgSimToClient::mutable_message() {
  _set_bit(1);
  if (message_ == NULL) message_ = new ::MsgsSimToClient::MsgSimToClient_Content;
  return message_;
}


}  // namespace MsgsSimToClient

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::OrderAck_ErrorCode>() {
  return ::MsgsSimToClient::OrderAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgSetAutomatModeAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::UnitActionAck_ErrorCode>() {
  return ::MsgsSimToClient::UnitActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgMagicActionAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgMagicActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgObjectMagicActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgPopulationMagicActionAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgPopulationMagicActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode>() {
  return ::MsgsSimToClient::MsgChangeDiplomacyAck_EnumChangeDiplomacyErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::HierarchyModificationAck_ErrorCode>() {
  return ::MsgsSimToClient::HierarchyModificationAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow>() {
  return ::MsgsSimToClient::MsgLogSupplyPushFlowAck_EnumLogSupplyPushFlow_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas>() {
  return ::MsgsSimToClient::MsgLogSupplyChangeQuotasAck_LogSupplyChangeQuotas_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode>() {
  return ::MsgsSimToClient::MsgActionCreateFireOrderAck_EnumActionCreateFireOrderErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::ControlAck_ErrorCode>() {
  return ::MsgsSimToClient::ControlAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::RulesOfEngagement_Value>() {
  return ::MsgsSimToClient::RulesOfEngagement_Value_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::ForceRatio_Value>() {
  return ::MsgsSimToClient::ForceRatio_Value_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgUnitAttributes_Posture>() {
  return ::MsgsSimToClient::MsgUnitAttributes_Posture_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgUnitAttributes_FireAvailability>() {
  return ::MsgsSimToClient::MsgUnitAttributes_FireAvailability_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgUnitAttributes_PopulationRoe>() {
  return ::MsgsSimToClient::MsgUnitAttributes_PopulationRoe_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode>() {
  return ::MsgsSimToClient::MsgUrbanMagicActionAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode>() {
  return ::MsgsSimToClient::KnowledgeGroupAck_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< MsgsSimToClient::EnumLogSupplyHandlingStatus>() {
  return MsgsSimToClient::EnumLogSupplyHandlingStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< MsgsSimToClient::EnumUnitIdentificationLevel>() {
  return MsgsSimToClient::EnumUnitIdentificationLevel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< MsgsSimToClient::EnumReportType>() {
  return MsgsSimToClient::EnumReportType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_SimToClient_2eproto__INCLUDED
