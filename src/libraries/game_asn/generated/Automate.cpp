/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 04-Apr-2007.
 */
#include "Automate.h"

/**************************************************************/
/*                                                            */
/*  AutomateIncludes                                          */
/*                                                            */
/**************************************************************/

ASN1C_AutomateIncludes::ASN1C_AutomateIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_AutomateIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AutomateIncludes (ASN1CTXT* ctxt_p, ASN1T_AutomateIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AutomateIncludes: start\n");

   /* encode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode unitExports */

   PU_PUSHNAME (ctxt_p, "unitExports");

   stat = asn1PE_UnitExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_AutomateIncludes: end\n");
   return (stat);
}

int ASN1C_AutomateIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AutomateIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AutomateIncludes (ASN1CTXT* ctxt_p, ASN1T_AutomateIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AutomateIncludes: start\n");

   /* decode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode unitExports */

   PU_PUSHNAME (ctxt_p, "unitExports");

   stat = asn1PD_UnitExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_AutomateIncludes: end\n");

   return (stat);
}

int ASN1C_AutomateIncludes::Decode ()
{
   return asn1PD_AutomateIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AutomateExports                                           */
/*                                                            */
/**************************************************************/

ASN1C_AutomateExports::ASN1C_AutomateExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_AutomateExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_AutomateExports: start\n");

   /* NULL */

   rtdiag ("asn1PE_AutomateExports: end\n");
   return (stat);
}

int ASN1C_AutomateExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AutomateExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_AutomateExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_AutomateExports: start\n");

   /* NULL */

   rtdiag ("asn1PD_AutomateExports: end\n");

   return (stat);
}

int ASN1C_AutomateExports::Decode ()
{
   return asn1PD_AutomateExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  EnumAutomateState                                         */
/*                                                            */
/**************************************************************/

ASN1C_EnumAutomateState::ASN1C_EnumAutomateState (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumAutomateState& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumAutomateState (ASN1CTXT* ctxt_p, ASN1T_EnumAutomateState value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumAutomateState: start\n");

   switch (value) {
      case EnumAutomateState::embraye: ui = 0; break;
      case EnumAutomateState::debraye: ui = 1; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumAutomateState: end\n");
   return (stat);
}

int ASN1C_EnumAutomateState::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumAutomateState (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumAutomateState (ASN1CTXT* ctxt_p, ASN1T_EnumAutomateState* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumAutomateState: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumAutomateState::embraye; break;
      case 1: *pvalue = EnumAutomateState::debraye; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumAutomateState: end\n");

   return (stat);
}

int ASN1C_EnumAutomateState::Decode ()
{
   return asn1PD_EnumAutomateState (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomateCreation                                       */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomateCreation::ASN1C_MsgAutomateCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomateCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomateCreation (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgAutomateCreation: start\n");

   /* encode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PE_Automate (ctxt_p, pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type_automate */

   PU_PUSHNAME (ctxt_p, "type_automate");

   stat = asn1PE_TypeAutomate (ctxt_p, pvalue->type_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nom */

   PU_PUSHNAME (ctxt_p, "nom");

   stat = pe_VisibleString (ctxt_p, pvalue->nom, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_formation */

   PU_PUSHNAME (ctxt_p, "oid_formation");

   stat = asn1PE_Formation (ctxt_p, pvalue->oid_formation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_camp */

   PU_PUSHNAME (ctxt_p, "oid_camp");

   stat = asn1PE_Camp (ctxt_p, pvalue->oid_camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_connaissance */

   PU_PUSHNAME (ctxt_p, "oid_groupe_connaissance");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_connaissance);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgAutomateCreation: end\n");
   return (stat);
}

int ASN1C_MsgAutomateCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomateCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomateCreation (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgAutomateCreation: start\n");

   /* decode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PD_Automate (ctxt_p, &pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type_automate */

   PU_PUSHNAME (ctxt_p, "type_automate");

   stat = asn1PD_TypeAutomate (ctxt_p, &pvalue->type_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nom */

   PU_PUSHNAME (ctxt_p, "nom");

   stat = pd_VisibleString (ctxt_p, &pvalue->nom, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_formation */

   PU_PUSHNAME (ctxt_p, "oid_formation");

   stat = asn1PD_Formation (ctxt_p, &pvalue->oid_formation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_camp */

   PU_PUSHNAME (ctxt_p, "oid_camp");

   stat = asn1PD_Camp (ctxt_p, &pvalue->oid_camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_connaissance */

   PU_PUSHNAME (ctxt_p, "oid_groupe_connaissance");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_connaissance);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgAutomateCreation: end\n");

   return (stat);
}

int ASN1C_MsgAutomateCreation::Decode ()
{
   return asn1PD_MsgAutomateCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomateAttributes                                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomateAttributes::ASN1C_MsgAutomateAttributes (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomateAttributes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomateAttributes (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateAttributes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgAutomateAttributes: start\n");

   PU_NEWFIELD (ctxt_p, "etat_automatePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.etat_automatePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "rapport_de_forcePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.rapport_de_forcePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "combat_de_rencontrePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.combat_de_rencontrePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "etat_operationnelPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.etat_operationnelPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "roePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.roePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PE_Automate (ctxt_p, pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode etat_automate */

   if (pvalue->m.etat_automatePresent) {
      PU_PUSHNAME (ctxt_p, "etat_automate");

      stat = asn1PE_EnumAutomateState (ctxt_p, pvalue->etat_automate);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode rapport_de_force */

   if (pvalue->m.rapport_de_forcePresent) {
      PU_PUSHNAME (ctxt_p, "rapport_de_force");

      stat = asn1PE_EnumEtatRapFor (ctxt_p, pvalue->rapport_de_force);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode combat_de_rencontre */

   if (pvalue->m.combat_de_rencontrePresent) {
      PU_PUSHNAME (ctxt_p, "combat_de_rencontre");

      stat = asn1PE_EnumEtatCombatRencontre (ctxt_p, pvalue->combat_de_rencontre);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode etat_operationnel */

   if (pvalue->m.etat_operationnelPresent) {
      PU_PUSHNAME (ctxt_p, "etat_operationnel");

      stat = asn1PE_EnumEtatOperationnel (ctxt_p, pvalue->etat_operationnel);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode roe */

   if (pvalue->m.roePresent) {
      PU_PUSHNAME (ctxt_p, "roe");

      stat = asn1PE_EnumRoe (ctxt_p, pvalue->roe);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgAutomateAttributes: end\n");
   return (stat);
}

int ASN1C_MsgAutomateAttributes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomateAttributes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomateAttributes (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateAttributes* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgAutomateAttributes: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "etat_automatePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.etat_automatePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "rapport_de_forcePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.rapport_de_forcePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "combat_de_rencontrePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.combat_de_rencontrePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "etat_operationnelPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.etat_operationnelPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "roePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.roePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PD_Automate (ctxt_p, &pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode etat_automate */

   if (pvalue->m.etat_automatePresent) {
      PU_PUSHNAME (ctxt_p, "etat_automate");

      stat = asn1PD_EnumAutomateState (ctxt_p, &pvalue->etat_automate);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode rapport_de_force */

   if (pvalue->m.rapport_de_forcePresent) {
      PU_PUSHNAME (ctxt_p, "rapport_de_force");

      stat = asn1PD_EnumEtatRapFor (ctxt_p, &pvalue->rapport_de_force);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode combat_de_rencontre */

   if (pvalue->m.combat_de_rencontrePresent) {
      PU_PUSHNAME (ctxt_p, "combat_de_rencontre");

      stat = asn1PD_EnumEtatCombatRencontre (ctxt_p, &pvalue->combat_de_rencontre);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode etat_operationnel */

   if (pvalue->m.etat_operationnelPresent) {
      PU_PUSHNAME (ctxt_p, "etat_operationnel");

      stat = asn1PD_EnumEtatOperationnel (ctxt_p, &pvalue->etat_operationnel);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode roe */

   if (pvalue->m.roePresent) {
      PU_PUSHNAME (ctxt_p, "roe");

      stat = asn1PD_EnumRoe (ctxt_p, &pvalue->roe);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgAutomateAttributes: end\n");

   return (stat);
}

int ASN1C_MsgAutomateAttributes::Decode ()
{
   return asn1PD_MsgAutomateAttributes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumSetAutomateModeErrorCode                              */
/*                                                            */
/**************************************************************/

ASN1C_EnumSetAutomateModeErrorCode::ASN1C_EnumSetAutomateModeErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumSetAutomateModeErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumSetAutomateModeErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumSetAutomateModeErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumSetAutomateModeErrorCode: start\n");

   switch (value) {
      case EnumSetAutomateModeErrorCode::no_error: ui = 0; break;
      case EnumSetAutomateModeErrorCode::error_invalid_unit: ui = 1; break;
      case EnumSetAutomateModeErrorCode::error_not_allowed: ui = 2; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumSetAutomateModeErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumSetAutomateModeErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumSetAutomateModeErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumSetAutomateModeErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumSetAutomateModeErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumSetAutomateModeErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumSetAutomateModeErrorCode::no_error; break;
      case 1: *pvalue = EnumSetAutomateModeErrorCode::error_invalid_unit; break;
      case 2: *pvalue = EnumSetAutomateModeErrorCode::error_not_allowed; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumSetAutomateModeErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumSetAutomateModeErrorCode::Decode ()
{
   return asn1PD_EnumSetAutomateModeErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgSetAutomateMode                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgSetAutomateMode::ASN1C_MsgSetAutomateMode (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgSetAutomateMode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgSetAutomateMode (ASN1CTXT* ctxt_p, ASN1T_MsgSetAutomateMode* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgSetAutomateMode: start\n");

   /* encode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PE_Agent (ctxt_p, pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode mode */

   PU_PUSHNAME (ctxt_p, "mode");

   stat = asn1PE_EnumAutomateState (ctxt_p, pvalue->mode);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgSetAutomateMode: end\n");
   return (stat);
}

int ASN1C_MsgSetAutomateMode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgSetAutomateMode (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgSetAutomateMode (ASN1CTXT* ctxt_p, ASN1T_MsgSetAutomateMode* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgSetAutomateMode: start\n");

   /* decode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PD_Agent (ctxt_p, &pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode mode */

   PU_PUSHNAME (ctxt_p, "mode");

   stat = asn1PD_EnumAutomateState (ctxt_p, &pvalue->mode);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgSetAutomateMode: end\n");

   return (stat);
}

int ASN1C_MsgSetAutomateMode::Decode ()
{
   return asn1PD_MsgSetAutomateMode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgSetAutomateModeAck                                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgSetAutomateModeAck::ASN1C_MsgSetAutomateModeAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgSetAutomateModeAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgSetAutomateModeAck (ASN1CTXT* ctxt_p, ASN1T_MsgSetAutomateModeAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgSetAutomateModeAck: start\n");

   /* encode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PE_Agent (ctxt_p, pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumSetAutomateModeErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgSetAutomateModeAck: end\n");
   return (stat);
}

int ASN1C_MsgSetAutomateModeAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgSetAutomateModeAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgSetAutomateModeAck (ASN1CTXT* ctxt_p, ASN1T_MsgSetAutomateModeAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgSetAutomateModeAck: start\n");

   /* decode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PD_Agent (ctxt_p, &pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumSetAutomateModeErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgSetAutomateModeAck: end\n");

   return (stat);
}

int ASN1C_MsgSetAutomateModeAck::Decode ()
{
   return asn1PD_MsgSetAutomateModeAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumChangeAutomateErrorCode                               */
/*                                                            */
/**************************************************************/

ASN1C_EnumChangeAutomateErrorCode::ASN1C_EnumChangeAutomateErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumChangeAutomateErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumChangeAutomateErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumChangeAutomateErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumChangeAutomateErrorCode: start\n");

   switch (value) {
      case EnumChangeAutomateErrorCode::no_error: ui = 0; break;
      case EnumChangeAutomateErrorCode::error_invalid_pion: ui = 1; break;
      case EnumChangeAutomateErrorCode::error_invalid_automate: ui = 2; break;
      case EnumChangeAutomateErrorCode::error_camps_incompatibles: ui = 3; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumChangeAutomateErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumChangeAutomateErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumChangeAutomateErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumChangeAutomateErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumChangeAutomateErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumChangeAutomateErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumChangeAutomateErrorCode::no_error; break;
      case 1: *pvalue = EnumChangeAutomateErrorCode::error_invalid_pion; break;
      case 2: *pvalue = EnumChangeAutomateErrorCode::error_invalid_automate; break;
      case 3: *pvalue = EnumChangeAutomateErrorCode::error_camps_incompatibles; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumChangeAutomateErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumChangeAutomateErrorCode::Decode ()
{
   return asn1PD_EnumChangeAutomateErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgChangeAutomateAck                                      */
/*                                                            */
/**************************************************************/

ASN1C_MsgChangeAutomateAck::ASN1C_MsgChangeAutomateAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgChangeAutomateAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgChangeAutomateAck (ASN1CTXT* ctxt_p, ASN1T_MsgChangeAutomateAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgChangeAutomateAck: start\n");

   /* encode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PE_Agent (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PE_Automate (ctxt_p, pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumChangeAutomateErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgChangeAutomateAck: end\n");
   return (stat);
}

int ASN1C_MsgChangeAutomateAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgChangeAutomateAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgChangeAutomateAck (ASN1CTXT* ctxt_p, ASN1T_MsgChangeAutomateAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgChangeAutomateAck: start\n");

   /* decode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PD_Agent (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PD_Automate (ctxt_p, &pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumChangeAutomateErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgChangeAutomateAck: end\n");

   return (stat);
}

int ASN1C_MsgChangeAutomateAck::Decode ()
{
   return asn1PD_MsgChangeAutomateAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgChangeAutomate                                         */
/*                                                            */
/**************************************************************/

ASN1C_MsgChangeAutomate::ASN1C_MsgChangeAutomate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgChangeAutomate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgChangeAutomate (ASN1CTXT* ctxt_p, ASN1T_MsgChangeAutomate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgChangeAutomate: start\n");

   /* encode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PE_Agent (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PE_Automate (ctxt_p, pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgChangeAutomate: end\n");
   return (stat);
}

int ASN1C_MsgChangeAutomate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgChangeAutomate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgChangeAutomate (ASN1CTXT* ctxt_p, ASN1T_MsgChangeAutomate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgChangeAutomate: start\n");

   /* decode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PD_Agent (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PD_Automate (ctxt_p, &pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgChangeAutomate: end\n");

   return (stat);
}

int ASN1C_MsgChangeAutomate::Decode ()
{
   return asn1PD_MsgChangeAutomate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgChangeLiensLogistiques                                 */
/*                                                            */
/**************************************************************/

ASN1C_MsgChangeLiensLogistiques::ASN1C_MsgChangeLiensLogistiques (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgChangeLiensLogistiques& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgChangeLiensLogistiques (ASN1CTXT* ctxt_p, ASN1T_MsgChangeLiensLogistiques* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgChangeLiensLogistiques: start\n");

   PU_NEWFIELD (ctxt_p, "oid_tc2Present");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_tc2Present);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_maintenancePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_maintenancePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_santePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_santePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_ravitaillementPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_ravitaillementPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PE_Automate (ctxt_p, pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_tc2 */

   if (pvalue->m.oid_tc2Present) {
      PU_PUSHNAME (ctxt_p, "oid_tc2");

      stat = asn1PE_Automate (ctxt_p, pvalue->oid_tc2);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode oid_maintenance */

   if (pvalue->m.oid_maintenancePresent) {
      PU_PUSHNAME (ctxt_p, "oid_maintenance");

      stat = asn1PE_Automate (ctxt_p, pvalue->oid_maintenance);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode oid_sante */

   if (pvalue->m.oid_santePresent) {
      PU_PUSHNAME (ctxt_p, "oid_sante");

      stat = asn1PE_Automate (ctxt_p, pvalue->oid_sante);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode oid_ravitaillement */

   if (pvalue->m.oid_ravitaillementPresent) {
      PU_PUSHNAME (ctxt_p, "oid_ravitaillement");

      stat = asn1PE_Automate (ctxt_p, pvalue->oid_ravitaillement);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgChangeLiensLogistiques: end\n");
   return (stat);
}

int ASN1C_MsgChangeLiensLogistiques::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgChangeLiensLogistiques (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgChangeLiensLogistiques (ASN1CTXT* ctxt_p, ASN1T_MsgChangeLiensLogistiques* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgChangeLiensLogistiques: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "oid_tc2Present");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_tc2Present = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_maintenancePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_maintenancePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_santePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_santePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_ravitaillementPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_ravitaillementPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PD_Automate (ctxt_p, &pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_tc2 */

   if (pvalue->m.oid_tc2Present) {
      PU_PUSHNAME (ctxt_p, "oid_tc2");

      stat = asn1PD_Automate (ctxt_p, &pvalue->oid_tc2);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode oid_maintenance */

   if (pvalue->m.oid_maintenancePresent) {
      PU_PUSHNAME (ctxt_p, "oid_maintenance");

      stat = asn1PD_Automate (ctxt_p, &pvalue->oid_maintenance);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode oid_sante */

   if (pvalue->m.oid_santePresent) {
      PU_PUSHNAME (ctxt_p, "oid_sante");

      stat = asn1PD_Automate (ctxt_p, &pvalue->oid_sante);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode oid_ravitaillement */

   if (pvalue->m.oid_ravitaillementPresent) {
      PU_PUSHNAME (ctxt_p, "oid_ravitaillement");

      stat = asn1PD_Automate (ctxt_p, &pvalue->oid_ravitaillement);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgChangeLiensLogistiques: end\n");

   return (stat);
}

int ASN1C_MsgChangeLiensLogistiques::Decode ()
{
   return asn1PD_MsgChangeLiensLogistiques (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumChangeLiensLogistiquesErrorCode                       */
/*                                                            */
/**************************************************************/

ASN1C_EnumChangeLiensLogistiquesErrorCode::ASN1C_EnumChangeLiensLogistiquesErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumChangeLiensLogistiquesErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumChangeLiensLogistiquesErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumChangeLiensLogistiquesErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumChangeLiensLogistiquesErrorCode: start\n");

   switch (value) {
      case EnumChangeLiensLogistiquesErrorCode::no_error: ui = 0; break;
      case EnumChangeLiensLogistiquesErrorCode::error_invalid_automate: ui = 1; break;
      case EnumChangeLiensLogistiquesErrorCode::error_invalid_automate_tc2: ui = 2; break;
      case EnumChangeLiensLogistiquesErrorCode::error_invalid_automate_maintenance: ui = 3; break;
      case EnumChangeLiensLogistiquesErrorCode::error_invalid_automate_sante: ui = 4; break;
      case EnumChangeLiensLogistiquesErrorCode::error_invalid_automate_ravitaillement: ui = 5; break;
      case EnumChangeLiensLogistiquesErrorCode::error_unit_surrendered: ui = 6; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumChangeLiensLogistiquesErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumChangeLiensLogistiquesErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumChangeLiensLogistiquesErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumChangeLiensLogistiquesErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumChangeLiensLogistiquesErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumChangeLiensLogistiquesErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumChangeLiensLogistiquesErrorCode::no_error; break;
      case 1: *pvalue = EnumChangeLiensLogistiquesErrorCode::error_invalid_automate; break;
      case 2: *pvalue = EnumChangeLiensLogistiquesErrorCode::error_invalid_automate_tc2; break;
      case 3: *pvalue = EnumChangeLiensLogistiquesErrorCode::error_invalid_automate_maintenance; break;
      case 4: *pvalue = EnumChangeLiensLogistiquesErrorCode::error_invalid_automate_sante; break;
      case 5: *pvalue = EnumChangeLiensLogistiquesErrorCode::error_invalid_automate_ravitaillement; break;
      case 6: *pvalue = EnumChangeLiensLogistiquesErrorCode::error_unit_surrendered; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumChangeLiensLogistiquesErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumChangeLiensLogistiquesErrorCode::Decode ()
{
   return asn1PD_EnumChangeLiensLogistiquesErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgChangeLiensLogistiquesAck                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgChangeLiensLogistiquesAck::ASN1C_MsgChangeLiensLogistiquesAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgChangeLiensLogistiquesAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgChangeLiensLogistiquesAck (ASN1CTXT* ctxt_p, ASN1T_MsgChangeLiensLogistiquesAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgChangeLiensLogistiquesAck: start\n");

   PU_NEWFIELD (ctxt_p, "oid_tc2Present");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_tc2Present);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_maintenancePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_maintenancePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_santePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_santePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_ravitaillementPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_ravitaillementPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PE_Automate (ctxt_p, pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_tc2 */

   if (pvalue->m.oid_tc2Present) {
      PU_PUSHNAME (ctxt_p, "oid_tc2");

      stat = asn1PE_Automate (ctxt_p, pvalue->oid_tc2);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode oid_maintenance */

   if (pvalue->m.oid_maintenancePresent) {
      PU_PUSHNAME (ctxt_p, "oid_maintenance");

      stat = asn1PE_Automate (ctxt_p, pvalue->oid_maintenance);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode oid_sante */

   if (pvalue->m.oid_santePresent) {
      PU_PUSHNAME (ctxt_p, "oid_sante");

      stat = asn1PE_Automate (ctxt_p, pvalue->oid_sante);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode oid_ravitaillement */

   if (pvalue->m.oid_ravitaillementPresent) {
      PU_PUSHNAME (ctxt_p, "oid_ravitaillement");

      stat = asn1PE_Automate (ctxt_p, pvalue->oid_ravitaillement);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumChangeLiensLogistiquesErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgChangeLiensLogistiquesAck: end\n");
   return (stat);
}

int ASN1C_MsgChangeLiensLogistiquesAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgChangeLiensLogistiquesAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgChangeLiensLogistiquesAck (ASN1CTXT* ctxt_p, ASN1T_MsgChangeLiensLogistiquesAck* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgChangeLiensLogistiquesAck: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "oid_tc2Present");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_tc2Present = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_maintenancePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_maintenancePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_santePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_santePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "oid_ravitaillementPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_ravitaillementPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_automate */

   PU_PUSHNAME (ctxt_p, "oid_automate");

   stat = asn1PD_Automate (ctxt_p, &pvalue->oid_automate);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_tc2 */

   if (pvalue->m.oid_tc2Present) {
      PU_PUSHNAME (ctxt_p, "oid_tc2");

      stat = asn1PD_Automate (ctxt_p, &pvalue->oid_tc2);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode oid_maintenance */

   if (pvalue->m.oid_maintenancePresent) {
      PU_PUSHNAME (ctxt_p, "oid_maintenance");

      stat = asn1PD_Automate (ctxt_p, &pvalue->oid_maintenance);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode oid_sante */

   if (pvalue->m.oid_santePresent) {
      PU_PUSHNAME (ctxt_p, "oid_sante");

      stat = asn1PD_Automate (ctxt_p, &pvalue->oid_sante);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode oid_ravitaillement */

   if (pvalue->m.oid_ravitaillementPresent) {
      PU_PUSHNAME (ctxt_p, "oid_ravitaillement");

      stat = asn1PD_Automate (ctxt_p, &pvalue->oid_ravitaillement);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumChangeLiensLogistiquesErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgChangeLiensLogistiquesAck: end\n");

   return (stat);
}

int ASN1C_MsgChangeLiensLogistiquesAck::Decode ()
{
   return asn1PD_MsgChangeLiensLogistiquesAck (mpContext->GetPtr(), &msgData);
}

