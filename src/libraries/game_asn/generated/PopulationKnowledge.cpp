/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 18-Jun-2007.
 */
#include "PopulationKnowledge.h"

/**************************************************************/
/*                                                            */
/*  PopulationKnowledgeIncludes                               */
/*                                                            */
/**************************************************************/

ASN1C_PopulationKnowledgeIncludes::ASN1C_PopulationKnowledgeIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_PopulationKnowledgeIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_PopulationKnowledgeIncludes (ASN1CTXT* ctxt_p, ASN1T_PopulationKnowledgeIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_PopulationKnowledgeIncludes: start\n");

   /* encode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode populationExports */

   PU_PUSHNAME (ctxt_p, "populationExports");

   stat = asn1PE_PopulationExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_PopulationKnowledgeIncludes: end\n");
   return (stat);
}

int ASN1C_PopulationKnowledgeIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PopulationKnowledgeIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_PopulationKnowledgeIncludes (ASN1CTXT* ctxt_p, ASN1T_PopulationKnowledgeIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_PopulationKnowledgeIncludes: start\n");

   /* decode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode populationExports */

   PU_PUSHNAME (ctxt_p, "populationExports");

   stat = asn1PD_PopulationExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_PopulationKnowledgeIncludes: end\n");

   return (stat);
}

int ASN1C_PopulationKnowledgeIncludes::Decode ()
{
   return asn1PD_PopulationKnowledgeIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  PopulationKnowledgeExports                                */
/*                                                            */
/**************************************************************/

ASN1C_PopulationKnowledgeExports::ASN1C_PopulationKnowledgeExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_PopulationKnowledgeExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_PopulationKnowledgeExports: start\n");

   /* NULL */

   rtdiag ("asn1PE_PopulationKnowledgeExports: end\n");
   return (stat);
}

int ASN1C_PopulationKnowledgeExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PopulationKnowledgeExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_PopulationKnowledgeExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_PopulationKnowledgeExports: start\n");

   /* NULL */

   rtdiag ("asn1PD_PopulationKnowledgeExports: end\n");

   return (stat);
}

int ASN1C_PopulationKnowledgeExports::Decode ()
{
   return asn1PD_PopulationKnowledgeExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationKnowledgeCreation                            */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationKnowledgeCreation::ASN1C_MsgPopulationKnowledgeCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationKnowledgeCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationKnowledgeCreation (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationKnowledgeCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationKnowledgeCreation: start\n");

   /* encode oid_connaissance */

   PU_PUSHNAME (ctxt_p, "oid_connaissance");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_population_reelle */

   PU_PUSHNAME (ctxt_p, "oid_population_reelle");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_population_reelle);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode camp */

   PU_PUSHNAME (ctxt_p, "camp");

   stat = asn1PE_OID (ctxt_p, pvalue->camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationKnowledgeCreation: end\n");
   return (stat);
}

int ASN1C_MsgPopulationKnowledgeCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationKnowledgeCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationKnowledgeCreation (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationKnowledgeCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationKnowledgeCreation: start\n");

   /* decode oid_connaissance */

   PU_PUSHNAME (ctxt_p, "oid_connaissance");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_population_reelle */

   PU_PUSHNAME (ctxt_p, "oid_population_reelle");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_population_reelle);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode camp */

   PU_PUSHNAME (ctxt_p, "camp");

   stat = asn1PD_OID (ctxt_p, &pvalue->camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationKnowledgeCreation: end\n");

   return (stat);
}

int ASN1C_MsgPopulationKnowledgeCreation::Decode ()
{
   return asn1PD_MsgPopulationKnowledgeCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationKnowledgeUpdate                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationKnowledgeUpdate::ASN1C_MsgPopulationKnowledgeUpdate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationKnowledgeUpdate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationKnowledgeUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationKnowledgeUpdate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationKnowledgeUpdate: start\n");

   PU_NEWFIELD (ctxt_p, "etat_dominationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.etat_dominationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_connaissance */

   PU_PUSHNAME (ctxt_p, "oid_connaissance");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode etat_domination */

   if (pvalue->m.etat_dominationPresent) {
      PU_PUSHNAME (ctxt_p, "etat_domination");

      stat = asn1PE_Percentage (ctxt_p, pvalue->etat_domination);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgPopulationKnowledgeUpdate: end\n");
   return (stat);
}

int ASN1C_MsgPopulationKnowledgeUpdate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationKnowledgeUpdate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationKnowledgeUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationKnowledgeUpdate* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgPopulationKnowledgeUpdate: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "etat_dominationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.etat_dominationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_connaissance */

   PU_PUSHNAME (ctxt_p, "oid_connaissance");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode etat_domination */

   if (pvalue->m.etat_dominationPresent) {
      PU_PUSHNAME (ctxt_p, "etat_domination");

      stat = asn1PD_Percentage (ctxt_p, &pvalue->etat_domination);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgPopulationKnowledgeUpdate: end\n");

   return (stat);
}

int ASN1C_MsgPopulationKnowledgeUpdate::Decode ()
{
   return asn1PD_MsgPopulationKnowledgeUpdate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationKnowledgeDestruction                         */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationKnowledgeDestruction::ASN1C_MsgPopulationKnowledgeDestruction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationKnowledgeDestruction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationKnowledgeDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationKnowledgeDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationKnowledgeDestruction: start\n");

   /* encode oid_connaissance */

   PU_PUSHNAME (ctxt_p, "oid_connaissance");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationKnowledgeDestruction: end\n");
   return (stat);
}

int ASN1C_MsgPopulationKnowledgeDestruction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationKnowledgeDestruction (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationKnowledgeDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationKnowledgeDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationKnowledgeDestruction: start\n");

   /* decode oid_connaissance */

   PU_PUSHNAME (ctxt_p, "oid_connaissance");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationKnowledgeDestruction: end\n");

   return (stat);
}

int ASN1C_MsgPopulationKnowledgeDestruction::Decode ()
{
   return asn1PD_MsgPopulationKnowledgeDestruction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationConcentrationKnowledgeCreation               */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationConcentrationKnowledgeCreation::ASN1C_MsgPopulationConcentrationKnowledgeCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationConcentrationKnowledgeCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationConcentrationKnowledgeCreation (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationConcentrationKnowledgeCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationConcentrationKnowledgeCreation: start\n");

   /* encode oid_connaissance_concentration */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_concentration");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_concentration);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_concentration_reelle */

   PU_PUSHNAME (ctxt_p, "oid_concentration_reelle");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_concentration_reelle);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode position */

   PU_PUSHNAME (ctxt_p, "position");

   stat = asn1PE_CoordUTM (ctxt_p, pvalue->position);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationConcentrationKnowledgeCreation: end\n");
   return (stat);
}

int ASN1C_MsgPopulationConcentrationKnowledgeCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationConcentrationKnowledgeCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationConcentrationKnowledgeCreation (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationConcentrationKnowledgeCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationConcentrationKnowledgeCreation: start\n");

   /* decode oid_connaissance_concentration */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_concentration");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_concentration);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_concentration_reelle */

   PU_PUSHNAME (ctxt_p, "oid_concentration_reelle");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_concentration_reelle);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode position */

   PU_PUSHNAME (ctxt_p, "position");

   stat = asn1PD_CoordUTM (ctxt_p, &pvalue->position);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationConcentrationKnowledgeCreation: end\n");

   return (stat);
}

int ASN1C_MsgPopulationConcentrationKnowledgeCreation::Decode ()
{
   return asn1PD_MsgPopulationConcentrationKnowledgeCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationConcentrationKnowledgeUpdate                 */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationConcentrationKnowledgeUpdate::ASN1C_MsgPopulationConcentrationKnowledgeUpdate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationConcentrationKnowledgeUpdate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationConcentrationKnowledgeUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationConcentrationKnowledgeUpdate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationConcentrationKnowledgeUpdate: start\n");

   PU_NEWFIELD (ctxt_p, "oid_concentration_reellePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_concentration_reellePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_humains_vivantsPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nb_humains_vivantsPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_humains_mortsPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nb_humains_mortsPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attitudePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.attitudePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pertinencePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pertinencePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "est_percuPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.est_percuPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_connaissance_concentration */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_concentration");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_concentration);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_concentration_reelle */

   if (pvalue->m.oid_concentration_reellePresent) {
      PU_PUSHNAME (ctxt_p, "oid_concentration_reelle");

      stat = asn1PE_OID (ctxt_p, pvalue->oid_concentration_reelle);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode nb_humains_vivants */

   if (pvalue->m.nb_humains_vivantsPresent) {
      PU_PUSHNAME (ctxt_p, "nb_humains_vivants");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nb_humains_vivants);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode nb_humains_morts */

   if (pvalue->m.nb_humains_mortsPresent) {
      PU_PUSHNAME (ctxt_p, "nb_humains_morts");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nb_humains_morts);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode attitude */

   if (pvalue->m.attitudePresent) {
      PU_PUSHNAME (ctxt_p, "attitude");

      stat = asn1PE_EnumPopulationAttitude (ctxt_p, pvalue->attitude);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode pertinence */

   if (pvalue->m.pertinencePresent) {
      PU_PUSHNAME (ctxt_p, "pertinence");

      stat = asn1PE_Percentage (ctxt_p, pvalue->pertinence);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode est_percu */

   if (pvalue->m.est_percuPresent) {
      PU_PUSHNAME (ctxt_p, "est_percu");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->est_percu);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgPopulationConcentrationKnowledgeUpdate: end\n");
   return (stat);
}

int ASN1C_MsgPopulationConcentrationKnowledgeUpdate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationConcentrationKnowledgeUpdate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationConcentrationKnowledgeUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationConcentrationKnowledgeUpdate* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgPopulationConcentrationKnowledgeUpdate: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "oid_concentration_reellePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_concentration_reellePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_humains_vivantsPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nb_humains_vivantsPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_humains_mortsPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nb_humains_mortsPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attitudePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.attitudePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pertinencePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pertinencePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "est_percuPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.est_percuPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_connaissance_concentration */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_concentration");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_concentration);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_concentration_reelle */

   if (pvalue->m.oid_concentration_reellePresent) {
      PU_PUSHNAME (ctxt_p, "oid_concentration_reelle");

      stat = asn1PD_OID (ctxt_p, &pvalue->oid_concentration_reelle);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode nb_humains_vivants */

   if (pvalue->m.nb_humains_vivantsPresent) {
      PU_PUSHNAME (ctxt_p, "nb_humains_vivants");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nb_humains_vivants);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode nb_humains_morts */

   if (pvalue->m.nb_humains_mortsPresent) {
      PU_PUSHNAME (ctxt_p, "nb_humains_morts");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nb_humains_morts);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode attitude */

   if (pvalue->m.attitudePresent) {
      PU_PUSHNAME (ctxt_p, "attitude");

      stat = asn1PD_EnumPopulationAttitude (ctxt_p, &pvalue->attitude);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pertinence */

   if (pvalue->m.pertinencePresent) {
      PU_PUSHNAME (ctxt_p, "pertinence");

      stat = asn1PD_Percentage (ctxt_p, &pvalue->pertinence);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode est_percu */

   if (pvalue->m.est_percuPresent) {
      PU_PUSHNAME (ctxt_p, "est_percu");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->est_percu);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgPopulationConcentrationKnowledgeUpdate: end\n");

   return (stat);
}

int ASN1C_MsgPopulationConcentrationKnowledgeUpdate::Decode ()
{
   return asn1PD_MsgPopulationConcentrationKnowledgeUpdate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationConcentrationKnowledgeDestruction            */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationConcentrationKnowledgeDestruction::ASN1C_MsgPopulationConcentrationKnowledgeDestruction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationConcentrationKnowledgeDestruction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationConcentrationKnowledgeDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationConcentrationKnowledgeDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationConcentrationKnowledgeDestruction: start\n");

   /* encode oid_connaissance_concentration */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_concentration");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_concentration);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationConcentrationKnowledgeDestruction: end\n");
   return (stat);
}

int ASN1C_MsgPopulationConcentrationKnowledgeDestruction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationConcentrationKnowledgeDestruction (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationConcentrationKnowledgeDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationConcentrationKnowledgeDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationConcentrationKnowledgeDestruction: start\n");

   /* decode oid_connaissance_concentration */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_concentration");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_concentration);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationConcentrationKnowledgeDestruction: end\n");

   return (stat);
}

int ASN1C_MsgPopulationConcentrationKnowledgeDestruction::Decode ()
{
   return asn1PD_MsgPopulationConcentrationKnowledgeDestruction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationFlowKnowledgeCreation                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationFlowKnowledgeCreation::ASN1C_MsgPopulationFlowKnowledgeCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationFlowKnowledgeCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationFlowKnowledgeCreation (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationFlowKnowledgeCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationFlowKnowledgeCreation: start\n");

   /* encode oid_connaissance_flux */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_flux");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_flux);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_flux_reel */

   PU_PUSHNAME (ctxt_p, "oid_flux_reel");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_flux_reel);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationFlowKnowledgeCreation: end\n");
   return (stat);
}

int ASN1C_MsgPopulationFlowKnowledgeCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationFlowKnowledgeCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationFlowKnowledgeCreation (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationFlowKnowledgeCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationFlowKnowledgeCreation: start\n");

   /* decode oid_connaissance_flux */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_flux");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_flux);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_flux_reel */

   PU_PUSHNAME (ctxt_p, "oid_flux_reel");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_flux_reel);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationFlowKnowledgeCreation: end\n");

   return (stat);
}

int ASN1C_MsgPopulationFlowKnowledgeCreation::Decode ()
{
   return asn1PD_MsgPopulationFlowKnowledgeCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  FlowPart                                                  */
/*                                                            */
/**************************************************************/

ASN1C_FlowPart::ASN1C_FlowPart (
   ASN1MessageBuffer& msgBuf, ASN1T_FlowPart& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_FlowPart (ASN1CTXT* ctxt_p, ASN1T_FlowPart* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_FlowPart: start\n");

   /* encode forme */

   PU_PUSHNAME (ctxt_p, "forme");

   stat = asn1PE_Path (ctxt_p, &pvalue->forme);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode pertinence */

   PU_PUSHNAME (ctxt_p, "pertinence");

   stat = asn1PE_Percentage (ctxt_p, pvalue->pertinence);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_FlowPart: end\n");
   return (stat);
}

int ASN1C_FlowPart::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_FlowPart (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_FlowPart (ASN1CTXT* ctxt_p, ASN1T_FlowPart* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_FlowPart: start\n");

   /* decode forme */

   PU_PUSHNAME (ctxt_p, "forme");

   stat = asn1PD_Path (ctxt_p, &pvalue->forme);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode pertinence */

   PU_PUSHNAME (ctxt_p, "pertinence");

   stat = asn1PD_Percentage (ctxt_p, &pvalue->pertinence);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_FlowPart: end\n");

   return (stat);
}

int ASN1C_FlowPart::Decode ()
{
   return asn1PD_FlowPart (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfFlowPart                                            */
/*                                                            */
/**************************************************************/

ASN1C__SeqOfFlowPart::ASN1C__SeqOfFlowPart (
   ASN1MessageBuffer& msgBuf, ASN1T__SeqOfFlowPart& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE__SeqOfFlowPart (ASN1CTXT* ctxt_p, ASN1T__SeqOfFlowPart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE__SeqOfFlowPart: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_FlowPart (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE__SeqOfFlowPart: end\n");
   return (stat);
}

int ASN1C__SeqOfFlowPart::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE__SeqOfFlowPart (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD__SeqOfFlowPart (ASN1CTXT* ctxt_p, ASN1T__SeqOfFlowPart* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD__SeqOfFlowPart: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_FlowPart);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_FlowPart (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD__SeqOfFlowPart: end\n");

   return (stat);
}

int ASN1C__SeqOfFlowPart::Decode ()
{
   return asn1PD__SeqOfFlowPart (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationFlowKnowledgeUpdate                          */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationFlowKnowledgeUpdate::ASN1C_MsgPopulationFlowKnowledgeUpdate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationFlowKnowledgeUpdate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationFlowKnowledgeUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationFlowKnowledgeUpdate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationFlowKnowledgeUpdate: start\n");

   PU_NEWFIELD (ctxt_p, "oid_flux_reelPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_flux_reelPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "portions_fluxPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.portions_fluxPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "directionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.directionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "vitessePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.vitessePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_humains_vivantsPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nb_humains_vivantsPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_humains_mortsPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nb_humains_mortsPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attitudePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.attitudePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "est_percuPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.est_percuPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_connaissance_flux */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_flux");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_flux);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_flux_reel */

   if (pvalue->m.oid_flux_reelPresent) {
      PU_PUSHNAME (ctxt_p, "oid_flux_reel");

      stat = asn1PE_OID (ctxt_p, pvalue->oid_flux_reel);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode portions_flux */

   if (pvalue->m.portions_fluxPresent) {
      PU_PUSHNAME (ctxt_p, "portions_flux");

      stat = asn1PE__SeqOfFlowPart (ctxt_p, &pvalue->portions_flux);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode direction */

   if (pvalue->m.directionPresent) {
      PU_PUSHNAME (ctxt_p, "direction");

      stat = asn1PE_Heading (ctxt_p, pvalue->direction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode vitesse */

   if (pvalue->m.vitessePresent) {
      PU_PUSHNAME (ctxt_p, "vitesse");

      stat = asn1PE_Speed (ctxt_p, pvalue->vitesse);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode nb_humains_vivants */

   if (pvalue->m.nb_humains_vivantsPresent) {
      PU_PUSHNAME (ctxt_p, "nb_humains_vivants");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nb_humains_vivants);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode nb_humains_morts */

   if (pvalue->m.nb_humains_mortsPresent) {
      PU_PUSHNAME (ctxt_p, "nb_humains_morts");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nb_humains_morts);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode attitude */

   if (pvalue->m.attitudePresent) {
      PU_PUSHNAME (ctxt_p, "attitude");

      stat = asn1PE_EnumPopulationAttitude (ctxt_p, pvalue->attitude);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode est_percu */

   if (pvalue->m.est_percuPresent) {
      PU_PUSHNAME (ctxt_p, "est_percu");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->est_percu);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgPopulationFlowKnowledgeUpdate: end\n");
   return (stat);
}

int ASN1C_MsgPopulationFlowKnowledgeUpdate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationFlowKnowledgeUpdate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationFlowKnowledgeUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationFlowKnowledgeUpdate* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgPopulationFlowKnowledgeUpdate: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "oid_flux_reelPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_flux_reelPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "portions_fluxPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.portions_fluxPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "directionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.directionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "vitessePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.vitessePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_humains_vivantsPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nb_humains_vivantsPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_humains_mortsPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nb_humains_mortsPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attitudePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.attitudePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "est_percuPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.est_percuPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_connaissance_flux */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_flux");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_flux);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_flux_reel */

   if (pvalue->m.oid_flux_reelPresent) {
      PU_PUSHNAME (ctxt_p, "oid_flux_reel");

      stat = asn1PD_OID (ctxt_p, &pvalue->oid_flux_reel);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode portions_flux */

   if (pvalue->m.portions_fluxPresent) {
      PU_PUSHNAME (ctxt_p, "portions_flux");

      stat = asn1PD__SeqOfFlowPart (ctxt_p, &pvalue->portions_flux);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode direction */

   if (pvalue->m.directionPresent) {
      PU_PUSHNAME (ctxt_p, "direction");

      stat = asn1PD_Heading (ctxt_p, &pvalue->direction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode vitesse */

   if (pvalue->m.vitessePresent) {
      PU_PUSHNAME (ctxt_p, "vitesse");

      stat = asn1PD_Speed (ctxt_p, &pvalue->vitesse);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode nb_humains_vivants */

   if (pvalue->m.nb_humains_vivantsPresent) {
      PU_PUSHNAME (ctxt_p, "nb_humains_vivants");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nb_humains_vivants);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode nb_humains_morts */

   if (pvalue->m.nb_humains_mortsPresent) {
      PU_PUSHNAME (ctxt_p, "nb_humains_morts");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nb_humains_morts);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode attitude */

   if (pvalue->m.attitudePresent) {
      PU_PUSHNAME (ctxt_p, "attitude");

      stat = asn1PD_EnumPopulationAttitude (ctxt_p, &pvalue->attitude);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode est_percu */

   if (pvalue->m.est_percuPresent) {
      PU_PUSHNAME (ctxt_p, "est_percu");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->est_percu);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgPopulationFlowKnowledgeUpdate: end\n");

   return (stat);
}

int ASN1C_MsgPopulationFlowKnowledgeUpdate::Decode ()
{
   return asn1PD_MsgPopulationFlowKnowledgeUpdate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationFlowKnowledgeDestruction                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationFlowKnowledgeDestruction::ASN1C_MsgPopulationFlowKnowledgeDestruction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationFlowKnowledgeDestruction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationFlowKnowledgeDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationFlowKnowledgeDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationFlowKnowledgeDestruction: start\n");

   /* encode oid_connaissance_flux */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_flux");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_flux);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationFlowKnowledgeDestruction: end\n");
   return (stat);
}

int ASN1C_MsgPopulationFlowKnowledgeDestruction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationFlowKnowledgeDestruction (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationFlowKnowledgeDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationFlowKnowledgeDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationFlowKnowledgeDestruction: start\n");

   /* decode oid_connaissance_flux */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_flux");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_flux);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_connaissance_population */

   PU_PUSHNAME (ctxt_p, "oid_connaissance_population");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_connaissance_population);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_groupe_possesseur */

   PU_PUSHNAME (ctxt_p, "oid_groupe_possesseur");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_groupe_possesseur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationFlowKnowledgeDestruction: end\n");

   return (stat);
}

int ASN1C_MsgPopulationFlowKnowledgeDestruction::Decode ()
{
   return asn1PD_MsgPopulationFlowKnowledgeDestruction (mpContext->GetPtr(), &msgData);
}

