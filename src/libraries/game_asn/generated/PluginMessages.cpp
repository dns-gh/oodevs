/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 24-Dec-2009.
 */
#include "PluginMessages.h"

/**************************************************************/
/*                                                            */
/*  PluginMessagesIncludes                                    */
/*                                                            */
/**************************************************************/

ASN1C_PluginMessagesIncludes::ASN1C_PluginMessagesIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_PluginMessagesIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_PluginMessagesIncludes (ASN1CTXT* ctxt_p, ASN1T_PluginMessagesIncludes* pvalue)
{
   int stat = ASN_OK;

   /* encode pluginExports */

   stat = asn1PE_PluginExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_PluginMessagesIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PluginMessagesIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_PluginMessagesIncludes (ASN1CTXT* ctxt_p, ASN1T_PluginMessagesIncludes* pvalue)
{
   int stat = ASN_OK;

   /* decode pluginExports */

   stat = asn1PD_PluginExports (ctxt_p);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_PluginMessagesIncludes::Decode ()
{
   return asn1PD_PluginMessagesIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  PluginMessagesExports                                     */
/*                                                            */
/**************************************************************/

ASN1C_PluginMessagesExports::ASN1C_PluginMessagesExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_PluginMessagesExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */
   return (stat);
}

int ASN1C_PluginMessagesExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PluginMessagesExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_PluginMessagesExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */

   return (stat);
}

int ASN1C_PluginMessagesExports::Decode ()
{
   return asn1PD_PluginMessagesExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  MsgsPluginToClient_msg                                    */
/*                                                            */
/**************************************************************/

ASN1C_MsgsPluginToClient_msg::ASN1C_MsgsPluginToClient_msg (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsPluginToClient_msg& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsPluginToClient_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsPluginToClient_msg* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 6);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* plugin_text_message */
      case 1:
         stat = asn1PE_MsgPluginTextMessage (ctxt_p, pvalue->u.plugin_text_message);
         if (stat != ASN_OK) return stat;
         break;

      /* plugin_intelligence_creation */
      case 2:
         stat = asn1PE_MsgIntelligenceCreation (ctxt_p, pvalue->u.plugin_intelligence_creation);
         if (stat != ASN_OK) return stat;
         break;

      /* plugin_intelligence_update */
      case 3:
         stat = asn1PE_MsgIntelligenceUpdate (ctxt_p, pvalue->u.plugin_intelligence_update);
         if (stat != ASN_OK) return stat;
         break;

      /* plugin_intelligence_destruction */
      case 4:
         stat = asn1PE_MsgIntelligenceDestruction (ctxt_p, pvalue->u.plugin_intelligence_destruction);
         if (stat != ASN_OK) return stat;
         break;

      /* plugin_limit_creation */
      case 5:
         stat = asn1PE_MsgLimitCreation (ctxt_p, pvalue->u.plugin_limit_creation);
         if (stat != ASN_OK) return stat;
         break;

      /* plugin_limit_update */
      case 6:
         stat = asn1PE_MsgLimitUpdate (ctxt_p, pvalue->u.plugin_limit_update);
         if (stat != ASN_OK) return stat;
         break;

      /* plugin_limit_destruction */
      case 7:
         stat = asn1PE_MsgLimitDestruction (ctxt_p, pvalue->u.plugin_limit_destruction);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MsgsPluginToClient_msg::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsPluginToClient_msg (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsPluginToClient_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsPluginToClient_msg* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 6);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* plugin_text_message */
      case 0:
         pvalue->u.plugin_text_message = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgPluginTextMessage);

         stat = asn1PD_MsgPluginTextMessage (ctxt_p, pvalue->u.plugin_text_message);
         if (stat != ASN_OK) return stat;

         break;

      /* plugin_intelligence_creation */
      case 1:
         pvalue->u.plugin_intelligence_creation = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgIntelligenceCreation);

         stat = asn1PD_MsgIntelligenceCreation (ctxt_p, pvalue->u.plugin_intelligence_creation);
         if (stat != ASN_OK) return stat;

         break;

      /* plugin_intelligence_update */
      case 2:
         pvalue->u.plugin_intelligence_update = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgIntelligenceUpdate);

         stat = asn1PD_MsgIntelligenceUpdate (ctxt_p, pvalue->u.plugin_intelligence_update);
         if (stat != ASN_OK) return stat;

         break;

      /* plugin_intelligence_destruction */
      case 3:
         pvalue->u.plugin_intelligence_destruction = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgIntelligenceDestruction);

         stat = asn1PD_MsgIntelligenceDestruction (ctxt_p, pvalue->u.plugin_intelligence_destruction);
         if (stat != ASN_OK) return stat;

         break;

      /* plugin_limit_creation */
      case 4:
         pvalue->u.plugin_limit_creation = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgLimitCreation);

         stat = asn1PD_MsgLimitCreation (ctxt_p, pvalue->u.plugin_limit_creation);
         if (stat != ASN_OK) return stat;

         break;

      /* plugin_limit_update */
      case 5:
         pvalue->u.plugin_limit_update = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgLimitUpdate);

         stat = asn1PD_MsgLimitUpdate (ctxt_p, pvalue->u.plugin_limit_update);
         if (stat != ASN_OK) return stat;

         break;

      /* plugin_limit_destruction */
      case 6:
         stat = asn1PD_MsgLimitDestruction (ctxt_p, &pvalue->u.plugin_limit_destruction);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MsgsPluginToClient_msg::Decode ()
{
   return asn1PD_MsgsPluginToClient_msg (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsPluginToClient                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgsPluginToClient::ASN1C_MsgsPluginToClient (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsPluginToClient& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsPluginToClient (ASN1CTXT* ctxt_p, ASN1T_MsgsPluginToClient* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->context != 0));

   /* encode context */

   if (pvalue->context != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->context);
      if (stat != ASN_OK) return stat;
   }

   /* encode msg */

   stat = asn1PE_MsgsPluginToClient_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgsPluginToClient::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsPluginToClient (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsPluginToClient (ASN1CTXT* ctxt_p, ASN1T_MsgsPluginToClient* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL contextPresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   contextPresent = optbit;

   /* decode context */

   if (contextPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->context);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->context = 0;
   }

   /* decode msg */

   stat = asn1PD_MsgsPluginToClient_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgsPluginToClient::Decode ()
{
   return asn1PD_MsgsPluginToClient (mpContext->GetPtr(), &msgData);
}

