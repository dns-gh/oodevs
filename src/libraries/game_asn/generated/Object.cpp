/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 13-Jul-2007.
 */
#include "Object.h"

/**************************************************************/
/*                                                            */
/*  ObjectIncludes                                            */
/*                                                            */
/**************************************************************/

ASN1C_ObjectIncludes::ASN1C_ObjectIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectIncludes (ASN1CTXT* ctxt_p, ASN1T_ObjectIncludes* pvalue)
{
   int stat = ASN_OK;

   /* encode baseExports */

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ObjectIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectIncludes (ASN1CTXT* ctxt_p, ASN1T_ObjectIncludes* pvalue)
{
   int stat = ASN_OK;

   /* decode baseExports */

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ObjectIncludes::Decode ()
{
   return asn1PD_ObjectIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectExports                                             */
/*                                                            */
/**************************************************************/

ASN1C_ObjectExports::ASN1C_ObjectExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_ObjectExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */
   return (stat);
}

int ASN1C_ObjectExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_ObjectExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */

   return (stat);
}

int ASN1C_ObjectExports::Decode ()
{
   return asn1PD_ObjectExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  EnumObstacleType                                          */
/*                                                            */
/**************************************************************/

ASN1C_EnumObstacleType::ASN1C_EnumObstacleType (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumObstacleType& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumObstacleType (ASN1CTXT* ctxt_p, ASN1T_EnumObstacleType value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   switch (value) {
      case EnumObstacleType::initial: ui = 0; break;
      case EnumObstacleType::reserved: ui = 1; break;
      default: return ASN_E_INVENUM;
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 1);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_EnumObstacleType::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumObstacleType (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumObstacleType (ASN1CTXT* ctxt_p, ASN1T_EnumObstacleType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return stat;

   switch (ui) {
      case 0: *pvalue = EnumObstacleType::initial; break;
      case 1: *pvalue = EnumObstacleType::reserved; break;
      default: return ASN_E_INVENUM;
   }

   return (stat);
}

int ASN1C_EnumObstacleType::Decode ()
{
   return asn1PD_EnumObstacleType (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumObjectType                                            */
/*                                                            */
/**************************************************************/

ASN1C_EnumObjectType::ASN1C_EnumObjectType (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumObjectType& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumObjectType (ASN1CTXT* ctxt_p, ASN1T_EnumObjectType value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   switch (value) {
      case EnumObjectType::bouchon_mines: ui = 0; break;
      case EnumObjectType::zone_minee_lineaire: ui = 1; break;
      case EnumObjectType::zone_minee_par_dispersion: ui = 2; break;
      case EnumObjectType::fosse_anti_char: ui = 3; break;
      case EnumObjectType::abattis: ui = 4; break;
      case EnumObjectType::barricade: ui = 5; break;
      case EnumObjectType::eboulement: ui = 6; break;
      case EnumObjectType::destruction_route: ui = 7; break;
      case EnumObjectType::destruction_pont: ui = 8; break;
      case EnumObjectType::pont_flottant_continu: ui = 9; break;
      case EnumObjectType::poste_tir: ui = 10; break;
      case EnumObjectType::zone_protegee: ui = 11; break;
      case EnumObjectType::zone_implantation_canon: ui = 12; break;
      case EnumObjectType::zone_implantation_cobra: ui = 13; break;
      case EnumObjectType::zone_implantation_lrm: ui = 14; break;
      case EnumObjectType::site_franchissement: ui = 15; break;
      case EnumObjectType::nuage_nbc: ui = 16; break;
      case EnumObjectType::plot_ravitaillement: ui = 17; break;
      case EnumObjectType::site_decontamination: ui = 18; break;
      case EnumObjectType::zone_brouillage_brod: ui = 19; break;
      case EnumObjectType::rota: ui = 20; break;
      case EnumObjectType::zone_nbc: ui = 21; break;
      case EnumObjectType::zone_brouillage_bromure: ui = 22; break;
      case EnumObjectType::aire_poser: ui = 23; break;
      case EnumObjectType::piste: ui = 24; break;
      case EnumObjectType::plateforme: ui = 25; break;
      case EnumObjectType::zone_mobilite_amelioree: ui = 26; break;
      case EnumObjectType::zone_poser_helicoptere: ui = 27; break;
      case EnumObjectType::aire_logistique: ui = 28; break;
      case EnumObjectType::itineraire_logistique: ui = 29; break;
      case EnumObjectType::camp_prisonniers: ui = 30; break;
      case EnumObjectType::camp_refugies: ui = 31; break;
      case EnumObjectType::poste_controle: ui = 32; break;
      case EnumObjectType::terrain_largage: ui = 33; break;
      case EnumObjectType::zone_interdite_mouvement: ui = 34; break;
      case EnumObjectType::zone_interdite_tir: ui = 35; break;
      case EnumObjectType::zone_implantation_mortier: ui = 36; break;
      case EnumObjectType::pont_flottant_discontinu: ui = 37; break;
      case EnumObjectType::installation: ui = 38; break;
      default: return ASN_E_INVENUM;
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 38);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_EnumObjectType::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumObjectType (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumObjectType (ASN1CTXT* ctxt_p, ASN1T_EnumObjectType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 38);
   if (stat != ASN_OK) return stat;

   switch (ui) {
      case 0: *pvalue = EnumObjectType::bouchon_mines; break;
      case 1: *pvalue = EnumObjectType::zone_minee_lineaire; break;
      case 2: *pvalue = EnumObjectType::zone_minee_par_dispersion; break;
      case 3: *pvalue = EnumObjectType::fosse_anti_char; break;
      case 4: *pvalue = EnumObjectType::abattis; break;
      case 5: *pvalue = EnumObjectType::barricade; break;
      case 6: *pvalue = EnumObjectType::eboulement; break;
      case 7: *pvalue = EnumObjectType::destruction_route; break;
      case 8: *pvalue = EnumObjectType::destruction_pont; break;
      case 9: *pvalue = EnumObjectType::pont_flottant_continu; break;
      case 10: *pvalue = EnumObjectType::poste_tir; break;
      case 11: *pvalue = EnumObjectType::zone_protegee; break;
      case 12: *pvalue = EnumObjectType::zone_implantation_canon; break;
      case 13: *pvalue = EnumObjectType::zone_implantation_cobra; break;
      case 14: *pvalue = EnumObjectType::zone_implantation_lrm; break;
      case 15: *pvalue = EnumObjectType::site_franchissement; break;
      case 16: *pvalue = EnumObjectType::nuage_nbc; break;
      case 17: *pvalue = EnumObjectType::plot_ravitaillement; break;
      case 18: *pvalue = EnumObjectType::site_decontamination; break;
      case 19: *pvalue = EnumObjectType::zone_brouillage_brod; break;
      case 20: *pvalue = EnumObjectType::rota; break;
      case 21: *pvalue = EnumObjectType::zone_nbc; break;
      case 22: *pvalue = EnumObjectType::zone_brouillage_bromure; break;
      case 23: *pvalue = EnumObjectType::aire_poser; break;
      case 24: *pvalue = EnumObjectType::piste; break;
      case 25: *pvalue = EnumObjectType::plateforme; break;
      case 26: *pvalue = EnumObjectType::zone_mobilite_amelioree; break;
      case 27: *pvalue = EnumObjectType::zone_poser_helicoptere; break;
      case 28: *pvalue = EnumObjectType::aire_logistique; break;
      case 29: *pvalue = EnumObjectType::itineraire_logistique; break;
      case 30: *pvalue = EnumObjectType::camp_prisonniers; break;
      case 31: *pvalue = EnumObjectType::camp_refugies; break;
      case 32: *pvalue = EnumObjectType::poste_controle; break;
      case 33: *pvalue = EnumObjectType::terrain_largage; break;
      case 34: *pvalue = EnumObjectType::zone_interdite_mouvement; break;
      case 35: *pvalue = EnumObjectType::zone_interdite_tir; break;
      case 36: *pvalue = EnumObjectType::zone_implantation_mortier; break;
      case 37: *pvalue = EnumObjectType::pont_flottant_discontinu; break;
      case 38: *pvalue = EnumObjectType::installation; break;
      default: return ASN_E_INVENUM;
   }

   return (stat);
}

int ASN1C_EnumObjectType::Decode ()
{
   return asn1PD_EnumObjectType (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumObjectErrorCode                                       */
/*                                                            */
/**************************************************************/

ASN1C_EnumObjectErrorCode::ASN1C_EnumObjectErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumObjectErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumObjectErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumObjectErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   switch (value) {
      case EnumObjectErrorCode::no_error: ui = 0; break;
      case EnumObjectErrorCode::error_invalid_object: ui = 1; break;
      case EnumObjectErrorCode::error_invalid_id: ui = 2; break;
      case EnumObjectErrorCode::error_invalid_camp: ui = 3; break;
      case EnumObjectErrorCode::error_invalid_localisation: ui = 4; break;
      case EnumObjectErrorCode::error_missing_specific_attributes: ui = 5; break;
      case EnumObjectErrorCode::error_invalid_specific_attributes: ui = 6; break;
      default: return ASN_E_INVENUM;
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 6);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_EnumObjectErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumObjectErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumObjectErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumObjectErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 6);
   if (stat != ASN_OK) return stat;

   switch (ui) {
      case 0: *pvalue = EnumObjectErrorCode::no_error; break;
      case 1: *pvalue = EnumObjectErrorCode::error_invalid_object; break;
      case 2: *pvalue = EnumObjectErrorCode::error_invalid_id; break;
      case 3: *pvalue = EnumObjectErrorCode::error_invalid_camp; break;
      case 4: *pvalue = EnumObjectErrorCode::error_invalid_localisation; break;
      case 5: *pvalue = EnumObjectErrorCode::error_missing_specific_attributes; break;
      case 6: *pvalue = EnumObjectErrorCode::error_invalid_specific_attributes; break;
      default: return ASN_E_INVENUM;
   }

   return (stat);
}

int ASN1C_EnumObjectErrorCode::Decode ()
{
   return asn1PD_EnumObjectErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesCrossingSite                              */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesCrossingSite::ASN1C_ObjectAttributesCrossingSite (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesCrossingSite& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesCrossingSite (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesCrossingSite* pvalue)
{
   int stat = ASN_OK;

   /* encode width */

   stat = pe_UnconsInteger (ctxt_p, pvalue->width);
   if (stat != ASN_OK) return stat;

   /* encode depth */

   stat = pe_UnconsInteger (ctxt_p, pvalue->depth);
   if (stat != ASN_OK) return stat;

   /* encode flow_rate */

   stat = pe_UnconsInteger (ctxt_p, pvalue->flow_rate);
   if (stat != ASN_OK) return stat;

   /* encode banks_require_fitting */

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->banks_require_fitting);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ObjectAttributesCrossingSite::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesCrossingSite (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesCrossingSite (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesCrossingSite* pvalue)
{
   int stat = ASN_OK;

   /* decode width */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->width);
   if (stat != ASN_OK) return stat;

   /* decode depth */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->depth);
   if (stat != ASN_OK) return stat;

   /* decode flow_rate */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->flow_rate);
   if (stat != ASN_OK) return stat;

   /* decode banks_require_fitting */

   stat = pd_bit (ctxt_p, &pvalue->banks_require_fitting);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ObjectAttributesCrossingSite::Decode ()
{
   return asn1PD_ObjectAttributesCrossingSite (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesNbcCloud                                  */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesNbcCloud::ASN1C_ObjectAttributesNbcCloud (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesNbcCloud& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesNbcCloud (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesNbcCloud* pvalue)
{
   int stat = ASN_OK;

   /* encode nbc_agent */

   stat = asn1PE_OID (ctxt_p, pvalue->nbc_agent);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ObjectAttributesNbcCloud::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesNbcCloud (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesNbcCloud (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesNbcCloud* pvalue)
{
   int stat = ASN_OK;

   /* decode nbc_agent */

   stat = asn1PD_OID (ctxt_p, &pvalue->nbc_agent);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ObjectAttributesNbcCloud::Decode ()
{
   return asn1PD_ObjectAttributesNbcCloud (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesNbcZone                                   */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesNbcZone::ASN1C_ObjectAttributesNbcZone (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesNbcZone& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesNbcZone (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesNbcZone* pvalue)
{
   int stat = ASN_OK;

   /* encode nbc_agent */

   stat = asn1PE_OID (ctxt_p, pvalue->nbc_agent);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ObjectAttributesNbcZone::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesNbcZone (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesNbcZone (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesNbcZone* pvalue)
{
   int stat = ASN_OK;

   /* decode nbc_agent */

   stat = asn1PD_OID (ctxt_p, &pvalue->nbc_agent);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ObjectAttributesNbcZone::Decode ()
{
   return asn1PD_ObjectAttributesNbcZone (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesRota                                      */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesRota::ASN1C_ObjectAttributesRota (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesRota& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesRota (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesRota* pvalue)
{
   int stat = ASN_OK;

   /* encode danger_level */

   stat = pe_ConsInteger (ctxt_p, pvalue->danger_level, 0, 10);
   if (stat != ASN_OK) return stat;


   /* encode nbc_agents */

   stat = asn1PE_ListOID (ctxt_p, &pvalue->nbc_agents);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ObjectAttributesRota::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesRota (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesRota (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesRota* pvalue)
{
   int stat = ASN_OK;

   /* decode danger_level */

   stat = pd_ConsInteger (ctxt_p, &pvalue->danger_level, 0, 10);
   if (stat != ASN_OK) return stat;

   /* decode nbc_agents */

   stat = asn1PD_ListOID (ctxt_p, &pvalue->nbc_agents);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ObjectAttributesRota::Decode ()
{
   return asn1PD_ObjectAttributesRota (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesLogisticRoute                             */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesLogisticRoute::ASN1C_ObjectAttributesLogisticRoute (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesLogisticRoute& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesLogisticRoute (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesLogisticRoute* pvalue)
{
   int stat = ASN_OK;

   /* encode equipped */

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->equipped);
   if (stat != ASN_OK) return stat;

   /* encode max_weight */

   stat = pe_UnconsInteger (ctxt_p, pvalue->max_weight);
   if (stat != ASN_OK) return stat;

   /* encode width */

   stat = pe_UnconsInteger (ctxt_p, pvalue->width);
   if (stat != ASN_OK) return stat;

   /* encode length */

   stat = pe_UnconsInteger (ctxt_p, pvalue->length);
   if (stat != ASN_OK) return stat;

   /* encode flow_rate */

   stat = pe_UnconsInteger (ctxt_p, pvalue->flow_rate);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ObjectAttributesLogisticRoute::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesLogisticRoute (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesLogisticRoute (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesLogisticRoute* pvalue)
{
   int stat = ASN_OK;

   /* decode equipped */

   stat = pd_bit (ctxt_p, &pvalue->equipped);
   if (stat != ASN_OK) return stat;

   /* decode max_weight */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->max_weight);
   if (stat != ASN_OK) return stat;

   /* decode width */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->width);
   if (stat != ASN_OK) return stat;

   /* decode length */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->length);
   if (stat != ASN_OK) return stat;

   /* decode flow_rate */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->flow_rate);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ObjectAttributesLogisticRoute::Decode ()
{
   return asn1PD_ObjectAttributesLogisticRoute (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesPrisonerCamp                              */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesPrisonerCamp::ASN1C_ObjectAttributesPrisonerCamp (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesPrisonerCamp& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesPrisonerCamp (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesPrisonerCamp* pvalue)
{
   int stat = ASN_OK;

   /* encode tc2 */

   stat = asn1PE_Automat (ctxt_p, pvalue->tc2);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ObjectAttributesPrisonerCamp::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesPrisonerCamp (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesPrisonerCamp (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesPrisonerCamp* pvalue)
{
   int stat = ASN_OK;

   /* decode tc2 */

   stat = asn1PD_Automat (ctxt_p, &pvalue->tc2);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ObjectAttributesPrisonerCamp::Decode ()
{
   return asn1PD_ObjectAttributesPrisonerCamp (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesRefugeeCamp                               */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesRefugeeCamp::ASN1C_ObjectAttributesRefugeeCamp (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesRefugeeCamp& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesRefugeeCamp (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesRefugeeCamp* pvalue)
{
   int stat = ASN_OK;

   /* encode tc2 */

   stat = asn1PE_Automat (ctxt_p, pvalue->tc2);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ObjectAttributesRefugeeCamp::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesRefugeeCamp (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesRefugeeCamp (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesRefugeeCamp* pvalue)
{
   int stat = ASN_OK;

   /* decode tc2 */

   stat = asn1PD_Automat (ctxt_p, &pvalue->tc2);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ObjectAttributesRefugeeCamp::Decode ()
{
   return asn1PD_ObjectAttributesRefugeeCamp (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesLinearMineArea                            */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesLinearMineArea::ASN1C_ObjectAttributesLinearMineArea (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesLinearMineArea& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesLinearMineArea (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesLinearMineArea* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->density != 0));

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->activity_time != 0));

   /* encode density */

   if (pvalue->density != 0) {
      stat = pe_Real (ctxt_p, pvalue->density);if (stat != ASN_OK) return stat;
   }

   /* encode activity_time */

   if (pvalue->activity_time != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->activity_time);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_ObjectAttributesLinearMineArea::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesLinearMineArea (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesLinearMineArea (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesLinearMineArea* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL densityPresent;
   ASN1BOOL activity_timePresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   densityPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   activity_timePresent = optbit;

   /* decode density */

   if (densityPresent) {
      stat = pd_Real (ctxt_p, &pvalue->density);if (stat != ASN_OK) return stat;
   }
   else {
   }

   /* decode activity_time */

   if (activity_timePresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->activity_time);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->activity_time = 0;
   }


   return (stat);
}

int ASN1C_ObjectAttributesLinearMineArea::Decode ()
{
   return asn1PD_ObjectAttributesLinearMineArea (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesDispersedMineArea                         */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesDispersedMineArea::ASN1C_ObjectAttributesDispersedMineArea (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesDispersedMineArea& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesDispersedMineArea (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesDispersedMineArea* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->density != 0));

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->activity_time != 0));

   /* encode density */

   if (pvalue->density != 0) {
      stat = pe_Real (ctxt_p, pvalue->density);if (stat != ASN_OK) return stat;
   }

   /* encode activity_time */

   if (pvalue->activity_time != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->activity_time);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_ObjectAttributesDispersedMineArea::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesDispersedMineArea (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesDispersedMineArea (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesDispersedMineArea* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL densityPresent;
   ASN1BOOL activity_timePresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   densityPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   activity_timePresent = optbit;

   /* decode density */

   if (densityPresent) {
      stat = pd_Real (ctxt_p, &pvalue->density);if (stat != ASN_OK) return stat;
   }
   else {
   }

   /* decode activity_time */

   if (activity_timePresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->activity_time);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->activity_time = 0;
   }


   return (stat);
}

int ASN1C_ObjectAttributesDispersedMineArea::Decode ()
{
   return asn1PD_ObjectAttributesDispersedMineArea (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesMineJam                                   */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesMineJam::ASN1C_ObjectAttributesMineJam (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesMineJam& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesMineJam (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesMineJam* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->activity_time != 0));

   /* encode activity_time */

   if (pvalue->activity_time != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->activity_time);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_ObjectAttributesMineJam::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesMineJam (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesMineJam (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesMineJam* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL activity_timePresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   activity_timePresent = optbit;

   /* decode activity_time */

   if (activity_timePresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->activity_time);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->activity_time = 0;
   }


   return (stat);
}

int ASN1C_ObjectAttributesMineJam::Decode ()
{
   return asn1PD_ObjectAttributesMineJam (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesSpecific                                  */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesSpecific::ASN1C_ObjectAttributesSpecific (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesSpecific& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesSpecific (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesSpecific* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 9);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* crossing_site */
      case 1:
         stat = asn1PE_ObjectAttributesCrossingSite (ctxt_p, pvalue->u.crossing_site);
         if (stat != ASN_OK) return stat;
         break;

      /* nbc_cloud */
      case 2:
         stat = asn1PE_ObjectAttributesNbcCloud (ctxt_p, pvalue->u.nbc_cloud);
         if (stat != ASN_OK) return stat;
         break;

      /* rota */
      case 3:
         stat = asn1PE_ObjectAttributesRota (ctxt_p, pvalue->u.rota);
         if (stat != ASN_OK) return stat;
         break;

      /* nbc_zone */
      case 4:
         stat = asn1PE_ObjectAttributesNbcZone (ctxt_p, pvalue->u.nbc_zone);
         if (stat != ASN_OK) return stat;
         break;

      /* logistic_route */
      case 5:
         stat = asn1PE_ObjectAttributesLogisticRoute (ctxt_p, pvalue->u.logistic_route);
         if (stat != ASN_OK) return stat;
         break;

      /* prisoner_camp */
      case 6:
         stat = asn1PE_ObjectAttributesPrisonerCamp (ctxt_p, pvalue->u.prisoner_camp);
         if (stat != ASN_OK) return stat;
         break;

      /* refugee_camp */
      case 7:
         stat = asn1PE_ObjectAttributesRefugeeCamp (ctxt_p, pvalue->u.refugee_camp);
         if (stat != ASN_OK) return stat;
         break;

      /* linear_mine_area */
      case 8:
         stat = asn1PE_ObjectAttributesLinearMineArea (ctxt_p, pvalue->u.linear_mine_area);
         if (stat != ASN_OK) return stat;
         break;

      /* dispersed_mine_area */
      case 9:
         stat = asn1PE_ObjectAttributesDispersedMineArea (ctxt_p, pvalue->u.dispersed_mine_area);
         if (stat != ASN_OK) return stat;
         break;

      /* mine_jam */
      case 10:
         stat = asn1PE_ObjectAttributesMineJam (ctxt_p, pvalue->u.mine_jam);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_ObjectAttributesSpecific::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesSpecific (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesSpecific (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesSpecific* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 9);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* crossing_site */
      case 0:
         pvalue->u.crossing_site = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesCrossingSite);

         stat = asn1PD_ObjectAttributesCrossingSite (ctxt_p, pvalue->u.crossing_site);
         if (stat != ASN_OK) return stat;

         break;

      /* nbc_cloud */
      case 1:
         pvalue->u.nbc_cloud = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesNbcCloud);

         stat = asn1PD_ObjectAttributesNbcCloud (ctxt_p, pvalue->u.nbc_cloud);
         if (stat != ASN_OK) return stat;

         break;

      /* rota */
      case 2:
         pvalue->u.rota = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesRota);

         stat = asn1PD_ObjectAttributesRota (ctxt_p, pvalue->u.rota);
         if (stat != ASN_OK) return stat;

         break;

      /* nbc_zone */
      case 3:
         pvalue->u.nbc_zone = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesNbcZone);

         stat = asn1PD_ObjectAttributesNbcZone (ctxt_p, pvalue->u.nbc_zone);
         if (stat != ASN_OK) return stat;

         break;

      /* logistic_route */
      case 4:
         pvalue->u.logistic_route = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesLogisticRoute);

         stat = asn1PD_ObjectAttributesLogisticRoute (ctxt_p, pvalue->u.logistic_route);
         if (stat != ASN_OK) return stat;

         break;

      /* prisoner_camp */
      case 5:
         pvalue->u.prisoner_camp = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesPrisonerCamp);

         stat = asn1PD_ObjectAttributesPrisonerCamp (ctxt_p, pvalue->u.prisoner_camp);
         if (stat != ASN_OK) return stat;

         break;

      /* refugee_camp */
      case 6:
         pvalue->u.refugee_camp = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesRefugeeCamp);

         stat = asn1PD_ObjectAttributesRefugeeCamp (ctxt_p, pvalue->u.refugee_camp);
         if (stat != ASN_OK) return stat;

         break;

      /* linear_mine_area */
      case 7:
         pvalue->u.linear_mine_area = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesLinearMineArea);

         stat = asn1PD_ObjectAttributesLinearMineArea (ctxt_p, pvalue->u.linear_mine_area);
         if (stat != ASN_OK) return stat;

         break;

      /* dispersed_mine_area */
      case 8:
         pvalue->u.dispersed_mine_area = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesDispersedMineArea);

         stat = asn1PD_ObjectAttributesDispersedMineArea (ctxt_p, pvalue->u.dispersed_mine_area);
         if (stat != ASN_OK) return stat;

         break;

      /* mine_jam */
      case 9:
         pvalue->u.mine_jam = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesMineJam);

         stat = asn1PD_ObjectAttributesMineJam (ctxt_p, pvalue->u.mine_jam);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_ObjectAttributesSpecific::Decode ()
{
   return asn1PD_ObjectAttributesSpecific (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectCreation                                         */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectCreation::ASN1C_MsgObjectCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectCreation (ASN1CTXT* ctxt_p, ASN1T_MsgObjectCreation* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.obstacle_typePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.reserved_obstacle_activatedPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.specific_attributesPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.construction_dotation_typePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.mining_dotation_typePresent);

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode type */

   stat = asn1PE_EnumObjectType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return stat;

   /* encode obstacle_type */

   if (pvalue->m.obstacle_typePresent) {
      stat = asn1PE_EnumObstacleType (ctxt_p, pvalue->obstacle_type);
      if (stat != ASN_OK) return stat;
   }

   /* encode reserved_obstacle_activated */

   if (pvalue->m.reserved_obstacle_activatedPresent) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->reserved_obstacle_activated);
      if (stat != ASN_OK) return stat;
   }

   /* encode location */

   stat = asn1PE_Location (ctxt_p, &pvalue->location);
   if (stat != ASN_OK) return stat;

   /* encode name */

   stat = pe_VisibleString (ctxt_p, pvalue->name, 0);
   if (stat != ASN_OK) return stat;

   /* encode team */

   stat = asn1PE_Team (ctxt_p, pvalue->team);
   if (stat != ASN_OK) return stat;

   /* encode specific_attributes */

   if (pvalue->m.specific_attributesPresent) {
      stat = asn1PE_ObjectAttributesSpecific (ctxt_p, &pvalue->specific_attributes);
      if (stat != ASN_OK) return stat;
   }

   /* encode construction_dotation_type */

   if (pvalue->m.construction_dotation_typePresent) {
      stat = asn1PE_DotationType (ctxt_p, pvalue->construction_dotation_type);
      if (stat != ASN_OK) return stat;
   }

   /* encode mining_dotation_type */

   if (pvalue->m.mining_dotation_typePresent) {
      stat = asn1PE_DotationType (ctxt_p, pvalue->mining_dotation_type);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_MsgObjectCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectCreation (ASN1CTXT* ctxt_p, ASN1T_MsgObjectCreation* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pd_bit (ctxt_p, &optbit);
   pvalue->m.obstacle_typePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.reserved_obstacle_activatedPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.specific_attributesPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.construction_dotation_typePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.mining_dotation_typePresent = optbit;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode type */

   stat = asn1PD_EnumObjectType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return stat;

   /* decode obstacle_type */

   if (pvalue->m.obstacle_typePresent) {
      stat = asn1PD_EnumObstacleType (ctxt_p, &pvalue->obstacle_type);
      if (stat != ASN_OK) return stat;
   }

   /* decode reserved_obstacle_activated */

   if (pvalue->m.reserved_obstacle_activatedPresent) {
      stat = pd_bit (ctxt_p, &pvalue->reserved_obstacle_activated);
      if (stat != ASN_OK) return stat;
   }

   /* decode location */

   stat = asn1PD_Location (ctxt_p, &pvalue->location);
   if (stat != ASN_OK) return stat;

   /* decode name */

   stat = pd_VisibleString (ctxt_p, &pvalue->name, 0);
   if (stat != ASN_OK) return stat;

   /* decode team */

   stat = asn1PD_Team (ctxt_p, &pvalue->team);
   if (stat != ASN_OK) return stat;

   /* decode specific_attributes */

   if (pvalue->m.specific_attributesPresent) {
      stat = asn1PD_ObjectAttributesSpecific (ctxt_p, &pvalue->specific_attributes);
      if (stat != ASN_OK) return stat;
   }

   /* decode construction_dotation_type */

   if (pvalue->m.construction_dotation_typePresent) {
      stat = asn1PD_DotationType (ctxt_p, &pvalue->construction_dotation_type);
      if (stat != ASN_OK) return stat;
   }

   /* decode mining_dotation_type */

   if (pvalue->m.mining_dotation_typePresent) {
      stat = asn1PD_DotationType (ctxt_p, &pvalue->mining_dotation_type);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_MsgObjectCreation::Decode ()
{
   return asn1PD_MsgObjectCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectUpdate                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectUpdate::ASN1C_MsgObjectUpdate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectUpdate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgObjectUpdate* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.construction_percentagePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.mining_percentagePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.bypass_construction_percentagePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.reserved_obstacle_activatedPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.construction_dotation_nbrPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.mining_dotation_nbrPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.locationPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.specific_attributesPresent);

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode construction_percentage */

   if (pvalue->m.construction_percentagePresent) {
      stat = pe_ConsInteger (ctxt_p, pvalue->construction_percentage, 0, 100);
      if (stat != ASN_OK) return stat;

   }

   /* encode mining_percentage */

   if (pvalue->m.mining_percentagePresent) {
      stat = pe_ConsInteger (ctxt_p, pvalue->mining_percentage, 0, 100);
      if (stat != ASN_OK) return stat;

   }

   /* encode bypass_construction_percentage */

   if (pvalue->m.bypass_construction_percentagePresent) {
      stat = pe_ConsInteger (ctxt_p, pvalue->bypass_construction_percentage, 0, 100);
      if (stat != ASN_OK) return stat;

   }

   /* encode reserved_obstacle_activated */

   if (pvalue->m.reserved_obstacle_activatedPresent) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->reserved_obstacle_activated);
      if (stat != ASN_OK) return stat;
   }

   /* encode construction_dotation_nbr */

   if (pvalue->m.construction_dotation_nbrPresent) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->construction_dotation_nbr);
      if (stat != ASN_OK) return stat;
   }

   /* encode mining_dotation_nbr */

   if (pvalue->m.mining_dotation_nbrPresent) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->mining_dotation_nbr);
      if (stat != ASN_OK) return stat;
   }

   /* encode location */

   if (pvalue->m.locationPresent) {
      stat = asn1PE_Location (ctxt_p, &pvalue->location);
      if (stat != ASN_OK) return stat;
   }

   /* encode specific_attributes */

   if (pvalue->m.specific_attributesPresent) {
      stat = asn1PE_ObjectAttributesSpecific (ctxt_p, &pvalue->specific_attributes);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_MsgObjectUpdate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectUpdate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgObjectUpdate* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pd_bit (ctxt_p, &optbit);
   pvalue->m.construction_percentagePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.mining_percentagePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.bypass_construction_percentagePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.reserved_obstacle_activatedPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.construction_dotation_nbrPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.mining_dotation_nbrPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.locationPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.specific_attributesPresent = optbit;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode construction_percentage */

   if (pvalue->m.construction_percentagePresent) {
      stat = pd_ConsInteger (ctxt_p, &pvalue->construction_percentage, 0, 100);
      if (stat != ASN_OK) return stat;
   }

   /* decode mining_percentage */

   if (pvalue->m.mining_percentagePresent) {
      stat = pd_ConsInteger (ctxt_p, &pvalue->mining_percentage, 0, 100);
      if (stat != ASN_OK) return stat;
   }

   /* decode bypass_construction_percentage */

   if (pvalue->m.bypass_construction_percentagePresent) {
      stat = pd_ConsInteger (ctxt_p, &pvalue->bypass_construction_percentage, 0, 100);
      if (stat != ASN_OK) return stat;
   }

   /* decode reserved_obstacle_activated */

   if (pvalue->m.reserved_obstacle_activatedPresent) {
      stat = pd_bit (ctxt_p, &pvalue->reserved_obstacle_activated);
      if (stat != ASN_OK) return stat;
   }

   /* decode construction_dotation_nbr */

   if (pvalue->m.construction_dotation_nbrPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->construction_dotation_nbr);
      if (stat != ASN_OK) return stat;
   }

   /* decode mining_dotation_nbr */

   if (pvalue->m.mining_dotation_nbrPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->mining_dotation_nbr);
      if (stat != ASN_OK) return stat;
   }

   /* decode location */

   if (pvalue->m.locationPresent) {
      stat = asn1PD_Location (ctxt_p, &pvalue->location);
      if (stat != ASN_OK) return stat;
   }

   /* decode specific_attributes */

   if (pvalue->m.specific_attributesPresent) {
      stat = asn1PD_ObjectAttributesSpecific (ctxt_p, &pvalue->specific_attributes);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_MsgObjectUpdate::Decode ()
{
   return asn1PD_MsgObjectUpdate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectDestruction                                      */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectDestruction::ASN1C_MsgObjectDestruction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectDestruction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectDestruction value)
{
   int stat = ASN_OK;

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_MsgObjectDestruction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectDestruction (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectDestruction* pvalue)
{
   int stat = ASN_OK;

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgObjectDestruction::Decode ()
{
   return asn1PD_MsgObjectDestruction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionUpdateObject                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionUpdateObject::ASN1C_MagicActionUpdateObject (
   ASN1MessageBuffer& msgBuf, ASN1T_MagicActionUpdateObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MagicActionUpdateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionUpdateObject* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.construction_percentagePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.mining_percentagePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.bypass_construction_percentagePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.reserved_obstacle_activatedPresent);

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode construction_percentage */

   if (pvalue->m.construction_percentagePresent) {
      stat = pe_ConsInteger (ctxt_p, pvalue->construction_percentage, 0, 100);
      if (stat != ASN_OK) return stat;

   }

   /* encode mining_percentage */

   if (pvalue->m.mining_percentagePresent) {
      stat = pe_ConsInteger (ctxt_p, pvalue->mining_percentage, 0, 100);
      if (stat != ASN_OK) return stat;

   }

   /* encode bypass_construction_percentage */

   if (pvalue->m.bypass_construction_percentagePresent) {
      stat = pe_ConsInteger (ctxt_p, pvalue->bypass_construction_percentage, 0, 100);
      if (stat != ASN_OK) return stat;

   }

   /* encode reserved_obstacle_activated */

   if (pvalue->m.reserved_obstacle_activatedPresent) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->reserved_obstacle_activated);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_MagicActionUpdateObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionUpdateObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MagicActionUpdateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionUpdateObject* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pd_bit (ctxt_p, &optbit);
   pvalue->m.construction_percentagePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.mining_percentagePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.bypass_construction_percentagePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.reserved_obstacle_activatedPresent = optbit;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode construction_percentage */

   if (pvalue->m.construction_percentagePresent) {
      stat = pd_ConsInteger (ctxt_p, &pvalue->construction_percentage, 0, 100);
      if (stat != ASN_OK) return stat;
   }

   /* decode mining_percentage */

   if (pvalue->m.mining_percentagePresent) {
      stat = pd_ConsInteger (ctxt_p, &pvalue->mining_percentage, 0, 100);
      if (stat != ASN_OK) return stat;
   }

   /* decode bypass_construction_percentage */

   if (pvalue->m.bypass_construction_percentagePresent) {
      stat = pd_ConsInteger (ctxt_p, &pvalue->bypass_construction_percentage, 0, 100);
      if (stat != ASN_OK) return stat;
   }

   /* decode reserved_obstacle_activated */

   if (pvalue->m.reserved_obstacle_activatedPresent) {
      stat = pd_bit (ctxt_p, &pvalue->reserved_obstacle_activated);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_MagicActionUpdateObject::Decode ()
{
   return asn1PD_MagicActionUpdateObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionCreateObject                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionCreateObject::ASN1C_MagicActionCreateObject (
   ASN1MessageBuffer& msgBuf, ASN1T_MagicActionCreateObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MagicActionCreateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionCreateObject* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.obstacle_typePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.reserved_obstacle_activatedPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.namePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.specific_attributesPresent);

   /* encode team */

   stat = asn1PE_Team (ctxt_p, pvalue->team);
   if (stat != ASN_OK) return stat;

   /* encode type */

   stat = asn1PE_EnumObjectType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return stat;

   /* encode obstacle_type */

   if (pvalue->m.obstacle_typePresent) {
      stat = asn1PE_EnumObstacleType (ctxt_p, pvalue->obstacle_type);
      if (stat != ASN_OK) return stat;
   }

   /* encode reserved_obstacle_activated */

   if (pvalue->m.reserved_obstacle_activatedPresent) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->reserved_obstacle_activated);
      if (stat != ASN_OK) return stat;
   }

   /* encode location */

   stat = asn1PE_Location (ctxt_p, &pvalue->location);
   if (stat != ASN_OK) return stat;

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = pe_VisibleString (ctxt_p, pvalue->name, 0);
      if (stat != ASN_OK) return stat;
   }

   /* encode specific_attributes */

   if (pvalue->m.specific_attributesPresent) {
      stat = asn1PE_ObjectAttributesSpecific (ctxt_p, &pvalue->specific_attributes);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_MagicActionCreateObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionCreateObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MagicActionCreateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionCreateObject* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pd_bit (ctxt_p, &optbit);
   pvalue->m.obstacle_typePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.reserved_obstacle_activatedPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.namePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.specific_attributesPresent = optbit;

   /* decode team */

   stat = asn1PD_Team (ctxt_p, &pvalue->team);
   if (stat != ASN_OK) return stat;

   /* decode type */

   stat = asn1PD_EnumObjectType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return stat;

   /* decode obstacle_type */

   if (pvalue->m.obstacle_typePresent) {
      stat = asn1PD_EnumObstacleType (ctxt_p, &pvalue->obstacle_type);
      if (stat != ASN_OK) return stat;
   }

   /* decode reserved_obstacle_activated */

   if (pvalue->m.reserved_obstacle_activatedPresent) {
      stat = pd_bit (ctxt_p, &pvalue->reserved_obstacle_activated);
      if (stat != ASN_OK) return stat;
   }

   /* decode location */

   stat = asn1PD_Location (ctxt_p, &pvalue->location);
   if (stat != ASN_OK) return stat;

   /* decode name */

   if (pvalue->m.namePresent) {
      stat = pd_VisibleString (ctxt_p, &pvalue->name, 0);
      if (stat != ASN_OK) return stat;
   }

   /* decode specific_attributes */

   if (pvalue->m.specific_attributesPresent) {
      stat = asn1PD_ObjectAttributesSpecific (ctxt_p, &pvalue->specific_attributes);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_MagicActionCreateObject::Decode ()
{
   return asn1PD_MagicActionCreateObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionDestroyObjet                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionDestroyObjet::ASN1C_MagicActionDestroyObjet (
   ASN1MessageBuffer& msgBuf, ASN1T_MagicActionDestroyObjet& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MagicActionDestroyObjet (ASN1CTXT* ctxt_p, ASN1T_MagicActionDestroyObjet value)
{
   int stat = ASN_OK;

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_MagicActionDestroyObjet::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionDestroyObjet (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_MagicActionDestroyObjet (ASN1CTXT* ctxt_p, ASN1T_MagicActionDestroyObjet* pvalue)
{
   int stat = ASN_OK;

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MagicActionDestroyObjet::Decode ()
{
   return asn1PD_MagicActionDestroyObjet (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicAction_action                               */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicAction_action::ASN1C_MsgObjectMagicAction_action (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicAction_action& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicAction_action (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction_action* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 2);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* create_object */
      case 1:
         stat = asn1PE_MagicActionCreateObject (ctxt_p, pvalue->u.create_object);
         if (stat != ASN_OK) return stat;
         break;

      /* update_object */
      case 2:
         stat = asn1PE_MagicActionUpdateObject (ctxt_p, pvalue->u.update_object);
         if (stat != ASN_OK) return stat;
         break;

      /* destroy_object */
      case 3:
         stat = asn1PE_MagicActionDestroyObjet (ctxt_p, pvalue->u.destroy_object);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MsgObjectMagicAction_action::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicAction_action (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicAction_action (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction_action* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 2);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* create_object */
      case 0:
         pvalue->u.create_object = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MagicActionCreateObject);

         stat = asn1PD_MagicActionCreateObject (ctxt_p, pvalue->u.create_object);
         if (stat != ASN_OK) return stat;

         break;

      /* update_object */
      case 1:
         pvalue->u.update_object = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MagicActionUpdateObject);

         stat = asn1PD_MagicActionUpdateObject (ctxt_p, pvalue->u.update_object);
         if (stat != ASN_OK) return stat;

         break;

      /* destroy_object */
      case 2:
         stat = asn1PD_MagicActionDestroyObjet (ctxt_p, &pvalue->u.destroy_object);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MsgObjectMagicAction_action::Decode ()
{
   return asn1PD_MsgObjectMagicAction_action (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicAction                                      */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicAction::ASN1C_MsgObjectMagicAction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicAction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicAction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction* pvalue)
{
   int stat = ASN_OK;

   /* encode action */

   stat = asn1PE_MsgObjectMagicAction_action (ctxt_p, &pvalue->action);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgObjectMagicAction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicAction (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicAction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction* pvalue)
{
   int stat = ASN_OK;

   /* decode action */

   stat = asn1PD_MsgObjectMagicAction_action (ctxt_p, &pvalue->action);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgObjectMagicAction::Decode ()
{
   return asn1PD_MsgObjectMagicAction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicActionAck                                   */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicActionAck::ASN1C_MsgObjectMagicActionAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicActionAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicActionAck (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicActionAck* pvalue)
{
   int stat = ASN_OK;

   /* encode error_code */

   stat = asn1PE_EnumObjectErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgObjectMagicActionAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicActionAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicActionAck (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicActionAck* pvalue)
{
   int stat = ASN_OK;

   /* decode error_code */

   stat = asn1PD_EnumObjectErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgObjectMagicActionAck::Decode ()
{
   return asn1PD_MsgObjectMagicActionAck (mpContext->GetPtr(), &msgData);
}

