/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 18-Jun-2007.
 */
#include "Object.h"

/**************************************************************/
/*                                                            */
/*  ObjectIncludes                                            */
/*                                                            */
/**************************************************************/

ASN1C_ObjectIncludes::ASN1C_ObjectIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectIncludes (ASN1CTXT* ctxt_p, ASN1T_ObjectIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectIncludes: start\n");

   /* encode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_ObjectIncludes: end\n");
   return (stat);
}

int ASN1C_ObjectIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectIncludes (ASN1CTXT* ctxt_p, ASN1T_ObjectIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectIncludes: start\n");

   /* decode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_ObjectIncludes: end\n");

   return (stat);
}

int ASN1C_ObjectIncludes::Decode ()
{
   return asn1PD_ObjectIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectExports                                             */
/*                                                            */
/**************************************************************/

ASN1C_ObjectExports::ASN1C_ObjectExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_ObjectExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectExports: start\n");

   /* NULL */

   rtdiag ("asn1PE_ObjectExports: end\n");
   return (stat);
}

int ASN1C_ObjectExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_ObjectExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectExports: start\n");

   /* NULL */

   rtdiag ("asn1PD_ObjectExports: end\n");

   return (stat);
}

int ASN1C_ObjectExports::Decode ()
{
   return asn1PD_ObjectExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  EnumObstacleType                                          */
/*                                                            */
/**************************************************************/

ASN1C_EnumObstacleType::ASN1C_EnumObstacleType (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumObstacleType& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumObstacleType (ASN1CTXT* ctxt_p, ASN1T_EnumObstacleType value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumObstacleType: start\n");

   switch (value) {
      case EnumObstacleType::preliminaire: ui = 0; break;
      case EnumObstacleType::de_manoeuvre: ui = 1; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumObstacleType: end\n");
   return (stat);
}

int ASN1C_EnumObstacleType::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumObstacleType (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumObstacleType (ASN1CTXT* ctxt_p, ASN1T_EnumObstacleType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumObstacleType: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumObstacleType::preliminaire; break;
      case 1: *pvalue = EnumObstacleType::de_manoeuvre; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumObstacleType: end\n");

   return (stat);
}

int ASN1C_EnumObstacleType::Decode ()
{
   return asn1PD_EnumObstacleType (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumObjectType                                            */
/*                                                            */
/**************************************************************/

ASN1C_EnumObjectType::ASN1C_EnumObjectType (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumObjectType& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumObjectType (ASN1CTXT* ctxt_p, ASN1T_EnumObjectType value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumObjectType: start\n");

   switch (value) {
      case EnumObjectType::bouchon_mines: ui = 0; break;
      case EnumObjectType::zone_minee_lineaire: ui = 1; break;
      case EnumObjectType::zone_minee_par_dispersion: ui = 2; break;
      case EnumObjectType::fosse_anti_char: ui = 3; break;
      case EnumObjectType::abattis: ui = 4; break;
      case EnumObjectType::barricade: ui = 5; break;
      case EnumObjectType::eboulement: ui = 6; break;
      case EnumObjectType::destruction_route: ui = 7; break;
      case EnumObjectType::destruction_pont: ui = 8; break;
      case EnumObjectType::pont_flottant_continu: ui = 9; break;
      case EnumObjectType::poste_tir: ui = 10; break;
      case EnumObjectType::zone_protegee: ui = 11; break;
      case EnumObjectType::zone_implantation_canon: ui = 12; break;
      case EnumObjectType::zone_implantation_cobra: ui = 13; break;
      case EnumObjectType::zone_implantation_lrm: ui = 14; break;
      case EnumObjectType::site_franchissement: ui = 15; break;
      case EnumObjectType::nuage_nbc: ui = 16; break;
      case EnumObjectType::plot_ravitaillement: ui = 17; break;
      case EnumObjectType::site_decontamination: ui = 18; break;
      case EnumObjectType::zone_brouillage_brod: ui = 19; break;
      case EnumObjectType::rota: ui = 20; break;
      case EnumObjectType::zone_nbc: ui = 21; break;
      case EnumObjectType::zone_brouillage_bromure: ui = 22; break;
      case EnumObjectType::aire_poser: ui = 23; break;
      case EnumObjectType::piste: ui = 24; break;
      case EnumObjectType::plateforme: ui = 25; break;
      case EnumObjectType::zone_mobilite_amelioree: ui = 26; break;
      case EnumObjectType::zone_poser_helicoptere: ui = 27; break;
      case EnumObjectType::aire_logistique: ui = 28; break;
      case EnumObjectType::itineraire_logistique: ui = 29; break;
      case EnumObjectType::camp_prisonniers: ui = 30; break;
      case EnumObjectType::camp_refugies: ui = 31; break;
      case EnumObjectType::poste_controle: ui = 32; break;
      case EnumObjectType::terrain_largage: ui = 33; break;
      case EnumObjectType::zone_interdite_mouvement: ui = 34; break;
      case EnumObjectType::zone_interdite_tir: ui = 35; break;
      case EnumObjectType::zone_implantation_mortier: ui = 36; break;
      case EnumObjectType::pont_flottant_discontinu: ui = 37; break;
      case EnumObjectType::installation: ui = 38; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 38);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumObjectType: end\n");
   return (stat);
}

int ASN1C_EnumObjectType::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumObjectType (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumObjectType (ASN1CTXT* ctxt_p, ASN1T_EnumObjectType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumObjectType: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 38);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumObjectType::bouchon_mines; break;
      case 1: *pvalue = EnumObjectType::zone_minee_lineaire; break;
      case 2: *pvalue = EnumObjectType::zone_minee_par_dispersion; break;
      case 3: *pvalue = EnumObjectType::fosse_anti_char; break;
      case 4: *pvalue = EnumObjectType::abattis; break;
      case 5: *pvalue = EnumObjectType::barricade; break;
      case 6: *pvalue = EnumObjectType::eboulement; break;
      case 7: *pvalue = EnumObjectType::destruction_route; break;
      case 8: *pvalue = EnumObjectType::destruction_pont; break;
      case 9: *pvalue = EnumObjectType::pont_flottant_continu; break;
      case 10: *pvalue = EnumObjectType::poste_tir; break;
      case 11: *pvalue = EnumObjectType::zone_protegee; break;
      case 12: *pvalue = EnumObjectType::zone_implantation_canon; break;
      case 13: *pvalue = EnumObjectType::zone_implantation_cobra; break;
      case 14: *pvalue = EnumObjectType::zone_implantation_lrm; break;
      case 15: *pvalue = EnumObjectType::site_franchissement; break;
      case 16: *pvalue = EnumObjectType::nuage_nbc; break;
      case 17: *pvalue = EnumObjectType::plot_ravitaillement; break;
      case 18: *pvalue = EnumObjectType::site_decontamination; break;
      case 19: *pvalue = EnumObjectType::zone_brouillage_brod; break;
      case 20: *pvalue = EnumObjectType::rota; break;
      case 21: *pvalue = EnumObjectType::zone_nbc; break;
      case 22: *pvalue = EnumObjectType::zone_brouillage_bromure; break;
      case 23: *pvalue = EnumObjectType::aire_poser; break;
      case 24: *pvalue = EnumObjectType::piste; break;
      case 25: *pvalue = EnumObjectType::plateforme; break;
      case 26: *pvalue = EnumObjectType::zone_mobilite_amelioree; break;
      case 27: *pvalue = EnumObjectType::zone_poser_helicoptere; break;
      case 28: *pvalue = EnumObjectType::aire_logistique; break;
      case 29: *pvalue = EnumObjectType::itineraire_logistique; break;
      case 30: *pvalue = EnumObjectType::camp_prisonniers; break;
      case 31: *pvalue = EnumObjectType::camp_refugies; break;
      case 32: *pvalue = EnumObjectType::poste_controle; break;
      case 33: *pvalue = EnumObjectType::terrain_largage; break;
      case 34: *pvalue = EnumObjectType::zone_interdite_mouvement; break;
      case 35: *pvalue = EnumObjectType::zone_interdite_tir; break;
      case 36: *pvalue = EnumObjectType::zone_implantation_mortier; break;
      case 37: *pvalue = EnumObjectType::pont_flottant_discontinu; break;
      case 38: *pvalue = EnumObjectType::installation; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumObjectType: end\n");

   return (stat);
}

int ASN1C_EnumObjectType::Decode ()
{
   return asn1PD_EnumObjectType (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumObjectErrorCode                                       */
/*                                                            */
/**************************************************************/

ASN1C_EnumObjectErrorCode::ASN1C_EnumObjectErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumObjectErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumObjectErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumObjectErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumObjectErrorCode: start\n");

   switch (value) {
      case EnumObjectErrorCode::no_error: ui = 0; break;
      case EnumObjectErrorCode::error_invalid_object: ui = 1; break;
      case EnumObjectErrorCode::error_invalid_id: ui = 2; break;
      case EnumObjectErrorCode::error_invalid_camp: ui = 3; break;
      case EnumObjectErrorCode::error_invalid_localisation: ui = 4; break;
      case EnumObjectErrorCode::error_missing_specific_attributes: ui = 5; break;
      case EnumObjectErrorCode::error_invalid_specific_attributes: ui = 6; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumObjectErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumObjectErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumObjectErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumObjectErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumObjectErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumObjectErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 6);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumObjectErrorCode::no_error; break;
      case 1: *pvalue = EnumObjectErrorCode::error_invalid_object; break;
      case 2: *pvalue = EnumObjectErrorCode::error_invalid_id; break;
      case 3: *pvalue = EnumObjectErrorCode::error_invalid_camp; break;
      case 4: *pvalue = EnumObjectErrorCode::error_invalid_localisation; break;
      case 5: *pvalue = EnumObjectErrorCode::error_missing_specific_attributes; break;
      case 6: *pvalue = EnumObjectErrorCode::error_invalid_specific_attributes; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumObjectErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumObjectErrorCode::Decode ()
{
   return asn1PD_EnumObjectErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesCrossingSite                              */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesCrossingSite::ASN1C_ObjectAttributesCrossingSite (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesCrossingSite& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesCrossingSite (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesCrossingSite* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesCrossingSite: start\n");

   /* encode largeur */

   PU_PUSHNAME (ctxt_p, "largeur");

   stat = pe_UnconsInteger (ctxt_p, pvalue->largeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode profondeur */

   PU_PUSHNAME (ctxt_p, "profondeur");

   stat = pe_UnconsInteger (ctxt_p, pvalue->profondeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode vitesse_courant */

   PU_PUSHNAME (ctxt_p, "vitesse_courant");

   stat = pe_UnconsInteger (ctxt_p, pvalue->vitesse_courant);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode berges_a_amenager */

   PU_PUSHNAME (ctxt_p, "berges_a_amenager");

   PU_NEWFIELD (ctxt_p, "boolean");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->berges_a_amenager);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_ObjectAttributesCrossingSite: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesCrossingSite::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesCrossingSite (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesCrossingSite (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesCrossingSite* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectAttributesCrossingSite: start\n");

   /* decode largeur */

   PU_PUSHNAME (ctxt_p, "largeur");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->largeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode profondeur */

   PU_PUSHNAME (ctxt_p, "profondeur");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->profondeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode vitesse_courant */

   PU_PUSHNAME (ctxt_p, "vitesse_courant");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->vitesse_courant);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode berges_a_amenager */

   PU_PUSHNAME (ctxt_p, "berges_a_amenager");

   PU_NEWFIELD (ctxt_p, "boolean");

   stat = pd_bit (ctxt_p, &pvalue->berges_a_amenager);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_ObjectAttributesCrossingSite: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesCrossingSite::Decode ()
{
   return asn1PD_ObjectAttributesCrossingSite (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesNbcCloud                                  */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesNbcCloud::ASN1C_ObjectAttributesNbcCloud (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesNbcCloud& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesNbcCloud (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesNbcCloud* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesNbcCloud: start\n");

   /* encode agent_nbc */

   PU_PUSHNAME (ctxt_p, "agent_nbc");

   stat = asn1PE_OID (ctxt_p, pvalue->agent_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_ObjectAttributesNbcCloud: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesNbcCloud::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesNbcCloud (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesNbcCloud (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesNbcCloud* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectAttributesNbcCloud: start\n");

   /* decode agent_nbc */

   PU_PUSHNAME (ctxt_p, "agent_nbc");

   stat = asn1PD_OID (ctxt_p, &pvalue->agent_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_ObjectAttributesNbcCloud: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesNbcCloud::Decode ()
{
   return asn1PD_ObjectAttributesNbcCloud (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesNbcZone                                   */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesNbcZone::ASN1C_ObjectAttributesNbcZone (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesNbcZone& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesNbcZone (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesNbcZone* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesNbcZone: start\n");

   /* encode agent_nbc */

   PU_PUSHNAME (ctxt_p, "agent_nbc");

   stat = asn1PE_OID (ctxt_p, pvalue->agent_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_ObjectAttributesNbcZone: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesNbcZone::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesNbcZone (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesNbcZone (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesNbcZone* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectAttributesNbcZone: start\n");

   /* decode agent_nbc */

   PU_PUSHNAME (ctxt_p, "agent_nbc");

   stat = asn1PD_OID (ctxt_p, &pvalue->agent_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_ObjectAttributesNbcZone: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesNbcZone::Decode ()
{
   return asn1PD_ObjectAttributesNbcZone (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesRota                                      */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesRota::ASN1C_ObjectAttributesRota (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesRota& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesRota (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesRota* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesRota: start\n");

   /* encode niveau_danger */

   PU_PUSHNAME (ctxt_p, "niveau_danger");

   if ( (pvalue->niveau_danger >= 0 && pvalue->niveau_danger <= 10) ) {
      stat = pe_ConsInteger (ctxt_p, pvalue->niveau_danger, 0, 10);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   }
   else
      return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

   PU_POPNAME (ctxt_p);

   /* encode agents_nbc */

   PU_PUSHNAME (ctxt_p, "agents_nbc");

   stat = asn1PE_ListOID (ctxt_p, &pvalue->agents_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_ObjectAttributesRota: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesRota::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesRota (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesRota (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesRota* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectAttributesRota: start\n");

   /* decode niveau_danger */

   PU_PUSHNAME (ctxt_p, "niveau_danger");

   stat = pd_ConsInteger (ctxt_p, &pvalue->niveau_danger, 0, 10);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode agents_nbc */

   PU_PUSHNAME (ctxt_p, "agents_nbc");

   stat = asn1PD_ListOID (ctxt_p, &pvalue->agents_nbc);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_ObjectAttributesRota: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesRota::Decode ()
{
   return asn1PD_ObjectAttributesRota (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesLogisticRoute                             */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesLogisticRoute::ASN1C_ObjectAttributesLogisticRoute (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesLogisticRoute& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesLogisticRoute (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesLogisticRoute* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesLogisticRoute: start\n");

   /* encode itineraire_equipe */

   PU_PUSHNAME (ctxt_p, "itineraire_equipe");

   PU_NEWFIELD (ctxt_p, "boolean");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->itineraire_equipe);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);
   PU_POPNAME (ctxt_p);

   /* encode poids_max_supporte */

   PU_PUSHNAME (ctxt_p, "poids_max_supporte");

   stat = pe_UnconsInteger (ctxt_p, pvalue->poids_max_supporte);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode largeur */

   PU_PUSHNAME (ctxt_p, "largeur");

   stat = pe_UnconsInteger (ctxt_p, pvalue->largeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode longueur */

   PU_PUSHNAME (ctxt_p, "longueur");

   stat = pe_UnconsInteger (ctxt_p, pvalue->longueur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode debit */

   PU_PUSHNAME (ctxt_p, "debit");

   stat = pe_UnconsInteger (ctxt_p, pvalue->debit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_ObjectAttributesLogisticRoute: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesLogisticRoute::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesLogisticRoute (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesLogisticRoute (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesLogisticRoute* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectAttributesLogisticRoute: start\n");

   /* decode itineraire_equipe */

   PU_PUSHNAME (ctxt_p, "itineraire_equipe");

   PU_NEWFIELD (ctxt_p, "boolean");

   stat = pd_bit (ctxt_p, &pvalue->itineraire_equipe);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_POPNAME (ctxt_p);

   /* decode poids_max_supporte */

   PU_PUSHNAME (ctxt_p, "poids_max_supporte");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->poids_max_supporte);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode largeur */

   PU_PUSHNAME (ctxt_p, "largeur");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->largeur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode longueur */

   PU_PUSHNAME (ctxt_p, "longueur");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->longueur);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode debit */

   PU_PUSHNAME (ctxt_p, "debit");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->debit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_ObjectAttributesLogisticRoute: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesLogisticRoute::Decode ()
{
   return asn1PD_ObjectAttributesLogisticRoute (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesPrisonerCamp                              */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesPrisonerCamp::ASN1C_ObjectAttributesPrisonerCamp (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesPrisonerCamp& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesPrisonerCamp (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesPrisonerCamp* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesPrisonerCamp: start\n");

   /* encode tc2 */

   PU_PUSHNAME (ctxt_p, "tc2");

   stat = asn1PE_Automat (ctxt_p, pvalue->tc2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_ObjectAttributesPrisonerCamp: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesPrisonerCamp::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesPrisonerCamp (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesPrisonerCamp (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesPrisonerCamp* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectAttributesPrisonerCamp: start\n");

   /* decode tc2 */

   PU_PUSHNAME (ctxt_p, "tc2");

   stat = asn1PD_Automat (ctxt_p, &pvalue->tc2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_ObjectAttributesPrisonerCamp: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesPrisonerCamp::Decode ()
{
   return asn1PD_ObjectAttributesPrisonerCamp (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesRefugeeCamp                               */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesRefugeeCamp::ASN1C_ObjectAttributesRefugeeCamp (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesRefugeeCamp& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesRefugeeCamp (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesRefugeeCamp* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesRefugeeCamp: start\n");

   /* encode tc2 */

   PU_PUSHNAME (ctxt_p, "tc2");

   stat = asn1PE_Automat (ctxt_p, pvalue->tc2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_ObjectAttributesRefugeeCamp: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesRefugeeCamp::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesRefugeeCamp (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesRefugeeCamp (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesRefugeeCamp* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_ObjectAttributesRefugeeCamp: start\n");

   /* decode tc2 */

   PU_PUSHNAME (ctxt_p, "tc2");

   stat = asn1PD_Automat (ctxt_p, &pvalue->tc2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_ObjectAttributesRefugeeCamp: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesRefugeeCamp::Decode ()
{
   return asn1PD_ObjectAttributesRefugeeCamp (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesLinearMineArea                            */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesLinearMineArea::ASN1C_ObjectAttributesLinearMineArea (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesLinearMineArea& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesLinearMineArea (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesLinearMineArea* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesLinearMineArea: start\n");

   PU_NEWFIELD (ctxt_p, "densitePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->densite != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "delai_activite_minesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->delai_activite_mines != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode densite */

   if (pvalue->densite != 0) {
      PU_PUSHNAME (ctxt_p, "densite");

      stat = pe_Real (ctxt_p, pvalue->densite);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode delai_activite_mines */

   if (pvalue->delai_activite_mines != 0) {
      PU_PUSHNAME (ctxt_p, "delai_activite_mines");

      stat = pe_UnconsInteger (ctxt_p, pvalue->delai_activite_mines);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_ObjectAttributesLinearMineArea: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesLinearMineArea::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesLinearMineArea (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesLinearMineArea (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesLinearMineArea* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL densitePresent;
   ASN1BOOL delai_activite_minesPresent;

   rtdiag ("asn1PD_ObjectAttributesLinearMineArea: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "densitePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else densitePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "delai_activite_minesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else delai_activite_minesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode densite */

   if (densitePresent) {
      PU_PUSHNAME (ctxt_p, "densite");

      stat = pd_Real (ctxt_p, &pvalue->densite);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
   }

   /* decode delai_activite_mines */

   if (delai_activite_minesPresent) {
      PU_PUSHNAME (ctxt_p, "delai_activite_mines");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->delai_activite_mines);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->delai_activite_mines = 0;
   }


   rtdiag ("asn1PD_ObjectAttributesLinearMineArea: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesLinearMineArea::Decode ()
{
   return asn1PD_ObjectAttributesLinearMineArea (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesDispersedMineArea                         */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesDispersedMineArea::ASN1C_ObjectAttributesDispersedMineArea (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesDispersedMineArea& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesDispersedMineArea (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesDispersedMineArea* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesDispersedMineArea: start\n");

   PU_NEWFIELD (ctxt_p, "densitePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->densite != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "delai_activite_minesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->delai_activite_mines != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode densite */

   if (pvalue->densite != 0) {
      PU_PUSHNAME (ctxt_p, "densite");

      stat = pe_Real (ctxt_p, pvalue->densite);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode delai_activite_mines */

   if (pvalue->delai_activite_mines != 0) {
      PU_PUSHNAME (ctxt_p, "delai_activite_mines");

      stat = pe_UnconsInteger (ctxt_p, pvalue->delai_activite_mines);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_ObjectAttributesDispersedMineArea: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesDispersedMineArea::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesDispersedMineArea (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesDispersedMineArea (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesDispersedMineArea* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL densitePresent;
   ASN1BOOL delai_activite_minesPresent;

   rtdiag ("asn1PD_ObjectAttributesDispersedMineArea: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "densitePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else densitePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "delai_activite_minesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else delai_activite_minesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode densite */

   if (densitePresent) {
      PU_PUSHNAME (ctxt_p, "densite");

      stat = pd_Real (ctxt_p, &pvalue->densite);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
   }

   /* decode delai_activite_mines */

   if (delai_activite_minesPresent) {
      PU_PUSHNAME (ctxt_p, "delai_activite_mines");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->delai_activite_mines);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->delai_activite_mines = 0;
   }


   rtdiag ("asn1PD_ObjectAttributesDispersedMineArea: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesDispersedMineArea::Decode ()
{
   return asn1PD_ObjectAttributesDispersedMineArea (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesMineJam                                   */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesMineJam::ASN1C_ObjectAttributesMineJam (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesMineJam& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesMineJam (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesMineJam* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesMineJam: start\n");

   PU_NEWFIELD (ctxt_p, "delai_activite_minesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->delai_activite_mines != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode delai_activite_mines */

   if (pvalue->delai_activite_mines != 0) {
      PU_PUSHNAME (ctxt_p, "delai_activite_mines");

      stat = pe_UnconsInteger (ctxt_p, pvalue->delai_activite_mines);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_ObjectAttributesMineJam: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesMineJam::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesMineJam (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesMineJam (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesMineJam* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL delai_activite_minesPresent;

   rtdiag ("asn1PD_ObjectAttributesMineJam: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "delai_activite_minesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else delai_activite_minesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode delai_activite_mines */

   if (delai_activite_minesPresent) {
      PU_PUSHNAME (ctxt_p, "delai_activite_mines");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->delai_activite_mines);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->delai_activite_mines = 0;
   }


   rtdiag ("asn1PD_ObjectAttributesMineJam: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesMineJam::Decode ()
{
   return asn1PD_ObjectAttributesMineJam (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ObjectAttributesSpecific                                  */
/*                                                            */
/**************************************************************/

ASN1C_ObjectAttributesSpecific::ASN1C_ObjectAttributesSpecific (
   ASN1MessageBuffer& msgBuf, ASN1T_ObjectAttributesSpecific& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ObjectAttributesSpecific (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesSpecific* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_ObjectAttributesSpecific: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (ctxt_p, "t");

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 9);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* site_franchissement */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.site_franchissement");

         stat = asn1PE_ObjectAttributesCrossingSite (ctxt_p, pvalue->u.site_franchissement);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* nuage_nbc */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.nuage_nbc");

         stat = asn1PE_ObjectAttributesNbcCloud (ctxt_p, pvalue->u.nuage_nbc);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* rota */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.rota");

         stat = asn1PE_ObjectAttributesRota (ctxt_p, pvalue->u.rota);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* zone_nbc */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.zone_nbc");

         stat = asn1PE_ObjectAttributesNbcZone (ctxt_p, pvalue->u.zone_nbc);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* itineraire_logistique */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.itineraire_logistique");

         stat = asn1PE_ObjectAttributesLogisticRoute (ctxt_p, pvalue->u.itineraire_logistique);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* camp_prisonniers */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.camp_prisonniers");

         stat = asn1PE_ObjectAttributesPrisonerCamp (ctxt_p, pvalue->u.camp_prisonniers);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* camp_refugies */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.camp_refugies");

         stat = asn1PE_ObjectAttributesRefugeeCamp (ctxt_p, pvalue->u.camp_refugies);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* zone_minee_lineaire */
      case 8:
         PU_PUSHNAME (ctxt_p, "u.zone_minee_lineaire");

         stat = asn1PE_ObjectAttributesLinearMineArea (ctxt_p, pvalue->u.zone_minee_lineaire);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* zone_minee_par_dispersion */
      case 9:
         PU_PUSHNAME (ctxt_p, "u.zone_minee_par_dispersion");

         stat = asn1PE_ObjectAttributesDispersedMineArea (ctxt_p, pvalue->u.zone_minee_par_dispersion);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* bouchon_mines */
      case 10:
         PU_PUSHNAME (ctxt_p, "u.bouchon_mines");

         stat = asn1PE_ObjectAttributesMineJam (ctxt_p, pvalue->u.bouchon_mines);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PE_ObjectAttributesSpecific: end\n");
   return (stat);
}

int ASN1C_ObjectAttributesSpecific::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ObjectAttributesSpecific (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ObjectAttributesSpecific (ASN1CTXT* ctxt_p, ASN1T_ObjectAttributesSpecific* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_ObjectAttributesSpecific: start\n");

   PU_PUSHNAME (ctxt_p, "t");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 9);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (ctxt_p);

   switch (ui) {
      /* site_franchissement */
      case 0:
         PU_PUSHNAME (ctxt_p, "u.site_franchissement");

         pvalue->u.site_franchissement = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesCrossingSite);
         if (pvalue->u.site_franchissement == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesCrossingSite (ctxt_p, pvalue->u.site_franchissement);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* nuage_nbc */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.nuage_nbc");

         pvalue->u.nuage_nbc = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesNbcCloud);
         if (pvalue->u.nuage_nbc == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesNbcCloud (ctxt_p, pvalue->u.nuage_nbc);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* rota */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.rota");

         pvalue->u.rota = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesRota);
         if (pvalue->u.rota == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesRota (ctxt_p, pvalue->u.rota);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* zone_nbc */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.zone_nbc");

         pvalue->u.zone_nbc = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesNbcZone);
         if (pvalue->u.zone_nbc == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesNbcZone (ctxt_p, pvalue->u.zone_nbc);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* itineraire_logistique */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.itineraire_logistique");

         pvalue->u.itineraire_logistique = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesLogisticRoute);
         if (pvalue->u.itineraire_logistique == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesLogisticRoute (ctxt_p, pvalue->u.itineraire_logistique);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* camp_prisonniers */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.camp_prisonniers");

         pvalue->u.camp_prisonniers = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesPrisonerCamp);
         if (pvalue->u.camp_prisonniers == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesPrisonerCamp (ctxt_p, pvalue->u.camp_prisonniers);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* camp_refugies */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.camp_refugies");

         pvalue->u.camp_refugies = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesRefugeeCamp);
         if (pvalue->u.camp_refugies == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesRefugeeCamp (ctxt_p, pvalue->u.camp_refugies);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* zone_minee_lineaire */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.zone_minee_lineaire");

         pvalue->u.zone_minee_lineaire = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesLinearMineArea);
         if (pvalue->u.zone_minee_lineaire == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesLinearMineArea (ctxt_p, pvalue->u.zone_minee_lineaire);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* zone_minee_par_dispersion */
      case 8:
         PU_PUSHNAME (ctxt_p, "u.zone_minee_par_dispersion");

         pvalue->u.zone_minee_par_dispersion = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesDispersedMineArea);
         if (pvalue->u.zone_minee_par_dispersion == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesDispersedMineArea (ctxt_p, pvalue->u.zone_minee_par_dispersion);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* bouchon_mines */
      case 9:
         PU_PUSHNAME (ctxt_p, "u.bouchon_mines");

         pvalue->u.bouchon_mines = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectAttributesMineJam);
         if (pvalue->u.bouchon_mines == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectAttributesMineJam (ctxt_p, pvalue->u.bouchon_mines);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PD_ObjectAttributesSpecific: end\n");

   return (stat);
}

int ASN1C_ObjectAttributesSpecific::Decode ()
{
   return asn1PD_ObjectAttributesSpecific (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectCreation                                         */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectCreation::ASN1C_MsgObjectCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectCreation (ASN1CTXT* ctxt_p, ASN1T_MsgObjectCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectCreation: start\n");

   PU_NEWFIELD (ctxt_p, "type_obstaclePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.type_obstaclePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "obstacle_de_manoeuvre_activePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.obstacle_de_manoeuvre_activePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.attributs_specifiquesPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "type_dotation_constructionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.type_dotation_constructionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "type_dotation_valorisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.type_dotation_valorisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumObjectType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type_obstacle */

   if (pvalue->m.type_obstaclePresent) {
      PU_PUSHNAME (ctxt_p, "type_obstacle");

      stat = asn1PE_EnumObstacleType (ctxt_p, pvalue->type_obstacle);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode obstacle_de_manoeuvre_active */

   if (pvalue->m.obstacle_de_manoeuvre_activePresent) {
      PU_PUSHNAME (ctxt_p, "obstacle_de_manoeuvre_active");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->obstacle_de_manoeuvre_active);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode localisation */

   PU_PUSHNAME (ctxt_p, "localisation");

   stat = asn1PE_Location (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nom */

   PU_PUSHNAME (ctxt_p, "nom");

   stat = pe_VisibleString (ctxt_p, pvalue->nom, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode camp */

   PU_PUSHNAME (ctxt_p, "camp");

   stat = asn1PE_Team (ctxt_p, pvalue->camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PE_ObjectAttributesSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode type_dotation_construction */

   if (pvalue->m.type_dotation_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "type_dotation_construction");

      stat = asn1PE_DotationType (ctxt_p, pvalue->type_dotation_construction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode type_dotation_valorisation */

   if (pvalue->m.type_dotation_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "type_dotation_valorisation");

      stat = asn1PE_DotationType (ctxt_p, pvalue->type_dotation_valorisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgObjectCreation: end\n");
   return (stat);
}

int ASN1C_MsgObjectCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectCreation (ASN1CTXT* ctxt_p, ASN1T_MsgObjectCreation* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgObjectCreation: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "type_obstaclePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.type_obstaclePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "obstacle_de_manoeuvre_activePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.obstacle_de_manoeuvre_activePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.attributs_specifiquesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "type_dotation_constructionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.type_dotation_constructionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "type_dotation_valorisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.type_dotation_valorisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumObjectType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type_obstacle */

   if (pvalue->m.type_obstaclePresent) {
      PU_PUSHNAME (ctxt_p, "type_obstacle");

      stat = asn1PD_EnumObstacleType (ctxt_p, &pvalue->type_obstacle);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode obstacle_de_manoeuvre_active */

   if (pvalue->m.obstacle_de_manoeuvre_activePresent) {
      PU_PUSHNAME (ctxt_p, "obstacle_de_manoeuvre_active");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->obstacle_de_manoeuvre_active);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }

   /* decode localisation */

   PU_PUSHNAME (ctxt_p, "localisation");

   stat = asn1PD_Location (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nom */

   PU_PUSHNAME (ctxt_p, "nom");

   stat = pd_VisibleString (ctxt_p, &pvalue->nom, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode camp */

   PU_PUSHNAME (ctxt_p, "camp");

   stat = asn1PD_Team (ctxt_p, &pvalue->camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PD_ObjectAttributesSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode type_dotation_construction */

   if (pvalue->m.type_dotation_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "type_dotation_construction");

      stat = asn1PD_DotationType (ctxt_p, &pvalue->type_dotation_construction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode type_dotation_valorisation */

   if (pvalue->m.type_dotation_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "type_dotation_valorisation");

      stat = asn1PD_DotationType (ctxt_p, &pvalue->type_dotation_valorisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgObjectCreation: end\n");

   return (stat);
}

int ASN1C_MsgObjectCreation::Decode ()
{
   return asn1PD_MsgObjectCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectUpdate                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectUpdate::ASN1C_MsgObjectUpdate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectUpdate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgObjectUpdate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectUpdate: start\n");

   PU_NEWFIELD (ctxt_p, "pourcentage_constructionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_constructionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_valorisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_valorisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_creation_contournementPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_creation_contournementPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "obstacle_de_manoeuvre_activePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.obstacle_de_manoeuvre_activePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_dotation_constructionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nb_dotation_constructionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_dotation_valorisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nb_dotation_valorisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "localisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.localisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.attributs_specifiquesPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode pourcentage_construction */

   if (pvalue->m.pourcentage_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_construction");

      if ( (pvalue->pourcentage_construction >= 0 && pvalue->pourcentage_construction <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_construction, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode pourcentage_valorisation */

   if (pvalue->m.pourcentage_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_valorisation");

      if ( (pvalue->pourcentage_valorisation >= 0 && pvalue->pourcentage_valorisation <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_valorisation, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode pourcentage_creation_contournement */

   if (pvalue->m.pourcentage_creation_contournementPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_creation_contournement");

      if ( (pvalue->pourcentage_creation_contournement >= 0 && pvalue->pourcentage_creation_contournement <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_creation_contournement, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode obstacle_de_manoeuvre_active */

   if (pvalue->m.obstacle_de_manoeuvre_activePresent) {
      PU_PUSHNAME (ctxt_p, "obstacle_de_manoeuvre_active");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->obstacle_de_manoeuvre_active);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode nb_dotation_construction */

   if (pvalue->m.nb_dotation_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "nb_dotation_construction");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nb_dotation_construction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode nb_dotation_valorisation */

   if (pvalue->m.nb_dotation_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "nb_dotation_valorisation");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nb_dotation_valorisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode localisation */

   if (pvalue->m.localisationPresent) {
      PU_PUSHNAME (ctxt_p, "localisation");

      stat = asn1PE_Location (ctxt_p, &pvalue->localisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PE_ObjectAttributesSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgObjectUpdate: end\n");
   return (stat);
}

int ASN1C_MsgObjectUpdate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectUpdate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgObjectUpdate* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgObjectUpdate: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "pourcentage_constructionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_constructionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_valorisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_valorisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_creation_contournementPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_creation_contournementPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "obstacle_de_manoeuvre_activePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.obstacle_de_manoeuvre_activePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_dotation_constructionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nb_dotation_constructionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nb_dotation_valorisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nb_dotation_valorisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "localisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.localisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.attributs_specifiquesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid */

   PU_PUSHNAME (ctxt_p, "oid");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode pourcentage_construction */

   if (pvalue->m.pourcentage_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_construction");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_construction, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pourcentage_valorisation */

   if (pvalue->m.pourcentage_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_valorisation");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_valorisation, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pourcentage_creation_contournement */

   if (pvalue->m.pourcentage_creation_contournementPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_creation_contournement");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_creation_contournement, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode obstacle_de_manoeuvre_active */

   if (pvalue->m.obstacle_de_manoeuvre_activePresent) {
      PU_PUSHNAME (ctxt_p, "obstacle_de_manoeuvre_active");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->obstacle_de_manoeuvre_active);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }

   /* decode nb_dotation_construction */

   if (pvalue->m.nb_dotation_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "nb_dotation_construction");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nb_dotation_construction);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode nb_dotation_valorisation */

   if (pvalue->m.nb_dotation_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "nb_dotation_valorisation");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nb_dotation_valorisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode localisation */

   if (pvalue->m.localisationPresent) {
      PU_PUSHNAME (ctxt_p, "localisation");

      stat = asn1PD_Location (ctxt_p, &pvalue->localisation);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PD_ObjectAttributesSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgObjectUpdate: end\n");

   return (stat);
}

int ASN1C_MsgObjectUpdate::Decode ()
{
   return asn1PD_MsgObjectUpdate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectDestruction                                      */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectDestruction::ASN1C_MsgObjectDestruction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectDestruction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectDestruction value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectDestruction: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_MsgObjectDestruction: end\n");
   return (stat);
}

int ASN1C_MsgObjectDestruction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectDestruction (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgObjectDestruction: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_MsgObjectDestruction: end\n");

   return (stat);
}

int ASN1C_MsgObjectDestruction::Decode ()
{
   return asn1PD_MsgObjectDestruction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionUpdateObject                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionUpdateObject::ASN1C_MagicActionUpdateObject (
   ASN1MessageBuffer& msgBuf, ASN1T_MagicActionUpdateObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MagicActionUpdateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionUpdateObject* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MagicActionUpdateObject: start\n");

   PU_NEWFIELD (ctxt_p, "pourcentage_constructionPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_constructionPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_valorisationPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_valorisationPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_creation_contournementPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.pourcentage_creation_contournementPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "obstacle_de_manoeuvre_activePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.obstacle_de_manoeuvre_activePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_objet */

   PU_PUSHNAME (ctxt_p, "oid_objet");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_objet);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode pourcentage_construction */

   if (pvalue->m.pourcentage_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_construction");

      if ( (pvalue->pourcentage_construction >= 0 && pvalue->pourcentage_construction <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_construction, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode pourcentage_valorisation */

   if (pvalue->m.pourcentage_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_valorisation");

      if ( (pvalue->pourcentage_valorisation >= 0 && pvalue->pourcentage_valorisation <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_valorisation, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode pourcentage_creation_contournement */

   if (pvalue->m.pourcentage_creation_contournementPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_creation_contournement");

      if ( (pvalue->pourcentage_creation_contournement >= 0 && pvalue->pourcentage_creation_contournement <= 100) ) {
         stat = pe_ConsInteger (ctxt_p, pvalue->pourcentage_creation_contournement, 0, 100);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      }
      else
         return LOG_ASN1ERR (ctxt_p, ASN_E_CONSVIO);

      PU_POPNAME (ctxt_p);
   }

   /* encode obstacle_de_manoeuvre_active */

   if (pvalue->m.obstacle_de_manoeuvre_activePresent) {
      PU_PUSHNAME (ctxt_p, "obstacle_de_manoeuvre_active");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->obstacle_de_manoeuvre_active);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MagicActionUpdateObject: end\n");
   return (stat);
}

int ASN1C_MagicActionUpdateObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionUpdateObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MagicActionUpdateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionUpdateObject* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MagicActionUpdateObject: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "pourcentage_constructionPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_constructionPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_valorisationPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_valorisationPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "pourcentage_creation_contournementPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.pourcentage_creation_contournementPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "obstacle_de_manoeuvre_activePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.obstacle_de_manoeuvre_activePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_objet */

   PU_PUSHNAME (ctxt_p, "oid_objet");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_objet);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode pourcentage_construction */

   if (pvalue->m.pourcentage_constructionPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_construction");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_construction, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pourcentage_valorisation */

   if (pvalue->m.pourcentage_valorisationPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_valorisation");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_valorisation, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode pourcentage_creation_contournement */

   if (pvalue->m.pourcentage_creation_contournementPresent) {
      PU_PUSHNAME (ctxt_p, "pourcentage_creation_contournement");

      stat = pd_ConsInteger (ctxt_p, &pvalue->pourcentage_creation_contournement, 0, 100);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode obstacle_de_manoeuvre_active */

   if (pvalue->m.obstacle_de_manoeuvre_activePresent) {
      PU_PUSHNAME (ctxt_p, "obstacle_de_manoeuvre_active");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->obstacle_de_manoeuvre_active);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MagicActionUpdateObject: end\n");

   return (stat);
}

int ASN1C_MagicActionUpdateObject::Decode ()
{
   return asn1PD_MagicActionUpdateObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionCreateObject                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionCreateObject::ASN1C_MagicActionCreateObject (
   ASN1MessageBuffer& msgBuf, ASN1T_MagicActionCreateObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MagicActionCreateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionCreateObject* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MagicActionCreateObject: start\n");

   PU_NEWFIELD (ctxt_p, "type_obstaclePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.type_obstaclePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "obstacle_de_manoeuvre_activePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.obstacle_de_manoeuvre_activePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nomPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nomPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.attributs_specifiquesPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_camp */

   PU_PUSHNAME (ctxt_p, "oid_camp");

   stat = asn1PE_Team (ctxt_p, pvalue->oid_camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumObjectType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type_obstacle */

   if (pvalue->m.type_obstaclePresent) {
      PU_PUSHNAME (ctxt_p, "type_obstacle");

      stat = asn1PE_EnumObstacleType (ctxt_p, pvalue->type_obstacle);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode obstacle_de_manoeuvre_active */

   if (pvalue->m.obstacle_de_manoeuvre_activePresent) {
      PU_PUSHNAME (ctxt_p, "obstacle_de_manoeuvre_active");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->obstacle_de_manoeuvre_active);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode localisation */

   PU_PUSHNAME (ctxt_p, "localisation");

   stat = asn1PE_Location (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nom */

   if (pvalue->m.nomPresent) {
      PU_PUSHNAME (ctxt_p, "nom");

      stat = pe_VisibleString (ctxt_p, pvalue->nom, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PE_ObjectAttributesSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MagicActionCreateObject: end\n");
   return (stat);
}

int ASN1C_MagicActionCreateObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionCreateObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MagicActionCreateObject (ASN1CTXT* ctxt_p, ASN1T_MagicActionCreateObject* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MagicActionCreateObject: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "type_obstaclePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.type_obstaclePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "obstacle_de_manoeuvre_activePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.obstacle_de_manoeuvre_activePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nomPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nomPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "attributs_specifiquesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.attributs_specifiquesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_camp */

   PU_PUSHNAME (ctxt_p, "oid_camp");

   stat = asn1PD_Team (ctxt_p, &pvalue->oid_camp);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumObjectType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type_obstacle */

   if (pvalue->m.type_obstaclePresent) {
      PU_PUSHNAME (ctxt_p, "type_obstacle");

      stat = asn1PD_EnumObstacleType (ctxt_p, &pvalue->type_obstacle);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode obstacle_de_manoeuvre_active */

   if (pvalue->m.obstacle_de_manoeuvre_activePresent) {
      PU_PUSHNAME (ctxt_p, "obstacle_de_manoeuvre_active");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->obstacle_de_manoeuvre_active);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }

   /* decode localisation */

   PU_PUSHNAME (ctxt_p, "localisation");

   stat = asn1PD_Location (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nom */

   if (pvalue->m.nomPresent) {
      PU_PUSHNAME (ctxt_p, "nom");

      stat = pd_VisibleString (ctxt_p, &pvalue->nom, 0);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode attributs_specifiques */

   if (pvalue->m.attributs_specifiquesPresent) {
      PU_PUSHNAME (ctxt_p, "attributs_specifiques");

      stat = asn1PD_ObjectAttributesSpecific (ctxt_p, &pvalue->attributs_specifiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MagicActionCreateObject: end\n");

   return (stat);
}

int ASN1C_MagicActionCreateObject::Decode ()
{
   return asn1PD_MagicActionCreateObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MagicActionDestroyObjet                                   */
/*                                                            */
/**************************************************************/

ASN1C_MagicActionDestroyObjet::ASN1C_MagicActionDestroyObjet (
   ASN1MessageBuffer& msgBuf, ASN1T_MagicActionDestroyObjet& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MagicActionDestroyObjet (ASN1CTXT* ctxt_p, ASN1T_MagicActionDestroyObjet value)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MagicActionDestroyObjet: start\n");

   stat = asn1PE_OID (ctxt_p, value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_MagicActionDestroyObjet: end\n");
   return (stat);
}

int ASN1C_MagicActionDestroyObjet::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MagicActionDestroyObjet (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_MagicActionDestroyObjet (ASN1CTXT* ctxt_p, ASN1T_MagicActionDestroyObjet* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MagicActionDestroyObjet: start\n");

   stat = asn1PD_OID (ctxt_p, pvalue);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PD_MagicActionDestroyObjet: end\n");

   return (stat);
}

int ASN1C_MagicActionDestroyObjet::Decode ()
{
   return asn1PD_MagicActionDestroyObjet (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicAction_action                               */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicAction_action::ASN1C_MsgObjectMagicAction_action (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicAction_action& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicAction_action (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction_action* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectMagicAction_action: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (ctxt_p, "t");

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* create_object */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.create_object");

         stat = asn1PE_MagicActionCreateObject (ctxt_p, pvalue->u.create_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* update_object */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.update_object");

         stat = asn1PE_MagicActionUpdateObject (ctxt_p, pvalue->u.update_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* destroy_object */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.destroy_object");

         stat = asn1PE_MagicActionDestroyObjet (ctxt_p, pvalue->u.destroy_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PE_MsgObjectMagicAction_action: end\n");
   return (stat);
}

int ASN1C_MsgObjectMagicAction_action::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicAction_action (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicAction_action (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction_action* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_MsgObjectMagicAction_action: start\n");

   PU_PUSHNAME (ctxt_p, "t");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 2);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (ctxt_p);

   switch (ui) {
      /* create_object */
      case 0:
         PU_PUSHNAME (ctxt_p, "u.create_object");

         pvalue->u.create_object = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MagicActionCreateObject);
         if (pvalue->u.create_object == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_MagicActionCreateObject (ctxt_p, pvalue->u.create_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* update_object */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.update_object");

         pvalue->u.update_object = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MagicActionUpdateObject);
         if (pvalue->u.update_object == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_MagicActionUpdateObject (ctxt_p, pvalue->u.update_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* destroy_object */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.destroy_object");

         stat = asn1PD_MagicActionDestroyObjet (ctxt_p, &pvalue->u.destroy_object);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PD_MsgObjectMagicAction_action: end\n");

   return (stat);
}

int ASN1C_MsgObjectMagicAction_action::Decode ()
{
   return asn1PD_MsgObjectMagicAction_action (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicAction                                      */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicAction::ASN1C_MsgObjectMagicAction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicAction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicAction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectMagicAction: start\n");

   /* encode action */

   PU_PUSHNAME (ctxt_p, "action");

   stat = asn1PE_MsgObjectMagicAction_action (ctxt_p, &pvalue->action);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgObjectMagicAction: end\n");
   return (stat);
}

int ASN1C_MsgObjectMagicAction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicAction (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicAction (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicAction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgObjectMagicAction: start\n");

   /* decode action */

   PU_PUSHNAME (ctxt_p, "action");

   stat = asn1PD_MsgObjectMagicAction_action (ctxt_p, &pvalue->action);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgObjectMagicAction: end\n");

   return (stat);
}

int ASN1C_MsgObjectMagicAction::Decode ()
{
   return asn1PD_MsgObjectMagicAction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgObjectMagicActionAck                                   */
/*                                                            */
/**************************************************************/

ASN1C_MsgObjectMagicActionAck::ASN1C_MsgObjectMagicActionAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgObjectMagicActionAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgObjectMagicActionAck (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicActionAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgObjectMagicActionAck: start\n");

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumObjectErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgObjectMagicActionAck: end\n");
   return (stat);
}

int ASN1C_MsgObjectMagicActionAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgObjectMagicActionAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgObjectMagicActionAck (ASN1CTXT* ctxt_p, ASN1T_MsgObjectMagicActionAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgObjectMagicActionAck: start\n");

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumObjectErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgObjectMagicActionAck: end\n");

   return (stat);
}

int ASN1C_MsgObjectMagicActionAck::Decode ()
{
   return asn1PD_MsgObjectMagicActionAck (mpContext->GetPtr(), &msgData);
}

