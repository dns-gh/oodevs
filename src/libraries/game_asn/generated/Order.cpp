/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 06-Jan-2010.
 */
#include "Order.h"

/**************************************************************/
/*                                                            */
/*  OrderIncludes                                             */
/*                                                            */
/**************************************************************/

ASN1C_OrderIncludes::ASN1C_OrderIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_OrderIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_OrderIncludes (ASN1CTXT* ctxt_p, ASN1T_OrderIncludes* pvalue)
{
   int stat = ASN_OK;

   /* encode baseExports */

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* encode limaLimiteExports */

   stat = asn1PE_LimaLimiteExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* encode logMaintenanceExports */

   stat = asn1PE_LogMaintenanceExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* encode logSanteExports */

   stat = asn1PE_LogSanteExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* encode objectExports */

   stat = asn1PE_ObjectExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* encode intelligenceExports */

   stat = asn1PE_IntelligenceExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_OrderIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_OrderIncludes (ASN1CTXT* ctxt_p, ASN1T_OrderIncludes* pvalue)
{
   int stat = ASN_OK;

   /* decode baseExports */

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* decode limaLimiteExports */

   stat = asn1PD_LimaLimiteExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* decode logMaintenanceExports */

   stat = asn1PD_LogMaintenanceExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* decode logSanteExports */

   stat = asn1PD_LogSanteExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* decode objectExports */

   stat = asn1PD_ObjectExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* decode intelligenceExports */

   stat = asn1PD_IntelligenceExports (ctxt_p);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_OrderIncludes::Decode ()
{
   return asn1PD_OrderIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  OrderExports                                              */
/*                                                            */
/**************************************************************/

ASN1C_OrderExports::ASN1C_OrderExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_OrderExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */
   return (stat);
}

int ASN1C_OrderExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_OrderExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */

   return (stat);
}

int ASN1C_OrderExports::Decode ()
{
   return asn1PD_OrderExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  EnumOrderErrorCode                                        */
/*                                                            */
/**************************************************************/

ASN1C_EnumOrderErrorCode::ASN1C_EnumOrderErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumOrderErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumOrderErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumOrderErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   switch (value) {
      case EnumOrderErrorCode::no_error: ui = 0; break;
      case EnumOrderErrorCode::error_invalid_unit: ui = 1; break;
      case EnumOrderErrorCode::error_invalid_limit: ui = 2; break;
      case EnumOrderErrorCode::error_invalid_lima: ui = 3; break;
      case EnumOrderErrorCode::error_invalid_mission: ui = 4; break;
      case EnumOrderErrorCode::error_invalid_mission_parameters: ui = 5; break;
      case EnumOrderErrorCode::error_unit_cannot_receive_order: ui = 6; break;
      case EnumOrderErrorCode::error_invalid_order_conduite: ui = 7; break;
      case EnumOrderErrorCode::error_invalid_order_mission: ui = 8; break;
      case EnumOrderErrorCode::error_invalid_order_initial: ui = 9; break;
      case EnumOrderErrorCode::error_invalid_order_conduite_parameters: ui = 10; break;
      case EnumOrderErrorCode::error_unit_surrendered: ui = 11; break;
      case EnumOrderErrorCode::error_invalid_lima_function: ui = 12; break;
      default: return ASN_E_INVENUM;
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 12);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_EnumOrderErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumOrderErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumOrderErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumOrderErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 12);
   if (stat != ASN_OK) return stat;

   switch (ui) {
      case 0: *pvalue = EnumOrderErrorCode::no_error; break;
      case 1: *pvalue = EnumOrderErrorCode::error_invalid_unit; break;
      case 2: *pvalue = EnumOrderErrorCode::error_invalid_limit; break;
      case 3: *pvalue = EnumOrderErrorCode::error_invalid_lima; break;
      case 4: *pvalue = EnumOrderErrorCode::error_invalid_mission; break;
      case 5: *pvalue = EnumOrderErrorCode::error_invalid_mission_parameters; break;
      case 6: *pvalue = EnumOrderErrorCode::error_unit_cannot_receive_order; break;
      case 7: *pvalue = EnumOrderErrorCode::error_invalid_order_conduite; break;
      case 8: *pvalue = EnumOrderErrorCode::error_invalid_order_mission; break;
      case 9: *pvalue = EnumOrderErrorCode::error_invalid_order_initial; break;
      case 10: *pvalue = EnumOrderErrorCode::error_invalid_order_conduite_parameters; break;
      case 11: *pvalue = EnumOrderErrorCode::error_unit_surrendered; break;
      case 12: *pvalue = EnumOrderErrorCode::error_invalid_lima_function; break;
      default: return ASN_E_INVENUM;
   }

   return (stat);
}

int ASN1C_EnumOrderErrorCode::Decode ()
{
   return asn1PD_EnumOrderErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionObjective                                          */
/*                                                            */
/**************************************************************/

ASN1C_MissionObjective::ASN1C_MissionObjective (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionObjective& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionObjective (ASN1CTXT* ctxt_p, ASN1T_MissionObjective* pvalue)
{
   int stat = ASN_OK;

   /* encode localisation */

   stat = asn1PE_Location (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return stat;

   /* encode horaire */

   stat = asn1PE_DateTime (ctxt_p, pvalue->horaire);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MissionObjective::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionObjective (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionObjective (ASN1CTXT* ctxt_p, ASN1T_MissionObjective* pvalue)
{
   int stat = ASN_OK;

   /* decode localisation */

   stat = asn1PD_Location (ctxt_p, &pvalue->localisation);
   if (stat != ASN_OK) return stat;

   /* decode horaire */

   stat = asn1PD_DateTime (ctxt_p, &pvalue->horaire);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MissionObjective::Decode ()
{
   return asn1PD_MissionObjective (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionObjectiveList                                      */
/*                                                            */
/**************************************************************/

ASN1C_MissionObjectiveList::ASN1C_MissionObjectiveList (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionObjectiveList& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionObjectiveList (ASN1CTXT* ctxt_p, ASN1T_MissionObjectiveList* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* encode length determinant */

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_MissionObjective (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }
   return (stat);
}

int ASN1C_MissionObjectiveList::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionObjectiveList (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionObjectiveList (ASN1CTXT* ctxt_p, ASN1T_MissionObjectiveList* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return stat;

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_MissionObjective);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MissionObjective (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_MissionObjectiveList::Decode ()
{
   return asn1PD_MissionObjectiveList (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  PlannedWork                                               */
/*                                                            */
/**************************************************************/

ASN1C_PlannedWork::ASN1C_PlannedWork (
   ASN1MessageBuffer& msgBuf, ASN1T_PlannedWork& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_PlannedWork (ASN1CTXT* ctxt_p, ASN1T_PlannedWork* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->type_obstacle != EnumDemolitionTargetType::preliminary));

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->densite != 0));

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->tc2 != 0));

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->activity_time != 0));

   /* encode type */

   stat = pe_VisibleString (ctxt_p, pvalue->type, 0);
   if (stat != ASN_OK) return stat;

   /* encode position */

   stat = asn1PE_Location (ctxt_p, &pvalue->position);
   if (stat != ASN_OK) return stat;

   /* encode type_obstacle */

   if (pvalue->type_obstacle != EnumDemolitionTargetType::preliminary) {
      stat = asn1PE_EnumDemolitionTargetType (ctxt_p, pvalue->type_obstacle);
      if (stat != ASN_OK) return stat;
   }

   /* encode densite */

   if (pvalue->densite != 0) {
      stat = pe_Real (ctxt_p, pvalue->densite);if (stat != ASN_OK) return stat;
   }

   /* encode tc2 */

   if (pvalue->tc2 != 0) {
      stat = asn1PE_Automat (ctxt_p, pvalue->tc2);
      if (stat != ASN_OK) return stat;
   }

   /* encode activity_time */

   if (pvalue->activity_time != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->activity_time);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_PlannedWork::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PlannedWork (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_PlannedWork (ASN1CTXT* ctxt_p, ASN1T_PlannedWork* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL type_obstaclePresent;
   ASN1BOOL densitePresent;
   ASN1BOOL tc2Present;
   ASN1BOOL activity_timePresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   type_obstaclePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   densitePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   tc2Present = optbit;

   pd_bit (ctxt_p, &optbit);
   activity_timePresent = optbit;

   /* decode type */

   stat = pd_VisibleString (ctxt_p, &pvalue->type, 0);
   if (stat != ASN_OK) return stat;

   /* decode position */

   stat = asn1PD_Location (ctxt_p, &pvalue->position);
   if (stat != ASN_OK) return stat;

   /* decode type_obstacle */

   if (type_obstaclePresent) {
      stat = asn1PD_EnumDemolitionTargetType (ctxt_p, &pvalue->type_obstacle);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->type_obstacle = EnumDemolitionTargetType::preliminary;
   }

   /* decode densite */

   if (densitePresent) {
      stat = pd_Real (ctxt_p, &pvalue->densite);if (stat != ASN_OK) return stat;
   }
   else {
   }

   /* decode tc2 */

   if (tc2Present) {
      stat = asn1PD_Automat (ctxt_p, &pvalue->tc2);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->tc2 = 0;
   }

   /* decode activity_time */

   if (activity_timePresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->activity_time);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->activity_time = 0;
   }


   return (stat);
}

int ASN1C_PlannedWork::Decode ()
{
   return asn1PD_PlannedWork (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  PlannedWorkList                                           */
/*                                                            */
/**************************************************************/

ASN1C_PlannedWorkList::ASN1C_PlannedWorkList (
   ASN1MessageBuffer& msgBuf, ASN1T_PlannedWorkList& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_PlannedWorkList (ASN1CTXT* ctxt_p, ASN1T_PlannedWorkList* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* encode length determinant */

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_PlannedWork (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }
   return (stat);
}

int ASN1C_PlannedWorkList::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PlannedWorkList (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_PlannedWorkList (ASN1CTXT* ctxt_p, ASN1T_PlannedWorkList* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return stat;

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_PlannedWork);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_PlannedWork (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_PlannedWorkList::Decode ()
{
   return asn1PD_PlannedWorkList (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameter_value                                    */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameter_value::ASN1C_MissionParameter_value (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameter_value& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameter_value (ASN1CTXT* ctxt_p, ASN1T_MissionParameter_value* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 36);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* aBool */
      case 1:
         stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->u.aBool);
         if (stat != ASN_OK) return stat;
         break;

      /* aReal */
      case 2:
         stat = pe_Real (ctxt_p, pvalue->u.aReal);if (stat != ASN_OK) return stat;
         break;

      /* enumeration */
      case 3:
         stat = pe_UnconsInteger (ctxt_p, pvalue->u.enumeration);
         if (stat != ASN_OK) return stat;
         break;

      /* path */
      case 4:
         stat = asn1PE_Path (ctxt_p, pvalue->u.path);
         if (stat != ASN_OK) return stat;
         break;

      /* pathList */
      case 5:
         stat = asn1PE_PathList (ctxt_p, pvalue->u.pathList);
         if (stat != ASN_OK) return stat;
         break;

      /* point */
      case 6:
         stat = asn1PE_Point (ctxt_p, pvalue->u.point);
         if (stat != ASN_OK) return stat;
         break;

      /* pointList */
      case 7:
         stat = asn1PE_PointList (ctxt_p, pvalue->u.pointList);
         if (stat != ASN_OK) return stat;
         break;

      /* polygon */
      case 8:
         stat = asn1PE_Polygon (ctxt_p, pvalue->u.polygon);
         if (stat != ASN_OK) return stat;
         break;

      /* polygonList */
      case 9:
         stat = asn1PE_PolygonList (ctxt_p, pvalue->u.polygonList);
         if (stat != ASN_OK) return stat;
         break;

      /* location */
      case 10:
         stat = asn1PE_Location (ctxt_p, pvalue->u.location);
         if (stat != ASN_OK) return stat;
         break;

      /* locationList */
      case 11:
         stat = asn1PE_LocationList (ctxt_p, pvalue->u.locationList);
         if (stat != ASN_OK) return stat;
         break;

      /* heading */
      case 12:
         stat = asn1PE_Heading (ctxt_p, pvalue->u.heading);
         if (stat != ASN_OK) return stat;
         break;

      /* atlasNature */
      case 13:
         stat = asn1PE_AtlasNature (ctxt_p, *pvalue->u.atlasNature);
         if (stat != ASN_OK) return stat;
         break;

      /* unit */
      case 14:
         stat = asn1PE_Unit (ctxt_p, pvalue->u.unit);
         if (stat != ASN_OK) return stat;
         break;

      /* unitList */
      case 15:
         stat = asn1PE_UnitList (ctxt_p, pvalue->u.unitList);
         if (stat != ASN_OK) return stat;
         break;

      /* automat */
      case 16:
         stat = asn1PE_Automat (ctxt_p, pvalue->u.automat);
         if (stat != ASN_OK) return stat;
         break;

      /* automatList */
      case 17:
         stat = asn1PE_AutomatList (ctxt_p, pvalue->u.automatList);
         if (stat != ASN_OK) return stat;
         break;

      /* unitKnowledge */
      case 18:
         stat = asn1PE_UnitKnowledge (ctxt_p, pvalue->u.unitKnowledge);
         if (stat != ASN_OK) return stat;
         break;

      /* unitKnowledgeList */
      case 19:
         stat = asn1PE_UnitKnowledgeList (ctxt_p, pvalue->u.unitKnowledgeList);
         if (stat != ASN_OK) return stat;
         break;

      /* objectKnowledge */
      case 20:
         stat = asn1PE_ObjectKnowledge (ctxt_p, pvalue->u.objectKnowledge);
         if (stat != ASN_OK) return stat;
         break;

      /* objectKnowledgeList */
      case 21:
         stat = asn1PE_ObjectKnowledgeList (ctxt_p, pvalue->u.objectKnowledgeList);
         if (stat != ASN_OK) return stat;
         break;

      /* populationKnowledge */
      case 22:
         stat = asn1PE_PopulationKnowledge (ctxt_p, pvalue->u.populationKnowledge);
         if (stat != ASN_OK) return stat;
         break;

      /* plannedWork */
      case 23:
         stat = asn1PE_PlannedWork (ctxt_p, pvalue->u.plannedWork);
         if (stat != ASN_OK) return stat;
         break;

      /* plannedWorkList */
      case 24:
         stat = asn1PE_PlannedWorkList (ctxt_p, pvalue->u.plannedWorkList);
         if (stat != ASN_OK) return stat;
         break;

      /* dotationType */
      case 25:
         stat = asn1PE_DotationType (ctxt_p, pvalue->u.dotationType);
         if (stat != ASN_OK) return stat;
         break;

      /* equipmentType */
      case 26:
         stat = asn1PE_EquipmentType (ctxt_p, pvalue->u.equipmentType);
         if (stat != ASN_OK) return stat;
         break;

      /* tirIndirect */
      case 27:
         stat = asn1PE_UnitFire (ctxt_p, pvalue->u.tirIndirect);
         if (stat != ASN_OK) return stat;
         break;

      /* dateTime */
      case 28:
         stat = asn1PE_DateTime (ctxt_p, *pvalue->u.dateTime);
         if (stat != ASN_OK) return stat;
         break;

      /* logMaintenancePriorities */
      case 29:
         stat = asn1PE_LogMaintenancePriorities (ctxt_p, pvalue->u.logMaintenancePriorities);
         if (stat != ASN_OK) return stat;
         break;

      /* logMedicalPriorities */
      case 30:
         stat = asn1PE_LogMedicalPriorities (ctxt_p, pvalue->u.logMedicalPriorities);
         if (stat != ASN_OK) return stat;
         break;

      /* aCharStr */
      case 31:
         stat = pe_VisibleString (ctxt_p, pvalue->u.aCharStr, 0);
         if (stat != ASN_OK) return stat;
         break;

      /* missionObjective */
      case 32:
         stat = asn1PE_MissionObjective (ctxt_p, pvalue->u.missionObjective);
         if (stat != ASN_OK) return stat;
         break;

      /* missionObjectiveList */
      case 33:
         stat = asn1PE_MissionObjectiveList (ctxt_p, pvalue->u.missionObjectiveList);
         if (stat != ASN_OK) return stat;
         break;

      /* line */
      case 34:
         stat = asn1PE_Line (ctxt_p, pvalue->u.line);
         if (stat != ASN_OK) return stat;
         break;

      /* limasOrder */
      case 35:
         stat = asn1PE_LimasOrder (ctxt_p, pvalue->u.limasOrder);
         if (stat != ASN_OK) return stat;
         break;

      /* intelligenceList */
      case 36:
         stat = asn1PE_IntelligenceList (ctxt_p, pvalue->u.intelligenceList);
         if (stat != ASN_OK) return stat;
         break;

      /* urbanBlock */
      case 37:
         stat = asn1PE_UrbanBlock (ctxt_p, pvalue->u.urbanBlock);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MissionParameter_value::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameter_value (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameter_value (ASN1CTXT* ctxt_p, ASN1T_MissionParameter_value* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 36);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* aBool */
      case 0:
         stat = pd_bit (ctxt_p, &pvalue->u.aBool);
         if (stat != ASN_OK) return stat;

         break;

      /* aReal */
      case 1:
         stat = pd_Real (ctxt_p, &pvalue->u.aReal);if (stat != ASN_OK) return stat;

         break;

      /* enumeration */
      case 2:
         stat = pd_UnconsInteger (ctxt_p, &pvalue->u.enumeration);
         if (stat != ASN_OK) return stat;

         break;

      /* path */
      case 3:
         pvalue->u.path = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Path);

         stat = asn1PD_Path (ctxt_p, pvalue->u.path);
         if (stat != ASN_OK) return stat;

         break;

      /* pathList */
      case 4:
         pvalue->u.pathList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PathList);

         stat = asn1PD_PathList (ctxt_p, pvalue->u.pathList);
         if (stat != ASN_OK) return stat;

         break;

      /* point */
      case 5:
         pvalue->u.point = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Point);

         stat = asn1PD_Point (ctxt_p, pvalue->u.point);
         if (stat != ASN_OK) return stat;

         break;

      /* pointList */
      case 6:
         pvalue->u.pointList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PointList);

         stat = asn1PD_PointList (ctxt_p, pvalue->u.pointList);
         if (stat != ASN_OK) return stat;

         break;

      /* polygon */
      case 7:
         pvalue->u.polygon = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Polygon);

         stat = asn1PD_Polygon (ctxt_p, pvalue->u.polygon);
         if (stat != ASN_OK) return stat;

         break;

      /* polygonList */
      case 8:
         pvalue->u.polygonList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PolygonList);

         stat = asn1PD_PolygonList (ctxt_p, pvalue->u.polygonList);
         if (stat != ASN_OK) return stat;

         break;

      /* location */
      case 9:
         pvalue->u.location = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Location);

         stat = asn1PD_Location (ctxt_p, pvalue->u.location);
         if (stat != ASN_OK) return stat;

         break;

      /* locationList */
      case 10:
         pvalue->u.locationList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_LocationList);

         stat = asn1PD_LocationList (ctxt_p, pvalue->u.locationList);
         if (stat != ASN_OK) return stat;

         break;

      /* heading */
      case 11:
         stat = asn1PD_Heading (ctxt_p, &pvalue->u.heading);
         if (stat != ASN_OK) return stat;

         break;

      /* atlasNature */
      case 12:
         pvalue->u.atlasNature = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AtlasNature);

         stat = asn1PD_AtlasNature (ctxt_p, pvalue->u.atlasNature);
         if (stat != ASN_OK) return stat;

         break;

      /* unit */
      case 13:
         stat = asn1PD_Unit (ctxt_p, &pvalue->u.unit);
         if (stat != ASN_OK) return stat;

         break;

      /* unitList */
      case 14:
         pvalue->u.unitList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_UnitList);

         stat = asn1PD_UnitList (ctxt_p, pvalue->u.unitList);
         if (stat != ASN_OK) return stat;

         break;

      /* automat */
      case 15:
         stat = asn1PD_Automat (ctxt_p, &pvalue->u.automat);
         if (stat != ASN_OK) return stat;

         break;

      /* automatList */
      case 16:
         pvalue->u.automatList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AutomatList);

         stat = asn1PD_AutomatList (ctxt_p, pvalue->u.automatList);
         if (stat != ASN_OK) return stat;

         break;

      /* unitKnowledge */
      case 17:
         stat = asn1PD_UnitKnowledge (ctxt_p, &pvalue->u.unitKnowledge);
         if (stat != ASN_OK) return stat;

         break;

      /* unitKnowledgeList */
      case 18:
         pvalue->u.unitKnowledgeList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_UnitKnowledgeList);

         stat = asn1PD_UnitKnowledgeList (ctxt_p, pvalue->u.unitKnowledgeList);
         if (stat != ASN_OK) return stat;

         break;

      /* objectKnowledge */
      case 19:
         stat = asn1PD_ObjectKnowledge (ctxt_p, &pvalue->u.objectKnowledge);
         if (stat != ASN_OK) return stat;

         break;

      /* objectKnowledgeList */
      case 20:
         pvalue->u.objectKnowledgeList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectKnowledgeList);

         stat = asn1PD_ObjectKnowledgeList (ctxt_p, pvalue->u.objectKnowledgeList);
         if (stat != ASN_OK) return stat;

         break;

      /* populationKnowledge */
      case 21:
         stat = asn1PD_PopulationKnowledge (ctxt_p, &pvalue->u.populationKnowledge);
         if (stat != ASN_OK) return stat;

         break;

      /* plannedWork */
      case 22:
         pvalue->u.plannedWork = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PlannedWork);

         stat = asn1PD_PlannedWork (ctxt_p, pvalue->u.plannedWork);
         if (stat != ASN_OK) return stat;

         break;

      /* plannedWorkList */
      case 23:
         pvalue->u.plannedWorkList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PlannedWorkList);

         stat = asn1PD_PlannedWorkList (ctxt_p, pvalue->u.plannedWorkList);
         if (stat != ASN_OK) return stat;

         break;

      /* dotationType */
      case 24:
         stat = asn1PD_DotationType (ctxt_p, &pvalue->u.dotationType);
         if (stat != ASN_OK) return stat;

         break;

      /* equipmentType */
      case 25:
         stat = asn1PD_EquipmentType (ctxt_p, &pvalue->u.equipmentType);
         if (stat != ASN_OK) return stat;

         break;

      /* tirIndirect */
      case 26:
         stat = asn1PD_UnitFire (ctxt_p, &pvalue->u.tirIndirect);
         if (stat != ASN_OK) return stat;

         break;

      /* dateTime */
      case 27:
         pvalue->u.dateTime = ALLOC_ASN1ELEM (ctxt_p, ASN1T_DateTime);

         stat = asn1PD_DateTime (ctxt_p, pvalue->u.dateTime);
         if (stat != ASN_OK) return stat;

         break;

      /* logMaintenancePriorities */
      case 28:
         pvalue->u.logMaintenancePriorities = ALLOC_ASN1ELEM (ctxt_p, ASN1T_LogMaintenancePriorities);

         stat = asn1PD_LogMaintenancePriorities (ctxt_p, pvalue->u.logMaintenancePriorities);
         if (stat != ASN_OK) return stat;

         break;

      /* logMedicalPriorities */
      case 29:
         pvalue->u.logMedicalPriorities = ALLOC_ASN1ELEM (ctxt_p, ASN1T_LogMedicalPriorities);

         stat = asn1PD_LogMedicalPriorities (ctxt_p, pvalue->u.logMedicalPriorities);
         if (stat != ASN_OK) return stat;

         break;

      /* aCharStr */
      case 30:
         stat = pd_VisibleString (ctxt_p, &pvalue->u.aCharStr, 0);
         if (stat != ASN_OK) return stat;

         break;

      /* missionObjective */
      case 31:
         pvalue->u.missionObjective = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MissionObjective);

         stat = asn1PD_MissionObjective (ctxt_p, pvalue->u.missionObjective);
         if (stat != ASN_OK) return stat;

         break;

      /* missionObjectiveList */
      case 32:
         pvalue->u.missionObjectiveList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MissionObjectiveList);

         stat = asn1PD_MissionObjectiveList (ctxt_p, pvalue->u.missionObjectiveList);
         if (stat != ASN_OK) return stat;

         break;

      /* line */
      case 33:
         pvalue->u.line = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Line);

         stat = asn1PD_Line (ctxt_p, pvalue->u.line);
         if (stat != ASN_OK) return stat;

         break;

      /* limasOrder */
      case 34:
         pvalue->u.limasOrder = ALLOC_ASN1ELEM (ctxt_p, ASN1T_LimasOrder);

         stat = asn1PD_LimasOrder (ctxt_p, pvalue->u.limasOrder);
         if (stat != ASN_OK) return stat;

         break;

      /* intelligenceList */
      case 35:
         pvalue->u.intelligenceList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_IntelligenceList);

         stat = asn1PD_IntelligenceList (ctxt_p, pvalue->u.intelligenceList);
         if (stat != ASN_OK) return stat;

         break;

      /* urbanBlock */
      case 36:
         stat = asn1PD_UrbanBlock (ctxt_p, &pvalue->u.urbanBlock);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MissionParameter_value::Decode ()
{
   return asn1PD_MissionParameter_value (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameter                                          */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameter::ASN1C_MissionParameter (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameter& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameter (ASN1CTXT* ctxt_p, ASN1T_MissionParameter* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->null_value != FALSE));

   /* encode null_value */

   if (pvalue->null_value != FALSE) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->null_value);
      if (stat != ASN_OK) return stat;
   }

   /* encode value */

   stat = asn1PE_MissionParameter_value (ctxt_p, &pvalue->value);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MissionParameter::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameter (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameter (ASN1CTXT* ctxt_p, ASN1T_MissionParameter* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL null_valuePresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   null_valuePresent = optbit;

   /* decode null_value */

   if (null_valuePresent) {
      stat = pd_bit (ctxt_p, &pvalue->null_value);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->null_value = FALSE;
   }

   /* decode value */

   stat = asn1PD_MissionParameter_value (ctxt_p, &pvalue->value);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MissionParameter::Decode ()
{
   return asn1PD_MissionParameter (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameters                                         */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameters::ASN1C_MissionParameters (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameters& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameters (ASN1CTXT* ctxt_p, ASN1T_MissionParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* encode length determinant */

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_MissionParameter (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }
   return (stat);
}

int ASN1C_MissionParameters::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameters (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameters (ASN1CTXT* ctxt_p, ASN1T_MissionParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return stat;

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_MissionParameter);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_MissionParameter (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_MissionParameters::Decode ()
{
   return asn1PD_MissionParameters (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgUnitOrder                                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgUnitOrder::ASN1C_MsgUnitOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgUnitOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgUnitOrder (ASN1CTXT* ctxt_p, ASN1T_MsgUnitOrder* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_Unit (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode mission */

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return stat;

   /* encode parametres */

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgUnitOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgUnitOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgUnitOrder (ASN1CTXT* ctxt_p, ASN1T_MsgUnitOrder* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode mission */

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return stat;

   /* decode parametres */

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgUnitOrder::Decode ()
{
   return asn1PD_MsgUnitOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgUnitOrderAck                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgUnitOrderAck::ASN1C_MsgUnitOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgUnitOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgUnitOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgUnitOrderAck* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_Unit (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode error_code */

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgUnitOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgUnitOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgUnitOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgUnitOrderAck* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode error_code */

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgUnitOrderAck::Decode ()
{
   return asn1PD_MsgUnitOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumAutomatOrderFormation                                 */
/*                                                            */
/**************************************************************/

ASN1C_EnumAutomatOrderFormation::ASN1C_EnumAutomatOrderFormation (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumAutomatOrderFormation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumAutomatOrderFormation (ASN1CTXT* ctxt_p, ASN1T_EnumAutomatOrderFormation value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   switch (value) {
      case EnumAutomatOrderFormation::un_echelon: ui = 0; break;
      case EnumAutomatOrderFormation::deux_echelons: ui = 1; break;
      default: return ASN_E_INVENUM;
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 1);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_EnumAutomatOrderFormation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumAutomatOrderFormation (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumAutomatOrderFormation (ASN1CTXT* ctxt_p, ASN1T_EnumAutomatOrderFormation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return stat;

   switch (ui) {
      case 0: *pvalue = EnumAutomatOrderFormation::un_echelon; break;
      case 1: *pvalue = EnumAutomatOrderFormation::deux_echelons; break;
      default: return ASN_E_INVENUM;
   }

   return (stat);
}

int ASN1C_EnumAutomatOrderFormation::Decode ()
{
   return asn1PD_EnumAutomatOrderFormation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomatOrder                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomatOrder::ASN1C_MsgAutomatOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomatOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomatOrder (ASN1CTXT* ctxt_p, ASN1T_MsgAutomatOrder* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_Automat (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode mission */

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return stat;

   /* encode parametres */

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgAutomatOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomatOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomatOrder (ASN1CTXT* ctxt_p, ASN1T_MsgAutomatOrder* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_Automat (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode mission */

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return stat;

   /* decode parametres */

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgAutomatOrder::Decode ()
{
   return asn1PD_MsgAutomatOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomatOrderAck                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomatOrderAck::ASN1C_MsgAutomatOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomatOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomatOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgAutomatOrderAck* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_Automat (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode error_code */

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgAutomatOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomatOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomatOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgAutomatOrderAck* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_Automat (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode error_code */

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgAutomatOrderAck::Decode ()
{
   return asn1PD_MsgAutomatOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationOrder                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationOrder::ASN1C_MsgPopulationOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationOrder (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrder* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_Population (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode mission */

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return stat;

   /* encode parametres */

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgPopulationOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationOrder (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrder* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_Population (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode mission */

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return stat;

   /* decode parametres */

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgPopulationOrder::Decode ()
{
   return asn1PD_MsgPopulationOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationOrderAck                                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationOrderAck::ASN1C_MsgPopulationOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrderAck* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_Population (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode error_code */

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgPopulationOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrderAck* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_Population (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode error_code */

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgPopulationOrderAck::Decode ()
{
   return asn1PD_MsgPopulationOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgFragOrder                                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgFragOrder::ASN1C_MsgFragOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgFragOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgFragOrder (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrder* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode frag_order */

   stat = asn1PE_OID (ctxt_p, pvalue->frag_order);
   if (stat != ASN_OK) return stat;

   /* encode parametres */

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgFragOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgFragOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgFragOrder (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrder* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode frag_order */

   stat = asn1PD_OID (ctxt_p, &pvalue->frag_order);
   if (stat != ASN_OK) return stat;

   /* decode parametres */

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgFragOrder::Decode ()
{
   return asn1PD_MsgFragOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgFragOrderAck                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgFragOrderAck::ASN1C_MsgFragOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgFragOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgFragOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrderAck* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode error_code */

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgFragOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgFragOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgFragOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrderAck* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode error_code */

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgFragOrderAck::Decode ()
{
   return asn1PD_MsgFragOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumReportType                                            */
/*                                                            */
/**************************************************************/

ASN1C_EnumReportType::ASN1C_EnumReportType (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumReportType& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumReportType (ASN1CTXT* ctxt_p, ASN1T_EnumReportType value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   switch (value) {
      case EnumReportType::message: ui = 0; break;
      case EnumReportType::operationel: ui = 1; break;
      case EnumReportType::evenement_exceptionnel: ui = 2; break;
      case EnumReportType::warning: ui = 3; break;
      default: return ASN_E_INVENUM;
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 3);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_EnumReportType::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumReportType (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumReportType (ASN1CTXT* ctxt_p, ASN1T_EnumReportType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 3);
   if (stat != ASN_OK) return stat;

   switch (ui) {
      case 0: *pvalue = EnumReportType::message; break;
      case 1: *pvalue = EnumReportType::operationel; break;
      case 2: *pvalue = EnumReportType::evenement_exceptionnel; break;
      case 3: *pvalue = EnumReportType::warning; break;
      default: return ASN_E_INVENUM;
   }

   return (stat);
}

int ASN1C_EnumReportType::Decode ()
{
   return asn1PD_EnumReportType (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgReport                                                 */
/*                                                            */
/**************************************************************/

ASN1C_MsgReport::ASN1C_MsgReport (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgReport& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgReport (ASN1CTXT* ctxt_p, ASN1T_MsgReport* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode cr */

   stat = asn1PE_OID (ctxt_p, pvalue->cr);
   if (stat != ASN_OK) return stat;

   /* encode cr_oid */

   stat = asn1PE_OID (ctxt_p, pvalue->cr_oid);
   if (stat != ASN_OK) return stat;

   /* encode type */

   stat = asn1PE_EnumReportType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return stat;

   /* encode time */

   stat = asn1PE_DateTime (ctxt_p, pvalue->time);
   if (stat != ASN_OK) return stat;

   /* encode parametres */

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgReport::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgReport (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgReport (ASN1CTXT* ctxt_p, ASN1T_MsgReport* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode cr */

   stat = asn1PD_OID (ctxt_p, &pvalue->cr);
   if (stat != ASN_OK) return stat;

   /* decode cr_oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->cr_oid);
   if (stat != ASN_OK) return stat;

   /* decode type */

   stat = asn1PD_EnumReportType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return stat;

   /* decode time */

   stat = asn1PD_DateTime (ctxt_p, &pvalue->time);
   if (stat != ASN_OK) return stat;

   /* decode parametres */

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgReport::Decode ()
{
   return asn1PD_MsgReport (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgInvalidateReport                                       */
/*                                                            */
/**************************************************************/

ASN1C_MsgInvalidateReport::ASN1C_MsgInvalidateReport (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgInvalidateReport& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgInvalidateReport (ASN1CTXT* ctxt_p, ASN1T_MsgInvalidateReport* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode cr_oid */

   stat = asn1PE_OID (ctxt_p, pvalue->cr_oid);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgInvalidateReport::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgInvalidateReport (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgInvalidateReport (ASN1CTXT* ctxt_p, ASN1T_MsgInvalidateReport* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode cr_oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->cr_oid);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgInvalidateReport::Decode ()
{
   return asn1PD_MsgInvalidateReport (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgTrace                                                  */
/*                                                            */
/**************************************************************/

ASN1C_MsgTrace::ASN1C_MsgTrace (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgTrace& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgTrace (ASN1CTXT* ctxt_p, ASN1T_MsgTrace* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode message */

   stat = pe_VisibleString (ctxt_p, pvalue->message, 0);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgTrace::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgTrace (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgTrace (ASN1CTXT* ctxt_p, ASN1T_MsgTrace* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode message */

   stat = pd_VisibleString (ctxt_p, &pvalue->message, 0);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgTrace::Decode ()
{
   return asn1PD_MsgTrace (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgDecisionalState                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgDecisionalState::ASN1C_MsgDecisionalState (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgDecisionalState& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgDecisionalState (ASN1CTXT* ctxt_p, ASN1T_MsgDecisionalState* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode key */

   stat = pe_VisibleString (ctxt_p, pvalue->key, 0);
   if (stat != ASN_OK) return stat;

   /* encode value */

   stat = pe_VisibleString (ctxt_p, pvalue->value, 0);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgDecisionalState::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgDecisionalState (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgDecisionalState (ASN1CTXT* ctxt_p, ASN1T_MsgDecisionalState* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode key */

   stat = pd_VisibleString (ctxt_p, &pvalue->key, 0);
   if (stat != ASN_OK) return stat;

   /* decode value */

   stat = pd_VisibleString (ctxt_p, &pvalue->value, 0);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgDecisionalState::Decode ()
{
   return asn1PD_MsgDecisionalState (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgDebugPoints                                            */
/*                                                            */
/**************************************************************/

ASN1C_MsgDebugPoints::ASN1C_MsgDebugPoints (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgDebugPoints& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgDebugPoints (ASN1CTXT* ctxt_p, ASN1T_MsgDebugPoints* pvalue)
{
   int stat = ASN_OK;

   /* encode oid */

   stat = asn1PE_OID (ctxt_p, pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* encode coordinates */

   stat = asn1PE_CoordLatLongList (ctxt_p, &pvalue->coordinates);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgDebugPoints::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgDebugPoints (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgDebugPoints (ASN1CTXT* ctxt_p, ASN1T_MsgDebugPoints* pvalue)
{
   int stat = ASN_OK;

   /* decode oid */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid);
   if (stat != ASN_OK) return stat;

   /* decode coordinates */

   stat = asn1PD_CoordLatLongList (ctxt_p, &pvalue->coordinates);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgDebugPoints::Decode ()
{
   return asn1PD_MsgDebugPoints (mpContext->GetPtr(), &msgData);
}

