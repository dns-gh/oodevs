/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 25-Jun-2007.
 */
#include "Order.h"

/**************************************************************/
/*                                                            */
/*  OrderIncludes                                             */
/*                                                            */
/**************************************************************/

ASN1C_OrderIncludes::ASN1C_OrderIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_OrderIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_OrderIncludes (ASN1CTXT* ctxt_p, ASN1T_OrderIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_OrderIncludes: start\n");

   /* encode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode limaLimiteExports */

   PU_PUSHNAME (ctxt_p, "limaLimiteExports");

   stat = asn1PE_LimaLimiteExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode logMaintenanceExports */

   PU_PUSHNAME (ctxt_p, "logMaintenanceExports");

   stat = asn1PE_LogMaintenanceExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode logSanteExports */

   PU_PUSHNAME (ctxt_p, "logSanteExports");

   stat = asn1PE_LogSanteExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode objectExports */

   PU_PUSHNAME (ctxt_p, "objectExports");

   stat = asn1PE_ObjectExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_OrderIncludes: end\n");
   return (stat);
}

int ASN1C_OrderIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_OrderIncludes (ASN1CTXT* ctxt_p, ASN1T_OrderIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_OrderIncludes: start\n");

   /* decode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode limaLimiteExports */

   PU_PUSHNAME (ctxt_p, "limaLimiteExports");

   stat = asn1PD_LimaLimiteExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode logMaintenanceExports */

   PU_PUSHNAME (ctxt_p, "logMaintenanceExports");

   stat = asn1PD_LogMaintenanceExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode logSanteExports */

   PU_PUSHNAME (ctxt_p, "logSanteExports");

   stat = asn1PD_LogSanteExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode objectExports */

   PU_PUSHNAME (ctxt_p, "objectExports");

   stat = asn1PD_ObjectExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_OrderIncludes: end\n");

   return (stat);
}

int ASN1C_OrderIncludes::Decode ()
{
   return asn1PD_OrderIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  OrderExports                                              */
/*                                                            */
/**************************************************************/

ASN1C_OrderExports::ASN1C_OrderExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_OrderExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_OrderExports: start\n");

   /* NULL */

   rtdiag ("asn1PE_OrderExports: end\n");
   return (stat);
}

int ASN1C_OrderExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_OrderExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_OrderExports: start\n");

   /* NULL */

   rtdiag ("asn1PD_OrderExports: end\n");

   return (stat);
}

int ASN1C_OrderExports::Decode ()
{
   return asn1PD_OrderExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  EnumOrderErrorCode                                        */
/*                                                            */
/**************************************************************/

ASN1C_EnumOrderErrorCode::ASN1C_EnumOrderErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumOrderErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumOrderErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumOrderErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumOrderErrorCode: start\n");

   switch (value) {
      case EnumOrderErrorCode::no_error: ui = 0; break;
      case EnumOrderErrorCode::error_invalid_unit: ui = 1; break;
      case EnumOrderErrorCode::error_invalid_limit: ui = 2; break;
      case EnumOrderErrorCode::error_invalid_lima: ui = 3; break;
      case EnumOrderErrorCode::error_invalid_mission: ui = 4; break;
      case EnumOrderErrorCode::error_invalid_mission_parameters: ui = 5; break;
      case EnumOrderErrorCode::error_unit_cannot_receive_order: ui = 6; break;
      case EnumOrderErrorCode::error_invalid_order_conduite: ui = 7; break;
      case EnumOrderErrorCode::error_invalid_order_mission: ui = 8; break;
      case EnumOrderErrorCode::error_invalid_order_initial: ui = 9; break;
      case EnumOrderErrorCode::error_invalid_order_conduite_parameters: ui = 10; break;
      case EnumOrderErrorCode::error_unit_surrendered: ui = 11; break;
      case EnumOrderErrorCode::error_invalid_lima_function: ui = 12; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 12);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumOrderErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumOrderErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumOrderErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumOrderErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumOrderErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumOrderErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 12);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumOrderErrorCode::no_error; break;
      case 1: *pvalue = EnumOrderErrorCode::error_invalid_unit; break;
      case 2: *pvalue = EnumOrderErrorCode::error_invalid_limit; break;
      case 3: *pvalue = EnumOrderErrorCode::error_invalid_lima; break;
      case 4: *pvalue = EnumOrderErrorCode::error_invalid_mission; break;
      case 5: *pvalue = EnumOrderErrorCode::error_invalid_mission_parameters; break;
      case 6: *pvalue = EnumOrderErrorCode::error_unit_cannot_receive_order; break;
      case 7: *pvalue = EnumOrderErrorCode::error_invalid_order_conduite; break;
      case 8: *pvalue = EnumOrderErrorCode::error_invalid_order_mission; break;
      case 9: *pvalue = EnumOrderErrorCode::error_invalid_order_initial; break;
      case 10: *pvalue = EnumOrderErrorCode::error_invalid_order_conduite_parameters; break;
      case 11: *pvalue = EnumOrderErrorCode::error_unit_surrendered; break;
      case 12: *pvalue = EnumOrderErrorCode::error_invalid_lima_function; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumOrderErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumOrderErrorCode::Decode ()
{
   return asn1PD_EnumOrderErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  OrderContext                                              */
/*                                                            */
/**************************************************************/

ASN1C_OrderContext::ASN1C_OrderContext (
   ASN1MessageBuffer& msgBuf, ASN1T_OrderContext& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_OrderContext (ASN1CTXT* ctxt_p, ASN1T_OrderContext* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_OrderContext: start\n");

   PU_NEWFIELD (ctxt_p, "limite_gauchePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.limite_gauchePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "limite_droitePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.limite_droitePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode limite_gauche */

   if (pvalue->m.limite_gauchePresent) {
      PU_PUSHNAME (ctxt_p, "limite_gauche");

      stat = asn1PE_Line (ctxt_p, &pvalue->limite_gauche);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode limite_droite */

   if (pvalue->m.limite_droitePresent) {
      PU_PUSHNAME (ctxt_p, "limite_droite");

      stat = asn1PE_Line (ctxt_p, &pvalue->limite_droite);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode limas */

   PU_PUSHNAME (ctxt_p, "limas");

   stat = asn1PE_LimasOrder (ctxt_p, &pvalue->limas);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode direction_dangereuse */

   PU_PUSHNAME (ctxt_p, "direction_dangereuse");

   stat = asn1PE_Heading (ctxt_p, pvalue->direction_dangereuse);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_OrderContext: end\n");
   return (stat);
}

int ASN1C_OrderContext::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderContext (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_OrderContext (ASN1CTXT* ctxt_p, ASN1T_OrderContext* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_OrderContext: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "limite_gauchePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.limite_gauchePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "limite_droitePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.limite_droitePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode limite_gauche */

   if (pvalue->m.limite_gauchePresent) {
      PU_PUSHNAME (ctxt_p, "limite_gauche");

      stat = asn1PD_Line (ctxt_p, &pvalue->limite_gauche);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode limite_droite */

   if (pvalue->m.limite_droitePresent) {
      PU_PUSHNAME (ctxt_p, "limite_droite");

      stat = asn1PD_Line (ctxt_p, &pvalue->limite_droite);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode limas */

   PU_PUSHNAME (ctxt_p, "limas");

   stat = asn1PD_LimasOrder (ctxt_p, &pvalue->limas);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode direction_dangereuse */

   PU_PUSHNAME (ctxt_p, "direction_dangereuse");

   stat = asn1PD_Heading (ctxt_p, &pvalue->direction_dangereuse);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_OrderContext: end\n");

   return (stat);
}

int ASN1C_OrderContext::Decode ()
{
   return asn1PD_OrderContext (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  PlannedWork                                               */
/*                                                            */
/**************************************************************/

ASN1C_PlannedWork::ASN1C_PlannedWork (
   ASN1MessageBuffer& msgBuf, ASN1T_PlannedWork& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_PlannedWork (ASN1CTXT* ctxt_p, ASN1T_PlannedWork* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_PlannedWork: start\n");

   PU_NEWFIELD (ctxt_p, "type_obstaclePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->type_obstacle != EnumObstacleType::initial));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "densitePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->densite != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "tc2Present");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->tc2 != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "activity_timePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->activity_time != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumObjectType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode position */

   PU_PUSHNAME (ctxt_p, "position");

   stat = asn1PE_Location (ctxt_p, &pvalue->position);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type_obstacle */

   if (pvalue->type_obstacle != EnumObstacleType::initial) {
      PU_PUSHNAME (ctxt_p, "type_obstacle");

      stat = asn1PE_EnumObstacleType (ctxt_p, pvalue->type_obstacle);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode densite */

   if (pvalue->densite != 0) {
      PU_PUSHNAME (ctxt_p, "densite");

      stat = pe_Real (ctxt_p, pvalue->densite);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode tc2 */

   if (pvalue->tc2 != 0) {
      PU_PUSHNAME (ctxt_p, "tc2");

      stat = asn1PE_Automat (ctxt_p, pvalue->tc2);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode activity_time */

   if (pvalue->activity_time != 0) {
      PU_PUSHNAME (ctxt_p, "activity_time");

      stat = pe_UnconsInteger (ctxt_p, pvalue->activity_time);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_PlannedWork: end\n");
   return (stat);
}

int ASN1C_PlannedWork::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PlannedWork (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_PlannedWork (ASN1CTXT* ctxt_p, ASN1T_PlannedWork* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL type_obstaclePresent;
   ASN1BOOL densitePresent;
   ASN1BOOL tc2Present;
   ASN1BOOL activity_timePresent;

   rtdiag ("asn1PD_PlannedWork: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "type_obstaclePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else type_obstaclePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "densitePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else densitePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "tc2Present");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else tc2Present = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "activity_timePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else activity_timePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumObjectType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode position */

   PU_PUSHNAME (ctxt_p, "position");

   stat = asn1PD_Location (ctxt_p, &pvalue->position);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type_obstacle */

   if (type_obstaclePresent) {
      PU_PUSHNAME (ctxt_p, "type_obstacle");

      stat = asn1PD_EnumObstacleType (ctxt_p, &pvalue->type_obstacle);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->type_obstacle = EnumObstacleType::initial;
   }

   /* decode densite */

   if (densitePresent) {
      PU_PUSHNAME (ctxt_p, "densite");

      stat = pd_Real (ctxt_p, &pvalue->densite);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
   }

   /* decode tc2 */

   if (tc2Present) {
      PU_PUSHNAME (ctxt_p, "tc2");

      stat = asn1PD_Automat (ctxt_p, &pvalue->tc2);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->tc2 = 0;
   }

   /* decode activity_time */

   if (activity_timePresent) {
      PU_PUSHNAME (ctxt_p, "activity_time");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->activity_time);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->activity_time = 0;
   }


   rtdiag ("asn1PD_PlannedWork: end\n");

   return (stat);
}

int ASN1C_PlannedWork::Decode ()
{
   return asn1PD_PlannedWork (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  PlannedWorkList                                           */
/*                                                            */
/**************************************************************/

ASN1C_PlannedWorkList::ASN1C_PlannedWorkList (
   ASN1MessageBuffer& msgBuf, ASN1T_PlannedWorkList& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_PlannedWorkList (ASN1CTXT* ctxt_p, ASN1T_PlannedWorkList* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_PlannedWorkList: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_PlannedWork (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_PlannedWorkList: end\n");
   return (stat);
}

int ASN1C_PlannedWorkList::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_PlannedWorkList (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_PlannedWorkList (ASN1CTXT* ctxt_p, ASN1T_PlannedWorkList* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_PlannedWorkList: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_PlannedWork);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_PlannedWork (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_PlannedWorkList: end\n");

   return (stat);
}

int ASN1C_PlannedWorkList::Decode ()
{
   return asn1PD_PlannedWorkList (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameter_value                                    */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameter_value::ASN1C_MissionParameter_value (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameter_value& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameter_value (ASN1CTXT* ctxt_p, ASN1T_MissionParameter_value* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MissionParameter_value: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (ctxt_p, "t");

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 30);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* aBool */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.aBool");

         PU_NEWFIELD (ctxt_p, "boolean");

         stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->u.aBool);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_SETBITCOUNT (ctxt_p);
         PU_POPNAME (ctxt_p);

         break;

      /* aReal */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.aReal");

         stat = pe_Real (ctxt_p, pvalue->u.aReal);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* enumeration */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.enumeration");

         stat = pe_UnconsInteger (ctxt_p, pvalue->u.enumeration);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* path */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.path");

         stat = asn1PE_Path (ctxt_p, pvalue->u.path);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* pathList */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.pathList");

         stat = asn1PE_PathList (ctxt_p, pvalue->u.pathList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* point */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.point");

         stat = asn1PE_Point (ctxt_p, pvalue->u.point);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* pointList */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.pointList");

         stat = asn1PE_PointList (ctxt_p, pvalue->u.pointList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* polygon */
      case 8:
         PU_PUSHNAME (ctxt_p, "u.polygon");

         stat = asn1PE_Polygon (ctxt_p, pvalue->u.polygon);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* polygonList */
      case 9:
         PU_PUSHNAME (ctxt_p, "u.polygonList");

         stat = asn1PE_PolygonList (ctxt_p, pvalue->u.polygonList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* location */
      case 10:
         PU_PUSHNAME (ctxt_p, "u.location");

         stat = asn1PE_Location (ctxt_p, pvalue->u.location);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* locationList */
      case 11:
         PU_PUSHNAME (ctxt_p, "u.locationList");

         stat = asn1PE_LocationList (ctxt_p, pvalue->u.locationList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* heading */
      case 12:
         PU_PUSHNAME (ctxt_p, "u.heading");

         stat = asn1PE_Heading (ctxt_p, pvalue->u.heading);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* atlasNature */
      case 13:
         PU_PUSHNAME (ctxt_p, "u.atlasNature");

         stat = asn1PE_AtlasNature (ctxt_p, *pvalue->u.atlasNature);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* unit */
      case 14:
         PU_PUSHNAME (ctxt_p, "u.unit");

         stat = asn1PE_Unit (ctxt_p, pvalue->u.unit);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* unitList */
      case 15:
         PU_PUSHNAME (ctxt_p, "u.unitList");

         stat = asn1PE_UnitList (ctxt_p, pvalue->u.unitList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* automat */
      case 16:
         PU_PUSHNAME (ctxt_p, "u.automat");

         stat = asn1PE_Automat (ctxt_p, pvalue->u.automat);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* automatList */
      case 17:
         PU_PUSHNAME (ctxt_p, "u.automatList");

         stat = asn1PE_AutomatList (ctxt_p, pvalue->u.automatList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* unitKnowledge */
      case 18:
         PU_PUSHNAME (ctxt_p, "u.unitKnowledge");

         stat = asn1PE_UnitKnowledge (ctxt_p, pvalue->u.unitKnowledge);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* unitKnowledgeList */
      case 19:
         PU_PUSHNAME (ctxt_p, "u.unitKnowledgeList");

         stat = asn1PE_UnitKnowledgeList (ctxt_p, pvalue->u.unitKnowledgeList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* objectKnowledge */
      case 20:
         PU_PUSHNAME (ctxt_p, "u.objectKnowledge");

         stat = asn1PE_ObjectKnowledge (ctxt_p, pvalue->u.objectKnowledge);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* objectKnowledgeList */
      case 21:
         PU_PUSHNAME (ctxt_p, "u.objectKnowledgeList");

         stat = asn1PE_ObjectKnowledgeList (ctxt_p, pvalue->u.objectKnowledgeList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* populationKnowledge */
      case 22:
         PU_PUSHNAME (ctxt_p, "u.populationKnowledge");

         stat = asn1PE_PopulationKnowledge (ctxt_p, pvalue->u.populationKnowledge);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* plannedWork */
      case 23:
         PU_PUSHNAME (ctxt_p, "u.plannedWork");

         stat = asn1PE_PlannedWork (ctxt_p, pvalue->u.plannedWork);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* plannedWorkList */
      case 24:
         PU_PUSHNAME (ctxt_p, "u.plannedWorkList");

         stat = asn1PE_PlannedWorkList (ctxt_p, pvalue->u.plannedWorkList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* dotationType */
      case 25:
         PU_PUSHNAME (ctxt_p, "u.dotationType");

         stat = asn1PE_DotationType (ctxt_p, pvalue->u.dotationType);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* equipmentType */
      case 26:
         PU_PUSHNAME (ctxt_p, "u.equipmentType");

         stat = asn1PE_EquipmentType (ctxt_p, pvalue->u.equipmentType);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* tirIndirect */
      case 27:
         PU_PUSHNAME (ctxt_p, "u.tirIndirect");

         stat = asn1PE_UnitFire (ctxt_p, pvalue->u.tirIndirect);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* dateTime */
      case 28:
         PU_PUSHNAME (ctxt_p, "u.dateTime");

         stat = asn1PE_DateTime (ctxt_p, pvalue->u.dateTime);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* logMaintenancePriorities */
      case 29:
         PU_PUSHNAME (ctxt_p, "u.logMaintenancePriorities");

         stat = asn1PE_LogMaintenancePriorities (ctxt_p, pvalue->u.logMaintenancePriorities);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* logMedicalPriorities */
      case 30:
         PU_PUSHNAME (ctxt_p, "u.logMedicalPriorities");

         stat = asn1PE_LogMedicalPriorities (ctxt_p, pvalue->u.logMedicalPriorities);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* aCharStr */
      case 31:
         PU_PUSHNAME (ctxt_p, "u.aCharStr");

         stat = pe_VisibleString (ctxt_p, pvalue->u.aCharStr, 0);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PE_MissionParameter_value: end\n");
   return (stat);
}

int ASN1C_MissionParameter_value::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameter_value (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameter_value (ASN1CTXT* ctxt_p, ASN1T_MissionParameter_value* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_MissionParameter_value: start\n");

   PU_PUSHNAME (ctxt_p, "t");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 30);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (ctxt_p);

   switch (ui) {
      /* aBool */
      case 0:
         PU_PUSHNAME (ctxt_p, "u.aBool");

         PU_NEWFIELD (ctxt_p, "boolean");

         stat = pd_bit (ctxt_p, &pvalue->u.aBool);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_SETBITCOUNT (ctxt_p);

         PU_POPNAME (ctxt_p);

         break;

      /* aReal */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.aReal");

         stat = pd_Real (ctxt_p, &pvalue->u.aReal);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* enumeration */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.enumeration");

         stat = pd_UnconsInteger (ctxt_p, &pvalue->u.enumeration);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* path */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.path");

         pvalue->u.path = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Path);
         if (pvalue->u.path == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_Path (ctxt_p, pvalue->u.path);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* pathList */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.pathList");

         pvalue->u.pathList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PathList);
         if (pvalue->u.pathList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_PathList (ctxt_p, pvalue->u.pathList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* point */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.point");

         pvalue->u.point = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Point);
         if (pvalue->u.point == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_Point (ctxt_p, pvalue->u.point);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* pointList */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.pointList");

         pvalue->u.pointList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PointList);
         if (pvalue->u.pointList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_PointList (ctxt_p, pvalue->u.pointList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* polygon */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.polygon");

         pvalue->u.polygon = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Polygon);
         if (pvalue->u.polygon == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_Polygon (ctxt_p, pvalue->u.polygon);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* polygonList */
      case 8:
         PU_PUSHNAME (ctxt_p, "u.polygonList");

         pvalue->u.polygonList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PolygonList);
         if (pvalue->u.polygonList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_PolygonList (ctxt_p, pvalue->u.polygonList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* location */
      case 9:
         PU_PUSHNAME (ctxt_p, "u.location");

         pvalue->u.location = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Location);
         if (pvalue->u.location == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_Location (ctxt_p, pvalue->u.location);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* locationList */
      case 10:
         PU_PUSHNAME (ctxt_p, "u.locationList");

         pvalue->u.locationList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_LocationList);
         if (pvalue->u.locationList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_LocationList (ctxt_p, pvalue->u.locationList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* heading */
      case 11:
         PU_PUSHNAME (ctxt_p, "u.heading");

         stat = asn1PD_Heading (ctxt_p, &pvalue->u.heading);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* atlasNature */
      case 12:
         PU_PUSHNAME (ctxt_p, "u.atlasNature");

         pvalue->u.atlasNature = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AtlasNature);
         if (pvalue->u.atlasNature == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AtlasNature (ctxt_p, pvalue->u.atlasNature);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* unit */
      case 13:
         PU_PUSHNAME (ctxt_p, "u.unit");

         stat = asn1PD_Unit (ctxt_p, &pvalue->u.unit);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* unitList */
      case 14:
         PU_PUSHNAME (ctxt_p, "u.unitList");

         pvalue->u.unitList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_UnitList);
         if (pvalue->u.unitList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_UnitList (ctxt_p, pvalue->u.unitList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* automat */
      case 15:
         PU_PUSHNAME (ctxt_p, "u.automat");

         stat = asn1PD_Automat (ctxt_p, &pvalue->u.automat);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* automatList */
      case 16:
         PU_PUSHNAME (ctxt_p, "u.automatList");

         pvalue->u.automatList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_AutomatList);
         if (pvalue->u.automatList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_AutomatList (ctxt_p, pvalue->u.automatList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* unitKnowledge */
      case 17:
         PU_PUSHNAME (ctxt_p, "u.unitKnowledge");

         stat = asn1PD_UnitKnowledge (ctxt_p, &pvalue->u.unitKnowledge);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* unitKnowledgeList */
      case 18:
         PU_PUSHNAME (ctxt_p, "u.unitKnowledgeList");

         pvalue->u.unitKnowledgeList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_UnitKnowledgeList);
         if (pvalue->u.unitKnowledgeList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_UnitKnowledgeList (ctxt_p, pvalue->u.unitKnowledgeList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* objectKnowledge */
      case 19:
         PU_PUSHNAME (ctxt_p, "u.objectKnowledge");

         stat = asn1PD_ObjectKnowledge (ctxt_p, &pvalue->u.objectKnowledge);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* objectKnowledgeList */
      case 20:
         PU_PUSHNAME (ctxt_p, "u.objectKnowledgeList");

         pvalue->u.objectKnowledgeList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ObjectKnowledgeList);
         if (pvalue->u.objectKnowledgeList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ObjectKnowledgeList (ctxt_p, pvalue->u.objectKnowledgeList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* populationKnowledge */
      case 21:
         PU_PUSHNAME (ctxt_p, "u.populationKnowledge");

         stat = asn1PD_PopulationKnowledge (ctxt_p, &pvalue->u.populationKnowledge);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* plannedWork */
      case 22:
         PU_PUSHNAME (ctxt_p, "u.plannedWork");

         pvalue->u.plannedWork = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PlannedWork);
         if (pvalue->u.plannedWork == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_PlannedWork (ctxt_p, pvalue->u.plannedWork);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* plannedWorkList */
      case 23:
         PU_PUSHNAME (ctxt_p, "u.plannedWorkList");

         pvalue->u.plannedWorkList = ALLOC_ASN1ELEM (ctxt_p, ASN1T_PlannedWorkList);
         if (pvalue->u.plannedWorkList == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_PlannedWorkList (ctxt_p, pvalue->u.plannedWorkList);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* dotationType */
      case 24:
         PU_PUSHNAME (ctxt_p, "u.dotationType");

         stat = asn1PD_DotationType (ctxt_p, &pvalue->u.dotationType);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* equipmentType */
      case 25:
         PU_PUSHNAME (ctxt_p, "u.equipmentType");

         stat = asn1PD_EquipmentType (ctxt_p, &pvalue->u.equipmentType);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* tirIndirect */
      case 26:
         PU_PUSHNAME (ctxt_p, "u.tirIndirect");

         stat = asn1PD_UnitFire (ctxt_p, &pvalue->u.tirIndirect);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* dateTime */
      case 27:
         PU_PUSHNAME (ctxt_p, "u.dateTime");

         stat = asn1PD_DateTime (ctxt_p, &pvalue->u.dateTime);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* logMaintenancePriorities */
      case 28:
         PU_PUSHNAME (ctxt_p, "u.logMaintenancePriorities");

         pvalue->u.logMaintenancePriorities = ALLOC_ASN1ELEM (ctxt_p, ASN1T_LogMaintenancePriorities);
         if (pvalue->u.logMaintenancePriorities == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_LogMaintenancePriorities (ctxt_p, pvalue->u.logMaintenancePriorities);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* logMedicalPriorities */
      case 29:
         PU_PUSHNAME (ctxt_p, "u.logMedicalPriorities");

         pvalue->u.logMedicalPriorities = ALLOC_ASN1ELEM (ctxt_p, ASN1T_LogMedicalPriorities);
         if (pvalue->u.logMedicalPriorities == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_LogMedicalPriorities (ctxt_p, pvalue->u.logMedicalPriorities);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* aCharStr */
      case 30:
         PU_PUSHNAME (ctxt_p, "u.aCharStr");

         stat = pd_VisibleString (ctxt_p, &pvalue->u.aCharStr, 0);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PD_MissionParameter_value: end\n");

   return (stat);
}

int ASN1C_MissionParameter_value::Decode ()
{
   return asn1PD_MissionParameter_value (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameter                                          */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameter::ASN1C_MissionParameter (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameter& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameter (ASN1CTXT* ctxt_p, ASN1T_MissionParameter* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MissionParameter: start\n");

   PU_NEWFIELD (ctxt_p, "null_valuePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->null_value != FALSE));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode null_value */

   if (pvalue->null_value != FALSE) {
      PU_PUSHNAME (ctxt_p, "null_value");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->null_value);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode value */

   PU_PUSHNAME (ctxt_p, "value");

   stat = asn1PE_MissionParameter_value (ctxt_p, &pvalue->value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MissionParameter: end\n");
   return (stat);
}

int ASN1C_MissionParameter::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameter (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameter (ASN1CTXT* ctxt_p, ASN1T_MissionParameter* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL null_valuePresent;

   rtdiag ("asn1PD_MissionParameter: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "null_valuePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else null_valuePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode null_value */

   if (null_valuePresent) {
      PU_PUSHNAME (ctxt_p, "null_value");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->null_value);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->null_value = FALSE;
   }

   /* decode value */

   PU_PUSHNAME (ctxt_p, "value");

   stat = asn1PD_MissionParameter_value (ctxt_p, &pvalue->value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MissionParameter: end\n");

   return (stat);
}

int ASN1C_MissionParameter::Decode ()
{
   return asn1PD_MissionParameter (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameters                                         */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameters::ASN1C_MissionParameters (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameters& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameters (ASN1CTXT* ctxt_p, ASN1T_MissionParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_MissionParameters: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_MissionParameter (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_MissionParameters: end\n");
   return (stat);
}

int ASN1C_MissionParameters::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameters (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameters (ASN1CTXT* ctxt_p, ASN1T_MissionParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_MissionParameters: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_MissionParameter);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_MissionParameter (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MissionParameters: end\n");

   return (stat);
}

int ASN1C_MissionParameters::Decode ()
{
   return asn1PD_MissionParameters (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgUnitOrder                                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgUnitOrder::ASN1C_MsgUnitOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgUnitOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgUnitOrder (ASN1CTXT* ctxt_p, ASN1T_MsgUnitOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgUnitOrder: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode order_context */

   PU_PUSHNAME (ctxt_p, "order_context");

   stat = asn1PE_OrderContext (ctxt_p, &pvalue->order_context);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgUnitOrder: end\n");
   return (stat);
}

int ASN1C_MsgUnitOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgUnitOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgUnitOrder (ASN1CTXT* ctxt_p, ASN1T_MsgUnitOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgUnitOrder: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode order_context */

   PU_PUSHNAME (ctxt_p, "order_context");

   stat = asn1PD_OrderContext (ctxt_p, &pvalue->order_context);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgUnitOrder: end\n");

   return (stat);
}

int ASN1C_MsgUnitOrder::Decode ()
{
   return asn1PD_MsgUnitOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgUnitOrderAck                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgUnitOrderAck::ASN1C_MsgUnitOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgUnitOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgUnitOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgUnitOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgUnitOrderAck: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgUnitOrderAck: end\n");
   return (stat);
}

int ASN1C_MsgUnitOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgUnitOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgUnitOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgUnitOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgUnitOrderAck: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgUnitOrderAck: end\n");

   return (stat);
}

int ASN1C_MsgUnitOrderAck::Decode ()
{
   return asn1PD_MsgUnitOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumAutomatOrderFormation                                 */
/*                                                            */
/**************************************************************/

ASN1C_EnumAutomatOrderFormation::ASN1C_EnumAutomatOrderFormation (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumAutomatOrderFormation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumAutomatOrderFormation (ASN1CTXT* ctxt_p, ASN1T_EnumAutomatOrderFormation value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumAutomatOrderFormation: start\n");

   switch (value) {
      case EnumAutomatOrderFormation::un_echelon: ui = 0; break;
      case EnumAutomatOrderFormation::deux_echelons: ui = 1; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumAutomatOrderFormation: end\n");
   return (stat);
}

int ASN1C_EnumAutomatOrderFormation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumAutomatOrderFormation (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumAutomatOrderFormation (ASN1CTXT* ctxt_p, ASN1T_EnumAutomatOrderFormation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumAutomatOrderFormation: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumAutomatOrderFormation::un_echelon; break;
      case 1: *pvalue = EnumAutomatOrderFormation::deux_echelons; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumAutomatOrderFormation: end\n");

   return (stat);
}

int ASN1C_EnumAutomatOrderFormation::Decode ()
{
   return asn1PD_EnumAutomatOrderFormation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomatOrder                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomatOrder::ASN1C_MsgAutomatOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomatOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomatOrder (ASN1CTXT* ctxt_p, ASN1T_MsgAutomatOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgAutomatOrder: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Automat (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode order_context */

   PU_PUSHNAME (ctxt_p, "order_context");

   stat = asn1PE_OrderContext (ctxt_p, &pvalue->order_context);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode formation */

   PU_PUSHNAME (ctxt_p, "formation");

   stat = asn1PE_EnumAutomatOrderFormation (ctxt_p, pvalue->formation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgAutomatOrder: end\n");
   return (stat);
}

int ASN1C_MsgAutomatOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomatOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomatOrder (ASN1CTXT* ctxt_p, ASN1T_MsgAutomatOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgAutomatOrder: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Automat (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode order_context */

   PU_PUSHNAME (ctxt_p, "order_context");

   stat = asn1PD_OrderContext (ctxt_p, &pvalue->order_context);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode formation */

   PU_PUSHNAME (ctxt_p, "formation");

   stat = asn1PD_EnumAutomatOrderFormation (ctxt_p, &pvalue->formation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgAutomatOrder: end\n");

   return (stat);
}

int ASN1C_MsgAutomatOrder::Decode ()
{
   return asn1PD_MsgAutomatOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomatOrderAck                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomatOrderAck::ASN1C_MsgAutomatOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomatOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomatOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgAutomatOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgAutomatOrderAck: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgAutomatOrderAck: end\n");
   return (stat);
}

int ASN1C_MsgAutomatOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomatOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomatOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgAutomatOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgAutomatOrderAck: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgAutomatOrderAck: end\n");

   return (stat);
}

int ASN1C_MsgAutomatOrderAck::Decode ()
{
   return asn1PD_MsgAutomatOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationOrder                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationOrder::ASN1C_MsgPopulationOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationOrder (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationOrder: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Population (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationOrder: end\n");
   return (stat);
}

int ASN1C_MsgPopulationOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationOrder (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationOrder: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Population (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationOrder: end\n");

   return (stat);
}

int ASN1C_MsgPopulationOrder::Decode ()
{
   return asn1PD_MsgPopulationOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationOrderAck                                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationOrderAck::ASN1C_MsgPopulationOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationOrderAck: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Population (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationOrderAck: end\n");
   return (stat);
}

int ASN1C_MsgPopulationOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationOrderAck: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Population (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationOrderAck: end\n");

   return (stat);
}

int ASN1C_MsgPopulationOrderAck::Decode ()
{
   return asn1PD_MsgPopulationOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgFragOrder                                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgFragOrder::ASN1C_MsgFragOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgFragOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgFragOrder (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgFragOrder: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode frag_order */

   PU_PUSHNAME (ctxt_p, "frag_order");

   stat = asn1PE_OID (ctxt_p, pvalue->frag_order);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgFragOrder: end\n");
   return (stat);
}

int ASN1C_MsgFragOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgFragOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgFragOrder (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgFragOrder: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode frag_order */

   PU_PUSHNAME (ctxt_p, "frag_order");

   stat = asn1PD_OID (ctxt_p, &pvalue->frag_order);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgFragOrder: end\n");

   return (stat);
}

int ASN1C_MsgFragOrder::Decode ()
{
   return asn1PD_MsgFragOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgFragOrderAck                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgFragOrderAck::ASN1C_MsgFragOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgFragOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgFragOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgFragOrderAck: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgFragOrderAck: end\n");
   return (stat);
}

int ASN1C_MsgFragOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgFragOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgFragOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgFragOrderAck: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgFragOrderAck: end\n");

   return (stat);
}

int ASN1C_MsgFragOrderAck::Decode ()
{
   return asn1PD_MsgFragOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumReportType                                            */
/*                                                            */
/**************************************************************/

ASN1C_EnumReportType::ASN1C_EnumReportType (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumReportType& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumReportType (ASN1CTXT* ctxt_p, ASN1T_EnumReportType value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumReportType: start\n");

   switch (value) {
      case EnumReportType::message: ui = 0; break;
      case EnumReportType::operationel: ui = 1; break;
      case EnumReportType::evenement_exceptionnel: ui = 2; break;
      case EnumReportType::warning: ui = 3; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumReportType: end\n");
   return (stat);
}

int ASN1C_EnumReportType::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumReportType (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumReportType (ASN1CTXT* ctxt_p, ASN1T_EnumReportType* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumReportType: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumReportType::message; break;
      case 1: *pvalue = EnumReportType::operationel; break;
      case 2: *pvalue = EnumReportType::evenement_exceptionnel; break;
      case 3: *pvalue = EnumReportType::warning; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumReportType: end\n");

   return (stat);
}

int ASN1C_EnumReportType::Decode ()
{
   return asn1PD_EnumReportType (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgReport                                                 */
/*                                                            */
/**************************************************************/

ASN1C_MsgReport::ASN1C_MsgReport (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgReport& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgReport (ASN1CTXT* ctxt_p, ASN1T_MsgReport* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgReport: start\n");

   /* encode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PE_OID (ctxt_p, pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode cr */

   PU_PUSHNAME (ctxt_p, "cr");

   stat = asn1PE_OID (ctxt_p, pvalue->cr);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumReportType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgReport: end\n");
   return (stat);
}

int ASN1C_MsgReport::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgReport (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgReport (ASN1CTXT* ctxt_p, ASN1T_MsgReport* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgReport: start\n");

   /* decode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PD_OID (ctxt_p, &pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode cr */

   PU_PUSHNAME (ctxt_p, "cr");

   stat = asn1PD_OID (ctxt_p, &pvalue->cr);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumReportType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgReport: end\n");

   return (stat);
}

int ASN1C_MsgReport::Decode ()
{
   return asn1PD_MsgReport (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgTrace                                                  */
/*                                                            */
/**************************************************************/

ASN1C_MsgTrace::ASN1C_MsgTrace (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgTrace& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgTrace (ASN1CTXT* ctxt_p, ASN1T_MsgTrace* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgTrace: start\n");

   /* encode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PE_OID (ctxt_p, pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode message */

   PU_PUSHNAME (ctxt_p, "message");

   stat = pe_VisibleString (ctxt_p, pvalue->message, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgTrace: end\n");
   return (stat);
}

int ASN1C_MsgTrace::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgTrace (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgTrace (ASN1CTXT* ctxt_p, ASN1T_MsgTrace* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgTrace: start\n");

   /* decode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PD_OID (ctxt_p, &pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode message */

   PU_PUSHNAME (ctxt_p, "message");

   stat = pd_VisibleString (ctxt_p, &pvalue->message, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgTrace: end\n");

   return (stat);
}

int ASN1C_MsgTrace::Decode ()
{
   return asn1PD_MsgTrace (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgDecisionalState                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgDecisionalState::ASN1C_MsgDecisionalState (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgDecisionalState& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgDecisionalState (ASN1CTXT* ctxt_p, ASN1T_MsgDecisionalState* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgDecisionalState: start\n");

   /* encode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PE_OID (ctxt_p, pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode key */

   PU_PUSHNAME (ctxt_p, "key");

   stat = pe_VisibleString (ctxt_p, pvalue->key, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode value */

   PU_PUSHNAME (ctxt_p, "value");

   stat = pe_VisibleString (ctxt_p, pvalue->value, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgDecisionalState: end\n");
   return (stat);
}

int ASN1C_MsgDecisionalState::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgDecisionalState (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgDecisionalState (ASN1CTXT* ctxt_p, ASN1T_MsgDecisionalState* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgDecisionalState: start\n");

   /* decode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PD_OID (ctxt_p, &pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode key */

   PU_PUSHNAME (ctxt_p, "key");

   stat = pd_VisibleString (ctxt_p, &pvalue->key, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode value */

   PU_PUSHNAME (ctxt_p, "value");

   stat = pd_VisibleString (ctxt_p, &pvalue->value, 0);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgDecisionalState: end\n");

   return (stat);
}

int ASN1C_MsgDecisionalState::Decode ()
{
   return asn1PD_MsgDecisionalState (mpContext->GetPtr(), &msgData);
}

