/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 18-Jun-2007.
 */
#include "LogSante.h"

/**************************************************************/
/*                                                            */
/*  LogSanteIncludes                                          */
/*                                                            */
/**************************************************************/

ASN1C_LogSanteIncludes::ASN1C_LogSanteIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_LogSanteIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_LogSanteIncludes (ASN1CTXT* ctxt_p, ASN1T_LogSanteIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_LogSanteIncludes: start\n");

   /* encode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_LogSanteIncludes: end\n");
   return (stat);
}

int ASN1C_LogSanteIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_LogSanteIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_LogSanteIncludes (ASN1CTXT* ctxt_p, ASN1T_LogSanteIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_LogSanteIncludes: start\n");

   /* decode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_LogSanteIncludes: end\n");

   return (stat);
}

int ASN1C_LogSanteIncludes::Decode ()
{
   return asn1PD_LogSanteIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  LogSanteExports                                           */
/*                                                            */
/**************************************************************/

ASN1C_LogSanteExports::ASN1C_LogSanteExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_LogSanteExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_LogSanteExports: start\n");

   /* NULL */

   rtdiag ("asn1PE_LogSanteExports: end\n");
   return (stat);
}

int ASN1C_LogSanteExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_LogSanteExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_LogSanteExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_LogSanteExports: start\n");

   /* NULL */

   rtdiag ("asn1PD_LogSanteExports: end\n");

   return (stat);
}

int ASN1C_LogSanteExports::Decode ()
{
   return asn1PD_LogSanteExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  EnumLogMedicalHandlingStatus                              */
/*                                                            */
/**************************************************************/

ASN1C_EnumLogMedicalHandlingStatus::ASN1C_EnumLogMedicalHandlingStatus (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumLogMedicalHandlingStatus& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumLogMedicalHandlingStatus (ASN1CTXT* ctxt_p, ASN1T_EnumLogMedicalHandlingStatus value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumLogMedicalHandlingStatus: start\n");

   switch (value) {
      case EnumLogMedicalHandlingStatus::attente_disponibilite_ambulance_releve: ui = 0; break;
      case EnumLogMedicalHandlingStatus::ambulance_releve_deplacement_aller: ui = 1; break;
      case EnumLogMedicalHandlingStatus::ambulance_releve_chargement: ui = 2; break;
      case EnumLogMedicalHandlingStatus::attente_chargement_complet_ambulance_releve: ui = 3; break;
      case EnumLogMedicalHandlingStatus::ambulance_releve_deplacement_retour: ui = 4; break;
      case EnumLogMedicalHandlingStatus::ambulance_releve_dechargement: ui = 5; break;
      case EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_diagnostique: ui = 6; break;
      case EnumLogMedicalHandlingStatus::diagnostique: ui = 7; break;
      case EnumLogMedicalHandlingStatus::recherche_secteur_tri: ui = 8; break;
      case EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_tri: ui = 9; break;
      case EnumLogMedicalHandlingStatus::tri: ui = 10; break;
      case EnumLogMedicalHandlingStatus::recherche_secteur_soin: ui = 11; break;
      case EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_soin: ui = 12; break;
      case EnumLogMedicalHandlingStatus::soin: ui = 13; break;
      case EnumLogMedicalHandlingStatus::hospitalisation: ui = 14; break;
      case EnumLogMedicalHandlingStatus::attente_disponibilite_ambulance_ramassage: ui = 15; break;
      case EnumLogMedicalHandlingStatus::ambulance_ramassage_chargement: ui = 16; break;
      case EnumLogMedicalHandlingStatus::attente_chargement_complet_ambulance_ramassage: ui = 17; break;
      case EnumLogMedicalHandlingStatus::ambulance_ramassage_deplacement_aller: ui = 18; break;
      case EnumLogMedicalHandlingStatus::ambulance_ramassage_dechargement: ui = 19; break;
      case EnumLogMedicalHandlingStatus::termine: ui = 20; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 20);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumLogMedicalHandlingStatus: end\n");
   return (stat);
}

int ASN1C_EnumLogMedicalHandlingStatus::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumLogMedicalHandlingStatus (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumLogMedicalHandlingStatus (ASN1CTXT* ctxt_p, ASN1T_EnumLogMedicalHandlingStatus* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumLogMedicalHandlingStatus: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 20);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_ambulance_releve; break;
      case 1: *pvalue = EnumLogMedicalHandlingStatus::ambulance_releve_deplacement_aller; break;
      case 2: *pvalue = EnumLogMedicalHandlingStatus::ambulance_releve_chargement; break;
      case 3: *pvalue = EnumLogMedicalHandlingStatus::attente_chargement_complet_ambulance_releve; break;
      case 4: *pvalue = EnumLogMedicalHandlingStatus::ambulance_releve_deplacement_retour; break;
      case 5: *pvalue = EnumLogMedicalHandlingStatus::ambulance_releve_dechargement; break;
      case 6: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_diagnostique; break;
      case 7: *pvalue = EnumLogMedicalHandlingStatus::diagnostique; break;
      case 8: *pvalue = EnumLogMedicalHandlingStatus::recherche_secteur_tri; break;
      case 9: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_tri; break;
      case 10: *pvalue = EnumLogMedicalHandlingStatus::tri; break;
      case 11: *pvalue = EnumLogMedicalHandlingStatus::recherche_secteur_soin; break;
      case 12: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_soin; break;
      case 13: *pvalue = EnumLogMedicalHandlingStatus::soin; break;
      case 14: *pvalue = EnumLogMedicalHandlingStatus::hospitalisation; break;
      case 15: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_ambulance_ramassage; break;
      case 16: *pvalue = EnumLogMedicalHandlingStatus::ambulance_ramassage_chargement; break;
      case 17: *pvalue = EnumLogMedicalHandlingStatus::attente_chargement_complet_ambulance_ramassage; break;
      case 18: *pvalue = EnumLogMedicalHandlingStatus::ambulance_ramassage_deplacement_aller; break;
      case 19: *pvalue = EnumLogMedicalHandlingStatus::ambulance_ramassage_dechargement; break;
      case 20: *pvalue = EnumLogMedicalHandlingStatus::termine; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumLogMedicalHandlingStatus: end\n");

   return (stat);
}

int ASN1C_EnumLogMedicalHandlingStatus::Decode ()
{
   return asn1PD_EnumLogMedicalHandlingStatus (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgLogMedicalHandlingCreation                             */
/*                                                            */
/**************************************************************/

ASN1C_MsgLogMedicalHandlingCreation::ASN1C_MsgLogMedicalHandlingCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgLogMedicalHandlingCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgLogMedicalHandlingCreation (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingCreation* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgLogMedicalHandlingCreation: start\n");

   PU_NEWFIELD (ctxt_p, "blesse_mentalPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->blesse_mental != FALSE));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "contamine_nbcPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->contamine_nbc != FALSE));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_consigne */

   PU_PUSHNAME (ctxt_p, "oid_consigne");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_consigne);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode tick_creation */

   PU_PUSHNAME (ctxt_p, "tick_creation");

   stat = pe_UnconsInteger (ctxt_p, pvalue->tick_creation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode rang */

   PU_PUSHNAME (ctxt_p, "rang");

   stat = asn1PE_EnumHumanRank (ctxt_p, pvalue->rang);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode blessure */

   PU_PUSHNAME (ctxt_p, "blessure");

   stat = asn1PE_EnumHumanWound (ctxt_p, pvalue->blessure);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode blesse_mental */

   if (pvalue->blesse_mental != FALSE) {
      PU_PUSHNAME (ctxt_p, "blesse_mental");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->blesse_mental);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode contamine_nbc */

   if (pvalue->contamine_nbc != FALSE) {
      PU_PUSHNAME (ctxt_p, "contamine_nbc");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->contamine_nbc);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgLogMedicalHandlingCreation: end\n");
   return (stat);
}

int ASN1C_MsgLogMedicalHandlingCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgLogMedicalHandlingCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgLogMedicalHandlingCreation (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingCreation* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL blesse_mentalPresent;
   ASN1BOOL contamine_nbcPresent;

   rtdiag ("asn1PD_MsgLogMedicalHandlingCreation: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "blesse_mentalPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else blesse_mentalPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "contamine_nbcPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else contamine_nbcPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_consigne */

   PU_PUSHNAME (ctxt_p, "oid_consigne");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_consigne);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode tick_creation */

   PU_PUSHNAME (ctxt_p, "tick_creation");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->tick_creation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode rang */

   PU_PUSHNAME (ctxt_p, "rang");

   stat = asn1PD_EnumHumanRank (ctxt_p, &pvalue->rang);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode blessure */

   PU_PUSHNAME (ctxt_p, "blessure");

   stat = asn1PD_EnumHumanWound (ctxt_p, &pvalue->blessure);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode blesse_mental */

   if (blesse_mentalPresent) {
      PU_PUSHNAME (ctxt_p, "blesse_mental");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->blesse_mental);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->blesse_mental = FALSE;
   }

   /* decode contamine_nbc */

   if (contamine_nbcPresent) {
      PU_PUSHNAME (ctxt_p, "contamine_nbc");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->contamine_nbc);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->contamine_nbc = FALSE;
   }


   rtdiag ("asn1PD_MsgLogMedicalHandlingCreation: end\n");

   return (stat);
}

int ASN1C_MsgLogMedicalHandlingCreation::Decode ()
{
   return asn1PD_MsgLogMedicalHandlingCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgLogMedicalHandlingUpdate                               */
/*                                                            */
/**************************************************************/

ASN1C_MsgLogMedicalHandlingUpdate::ASN1C_MsgLogMedicalHandlingUpdate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgLogMedicalHandlingUpdate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgLogMedicalHandlingUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingUpdate* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgLogMedicalHandlingUpdate: start\n");

   PU_NEWFIELD (ctxt_p, "oid_pion_log_traitantPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_pion_log_traitantPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "blessurePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.blessurePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "blesse_mentalPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.blesse_mentalPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "contamine_nbcPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.contamine_nbcPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "etatPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.etatPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "diagnostique_effectuePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.diagnostique_effectuePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_consigne */

   PU_PUSHNAME (ctxt_p, "oid_consigne");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_consigne);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_pion_log_traitant */

   if (pvalue->m.oid_pion_log_traitantPresent) {
      PU_PUSHNAME (ctxt_p, "oid_pion_log_traitant");

      stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion_log_traitant);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode blessure */

   if (pvalue->m.blessurePresent) {
      PU_PUSHNAME (ctxt_p, "blessure");

      stat = asn1PE_EnumHumanWound (ctxt_p, pvalue->blessure);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode blesse_mental */

   if (pvalue->m.blesse_mentalPresent) {
      PU_PUSHNAME (ctxt_p, "blesse_mental");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->blesse_mental);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode contamine_nbc */

   if (pvalue->m.contamine_nbcPresent) {
      PU_PUSHNAME (ctxt_p, "contamine_nbc");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->contamine_nbc);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode etat */

   if (pvalue->m.etatPresent) {
      PU_PUSHNAME (ctxt_p, "etat");

      stat = asn1PE_EnumLogMedicalHandlingStatus (ctxt_p, pvalue->etat);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode diagnostique_effectue */

   if (pvalue->m.diagnostique_effectuePresent) {
      PU_PUSHNAME (ctxt_p, "diagnostique_effectue");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->diagnostique_effectue);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgLogMedicalHandlingUpdate: end\n");
   return (stat);
}

int ASN1C_MsgLogMedicalHandlingUpdate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgLogMedicalHandlingUpdate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgLogMedicalHandlingUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingUpdate* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgLogMedicalHandlingUpdate: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "oid_pion_log_traitantPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.oid_pion_log_traitantPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "blessurePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.blessurePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "blesse_mentalPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.blesse_mentalPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "contamine_nbcPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.contamine_nbcPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "etatPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.etatPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "diagnostique_effectuePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.diagnostique_effectuePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_consigne */

   PU_PUSHNAME (ctxt_p, "oid_consigne");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_consigne);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_pion_log_traitant */

   if (pvalue->m.oid_pion_log_traitantPresent) {
      PU_PUSHNAME (ctxt_p, "oid_pion_log_traitant");

      stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion_log_traitant);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode blessure */

   if (pvalue->m.blessurePresent) {
      PU_PUSHNAME (ctxt_p, "blessure");

      stat = asn1PD_EnumHumanWound (ctxt_p, &pvalue->blessure);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode blesse_mental */

   if (pvalue->m.blesse_mentalPresent) {
      PU_PUSHNAME (ctxt_p, "blesse_mental");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->blesse_mental);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }

   /* decode contamine_nbc */

   if (pvalue->m.contamine_nbcPresent) {
      PU_PUSHNAME (ctxt_p, "contamine_nbc");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->contamine_nbc);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }

   /* decode etat */

   if (pvalue->m.etatPresent) {
      PU_PUSHNAME (ctxt_p, "etat");

      stat = asn1PD_EnumLogMedicalHandlingStatus (ctxt_p, &pvalue->etat);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode diagnostique_effectue */

   if (pvalue->m.diagnostique_effectuePresent) {
      PU_PUSHNAME (ctxt_p, "diagnostique_effectue");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->diagnostique_effectue);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgLogMedicalHandlingUpdate: end\n");

   return (stat);
}

int ASN1C_MsgLogMedicalHandlingUpdate::Decode ()
{
   return asn1PD_MsgLogMedicalHandlingUpdate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgLogMedicalHandlingDestruction                          */
/*                                                            */
/**************************************************************/

ASN1C_MsgLogMedicalHandlingDestruction::ASN1C_MsgLogMedicalHandlingDestruction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgLogMedicalHandlingDestruction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgLogMedicalHandlingDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgLogMedicalHandlingDestruction: start\n");

   /* encode oid_consigne */

   PU_PUSHNAME (ctxt_p, "oid_consigne");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_consigne);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgLogMedicalHandlingDestruction: end\n");
   return (stat);
}

int ASN1C_MsgLogMedicalHandlingDestruction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgLogMedicalHandlingDestruction (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgLogMedicalHandlingDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingDestruction* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgLogMedicalHandlingDestruction: start\n");

   /* decode oid_consigne */

   PU_PUSHNAME (ctxt_p, "oid_consigne");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_consigne);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgLogMedicalHandlingDestruction: end\n");

   return (stat);
}

int ASN1C_MsgLogMedicalHandlingDestruction::Decode ()
{
   return asn1PD_MsgLogMedicalHandlingDestruction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  LogMedicalEquipmentAvailability                           */
/*                                                            */
/**************************************************************/

ASN1C_LogMedicalEquipmentAvailability::ASN1C_LogMedicalEquipmentAvailability (
   ASN1MessageBuffer& msgBuf, ASN1T_LogMedicalEquipmentAvailability& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_LogMedicalEquipmentAvailability (ASN1CTXT* ctxt_p, ASN1T_LogMedicalEquipmentAvailability* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_LogMedicalEquipmentAvailability: start\n");

   PU_NEWFIELD (ctxt_p, "nbr_pretesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->nbr_pretes != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nbr_au_reposPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nbr_au_reposPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode type_equipement */

   PU_PUSHNAME (ctxt_p, "type_equipement");

   stat = asn1PE_EquipmentType (ctxt_p, pvalue->type_equipement);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nbr_total */

   PU_PUSHNAME (ctxt_p, "nbr_total");

   stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_total);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nbr_disponibles */

   PU_PUSHNAME (ctxt_p, "nbr_disponibles");

   stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_disponibles);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nbr_au_travail */

   PU_PUSHNAME (ctxt_p, "nbr_au_travail");

   stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_au_travail);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode nbr_pretes */

   if (pvalue->nbr_pretes != 0) {
      PU_PUSHNAME (ctxt_p, "nbr_pretes");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_pretes);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode nbr_au_repos */

   if (pvalue->m.nbr_au_reposPresent) {
      PU_PUSHNAME (ctxt_p, "nbr_au_repos");

      stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_au_repos);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_LogMedicalEquipmentAvailability: end\n");
   return (stat);
}

int ASN1C_LogMedicalEquipmentAvailability::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_LogMedicalEquipmentAvailability (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_LogMedicalEquipmentAvailability (ASN1CTXT* ctxt_p, ASN1T_LogMedicalEquipmentAvailability* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL nbr_pretesPresent;

   rtdiag ("asn1PD_LogMedicalEquipmentAvailability: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "nbr_pretesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else nbr_pretesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "nbr_au_reposPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.nbr_au_reposPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode type_equipement */

   PU_PUSHNAME (ctxt_p, "type_equipement");

   stat = asn1PD_EquipmentType (ctxt_p, &pvalue->type_equipement);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nbr_total */

   PU_PUSHNAME (ctxt_p, "nbr_total");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_total);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nbr_disponibles */

   PU_PUSHNAME (ctxt_p, "nbr_disponibles");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_disponibles);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nbr_au_travail */

   PU_PUSHNAME (ctxt_p, "nbr_au_travail");

   stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_au_travail);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode nbr_pretes */

   if (nbr_pretesPresent) {
      PU_PUSHNAME (ctxt_p, "nbr_pretes");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_pretes);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->nbr_pretes = 0;
   }

   /* decode nbr_au_repos */

   if (pvalue->m.nbr_au_reposPresent) {
      PU_PUSHNAME (ctxt_p, "nbr_au_repos");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_au_repos);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_LogMedicalEquipmentAvailability: end\n");

   return (stat);
}

int ASN1C_LogMedicalEquipmentAvailability::Decode ()
{
   return asn1PD_LogMedicalEquipmentAvailability (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  LogMedicalPriorities                                      */
/*                                                            */
/**************************************************************/

ASN1C_LogMedicalPriorities::ASN1C_LogMedicalPriorities (
   ASN1MessageBuffer& msgBuf, ASN1T_LogMedicalPriorities& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_LogMedicalPriorities (ASN1CTXT* ctxt_p, ASN1T_LogMedicalPriorities* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_LogMedicalPriorities: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_EnumHumanWound (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_LogMedicalPriorities: end\n");
   return (stat);
}

int ASN1C_LogMedicalPriorities::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_LogMedicalPriorities (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_LogMedicalPriorities (ASN1CTXT* ctxt_p, ASN1T_LogMedicalPriorities* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_LogMedicalPriorities: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_EnumHumanWound);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_EnumHumanWound (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_LogMedicalPriorities: end\n");

   return (stat);
}

int ASN1C_LogMedicalPriorities::Decode ()
{
   return asn1PD_LogMedicalPriorities (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfLogMedicalEquipmentAvailability                     */
/*                                                            */
/**************************************************************/

ASN1C__SeqOfLogMedicalEquipmentAvailability::ASN1C__SeqOfLogMedicalEquipmentAvailability (
   ASN1MessageBuffer& msgBuf, ASN1T__SeqOfLogMedicalEquipmentAvailability& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE__SeqOfLogMedicalEquipmentAvailability (ASN1CTXT* ctxt_p, ASN1T__SeqOfLogMedicalEquipmentAvailability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE__SeqOfLogMedicalEquipmentAvailability: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_LogMedicalEquipmentAvailability (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE__SeqOfLogMedicalEquipmentAvailability: end\n");
   return (stat);
}

int ASN1C__SeqOfLogMedicalEquipmentAvailability::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE__SeqOfLogMedicalEquipmentAvailability (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD__SeqOfLogMedicalEquipmentAvailability (ASN1CTXT* ctxt_p, ASN1T__SeqOfLogMedicalEquipmentAvailability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD__SeqOfLogMedicalEquipmentAvailability: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_LogMedicalEquipmentAvailability);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_LogMedicalEquipmentAvailability (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD__SeqOfLogMedicalEquipmentAvailability: end\n");

   return (stat);
}

int ASN1C__SeqOfLogMedicalEquipmentAvailability::Decode ()
{
   return asn1PD__SeqOfLogMedicalEquipmentAvailability (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgLogMedicalState                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgLogMedicalState::ASN1C_MsgLogMedicalState (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgLogMedicalState& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgLogMedicalState (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalState* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgLogMedicalState: start\n");

   PU_NEWFIELD (ctxt_p, "chaine_activeePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.chaine_activeePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "prioritesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.prioritesPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "priorites_tactiquesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.priorites_tactiquesPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "disponibilites_ambulances_relevePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.disponibilites_ambulances_relevePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "disponibilites_ambulances_ramassagePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.disponibilites_ambulances_ramassagePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "disponibilites_medecinsPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.disponibilites_medecinsPresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode chaine_activee */

   if (pvalue->m.chaine_activeePresent) {
      PU_PUSHNAME (ctxt_p, "chaine_activee");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->chaine_activee);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode priorites */

   if (pvalue->m.prioritesPresent) {
      PU_PUSHNAME (ctxt_p, "priorites");

      stat = asn1PE_LogMedicalPriorities (ctxt_p, &pvalue->priorites);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode priorites_tactiques */

   if (pvalue->m.priorites_tactiquesPresent) {
      PU_PUSHNAME (ctxt_p, "priorites_tactiques");

      stat = asn1PE_AutomatList (ctxt_p, &pvalue->priorites_tactiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode disponibilites_ambulances_releve */

   if (pvalue->m.disponibilites_ambulances_relevePresent) {
      PU_PUSHNAME (ctxt_p, "disponibilites_ambulances_releve");

      stat = asn1PE__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_ambulances_releve);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode disponibilites_ambulances_ramassage */

   if (pvalue->m.disponibilites_ambulances_ramassagePresent) {
      PU_PUSHNAME (ctxt_p, "disponibilites_ambulances_ramassage");

      stat = asn1PE__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_ambulances_ramassage);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode disponibilites_medecins */

   if (pvalue->m.disponibilites_medecinsPresent) {
      PU_PUSHNAME (ctxt_p, "disponibilites_medecins");

      stat = asn1PE__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_medecins);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MsgLogMedicalState: end\n");
   return (stat);
}

int ASN1C_MsgLogMedicalState::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgLogMedicalState (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgLogMedicalState (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalState* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_MsgLogMedicalState: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "chaine_activeePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.chaine_activeePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "prioritesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.prioritesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "priorites_tactiquesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.priorites_tactiquesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "disponibilites_ambulances_relevePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.disponibilites_ambulances_relevePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "disponibilites_ambulances_ramassagePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.disponibilites_ambulances_ramassagePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "disponibilites_medecinsPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.disponibilites_medecinsPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode oid_pion */

   PU_PUSHNAME (ctxt_p, "oid_pion");

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode chaine_activee */

   if (pvalue->m.chaine_activeePresent) {
      PU_PUSHNAME (ctxt_p, "chaine_activee");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->chaine_activee);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }

   /* decode priorites */

   if (pvalue->m.prioritesPresent) {
      PU_PUSHNAME (ctxt_p, "priorites");

      stat = asn1PD_LogMedicalPriorities (ctxt_p, &pvalue->priorites);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode priorites_tactiques */

   if (pvalue->m.priorites_tactiquesPresent) {
      PU_PUSHNAME (ctxt_p, "priorites_tactiques");

      stat = asn1PD_AutomatList (ctxt_p, &pvalue->priorites_tactiques);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode disponibilites_ambulances_releve */

   if (pvalue->m.disponibilites_ambulances_relevePresent) {
      PU_PUSHNAME (ctxt_p, "disponibilites_ambulances_releve");

      stat = asn1PD__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_ambulances_releve);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode disponibilites_ambulances_ramassage */

   if (pvalue->m.disponibilites_ambulances_ramassagePresent) {
      PU_PUSHNAME (ctxt_p, "disponibilites_ambulances_ramassage");

      stat = asn1PD__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_ambulances_ramassage);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode disponibilites_medecins */

   if (pvalue->m.disponibilites_medecinsPresent) {
      PU_PUSHNAME (ctxt_p, "disponibilites_medecins");

      stat = asn1PD__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_medecins);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MsgLogMedicalState: end\n");

   return (stat);
}

int ASN1C_MsgLogMedicalState::Decode ()
{
   return asn1PD_MsgLogMedicalState (mpContext->GetPtr(), &msgData);
}

