/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 24-Dec-2009.
 */
#include "LogSante.h"

/**************************************************************/
/*                                                            */
/*  LogSanteIncludes                                          */
/*                                                            */
/**************************************************************/

ASN1C_LogSanteIncludes::ASN1C_LogSanteIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_LogSanteIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_LogSanteIncludes (ASN1CTXT* ctxt_p, ASN1T_LogSanteIncludes* pvalue)
{
   int stat = ASN_OK;

   /* encode baseExports */

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_LogSanteIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_LogSanteIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_LogSanteIncludes (ASN1CTXT* ctxt_p, ASN1T_LogSanteIncludes* pvalue)
{
   int stat = ASN_OK;

   /* decode baseExports */

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_LogSanteIncludes::Decode ()
{
   return asn1PD_LogSanteIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  LogSanteExports                                           */
/*                                                            */
/**************************************************************/

ASN1C_LogSanteExports::ASN1C_LogSanteExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_LogSanteExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */
   return (stat);
}

int ASN1C_LogSanteExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_LogSanteExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_LogSanteExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */

   return (stat);
}

int ASN1C_LogSanteExports::Decode ()
{
   return asn1PD_LogSanteExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  EnumLogMedicalHandlingStatus                              */
/*                                                            */
/**************************************************************/

ASN1C_EnumLogMedicalHandlingStatus::ASN1C_EnumLogMedicalHandlingStatus (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumLogMedicalHandlingStatus& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumLogMedicalHandlingStatus (ASN1CTXT* ctxt_p, ASN1T_EnumLogMedicalHandlingStatus value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   switch (value) {
      case EnumLogMedicalHandlingStatus::attente_disponibilite_ambulance_releve: ui = 0; break;
      case EnumLogMedicalHandlingStatus::ambulance_releve_deplacement_aller: ui = 1; break;
      case EnumLogMedicalHandlingStatus::ambulance_releve_chargement: ui = 2; break;
      case EnumLogMedicalHandlingStatus::attente_chargement_complet_ambulance_releve: ui = 3; break;
      case EnumLogMedicalHandlingStatus::ambulance_releve_deplacement_retour: ui = 4; break;
      case EnumLogMedicalHandlingStatus::ambulance_releve_dechargement: ui = 5; break;
      case EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_diagnostique: ui = 6; break;
      case EnumLogMedicalHandlingStatus::diagnostique: ui = 7; break;
      case EnumLogMedicalHandlingStatus::recherche_secteur_tri: ui = 8; break;
      case EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_tri: ui = 9; break;
      case EnumLogMedicalHandlingStatus::tri: ui = 10; break;
      case EnumLogMedicalHandlingStatus::recherche_secteur_soin: ui = 11; break;
      case EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_soin: ui = 12; break;
      case EnumLogMedicalHandlingStatus::soin: ui = 13; break;
      case EnumLogMedicalHandlingStatus::hospitalisation: ui = 14; break;
      case EnumLogMedicalHandlingStatus::attente_disponibilite_ambulance_ramassage: ui = 15; break;
      case EnumLogMedicalHandlingStatus::ambulance_ramassage_chargement: ui = 16; break;
      case EnumLogMedicalHandlingStatus::attente_chargement_complet_ambulance_ramassage: ui = 17; break;
      case EnumLogMedicalHandlingStatus::ambulance_ramassage_deplacement_aller: ui = 18; break;
      case EnumLogMedicalHandlingStatus::ambulance_ramassage_dechargement: ui = 19; break;
      case EnumLogMedicalHandlingStatus::termine: ui = 20; break;
      default: return ASN_E_INVENUM;
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 20);
   if (stat != ASN_OK) return stat;
   return (stat);
}

int ASN1C_EnumLogMedicalHandlingStatus::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumLogMedicalHandlingStatus (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumLogMedicalHandlingStatus (ASN1CTXT* ctxt_p, ASN1T_EnumLogMedicalHandlingStatus* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 20);
   if (stat != ASN_OK) return stat;

   switch (ui) {
      case 0: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_ambulance_releve; break;
      case 1: *pvalue = EnumLogMedicalHandlingStatus::ambulance_releve_deplacement_aller; break;
      case 2: *pvalue = EnumLogMedicalHandlingStatus::ambulance_releve_chargement; break;
      case 3: *pvalue = EnumLogMedicalHandlingStatus::attente_chargement_complet_ambulance_releve; break;
      case 4: *pvalue = EnumLogMedicalHandlingStatus::ambulance_releve_deplacement_retour; break;
      case 5: *pvalue = EnumLogMedicalHandlingStatus::ambulance_releve_dechargement; break;
      case 6: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_diagnostique; break;
      case 7: *pvalue = EnumLogMedicalHandlingStatus::diagnostique; break;
      case 8: *pvalue = EnumLogMedicalHandlingStatus::recherche_secteur_tri; break;
      case 9: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_tri; break;
      case 10: *pvalue = EnumLogMedicalHandlingStatus::tri; break;
      case 11: *pvalue = EnumLogMedicalHandlingStatus::recherche_secteur_soin; break;
      case 12: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_medecin_pour_soin; break;
      case 13: *pvalue = EnumLogMedicalHandlingStatus::soin; break;
      case 14: *pvalue = EnumLogMedicalHandlingStatus::hospitalisation; break;
      case 15: *pvalue = EnumLogMedicalHandlingStatus::attente_disponibilite_ambulance_ramassage; break;
      case 16: *pvalue = EnumLogMedicalHandlingStatus::ambulance_ramassage_chargement; break;
      case 17: *pvalue = EnumLogMedicalHandlingStatus::attente_chargement_complet_ambulance_ramassage; break;
      case 18: *pvalue = EnumLogMedicalHandlingStatus::ambulance_ramassage_deplacement_aller; break;
      case 19: *pvalue = EnumLogMedicalHandlingStatus::ambulance_ramassage_dechargement; break;
      case 20: *pvalue = EnumLogMedicalHandlingStatus::termine; break;
      default: return ASN_E_INVENUM;
   }

   return (stat);
}

int ASN1C_EnumLogMedicalHandlingStatus::Decode ()
{
   return asn1PD_EnumLogMedicalHandlingStatus (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgLogMedicalHandlingCreation                             */
/*                                                            */
/**************************************************************/

ASN1C_MsgLogMedicalHandlingCreation::ASN1C_MsgLogMedicalHandlingCreation (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgLogMedicalHandlingCreation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgLogMedicalHandlingCreation (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingCreation* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->blesse_mental != FALSE));

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->contamine_nbc != FALSE));

   /* encode oid_consigne */

   stat = asn1PE_OID (ctxt_p, pvalue->oid_consigne);
   if (stat != ASN_OK) return stat;

   /* encode oid_pion */

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return stat;

   /* encode tick_creation */

   stat = pe_UnconsInteger (ctxt_p, pvalue->tick_creation);
   if (stat != ASN_OK) return stat;

   /* encode rang */

   stat = asn1PE_EnumHumanRank (ctxt_p, pvalue->rang);
   if (stat != ASN_OK) return stat;

   /* encode blessure */

   stat = asn1PE_EnumHumanWound (ctxt_p, pvalue->blessure);
   if (stat != ASN_OK) return stat;

   /* encode blesse_mental */

   if (pvalue->blesse_mental != FALSE) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->blesse_mental);
      if (stat != ASN_OK) return stat;
   }

   /* encode contamine_nbc */

   if (pvalue->contamine_nbc != FALSE) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->contamine_nbc);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_MsgLogMedicalHandlingCreation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgLogMedicalHandlingCreation (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgLogMedicalHandlingCreation (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingCreation* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL blesse_mentalPresent;
   ASN1BOOL contamine_nbcPresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   blesse_mentalPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   contamine_nbcPresent = optbit;

   /* decode oid_consigne */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_consigne);
   if (stat != ASN_OK) return stat;

   /* decode oid_pion */

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return stat;

   /* decode tick_creation */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->tick_creation);
   if (stat != ASN_OK) return stat;

   /* decode rang */

   stat = asn1PD_EnumHumanRank (ctxt_p, &pvalue->rang);
   if (stat != ASN_OK) return stat;

   /* decode blessure */

   stat = asn1PD_EnumHumanWound (ctxt_p, &pvalue->blessure);
   if (stat != ASN_OK) return stat;

   /* decode blesse_mental */

   if (blesse_mentalPresent) {
      stat = pd_bit (ctxt_p, &pvalue->blesse_mental);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->blesse_mental = FALSE;
   }

   /* decode contamine_nbc */

   if (contamine_nbcPresent) {
      stat = pd_bit (ctxt_p, &pvalue->contamine_nbc);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->contamine_nbc = FALSE;
   }


   return (stat);
}

int ASN1C_MsgLogMedicalHandlingCreation::Decode ()
{
   return asn1PD_MsgLogMedicalHandlingCreation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgLogMedicalHandlingUpdate                               */
/*                                                            */
/**************************************************************/

ASN1C_MsgLogMedicalHandlingUpdate::ASN1C_MsgLogMedicalHandlingUpdate (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgLogMedicalHandlingUpdate& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgLogMedicalHandlingUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingUpdate* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.oid_pion_log_traitantPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.blessurePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.blesse_mentalPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.contamine_nbcPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.etatPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.diagnostique_effectuePresent);

   /* encode oid_consigne */

   stat = asn1PE_OID (ctxt_p, pvalue->oid_consigne);
   if (stat != ASN_OK) return stat;

   /* encode oid_pion */

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return stat;

   /* encode oid_pion_log_traitant */

   if (pvalue->m.oid_pion_log_traitantPresent) {
      stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion_log_traitant);
      if (stat != ASN_OK) return stat;
   }

   /* encode blessure */

   if (pvalue->m.blessurePresent) {
      stat = asn1PE_EnumHumanWound (ctxt_p, pvalue->blessure);
      if (stat != ASN_OK) return stat;
   }

   /* encode blesse_mental */

   if (pvalue->m.blesse_mentalPresent) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->blesse_mental);
      if (stat != ASN_OK) return stat;
   }

   /* encode contamine_nbc */

   if (pvalue->m.contamine_nbcPresent) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->contamine_nbc);
      if (stat != ASN_OK) return stat;
   }

   /* encode etat */

   if (pvalue->m.etatPresent) {
      stat = asn1PE_EnumLogMedicalHandlingStatus (ctxt_p, pvalue->etat);
      if (stat != ASN_OK) return stat;
   }

   /* encode diagnostique_effectue */

   if (pvalue->m.diagnostique_effectuePresent) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->diagnostique_effectue);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_MsgLogMedicalHandlingUpdate::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgLogMedicalHandlingUpdate (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgLogMedicalHandlingUpdate (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingUpdate* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pd_bit (ctxt_p, &optbit);
   pvalue->m.oid_pion_log_traitantPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.blessurePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.blesse_mentalPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.contamine_nbcPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.etatPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.diagnostique_effectuePresent = optbit;

   /* decode oid_consigne */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_consigne);
   if (stat != ASN_OK) return stat;

   /* decode oid_pion */

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return stat;

   /* decode oid_pion_log_traitant */

   if (pvalue->m.oid_pion_log_traitantPresent) {
      stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion_log_traitant);
      if (stat != ASN_OK) return stat;
   }

   /* decode blessure */

   if (pvalue->m.blessurePresent) {
      stat = asn1PD_EnumHumanWound (ctxt_p, &pvalue->blessure);
      if (stat != ASN_OK) return stat;
   }

   /* decode blesse_mental */

   if (pvalue->m.blesse_mentalPresent) {
      stat = pd_bit (ctxt_p, &pvalue->blesse_mental);
      if (stat != ASN_OK) return stat;
   }

   /* decode contamine_nbc */

   if (pvalue->m.contamine_nbcPresent) {
      stat = pd_bit (ctxt_p, &pvalue->contamine_nbc);
      if (stat != ASN_OK) return stat;
   }

   /* decode etat */

   if (pvalue->m.etatPresent) {
      stat = asn1PD_EnumLogMedicalHandlingStatus (ctxt_p, &pvalue->etat);
      if (stat != ASN_OK) return stat;
   }

   /* decode diagnostique_effectue */

   if (pvalue->m.diagnostique_effectuePresent) {
      stat = pd_bit (ctxt_p, &pvalue->diagnostique_effectue);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_MsgLogMedicalHandlingUpdate::Decode ()
{
   return asn1PD_MsgLogMedicalHandlingUpdate (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgLogMedicalHandlingDestruction                          */
/*                                                            */
/**************************************************************/

ASN1C_MsgLogMedicalHandlingDestruction::ASN1C_MsgLogMedicalHandlingDestruction (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgLogMedicalHandlingDestruction& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgLogMedicalHandlingDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingDestruction* pvalue)
{
   int stat = ASN_OK;

   /* encode oid_consigne */

   stat = asn1PE_OID (ctxt_p, pvalue->oid_consigne);
   if (stat != ASN_OK) return stat;

   /* encode oid_pion */

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgLogMedicalHandlingDestruction::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgLogMedicalHandlingDestruction (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgLogMedicalHandlingDestruction (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalHandlingDestruction* pvalue)
{
   int stat = ASN_OK;

   /* decode oid_consigne */

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_consigne);
   if (stat != ASN_OK) return stat;

   /* decode oid_pion */

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgLogMedicalHandlingDestruction::Decode ()
{
   return asn1PD_MsgLogMedicalHandlingDestruction (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  LogMedicalEquipmentAvailability                           */
/*                                                            */
/**************************************************************/

ASN1C_LogMedicalEquipmentAvailability::ASN1C_LogMedicalEquipmentAvailability (
   ASN1MessageBuffer& msgBuf, ASN1T_LogMedicalEquipmentAvailability& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_LogMedicalEquipmentAvailability (ASN1CTXT* ctxt_p, ASN1T_LogMedicalEquipmentAvailability* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->nbr_pretes != 0));

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.nbr_au_reposPresent);

   /* encode type_equipement */

   stat = asn1PE_EquipmentType (ctxt_p, pvalue->type_equipement);
   if (stat != ASN_OK) return stat;

   /* encode nbr_total */

   stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_total);
   if (stat != ASN_OK) return stat;

   /* encode nbr_disponibles */

   stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_disponibles);
   if (stat != ASN_OK) return stat;

   /* encode nbr_au_travail */

   stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_au_travail);
   if (stat != ASN_OK) return stat;

   /* encode nbr_pretes */

   if (pvalue->nbr_pretes != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_pretes);
      if (stat != ASN_OK) return stat;
   }

   /* encode nbr_au_repos */

   if (pvalue->m.nbr_au_reposPresent) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->nbr_au_repos);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_LogMedicalEquipmentAvailability::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_LogMedicalEquipmentAvailability (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_LogMedicalEquipmentAvailability (ASN1CTXT* ctxt_p, ASN1T_LogMedicalEquipmentAvailability* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL nbr_pretesPresent;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pd_bit (ctxt_p, &optbit);
   nbr_pretesPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.nbr_au_reposPresent = optbit;

   /* decode type_equipement */

   stat = asn1PD_EquipmentType (ctxt_p, &pvalue->type_equipement);
   if (stat != ASN_OK) return stat;

   /* decode nbr_total */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_total);
   if (stat != ASN_OK) return stat;

   /* decode nbr_disponibles */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_disponibles);
   if (stat != ASN_OK) return stat;

   /* decode nbr_au_travail */

   stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_au_travail);
   if (stat != ASN_OK) return stat;

   /* decode nbr_pretes */

   if (nbr_pretesPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_pretes);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->nbr_pretes = 0;
   }

   /* decode nbr_au_repos */

   if (pvalue->m.nbr_au_reposPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->nbr_au_repos);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_LogMedicalEquipmentAvailability::Decode ()
{
   return asn1PD_LogMedicalEquipmentAvailability (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  LogMedicalPriorities                                      */
/*                                                            */
/**************************************************************/

ASN1C_LogMedicalPriorities::ASN1C_LogMedicalPriorities (
   ASN1MessageBuffer& msgBuf, ASN1T_LogMedicalPriorities& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_LogMedicalPriorities (ASN1CTXT* ctxt_p, ASN1T_LogMedicalPriorities* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* encode length determinant */

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_EnumHumanWound (ctxt_p, pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }
   return (stat);
}

int ASN1C_LogMedicalPriorities::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_LogMedicalPriorities (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_LogMedicalPriorities (ASN1CTXT* ctxt_p, ASN1T_LogMedicalPriorities* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return stat;

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_EnumHumanWound);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_EnumHumanWound (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_LogMedicalPriorities::Decode ()
{
   return asn1PD_LogMedicalPriorities (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  _SeqOfLogMedicalEquipmentAvailability                     */
/*                                                            */
/**************************************************************/

ASN1C__SeqOfLogMedicalEquipmentAvailability::ASN1C__SeqOfLogMedicalEquipmentAvailability (
   ASN1MessageBuffer& msgBuf, ASN1T__SeqOfLogMedicalEquipmentAvailability& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE__SeqOfLogMedicalEquipmentAvailability (ASN1CTXT* ctxt_p, ASN1T__SeqOfLogMedicalEquipmentAvailability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* encode length determinant */

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_LogMedicalEquipmentAvailability (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }
   return (stat);
}

int ASN1C__SeqOfLogMedicalEquipmentAvailability::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE__SeqOfLogMedicalEquipmentAvailability (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD__SeqOfLogMedicalEquipmentAvailability (ASN1CTXT* ctxt_p, ASN1T__SeqOfLogMedicalEquipmentAvailability* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   /* decode length determinant */

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return stat;

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_LogMedicalEquipmentAvailability);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_LogMedicalEquipmentAvailability (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C__SeqOfLogMedicalEquipmentAvailability::Decode ()
{
   return asn1PD__SeqOfLogMedicalEquipmentAvailability (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgLogMedicalState                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgLogMedicalState::ASN1C_MsgLogMedicalState (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgLogMedicalState& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgLogMedicalState (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalState* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.chaine_activeePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.prioritesPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.priorites_tactiquesPresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.disponibilites_ambulances_relevePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.disponibilites_ambulances_ramassagePresent);

   pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.disponibilites_medecinsPresent);

   /* encode oid_pion */

   stat = asn1PE_Unit (ctxt_p, pvalue->oid_pion);
   if (stat != ASN_OK) return stat;

   /* encode chaine_activee */

   if (pvalue->m.chaine_activeePresent) {
      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->chaine_activee);
      if (stat != ASN_OK) return stat;
   }

   /* encode priorites */

   if (pvalue->m.prioritesPresent) {
      stat = asn1PE_LogMedicalPriorities (ctxt_p, &pvalue->priorites);
      if (stat != ASN_OK) return stat;
   }

   /* encode priorites_tactiques */

   if (pvalue->m.priorites_tactiquesPresent) {
      stat = asn1PE_AutomatList (ctxt_p, &pvalue->priorites_tactiques);
      if (stat != ASN_OK) return stat;
   }

   /* encode disponibilites_ambulances_releve */

   if (pvalue->m.disponibilites_ambulances_relevePresent) {
      stat = asn1PE__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_ambulances_releve);
      if (stat != ASN_OK) return stat;
   }

   /* encode disponibilites_ambulances_ramassage */

   if (pvalue->m.disponibilites_ambulances_ramassagePresent) {
      stat = asn1PE__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_ambulances_ramassage);
      if (stat != ASN_OK) return stat;
   }

   /* encode disponibilites_medecins */

   if (pvalue->m.disponibilites_medecinsPresent) {
      stat = asn1PE__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_medecins);
      if (stat != ASN_OK) return stat;
   }

   return (stat);
}

int ASN1C_MsgLogMedicalState::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgLogMedicalState (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgLogMedicalState (ASN1CTXT* ctxt_p, ASN1T_MsgLogMedicalState* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pd_bit (ctxt_p, &optbit);
   pvalue->m.chaine_activeePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.prioritesPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.priorites_tactiquesPresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.disponibilites_ambulances_relevePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.disponibilites_ambulances_ramassagePresent = optbit;

   pd_bit (ctxt_p, &optbit);
   pvalue->m.disponibilites_medecinsPresent = optbit;

   /* decode oid_pion */

   stat = asn1PD_Unit (ctxt_p, &pvalue->oid_pion);
   if (stat != ASN_OK) return stat;

   /* decode chaine_activee */

   if (pvalue->m.chaine_activeePresent) {
      stat = pd_bit (ctxt_p, &pvalue->chaine_activee);
      if (stat != ASN_OK) return stat;
   }

   /* decode priorites */

   if (pvalue->m.prioritesPresent) {
      stat = asn1PD_LogMedicalPriorities (ctxt_p, &pvalue->priorites);
      if (stat != ASN_OK) return stat;
   }

   /* decode priorites_tactiques */

   if (pvalue->m.priorites_tactiquesPresent) {
      stat = asn1PD_AutomatList (ctxt_p, &pvalue->priorites_tactiques);
      if (stat != ASN_OK) return stat;
   }

   /* decode disponibilites_ambulances_releve */

   if (pvalue->m.disponibilites_ambulances_relevePresent) {
      stat = asn1PD__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_ambulances_releve);
      if (stat != ASN_OK) return stat;
   }

   /* decode disponibilites_ambulances_ramassage */

   if (pvalue->m.disponibilites_ambulances_ramassagePresent) {
      stat = asn1PD__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_ambulances_ramassage);
      if (stat != ASN_OK) return stat;
   }

   /* decode disponibilites_medecins */

   if (pvalue->m.disponibilites_medecinsPresent) {
      stat = asn1PD__SeqOfLogMedicalEquipmentAvailability (ctxt_p, &pvalue->disponibilites_medecins);
      if (stat != ASN_OK) return stat;
   }


   return (stat);
}

int ASN1C_MsgLogMedicalState::Decode ()
{
   return asn1PD_MsgLogMedicalState (mpContext->GetPtr(), &msgData);
}

