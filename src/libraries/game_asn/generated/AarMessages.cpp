/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 28-Feb-2008.
 */
#include "AarMessages.h"

/**************************************************************/
/*                                                            */
/*  AarMessagesIncludes                                       */
/*                                                            */
/**************************************************************/

ASN1C_AarMessagesIncludes::ASN1C_AarMessagesIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_AarMessagesIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_AarMessagesIncludes (ASN1CTXT* ctxt_p, ASN1T_AarMessagesIncludes* pvalue)
{
   int stat = ASN_OK;

   /* encode aarExports */

   stat = asn1PE_AarExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_AarMessagesIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AarMessagesIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_AarMessagesIncludes (ASN1CTXT* ctxt_p, ASN1T_AarMessagesIncludes* pvalue)
{
   int stat = ASN_OK;

   /* decode aarExports */

   stat = asn1PD_AarExports (ctxt_p);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_AarMessagesIncludes::Decode ()
{
   return asn1PD_AarMessagesIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  AarMessagesExports                                        */
/*                                                            */
/**************************************************************/

ASN1C_AarMessagesExports::ASN1C_AarMessagesExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_AarMessagesExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */
   return (stat);
}

int ASN1C_AarMessagesExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_AarMessagesExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_AarMessagesExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */

   return (stat);
}

int ASN1C_AarMessagesExports::Decode ()
{
   return asn1PD_AarMessagesExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  MsgsAarToClient_msg                                       */
/*                                                            */
/**************************************************************/

ASN1C_MsgsAarToClient_msg::ASN1C_MsgsAarToClient_msg (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsAarToClient_msg& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsAarToClient_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsAarToClient_msg* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 1);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* msg_aar_information */
      case 1:
         stat = asn1PE_MsgAarInformation (ctxt_p, pvalue->u.msg_aar_information);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_indicator_result */
      case 2:
         stat = asn1PE_MsgIndicatorResult (ctxt_p, pvalue->u.msg_indicator_result);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MsgsAarToClient_msg::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsAarToClient_msg (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsAarToClient_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsAarToClient_msg* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* msg_aar_information */
      case 0:
         pvalue->u.msg_aar_information = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgAarInformation);

         stat = asn1PD_MsgAarInformation (ctxt_p, pvalue->u.msg_aar_information);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_indicator_result */
      case 1:
         pvalue->u.msg_indicator_result = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgIndicatorResult);

         stat = asn1PD_MsgIndicatorResult (ctxt_p, pvalue->u.msg_indicator_result);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MsgsAarToClient_msg::Decode ()
{
   return asn1PD_MsgsAarToClient_msg (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsAarToClient                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgsAarToClient::ASN1C_MsgsAarToClient (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsAarToClient& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsAarToClient (ASN1CTXT* ctxt_p, ASN1T_MsgsAarToClient* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->context != 0));

   /* encode context */

   if (pvalue->context != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->context);
      if (stat != ASN_OK) return stat;
   }

   /* encode msg */

   stat = asn1PE_MsgsAarToClient_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgsAarToClient::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsAarToClient (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsAarToClient (ASN1CTXT* ctxt_p, ASN1T_MsgsAarToClient* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL contextPresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   contextPresent = optbit;

   /* decode context */

   if (contextPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->context);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->context = 0;
   }

   /* decode msg */

   stat = asn1PD_MsgsAarToClient_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgsAarToClient::Decode ()
{
   return asn1PD_MsgsAarToClient (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsClientToAar_msg                                       */
/*                                                            */
/**************************************************************/

ASN1C_MsgsClientToAar_msg::ASN1C_MsgsClientToAar_msg (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsClientToAar_msg& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsClientToAar_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsClientToAar_msg* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 0);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* msg_indicator_request */
      case 1:
         stat = asn1PE_MsgIndicatorRequest (ctxt_p, pvalue->u.msg_indicator_request);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MsgsClientToAar_msg::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsClientToAar_msg (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsClientToAar_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsClientToAar_msg* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 0);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* msg_indicator_request */
      case 0:
         pvalue->u.msg_indicator_request = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgIndicatorRequest);

         stat = asn1PD_MsgIndicatorRequest (ctxt_p, pvalue->u.msg_indicator_request);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MsgsClientToAar_msg::Decode ()
{
   return asn1PD_MsgsClientToAar_msg (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsClientToAar                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgsClientToAar::ASN1C_MsgsClientToAar (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsClientToAar& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsClientToAar (ASN1CTXT* ctxt_p, ASN1T_MsgsClientToAar* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->context != 0));

   /* encode context */

   if (pvalue->context != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->context);
      if (stat != ASN_OK) return stat;
   }

   /* encode msg */

   stat = asn1PE_MsgsClientToAar_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgsClientToAar::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsClientToAar (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsClientToAar (ASN1CTXT* ctxt_p, ASN1T_MsgsClientToAar* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL contextPresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   contextPresent = optbit;

   /* decode context */

   if (contextPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->context);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->context = 0;
   }

   /* decode msg */

   stat = asn1PD_MsgsClientToAar_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgsClientToAar::Decode ()
{
   return asn1PD_MsgsClientToAar (mpContext->GetPtr(), &msgData);
}

