/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 09-Jul-2009.
 */
#include "ReplayMessages.h"

/**************************************************************/
/*                                                            */
/*  ReplayMessagesIncludes                                    */
/*                                                            */
/**************************************************************/

ASN1C_ReplayMessagesIncludes::ASN1C_ReplayMessagesIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_ReplayMessagesIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ReplayMessagesIncludes (ASN1CTXT* ctxt_p, ASN1T_ReplayMessagesIncludes* pvalue)
{
   int stat = ASN_OK;

   /* encode controlExports */

   stat = asn1PE_ControlExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_ReplayMessagesIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ReplayMessagesIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ReplayMessagesIncludes (ASN1CTXT* ctxt_p, ASN1T_ReplayMessagesIncludes* pvalue)
{
   int stat = ASN_OK;

   /* decode controlExports */

   stat = asn1PD_ControlExports (ctxt_p);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_ReplayMessagesIncludes::Decode ()
{
   return asn1PD_ReplayMessagesIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ReplayMessagesExports                                     */
/*                                                            */
/**************************************************************/

ASN1C_ReplayMessagesExports::ASN1C_ReplayMessagesExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_ReplayMessagesExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */
   return (stat);
}

int ASN1C_ReplayMessagesExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ReplayMessagesExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_ReplayMessagesExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */

   return (stat);
}

int ASN1C_ReplayMessagesExports::Decode ()
{
   return asn1PD_ReplayMessagesExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  MsgsReplayToClient_msg                                    */
/*                                                            */
/**************************************************************/

ASN1C_MsgsReplayToClient_msg::ASN1C_MsgsReplayToClient_msg (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsReplayToClient_msg& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsReplayToClient_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsReplayToClient_msg* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 5);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* msg_control_replay_information */
      case 1:
         stat = asn1PE_MsgControlReplayInformation (ctxt_p, pvalue->u.msg_control_replay_information);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_stop_ack */
      case 2:
         stat = asn1PE_MsgControlStopAck (ctxt_p, pvalue->u.msg_control_stop_ack);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_pause_ack */
      case 3:
         stat = asn1PE_MsgControlPauseAck (ctxt_p, pvalue->u.msg_control_pause_ack);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_resume_ack */
      case 4:
         stat = asn1PE_MsgControlResumeAck (ctxt_p, pvalue->u.msg_control_resume_ack);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_skip_to_tick_ack */
      case 5:
         stat = asn1PE_MsgControlSkipToTickAck (ctxt_p, pvalue->u.msg_control_skip_to_tick_ack);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_change_time_factor_ack */
      case 6:
         stat = asn1PE_MsgControlChangeTimeFactorAck (ctxt_p, pvalue->u.msg_control_change_time_factor_ack);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MsgsReplayToClient_msg::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsReplayToClient_msg (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsReplayToClient_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsReplayToClient_msg* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 5);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* msg_control_replay_information */
      case 0:
         pvalue->u.msg_control_replay_information = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgControlReplayInformation);

         stat = asn1PD_MsgControlReplayInformation (ctxt_p, pvalue->u.msg_control_replay_information);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_stop_ack */
      case 1:
         stat = asn1PD_MsgControlStopAck (ctxt_p, &pvalue->u.msg_control_stop_ack);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_pause_ack */
      case 2:
         stat = asn1PD_MsgControlPauseAck (ctxt_p, &pvalue->u.msg_control_pause_ack);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_resume_ack */
      case 3:
         stat = asn1PD_MsgControlResumeAck (ctxt_p, &pvalue->u.msg_control_resume_ack);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_skip_to_tick_ack */
      case 4:
         pvalue->u.msg_control_skip_to_tick_ack = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgControlSkipToTickAck);

         stat = asn1PD_MsgControlSkipToTickAck (ctxt_p, pvalue->u.msg_control_skip_to_tick_ack);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_change_time_factor_ack */
      case 5:
         pvalue->u.msg_control_change_time_factor_ack = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgControlChangeTimeFactorAck);

         stat = asn1PD_MsgControlChangeTimeFactorAck (ctxt_p, pvalue->u.msg_control_change_time_factor_ack);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MsgsReplayToClient_msg::Decode ()
{
   return asn1PD_MsgsReplayToClient_msg (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsReplayToClient                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgsReplayToClient::ASN1C_MsgsReplayToClient (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsReplayToClient& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsReplayToClient (ASN1CTXT* ctxt_p, ASN1T_MsgsReplayToClient* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->context != 0));

   /* encode context */

   if (pvalue->context != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->context);
      if (stat != ASN_OK) return stat;
   }

   /* encode msg */

   stat = asn1PE_MsgsReplayToClient_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgsReplayToClient::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsReplayToClient (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsReplayToClient (ASN1CTXT* ctxt_p, ASN1T_MsgsReplayToClient* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL contextPresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   contextPresent = optbit;

   /* decode context */

   if (contextPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->context);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->context = 0;
   }

   /* decode msg */

   stat = asn1PD_MsgsReplayToClient_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgsReplayToClient::Decode ()
{
   return asn1PD_MsgsReplayToClient (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsClientToReplay_msg                                    */
/*                                                            */
/**************************************************************/

ASN1C_MsgsClientToReplay_msg::ASN1C_MsgsClientToReplay_msg (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsClientToReplay_msg& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsClientToReplay_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsClientToReplay_msg* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 4);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* msg_control_stop */
      case 1:
         stat = asn1PE_MsgControlStop (ctxt_p);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_pause */
      case 2:
         stat = asn1PE_MsgControlPause (ctxt_p);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_resume */
      case 3:
         stat = asn1PE_MsgControlResume (ctxt_p);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_skip_to_tick */
      case 4:
         stat = asn1PE_MsgControlSkipToTick (ctxt_p, pvalue->u.msg_control_skip_to_tick);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_control_change_time_factor */
      case 5:
         stat = asn1PE_MsgControlChangeTimeFactor (ctxt_p, pvalue->u.msg_control_change_time_factor);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MsgsClientToReplay_msg::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsClientToReplay_msg (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsClientToReplay_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsClientToReplay_msg* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 4);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* msg_control_stop */
      case 0:
         stat = asn1PD_MsgControlStop (ctxt_p);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_pause */
      case 1:
         stat = asn1PD_MsgControlPause (ctxt_p);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_resume */
      case 2:
         stat = asn1PD_MsgControlResume (ctxt_p);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_skip_to_tick */
      case 3:
         stat = asn1PD_MsgControlSkipToTick (ctxt_p, &pvalue->u.msg_control_skip_to_tick);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_control_change_time_factor */
      case 4:
         stat = asn1PD_MsgControlChangeTimeFactor (ctxt_p, &pvalue->u.msg_control_change_time_factor);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MsgsClientToReplay_msg::Decode ()
{
   return asn1PD_MsgsClientToReplay_msg (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsClientToReplay                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgsClientToReplay::ASN1C_MsgsClientToReplay (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsClientToReplay& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsClientToReplay (ASN1CTXT* ctxt_p, ASN1T_MsgsClientToReplay* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->context != 0));

   /* encode context */

   if (pvalue->context != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->context);
      if (stat != ASN_OK) return stat;
   }

   /* encode msg */

   stat = asn1PE_MsgsClientToReplay_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgsClientToReplay::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsClientToReplay (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsClientToReplay (ASN1CTXT* ctxt_p, ASN1T_MsgsClientToReplay* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL contextPresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   contextPresent = optbit;

   /* decode context */

   if (contextPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->context);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->context = 0;
   }

   /* decode msg */

   stat = asn1PD_MsgsClientToReplay_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgsClientToReplay::Decode ()
{
   return asn1PD_MsgsClientToReplay (mpContext->GetPtr(), &msgData);
}

