/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 20-Sep-2007.
 */
#include "Messages.h"

/**************************************************************/
/*                                                            */
/*  MessagesIncludes                                          */
/*                                                            */
/**************************************************************/

ASN1C_MessagesIncludes::ASN1C_MessagesIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_MessagesIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MessagesIncludes (ASN1CTXT* ctxt_p, ASN1T_MessagesIncludes* pvalue)
{
   int stat = ASN_OK;

   /* encode profilesExports */

   stat = asn1PE_ProfilesExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* encode exercisesExports */

   stat = asn1PE_ExercisesExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* encode gamesExports */

   stat = asn1PE_GamesExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* encode dataExports */

   stat = asn1PE_DataExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MessagesIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MessagesIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MessagesIncludes (ASN1CTXT* ctxt_p, ASN1T_MessagesIncludes* pvalue)
{
   int stat = ASN_OK;

   /* decode profilesExports */

   stat = asn1PD_ProfilesExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* decode exercisesExports */

   stat = asn1PD_ExercisesExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* decode gamesExports */

   stat = asn1PD_GamesExports (ctxt_p);
   if (stat != ASN_OK) return stat;

   /* decode dataExports */

   stat = asn1PD_DataExports (ctxt_p);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MessagesIncludes::Decode ()
{
   return asn1PD_MessagesIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MessagesExports                                           */
/*                                                            */
/**************************************************************/

ASN1C_MessagesExports::ASN1C_MessagesExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_MessagesExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */
   return (stat);
}

int ASN1C_MessagesExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MessagesExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_MessagesExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   /* NULL */

   return (stat);
}

int ASN1C_MessagesExports::Decode ()
{
   return asn1PD_MessagesExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  MsgsInMaster_msg                                          */
/*                                                            */
/**************************************************************/

ASN1C_MsgsInMaster_msg::ASN1C_MsgsInMaster_msg (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsInMaster_msg& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsInMaster_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsInMaster_msg* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 3);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* msg_authentication_request */
      case 1:
         stat = asn1PE_MsgAuthenticationRequest (ctxt_p, pvalue->u.msg_authentication_request);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_creation_request */
      case 2:
         stat = asn1PE_MsgExerciseCreationRequest (ctxt_p, pvalue->u.msg_exercise_creation_request);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_update_request */
      case 3:
         stat = asn1PE_MsgExerciseUpdateRequest (ctxt_p, pvalue->u.msg_exercise_update_request);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_destruction_request */
      case 4:
         stat = asn1PE_MsgExerciseDestructionRequest (ctxt_p, pvalue->u.msg_exercise_destruction_request);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MsgsInMaster_msg::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsInMaster_msg (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsInMaster_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsInMaster_msg* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 3);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* msg_authentication_request */
      case 0:
         pvalue->u.msg_authentication_request = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgAuthenticationRequest);

         stat = asn1PD_MsgAuthenticationRequest (ctxt_p, pvalue->u.msg_authentication_request);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_creation_request */
      case 1:
         pvalue->u.msg_exercise_creation_request = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgExerciseCreationRequest);

         stat = asn1PD_MsgExerciseCreationRequest (ctxt_p, pvalue->u.msg_exercise_creation_request);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_update_request */
      case 2:
         pvalue->u.msg_exercise_update_request = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgExerciseUpdateRequest);

         stat = asn1PD_MsgExerciseUpdateRequest (ctxt_p, pvalue->u.msg_exercise_update_request);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_destruction_request */
      case 3:
         stat = asn1PD_MsgExerciseDestructionRequest (ctxt_p, &pvalue->u.msg_exercise_destruction_request);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MsgsInMaster_msg::Decode ()
{
   return asn1PD_MsgsInMaster_msg (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsInMaster                                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgsInMaster::ASN1C_MsgsInMaster (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsInMaster& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsInMaster (ASN1CTXT* ctxt_p, ASN1T_MsgsInMaster* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->context != 0));

   /* encode context */

   if (pvalue->context != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->context);
      if (stat != ASN_OK) return stat;
   }

   /* encode msg */

   stat = asn1PE_MsgsInMaster_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgsInMaster::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsInMaster (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsInMaster (ASN1CTXT* ctxt_p, ASN1T_MsgsInMaster* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL contextPresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   contextPresent = optbit;

   /* decode context */

   if (contextPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->context);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->context = 0;
   }

   /* decode msg */

   stat = asn1PD_MsgsInMaster_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgsInMaster::Decode ()
{
   return asn1PD_MsgsInMaster (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsOutMaster_msg                                         */
/*                                                            */
/**************************************************************/

ASN1C_MsgsOutMaster_msg::ASN1C_MsgsOutMaster_msg (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsOutMaster_msg& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsOutMaster_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsOutMaster_msg* pvalue)
{
   int stat = ASN_OK;

   /* Encode choice index value */

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 9);
   if (stat != ASN_OK) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* msg_authentication_response */
      case 1:
         stat = asn1PE_MsgAuthenticationResponse (ctxt_p, pvalue->u.msg_authentication_response);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_dataset_creation */
      case 2:
         stat = asn1PE_MsgDatasetCreation (ctxt_p, pvalue->u.msg_dataset_creation);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_terrain_creation */
      case 3:
         stat = asn1PE_MsgTerrainCreation (ctxt_p, pvalue->u.msg_terrain_creation);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_physical_model_creation */
      case 4:
         stat = asn1PE_MsgPhysicalModelCreation (ctxt_p, pvalue->u.msg_physical_model_creation);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_creation */
      case 5:
         stat = asn1PE_MsgExerciseCreation (ctxt_p, pvalue->u.msg_exercise_creation);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_update */
      case 6:
         stat = asn1PE_MsgExerciseUpdate (ctxt_p, pvalue->u.msg_exercise_update);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_destruction */
      case 7:
         stat = asn1PE_MsgExerciseDestruction (ctxt_p, pvalue->u.msg_exercise_destruction);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_creation_ack */
      case 8:
         stat = asn1PE_MsgExerciseCreationRequestAck (ctxt_p, pvalue->u.msg_exercise_creation_ack);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_update_ack */
      case 9:
         stat = asn1PE_MsgExerciseUpdateRequestAck (ctxt_p, pvalue->u.msg_exercise_update_ack);
         if (stat != ASN_OK) return stat;
         break;

      /* msg_exercise_destruction_ack */
      case 10:
         stat = asn1PE_MsgExerciseDestructionRequestAck (ctxt_p, pvalue->u.msg_exercise_destruction_ack);
         if (stat != ASN_OK) return stat;
         break;

      default:
         return ASN_E_INVOPT;
   }
   return (stat);
}

int ASN1C_MsgsOutMaster_msg::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsOutMaster_msg (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsOutMaster_msg (ASN1CTXT* ctxt_p, ASN1T_MsgsOutMaster_msg* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 9);
   if (stat != ASN_OK) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* msg_authentication_response */
      case 0:
         pvalue->u.msg_authentication_response = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgAuthenticationResponse);

         stat = asn1PD_MsgAuthenticationResponse (ctxt_p, pvalue->u.msg_authentication_response);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_dataset_creation */
      case 1:
         pvalue->u.msg_dataset_creation = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgDatasetCreation);

         stat = asn1PD_MsgDatasetCreation (ctxt_p, pvalue->u.msg_dataset_creation);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_terrain_creation */
      case 2:
         pvalue->u.msg_terrain_creation = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgTerrainCreation);

         stat = asn1PD_MsgTerrainCreation (ctxt_p, pvalue->u.msg_terrain_creation);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_physical_model_creation */
      case 3:
         pvalue->u.msg_physical_model_creation = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgPhysicalModelCreation);

         stat = asn1PD_MsgPhysicalModelCreation (ctxt_p, pvalue->u.msg_physical_model_creation);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_creation */
      case 4:
         pvalue->u.msg_exercise_creation = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgExerciseCreation);

         stat = asn1PD_MsgExerciseCreation (ctxt_p, pvalue->u.msg_exercise_creation);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_update */
      case 5:
         pvalue->u.msg_exercise_update = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgExerciseUpdate);

         stat = asn1PD_MsgExerciseUpdate (ctxt_p, pvalue->u.msg_exercise_update);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_destruction */
      case 6:
         stat = asn1PD_MsgExerciseDestruction (ctxt_p, &pvalue->u.msg_exercise_destruction);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_creation_ack */
      case 7:
         pvalue->u.msg_exercise_creation_ack = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgExerciseCreationRequestAck);

         stat = asn1PD_MsgExerciseCreationRequestAck (ctxt_p, pvalue->u.msg_exercise_creation_ack);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_update_ack */
      case 8:
         pvalue->u.msg_exercise_update_ack = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgExerciseUpdateRequestAck);

         stat = asn1PD_MsgExerciseUpdateRequestAck (ctxt_p, pvalue->u.msg_exercise_update_ack);
         if (stat != ASN_OK) return stat;

         break;

      /* msg_exercise_destruction_ack */
      case 9:
         pvalue->u.msg_exercise_destruction_ack = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MsgExerciseDestructionRequestAck);

         stat = asn1PD_MsgExerciseDestructionRequestAck (ctxt_p, pvalue->u.msg_exercise_destruction_ack);
         if (stat != ASN_OK) return stat;

         break;

      default:
         return ASN_E_INVOPT;
   }

   return (stat);
}

int ASN1C_MsgsOutMaster_msg::Decode ()
{
   return asn1PD_MsgsOutMaster_msg (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgsOutMaster                                             */
/*                                                            */
/**************************************************************/

ASN1C_MsgsOutMaster::ASN1C_MsgsOutMaster (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgsOutMaster& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgsOutMaster (ASN1CTXT* ctxt_p, ASN1T_MsgsOutMaster* pvalue)
{
   int stat = ASN_OK;

   pe_bit (ctxt_p, (ASN1BOOL)(pvalue->context != 0));

   /* encode context */

   if (pvalue->context != 0) {
      stat = pe_UnconsInteger (ctxt_p, pvalue->context);
      if (stat != ASN_OK) return stat;
   }

   /* encode msg */

   stat = asn1PE_MsgsOutMaster_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;

   return (stat);
}

int ASN1C_MsgsOutMaster::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgsOutMaster (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgsOutMaster (ASN1CTXT* ctxt_p, ASN1T_MsgsOutMaster* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL contextPresent;

   /* optional bits */

   pd_bit (ctxt_p, &optbit);
   contextPresent = optbit;

   /* decode context */

   if (contextPresent) {
      stat = pd_UnconsInteger (ctxt_p, &pvalue->context);
      if (stat != ASN_OK) return stat;
   }
   else {
      pvalue->context = 0;
   }

   /* decode msg */

   stat = asn1PD_MsgsOutMaster_msg (ctxt_p, &pvalue->msg);
   if (stat != ASN_OK) return stat;


   return (stat);
}

int ASN1C_MsgsOutMaster::Decode ()
{
   return asn1PD_MsgsOutMaster (mpContext->GetPtr(), &msgData);
}

