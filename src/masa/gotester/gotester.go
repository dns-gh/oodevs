// ****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2014 MASA Group
//
// ****************************************************************************
package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"swtest"
	"sync"
	"time"
)

var (
	// Matches gocheck test methods
	reTest = regexp.MustCompile(
		`^\s*func\s+\([^\)]+\*TestSuite\)\s*(Test[a-zA-Z0-9_]+)\([^\)]*C\)`)
)

// Returns a list of gocheck test names found in input file.
func listFileTests(path string) ([]string, error) {
	fp, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer fp.Close()

	tests := []string{}
	scanner := bufio.NewScanner(fp)
	for scanner.Scan() {
		line := scanner.Text()
		m := reTest.FindStringSubmatch(line)
		if m != nil {
			tests = append(tests, m[1])
		}
	}
	return tests, scanner.Err()
}

// Returns a list of all gocheck test names found in _test.go file in rootDir
// sub-tree. The names unicity is enforced, which means test names have to be
// unique over all packages in rootDir. This limitation will be lifted once
// we annotate the name with their package and use fine-grained execution.
func listTests(rootDir string) ([]string, error) {
	allTests := []string{}
	seen := map[string]struct{}{}
	err := filepath.Walk(rootDir, func(path string, fi os.FileInfo, err error) error {
		if err != nil || fi.IsDir() || !strings.HasSuffix(path, "_test.go") {
			return err
		}
		tests, err := listFileTests(path)
		if err != nil {
			return err
		}
		for _, test := range tests {
			if _, ok := seen[test]; ok {
				return fmt.Errorf("duplicate test found: %s", test)
			}
			seen[test] = struct{}{}
		}
		allTests = append(allTests, tests...)
		return nil
	})
	return allTests, err
}

func filterTests(tests []string, pattern string) ([]string, error) {
	reFilter, err := regexp.Compile(pattern)
	if err != nil {
		return nil, fmt.Errorf("filtering pattern is invalid: %s", err)
	}
	filtered := []string{}
	for _, test := range tests {
		if reFilter.MatchString(test) {
			filtered = append(filtered, test)
		}
	}
	return filtered, nil
}

// Splits "tests" into at least "jobs" groups. There may be more than "jobs" to
// ensure the generated test command does not run into the maximum runtime
// command line length.
func splitTests(tests []string, jobs int) [][]string {
	groups := [][]string{nil}
	// Maximum tests per group if we split equally
	testsPerGroup := len(tests) / jobs
	remainder := len(tests) % jobs
	// Maximum length in characters of concatenated group tests. This is a
	// pessimistic approximation, to avoid reaching the maximum command line
	// size when running go test.
	maxGroupStringLength := 15000
	totalLength := 0
	for _, test := range tests {
		i := len(groups) - 1
		// Add new group if current one is full
		if len(groups[i]) > testsPerGroup ||
			(len(groups[i]) == testsPerGroup && remainder == 0) {
			if remainder > 0 {
				remainder--
			}
			groups = append(groups, nil)
			i += 1
			totalLength = 0
		}
		groups[i] = append(groups[i], test)
		// Patterns are generated byte concatenating the identifiers separated
		// by a '|', hence the +1.
		totalLength += len(test) + 1
		if totalLength > maxGroupStringLength {
			groups = append(groups, nil)
			totalLength = 0
		}
	}
	if len(groups[len(groups)-1]) == 0 {
		groups = groups[:len(groups)-1]
	}
	return groups
}

// Runs a single test group, invoking "go test". Go environment is supposed to
// be set.
func runTests(runDir string, tests []string, port uint, args []string) (string, error) {
	escaped := []string{}
	for _, test := range tests {
		escaped = append(escaped, regexp.QuoteMeta(test))
	}
	filter := "(" + strings.Join(escaped, "|") + ")$"

	args = append([]string{"test"}, args...)
	args = append(args, "-gocheck.f", filter)
	cmd := exec.Command("go", args...)
	cmd.Dir = runDir
	// Remove existing TEST_PORT and populate with a new one
	env := []string{}
	for _, v := range os.Environ() {
		if strings.HasPrefix(v, "TEST_PORT=") {
			continue
		}
		env = append(env, v)
	}
	env = append(env, fmt.Sprintf("TEST_PORT=%d", port))
	cmd.Env = env
	output, err := cmd.CombinedOutput()
	return string(output), err
}

type RunResult struct {
	Tests  []string
	Err    error
	Output string
}

// Runs test groups in "jobs" sub-process, invoking them with "baseArgs".
// A distinct -test-port value will be appended to "baseArgs" for each run.
func runTestGroups(groups [][]string, baseArgs []string, runDir string,
	jobs, basePort uint) error {

	pending := make(chan []string, len(groups))
	for _, group := range groups {
		pending <- group
	}
	close(pending)

	running := &sync.WaitGroup{}
	results := make(chan RunResult, len(groups))
	for i := uint(0); i < jobs; i++ {
		running.Add(1)
		go func(id uint) {
			defer running.Done()
			port := basePort + id*10
			args := append([]string{}, baseArgs...)
			args = append(args, fmt.Sprintf("-test-port=%d", port))
			for group := range pending {
				output, err := runTests(runDir, group, port, args)
				result := RunResult{
					Tests:  group,
					Err:    err,
					Output: output,
				}
				results <- result
			}
		}(i)
	}
	running.Wait()
	close(results)

	var err error
	reports := []*swtest.TestReport{}
	configDisplayed := false
	for result := range results {
		report := swtest.ProcessReport(result.Output)
		if len(report.Config) > 0 && !configDisplayed {
			fmt.Printf("%s\n===\n", report.Config)
			configDisplayed = true
		}
		if result.Err != nil {
			err = fmt.Errorf("test failed: %s", result.Err)
		}
		reports = append(reports, report)
	}
	for _, report := range reports {
		for _, output := range report.Sections {
			fmt.Printf("%s\n", output)
		}
	}
	return err
}

func run(args []string) error {
	// "--" separates gotester arguments from the go test subprocess ones
	childrenArgs := []string{}
	testerArgs := []string{}
	childrenArgsStarted := false
	for _, arg := range args {
		if arg == "--" {
			childrenArgsStarted = true
			continue
		}
		if childrenArgsStarted {
			childrenArgs = append(childrenArgs, arg)
			if strings.Contains(arg, "-test-port") {
				return fmt.Errorf(
					"-test-port is filled by gotester and should not be supplied")
			}
		} else {
			testerArgs = append(testerArgs, arg)
		}
	}

	flags := flag.NewFlagSet("gotester", flag.ExitOnError)
	flags.Usage = func() {
		fmt.Fprintf(os.Stderr, ""+
			`gotester [OPTS] ROOTDIR -- [GOOPTS]

gotester splits and runs gosword tests in -j child process. To invoke it, first
pass its options and argument, then the child process ones prefixed by a single
"--" argument. gotester handles the -test-port option itself, do not supply it
in child arguments.

`)
		flags.PrintDefaults()
	}
	basePort := flags.Uint("port", 20000, "base port")
	jobs := flags.Uint("j", 1, "number of concurrent jobs")
	filter := flags.String("f", "", "run only the matching the regular expression")
	flags.Parse(testerArgs)
	if flags.NArg() < 1 {
		return fmt.Errorf("root directory was not supplied")
	}
	rootDir := flags.Arg(0)
	srcDir := filepath.Join(rootDir, "src")

	tests, err := listTests(srcDir)
	if err != nil {
		return err
	}
	*filter = strings.TrimSpace(*filter)
	if len(*filter) > 0 {
		tests, err = filterTests(tests, *filter)
		if err != nil {
			return err
		}
	}
	fmt.Printf("running %d tests in %d processes\n", len(tests), *jobs)
	groups := splitTests(tests, int(*jobs))
	start := time.Now()
	err = runTestGroups(groups, childrenArgs, rootDir, *jobs, *basePort)
	end := time.Now()
	trailer := fmt.Sprintf("%d tests in %.0fs", len(tests), end.Sub(start).Seconds())
	if err == nil {
		fmt.Printf("OK: %s\n", trailer)
	} else {
		fmt.Printf("FAILED: %s\n", trailer)
	}
	return err
}

func main() {
	err := run(os.Args[1:])
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %s\n", err)
		os.Exit(1)
	}
}
