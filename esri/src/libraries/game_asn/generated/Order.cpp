/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.31, Date: 25-Apr-2007.
 */
#include "Order.h"

/**************************************************************/
/*                                                            */
/*  OrderIncludes                                             */
/*                                                            */
/**************************************************************/

ASN1C_OrderIncludes::ASN1C_OrderIncludes (
   ASN1MessageBuffer& msgBuf, ASN1T_OrderIncludes& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_OrderIncludes (ASN1CTXT* ctxt_p, ASN1T_OrderIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_OrderIncludes: start\n");

   /* encode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PE_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode limaLimiteExports */

   PU_PUSHNAME (ctxt_p, "limaLimiteExports");

   stat = asn1PE_LimaLimiteExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode logMaintenanceExports */

   PU_PUSHNAME (ctxt_p, "logMaintenanceExports");

   stat = asn1PE_LogMaintenanceExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode logSanteExports */

   PU_PUSHNAME (ctxt_p, "logSanteExports");

   stat = asn1PE_LogSanteExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode objectExports */

   PU_PUSHNAME (ctxt_p, "objectExports");

   stat = asn1PE_ObjectExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_OrderIncludes: end\n");
   return (stat);
}

int ASN1C_OrderIncludes::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderIncludes (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_OrderIncludes (ASN1CTXT* ctxt_p, ASN1T_OrderIncludes* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_OrderIncludes: start\n");

   /* decode baseExports */

   PU_PUSHNAME (ctxt_p, "baseExports");

   stat = asn1PD_BaseExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode limaLimiteExports */

   PU_PUSHNAME (ctxt_p, "limaLimiteExports");

   stat = asn1PD_LimaLimiteExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode logMaintenanceExports */

   PU_PUSHNAME (ctxt_p, "logMaintenanceExports");

   stat = asn1PD_LogMaintenanceExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode logSanteExports */

   PU_PUSHNAME (ctxt_p, "logSanteExports");

   stat = asn1PD_LogSanteExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode objectExports */

   PU_PUSHNAME (ctxt_p, "objectExports");

   stat = asn1PD_ObjectExports (ctxt_p);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_OrderIncludes: end\n");

   return (stat);
}

int ASN1C_OrderIncludes::Decode ()
{
   return asn1PD_OrderIncludes (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  OrderExports                                              */
/*                                                            */
/**************************************************************/

ASN1C_OrderExports::ASN1C_OrderExports (
   ASN1MessageBuffer& msgBuf) :
   ASN1CType(msgBuf)
{}

EXTERN int asn1PE_OrderExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_OrderExports: start\n");

   /* NULL */

   rtdiag ("asn1PE_OrderExports: end\n");
   return (stat);
}

int ASN1C_OrderExports::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderExports (mpContext->GetPtr());
   return stat;
}

EXTERN int asn1PD_OrderExports (ASN1CTXT* ctxt_p)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_OrderExports: start\n");

   /* NULL */

   rtdiag ("asn1PD_OrderExports: end\n");

   return (stat);
}

int ASN1C_OrderExports::Decode ()
{
   return asn1PD_OrderExports (mpContext->GetPtr());
}

/**************************************************************/
/*                                                            */
/*  EnumOrderErrorCode                                        */
/*                                                            */
/**************************************************************/

ASN1C_EnumOrderErrorCode::ASN1C_EnumOrderErrorCode (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumOrderErrorCode& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumOrderErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumOrderErrorCode value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumOrderErrorCode: start\n");

   switch (value) {
      case EnumOrderErrorCode::no_error: ui = 0; break;
      case EnumOrderErrorCode::error_invalid_unit: ui = 1; break;
      case EnumOrderErrorCode::error_invalid_limit: ui = 2; break;
      case EnumOrderErrorCode::error_invalid_lima: ui = 3; break;
      case EnumOrderErrorCode::error_invalid_mission: ui = 4; break;
      case EnumOrderErrorCode::error_invalid_mission_parameters: ui = 5; break;
      case EnumOrderErrorCode::error_unit_cannot_receive_order: ui = 6; break;
      case EnumOrderErrorCode::error_invalid_order_conduite: ui = 7; break;
      case EnumOrderErrorCode::error_invalid_order_mission: ui = 8; break;
      case EnumOrderErrorCode::error_invalid_order_initial: ui = 9; break;
      case EnumOrderErrorCode::error_invalid_order_conduite_parameters: ui = 10; break;
      case EnumOrderErrorCode::error_unit_surrendered: ui = 11; break;
      case EnumOrderErrorCode::error_invalid_lima_function: ui = 12; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 12);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumOrderErrorCode: end\n");
   return (stat);
}

int ASN1C_EnumOrderErrorCode::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumOrderErrorCode (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumOrderErrorCode (ASN1CTXT* ctxt_p, ASN1T_EnumOrderErrorCode* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumOrderErrorCode: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 12);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumOrderErrorCode::no_error; break;
      case 1: *pvalue = EnumOrderErrorCode::error_invalid_unit; break;
      case 2: *pvalue = EnumOrderErrorCode::error_invalid_limit; break;
      case 3: *pvalue = EnumOrderErrorCode::error_invalid_lima; break;
      case 4: *pvalue = EnumOrderErrorCode::error_invalid_mission; break;
      case 5: *pvalue = EnumOrderErrorCode::error_invalid_mission_parameters; break;
      case 6: *pvalue = EnumOrderErrorCode::error_unit_cannot_receive_order; break;
      case 7: *pvalue = EnumOrderErrorCode::error_invalid_order_conduite; break;
      case 8: *pvalue = EnumOrderErrorCode::error_invalid_order_mission; break;
      case 9: *pvalue = EnumOrderErrorCode::error_invalid_order_initial; break;
      case 10: *pvalue = EnumOrderErrorCode::error_invalid_order_conduite_parameters; break;
      case 11: *pvalue = EnumOrderErrorCode::error_unit_surrendered; break;
      case 12: *pvalue = EnumOrderErrorCode::error_invalid_lima_function; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumOrderErrorCode: end\n");

   return (stat);
}

int ASN1C_EnumOrderErrorCode::Decode ()
{
   return asn1PD_EnumOrderErrorCode (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  OrderContext                                              */
/*                                                            */
/**************************************************************/

ASN1C_OrderContext::ASN1C_OrderContext (
   ASN1MessageBuffer& msgBuf, ASN1T_OrderContext& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_OrderContext (ASN1CTXT* ctxt_p, ASN1T_OrderContext* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_OrderContext: start\n");

   PU_NEWFIELD (ctxt_p, "limite_gauchePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.limite_gauchePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "limite_droitePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->m.limite_droitePresent);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode limite_gauche */

   if (pvalue->m.limite_gauchePresent) {
      PU_PUSHNAME (ctxt_p, "limite_gauche");

      stat = asn1PE_Line (ctxt_p, &pvalue->limite_gauche);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode limite_droite */

   if (pvalue->m.limite_droitePresent) {
      PU_PUSHNAME (ctxt_p, "limite_droite");

      stat = asn1PE_Line (ctxt_p, &pvalue->limite_droite);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode limas */

   PU_PUSHNAME (ctxt_p, "limas");

   stat = asn1PE_LimasOrder (ctxt_p, &pvalue->limas);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode direction_dangereuse */

   PU_PUSHNAME (ctxt_p, "direction_dangereuse");

   stat = asn1PE_Direction (ctxt_p, pvalue->direction_dangereuse);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_OrderContext: end\n");
   return (stat);
}

int ASN1C_OrderContext::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_OrderContext (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_OrderContext (ASN1CTXT* ctxt_p, ASN1T_OrderContext* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;

   rtdiag ("asn1PD_OrderContext: start\n");

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   PU_NEWFIELD (ctxt_p, "limite_gauchePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.limite_gauchePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "limite_droitePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->m.limite_droitePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode limite_gauche */

   if (pvalue->m.limite_gauchePresent) {
      PU_PUSHNAME (ctxt_p, "limite_gauche");

      stat = asn1PD_Line (ctxt_p, &pvalue->limite_gauche);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode limite_droite */

   if (pvalue->m.limite_droitePresent) {
      PU_PUSHNAME (ctxt_p, "limite_droite");

      stat = asn1PD_Line (ctxt_p, &pvalue->limite_droite);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }

   /* decode limas */

   PU_PUSHNAME (ctxt_p, "limas");

   stat = asn1PD_LimasOrder (ctxt_p, &pvalue->limas);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode direction_dangereuse */

   PU_PUSHNAME (ctxt_p, "direction_dangereuse");

   stat = asn1PD_Direction (ctxt_p, &pvalue->direction_dangereuse);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_OrderContext: end\n");

   return (stat);
}

int ASN1C_OrderContext::Decode ()
{
   return asn1PD_OrderContext (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionGenObject                                          */
/*                                                            */
/**************************************************************/

ASN1C_MissionGenObject::ASN1C_MissionGenObject (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionGenObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionGenObject (ASN1CTXT* ctxt_p, ASN1T_MissionGenObject* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MissionGenObject: start\n");

   PU_NEWFIELD (ctxt_p, "preliminairePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->preliminaire != EnumMissionGenSousTypeObstacle::preliminaire));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "densitePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->densite != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "tc2Present");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->tc2 != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "delai_activite_minesPresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->delai_activite_mines != 0));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumObjectType (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode position */

   PU_PUSHNAME (ctxt_p, "position");

   stat = asn1PE_Localisation (ctxt_p, &pvalue->position);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode preliminaire */

   if (pvalue->preliminaire != EnumMissionGenSousTypeObstacle::preliminaire) {
      PU_PUSHNAME (ctxt_p, "preliminaire");

      stat = asn1PE_EnumMissionGenSousTypeObstacle (ctxt_p, pvalue->preliminaire);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode densite */

   if (pvalue->densite != 0) {
      PU_PUSHNAME (ctxt_p, "densite");

      stat = pe_Real (ctxt_p, pvalue->densite);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode tc2 */

   if (pvalue->tc2 != 0) {
      PU_PUSHNAME (ctxt_p, "tc2");

      stat = asn1PE_Automate (ctxt_p, pvalue->tc2);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   /* encode delai_activite_mines */

   if (pvalue->delai_activite_mines != 0) {
      PU_PUSHNAME (ctxt_p, "delai_activite_mines");

      stat = pe_UnconsInteger (ctxt_p, pvalue->delai_activite_mines);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PE_MissionGenObject: end\n");
   return (stat);
}

int ASN1C_MissionGenObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionGenObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionGenObject (ASN1CTXT* ctxt_p, ASN1T_MissionGenObject* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL preliminairePresent;
   ASN1BOOL densitePresent;
   ASN1BOOL tc2Present;
   ASN1BOOL delai_activite_minesPresent;

   rtdiag ("asn1PD_MissionGenObject: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "preliminairePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else preliminairePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "densitePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else densitePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "tc2Present");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else tc2Present = optbit;

   PU_SETBITCOUNT (ctxt_p);

   PU_NEWFIELD (ctxt_p, "delai_activite_minesPresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else delai_activite_minesPresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumObjectType (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode position */

   PU_PUSHNAME (ctxt_p, "position");

   stat = asn1PD_Localisation (ctxt_p, &pvalue->position);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode preliminaire */

   if (preliminairePresent) {
      PU_PUSHNAME (ctxt_p, "preliminaire");

      stat = asn1PD_EnumMissionGenSousTypeObstacle (ctxt_p, &pvalue->preliminaire);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->preliminaire = EnumMissionGenSousTypeObstacle::preliminaire;
   }

   /* decode densite */

   if (densitePresent) {
      PU_PUSHNAME (ctxt_p, "densite");

      stat = pd_Real (ctxt_p, &pvalue->densite);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
   }

   /* decode tc2 */

   if (tc2Present) {
      PU_PUSHNAME (ctxt_p, "tc2");

      stat = asn1PD_Automate (ctxt_p, &pvalue->tc2);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->tc2 = 0;
   }

   /* decode delai_activite_mines */

   if (delai_activite_minesPresent) {
      PU_PUSHNAME (ctxt_p, "delai_activite_mines");

      stat = pd_UnconsInteger (ctxt_p, &pvalue->delai_activite_mines);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->delai_activite_mines = 0;
   }


   rtdiag ("asn1PD_MissionGenObject: end\n");

   return (stat);
}

int ASN1C_MissionGenObject::Decode ()
{
   return asn1PD_MissionGenObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  ListMissionGenObject                                      */
/*                                                            */
/**************************************************************/

ASN1C_ListMissionGenObject::ASN1C_ListMissionGenObject (
   ASN1MessageBuffer& msgBuf, ASN1T_ListMissionGenObject& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_ListMissionGenObject (ASN1CTXT* ctxt_p, ASN1T_ListMissionGenObject* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_ListMissionGenObject: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_MissionGenObject (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_ListMissionGenObject: end\n");
   return (stat);
}

int ASN1C_ListMissionGenObject::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_ListMissionGenObject (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_ListMissionGenObject (ASN1CTXT* ctxt_p, ASN1T_ListMissionGenObject* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_ListMissionGenObject: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_MissionGenObject);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_MissionGenObject (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_ListMissionGenObject: end\n");

   return (stat);
}

int ASN1C_ListMissionGenObject::Decode ()
{
   return asn1PD_ListMissionGenObject (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameter_value                                    */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameter_value::ASN1C_MissionParameter_value (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameter_value& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameter_value (ASN1CTXT* ctxt_p, ASN1T_MissionParameter_value* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MissionParameter_value: start\n");

   /* Encode choice index value */

   PU_PUSHNAME (ctxt_p, "t");

   stat = pe_ConsUnsigned (ctxt_p, pvalue->t - 1, 0, 30);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* aBool */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.aBool");

         PU_NEWFIELD (ctxt_p, "boolean");

         stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->u.aBool);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_SETBITCOUNT (ctxt_p);
         PU_POPNAME (ctxt_p);

         break;

      /* aReal */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.aReal");

         stat = pe_Real (ctxt_p, pvalue->u.aReal);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* enumeration */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.enumeration");

         stat = pe_UnconsInteger (ctxt_p, pvalue->u.enumeration);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* itineraire */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.itineraire");

         stat = asn1PE_Itineraire (ctxt_p, pvalue->u.itineraire);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listItineraire */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.listItineraire");

         stat = asn1PE_ListItineraire (ctxt_p, pvalue->u.listItineraire);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* point */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.point");

         stat = asn1PE_Point (ctxt_p, pvalue->u.point);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listPoint */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.listPoint");

         stat = asn1PE_ListPoint (ctxt_p, pvalue->u.listPoint);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* polygon */
      case 8:
         PU_PUSHNAME (ctxt_p, "u.polygon");

         stat = asn1PE_Polygon (ctxt_p, pvalue->u.polygon);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listPolygon */
      case 9:
         PU_PUSHNAME (ctxt_p, "u.listPolygon");

         stat = asn1PE_ListPolygon (ctxt_p, pvalue->u.listPolygon);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* localisation */
      case 10:
         PU_PUSHNAME (ctxt_p, "u.localisation");

         stat = asn1PE_Localisation (ctxt_p, pvalue->u.localisation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listLocalisation */
      case 11:
         PU_PUSHNAME (ctxt_p, "u.listLocalisation");

         stat = asn1PE_ListLocalisation (ctxt_p, pvalue->u.listLocalisation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* direction */
      case 12:
         PU_PUSHNAME (ctxt_p, "u.direction");

         stat = asn1PE_Direction (ctxt_p, pvalue->u.direction);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* natureAtlas */
      case 13:
         PU_PUSHNAME (ctxt_p, "u.natureAtlas");

         stat = asn1PE_NatureAtlas (ctxt_p, *pvalue->u.natureAtlas);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* agent */
      case 14:
         PU_PUSHNAME (ctxt_p, "u.agent");

         stat = asn1PE_Agent (ctxt_p, pvalue->u.agent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listAgent */
      case 15:
         PU_PUSHNAME (ctxt_p, "u.listAgent");

         stat = asn1PE_ListAgent (ctxt_p, pvalue->u.listAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* automate */
      case 16:
         PU_PUSHNAME (ctxt_p, "u.automate");

         stat = asn1PE_Automate (ctxt_p, pvalue->u.automate);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listAutomate */
      case 17:
         PU_PUSHNAME (ctxt_p, "u.listAutomate");

         stat = asn1PE_ListAutomate (ctxt_p, pvalue->u.listAutomate);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* knowledgeAgent */
      case 18:
         PU_PUSHNAME (ctxt_p, "u.knowledgeAgent");

         stat = asn1PE_KnowledgeAgent (ctxt_p, pvalue->u.knowledgeAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listKnowledgeAgent */
      case 19:
         PU_PUSHNAME (ctxt_p, "u.listKnowledgeAgent");

         stat = asn1PE_ListKnowledgeAgent (ctxt_p, pvalue->u.listKnowledgeAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* knowledgeObject */
      case 20:
         PU_PUSHNAME (ctxt_p, "u.knowledgeObject");

         stat = asn1PE_KnowledgeObject (ctxt_p, pvalue->u.knowledgeObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listKnowledgeObject */
      case 21:
         PU_PUSHNAME (ctxt_p, "u.listKnowledgeObject");

         stat = asn1PE_ListKnowledgeObject (ctxt_p, pvalue->u.listKnowledgeObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* knowledgePopulation */
      case 22:
         PU_PUSHNAME (ctxt_p, "u.knowledgePopulation");

         stat = asn1PE_KnowledgePopulation (ctxt_p, pvalue->u.knowledgePopulation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* missionGenObject */
      case 23:
         PU_PUSHNAME (ctxt_p, "u.missionGenObject");

         stat = asn1PE_MissionGenObject (ctxt_p, pvalue->u.missionGenObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* listMissionGenObject */
      case 24:
         PU_PUSHNAME (ctxt_p, "u.listMissionGenObject");

         stat = asn1PE_ListMissionGenObject (ctxt_p, pvalue->u.listMissionGenObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* typeDotation */
      case 25:
         PU_PUSHNAME (ctxt_p, "u.typeDotation");

         stat = asn1PE_TypeDotation (ctxt_p, pvalue->u.typeDotation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* typeEquipement */
      case 26:
         PU_PUSHNAME (ctxt_p, "u.typeEquipement");

         stat = asn1PE_TypeEquipement (ctxt_p, pvalue->u.typeEquipement);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* tirIndirect */
      case 27:
         PU_PUSHNAME (ctxt_p, "u.tirIndirect");

         stat = asn1PE_TirPion (ctxt_p, pvalue->u.tirIndirect);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* gDH */
      case 28:
         PU_PUSHNAME (ctxt_p, "u.gDH");

         stat = asn1PE_GDH (ctxt_p, pvalue->u.gDH);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* maintenancePriorites */
      case 29:
         PU_PUSHNAME (ctxt_p, "u.maintenancePriorites");

         stat = asn1PE_MaintenancePriorites (ctxt_p, pvalue->u.maintenancePriorites);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* santePriorites */
      case 30:
         PU_PUSHNAME (ctxt_p, "u.santePriorites");

         stat = asn1PE_SantePriorites (ctxt_p, pvalue->u.santePriorites);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      /* aCharStr */
      case 31:
         PU_PUSHNAME (ctxt_p, "u.aCharStr");

         stat = pe_VisibleString (ctxt_p, pvalue->u.aCharStr, 0);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PE_MissionParameter_value: end\n");
   return (stat);
}

int ASN1C_MissionParameter_value::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameter_value (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameter_value (ASN1CTXT* ctxt_p, ASN1T_MissionParameter_value* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_MissionParameter_value: start\n");

   PU_PUSHNAME (ctxt_p, "t");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 30);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else pvalue->t = ui + 1;

   PU_POPNAME (ctxt_p);

   switch (ui) {
      /* aBool */
      case 0:
         PU_PUSHNAME (ctxt_p, "u.aBool");

         PU_NEWFIELD (ctxt_p, "boolean");

         stat = pd_bit (ctxt_p, &pvalue->u.aBool);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_SETBITCOUNT (ctxt_p);

         PU_POPNAME (ctxt_p);

         break;

      /* aReal */
      case 1:
         PU_PUSHNAME (ctxt_p, "u.aReal");

         stat = pd_Real (ctxt_p, &pvalue->u.aReal);if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* enumeration */
      case 2:
         PU_PUSHNAME (ctxt_p, "u.enumeration");

         stat = pd_UnconsInteger (ctxt_p, &pvalue->u.enumeration);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* itineraire */
      case 3:
         PU_PUSHNAME (ctxt_p, "u.itineraire");

         pvalue->u.itineraire = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Itineraire);
         if (pvalue->u.itineraire == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_Itineraire (ctxt_p, pvalue->u.itineraire);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listItineraire */
      case 4:
         PU_PUSHNAME (ctxt_p, "u.listItineraire");

         pvalue->u.listItineraire = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListItineraire);
         if (pvalue->u.listItineraire == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListItineraire (ctxt_p, pvalue->u.listItineraire);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* point */
      case 5:
         PU_PUSHNAME (ctxt_p, "u.point");

         pvalue->u.point = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Point);
         if (pvalue->u.point == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_Point (ctxt_p, pvalue->u.point);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listPoint */
      case 6:
         PU_PUSHNAME (ctxt_p, "u.listPoint");

         pvalue->u.listPoint = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListPoint);
         if (pvalue->u.listPoint == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListPoint (ctxt_p, pvalue->u.listPoint);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* polygon */
      case 7:
         PU_PUSHNAME (ctxt_p, "u.polygon");

         pvalue->u.polygon = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Polygon);
         if (pvalue->u.polygon == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_Polygon (ctxt_p, pvalue->u.polygon);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listPolygon */
      case 8:
         PU_PUSHNAME (ctxt_p, "u.listPolygon");

         pvalue->u.listPolygon = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListPolygon);
         if (pvalue->u.listPolygon == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListPolygon (ctxt_p, pvalue->u.listPolygon);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* localisation */
      case 9:
         PU_PUSHNAME (ctxt_p, "u.localisation");

         pvalue->u.localisation = ALLOC_ASN1ELEM (ctxt_p, ASN1T_Localisation);
         if (pvalue->u.localisation == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_Localisation (ctxt_p, pvalue->u.localisation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listLocalisation */
      case 10:
         PU_PUSHNAME (ctxt_p, "u.listLocalisation");

         pvalue->u.listLocalisation = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListLocalisation);
         if (pvalue->u.listLocalisation == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListLocalisation (ctxt_p, pvalue->u.listLocalisation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* direction */
      case 11:
         PU_PUSHNAME (ctxt_p, "u.direction");

         stat = asn1PD_Direction (ctxt_p, &pvalue->u.direction);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* natureAtlas */
      case 12:
         PU_PUSHNAME (ctxt_p, "u.natureAtlas");

         pvalue->u.natureAtlas = ALLOC_ASN1ELEM (ctxt_p, ASN1T_NatureAtlas);
         if (pvalue->u.natureAtlas == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_NatureAtlas (ctxt_p, pvalue->u.natureAtlas);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* agent */
      case 13:
         PU_PUSHNAME (ctxt_p, "u.agent");

         stat = asn1PD_Agent (ctxt_p, &pvalue->u.agent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listAgent */
      case 14:
         PU_PUSHNAME (ctxt_p, "u.listAgent");

         pvalue->u.listAgent = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListAgent);
         if (pvalue->u.listAgent == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListAgent (ctxt_p, pvalue->u.listAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* automate */
      case 15:
         PU_PUSHNAME (ctxt_p, "u.automate");

         stat = asn1PD_Automate (ctxt_p, &pvalue->u.automate);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listAutomate */
      case 16:
         PU_PUSHNAME (ctxt_p, "u.listAutomate");

         pvalue->u.listAutomate = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListAutomate);
         if (pvalue->u.listAutomate == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListAutomate (ctxt_p, pvalue->u.listAutomate);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* knowledgeAgent */
      case 17:
         PU_PUSHNAME (ctxt_p, "u.knowledgeAgent");

         stat = asn1PD_KnowledgeAgent (ctxt_p, &pvalue->u.knowledgeAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listKnowledgeAgent */
      case 18:
         PU_PUSHNAME (ctxt_p, "u.listKnowledgeAgent");

         pvalue->u.listKnowledgeAgent = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListKnowledgeAgent);
         if (pvalue->u.listKnowledgeAgent == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListKnowledgeAgent (ctxt_p, pvalue->u.listKnowledgeAgent);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* knowledgeObject */
      case 19:
         PU_PUSHNAME (ctxt_p, "u.knowledgeObject");

         stat = asn1PD_KnowledgeObject (ctxt_p, &pvalue->u.knowledgeObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listKnowledgeObject */
      case 20:
         PU_PUSHNAME (ctxt_p, "u.listKnowledgeObject");

         pvalue->u.listKnowledgeObject = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListKnowledgeObject);
         if (pvalue->u.listKnowledgeObject == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListKnowledgeObject (ctxt_p, pvalue->u.listKnowledgeObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* knowledgePopulation */
      case 21:
         PU_PUSHNAME (ctxt_p, "u.knowledgePopulation");

         stat = asn1PD_KnowledgePopulation (ctxt_p, &pvalue->u.knowledgePopulation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* missionGenObject */
      case 22:
         PU_PUSHNAME (ctxt_p, "u.missionGenObject");

         pvalue->u.missionGenObject = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MissionGenObject);
         if (pvalue->u.missionGenObject == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_MissionGenObject (ctxt_p, pvalue->u.missionGenObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* listMissionGenObject */
      case 23:
         PU_PUSHNAME (ctxt_p, "u.listMissionGenObject");

         pvalue->u.listMissionGenObject = ALLOC_ASN1ELEM (ctxt_p, ASN1T_ListMissionGenObject);
         if (pvalue->u.listMissionGenObject == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_ListMissionGenObject (ctxt_p, pvalue->u.listMissionGenObject);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* typeDotation */
      case 24:
         PU_PUSHNAME (ctxt_p, "u.typeDotation");

         stat = asn1PD_TypeDotation (ctxt_p, &pvalue->u.typeDotation);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* typeEquipement */
      case 25:
         PU_PUSHNAME (ctxt_p, "u.typeEquipement");

         stat = asn1PD_TypeEquipement (ctxt_p, &pvalue->u.typeEquipement);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* tirIndirect */
      case 26:
         PU_PUSHNAME (ctxt_p, "u.tirIndirect");

         stat = asn1PD_TirPion (ctxt_p, &pvalue->u.tirIndirect);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* gDH */
      case 27:
         PU_PUSHNAME (ctxt_p, "u.gDH");

         pvalue->u.gDH = ALLOC_ASN1ELEM (ctxt_p, ASN1T_GDH);
         if (pvalue->u.gDH == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_GDH (ctxt_p, pvalue->u.gDH);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* maintenancePriorites */
      case 28:
         PU_PUSHNAME (ctxt_p, "u.maintenancePriorites");

         pvalue->u.maintenancePriorites = ALLOC_ASN1ELEM (ctxt_p, ASN1T_MaintenancePriorites);
         if (pvalue->u.maintenancePriorites == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_MaintenancePriorites (ctxt_p, pvalue->u.maintenancePriorites);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* santePriorites */
      case 29:
         PU_PUSHNAME (ctxt_p, "u.santePriorites");

         pvalue->u.santePriorites = ALLOC_ASN1ELEM (ctxt_p, ASN1T_SantePriorites);
         if (pvalue->u.santePriorites == NULL)
            return LOG_ASN1ERR (ctxt_p, ASN_E_NOMEM);

         stat = asn1PD_SantePriorites (ctxt_p, pvalue->u.santePriorites);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      /* aCharStr */
      case 30:
         PU_PUSHNAME (ctxt_p, "u.aCharStr");

         stat = pd_VisibleString (ctxt_p, &pvalue->u.aCharStr, 0);
         if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

         PU_POPNAME (ctxt_p);

         break;

      default:
         return LOG_ASN1ERR (ctxt_p, ASN_E_INVOPT);
   }

   rtdiag ("asn1PD_MissionParameter_value: end\n");

   return (stat);
}

int ASN1C_MissionParameter_value::Decode ()
{
   return asn1PD_MissionParameter_value (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameter                                          */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameter::ASN1C_MissionParameter (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameter& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameter (ASN1CTXT* ctxt_p, ASN1T_MissionParameter* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MissionParameter: start\n");

   PU_NEWFIELD (ctxt_p, "null_valuePresent");

   stat = pe_bit (ctxt_p, (ASN1BOOL)(pvalue->null_value != FALSE));
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_SETBITCOUNT (ctxt_p);

   /* encode null_value */

   if (pvalue->null_value != FALSE) {
      PU_PUSHNAME (ctxt_p, "null_value");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pe_bit (ctxt_p, (ASN1BOOL)pvalue->null_value);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);
      PU_POPNAME (ctxt_p);
   }

   /* encode value */

   PU_PUSHNAME (ctxt_p, "value");

   stat = asn1PE_MissionParameter_value (ctxt_p, &pvalue->value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MissionParameter: end\n");
   return (stat);
}

int ASN1C_MissionParameter::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameter (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameter (ASN1CTXT* ctxt_p, ASN1T_MissionParameter* pvalue)
{
   int stat = ASN_OK;
   ASN1BOOL optbit;
   ASN1BOOL null_valuePresent;

   rtdiag ("asn1PD_MissionParameter: start\n");

   /* optional bits */

   PU_NEWFIELD (ctxt_p, "null_valuePresent");

   stat = pd_bit (ctxt_p, &optbit);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   else null_valuePresent = optbit;

   PU_SETBITCOUNT (ctxt_p);

   /* decode null_value */

   if (null_valuePresent) {
      PU_PUSHNAME (ctxt_p, "null_value");

      PU_NEWFIELD (ctxt_p, "boolean");

      stat = pd_bit (ctxt_p, &pvalue->null_value);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_SETBITCOUNT (ctxt_p);

      PU_POPNAME (ctxt_p);
   }
   else {
      pvalue->null_value = FALSE;
   }

   /* decode value */

   PU_PUSHNAME (ctxt_p, "value");

   stat = asn1PD_MissionParameter_value (ctxt_p, &pvalue->value);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MissionParameter: end\n");

   return (stat);
}

int ASN1C_MissionParameter::Decode ()
{
   return asn1PD_MissionParameter (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MissionParameters                                         */
/*                                                            */
/**************************************************************/

ASN1C_MissionParameters::ASN1C_MissionParameters (
   ASN1MessageBuffer& msgBuf, ASN1T_MissionParameters& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MissionParameters (ASN1CTXT* ctxt_p, ASN1T_MissionParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PE_MissionParameters: start\n");

   /* encode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pe_Length (ctxt_p, pvalue->n);
   if (stat < 0) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PE_MissionParameter (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
      PU_POPNAME (ctxt_p);
   }

   rtdiag ("asn1PE_MissionParameters: end\n");
   return (stat);
}

int ASN1C_MissionParameters::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MissionParameters (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MissionParameters (ASN1CTXT* ctxt_p, ASN1T_MissionParameters* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT xx1;

   rtdiag ("asn1PD_MissionParameters: start\n");

   /* decode length determinant */

   PU_PUSHNAME (ctxt_p, "n");

   stat = pd_Length (ctxt_p, &pvalue->n);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode elements */

   ALLOC_ASN1ARRAY (ctxt_p, pvalue, ASN1T_MissionParameter);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      PU_PUSHELEMNAME (ctxt_p, xx1);

      stat = asn1PD_MissionParameter (ctxt_p, &pvalue->elem[xx1]);
      if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

      PU_POPNAME (ctxt_p);
   }


   rtdiag ("asn1PD_MissionParameters: end\n");

   return (stat);
}

int ASN1C_MissionParameters::Decode ()
{
   return asn1PD_MissionParameters (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPionOrder                                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgPionOrder::ASN1C_MsgPionOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPionOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPionOrder (ASN1CTXT* ctxt_p, ASN1T_MsgPionOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPionOrder: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Agent (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode order_context */

   PU_PUSHNAME (ctxt_p, "order_context");

   stat = asn1PE_OrderContext (ctxt_p, &pvalue->order_context);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPionOrder: end\n");
   return (stat);
}

int ASN1C_MsgPionOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPionOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPionOrder (ASN1CTXT* ctxt_p, ASN1T_MsgPionOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPionOrder: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Agent (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode order_context */

   PU_PUSHNAME (ctxt_p, "order_context");

   stat = asn1PD_OrderContext (ctxt_p, &pvalue->order_context);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPionOrder: end\n");

   return (stat);
}

int ASN1C_MsgPionOrder::Decode ()
{
   return asn1PD_MsgPionOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPionOrderAck                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgPionOrderAck::ASN1C_MsgPionOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPionOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPionOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgPionOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPionOrderAck: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Agent (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPionOrderAck: end\n");
   return (stat);
}

int ASN1C_MsgPionOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPionOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPionOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgPionOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPionOrderAck: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Agent (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPionOrderAck: end\n");

   return (stat);
}

int ASN1C_MsgPionOrderAck::Decode ()
{
   return asn1PD_MsgPionOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumAutomateOrderFormation                                */
/*                                                            */
/**************************************************************/

ASN1C_EnumAutomateOrderFormation::ASN1C_EnumAutomateOrderFormation (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumAutomateOrderFormation& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumAutomateOrderFormation (ASN1CTXT* ctxt_p, ASN1T_EnumAutomateOrderFormation value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumAutomateOrderFormation: start\n");

   switch (value) {
      case EnumAutomateOrderFormation::un_echelon: ui = 0; break;
      case EnumAutomateOrderFormation::deux_echelons: ui = 1; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumAutomateOrderFormation: end\n");
   return (stat);
}

int ASN1C_EnumAutomateOrderFormation::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumAutomateOrderFormation (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumAutomateOrderFormation (ASN1CTXT* ctxt_p, ASN1T_EnumAutomateOrderFormation* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumAutomateOrderFormation: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 1);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumAutomateOrderFormation::un_echelon; break;
      case 1: *pvalue = EnumAutomateOrderFormation::deux_echelons; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumAutomateOrderFormation: end\n");

   return (stat);
}

int ASN1C_EnumAutomateOrderFormation::Decode ()
{
   return asn1PD_EnumAutomateOrderFormation (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomateOrder                                          */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomateOrder::ASN1C_MsgAutomateOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomateOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomateOrder (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgAutomateOrder: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Automate (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode order_context */

   PU_PUSHNAME (ctxt_p, "order_context");

   stat = asn1PE_OrderContext (ctxt_p, &pvalue->order_context);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode formation */

   PU_PUSHNAME (ctxt_p, "formation");

   stat = asn1PE_EnumAutomateOrderFormation (ctxt_p, pvalue->formation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgAutomateOrder: end\n");
   return (stat);
}

int ASN1C_MsgAutomateOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomateOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomateOrder (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgAutomateOrder: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Automate (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode order_context */

   PU_PUSHNAME (ctxt_p, "order_context");

   stat = asn1PD_OrderContext (ctxt_p, &pvalue->order_context);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode formation */

   PU_PUSHNAME (ctxt_p, "formation");

   stat = asn1PD_EnumAutomateOrderFormation (ctxt_p, &pvalue->formation);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgAutomateOrder: end\n");

   return (stat);
}

int ASN1C_MsgAutomateOrder::Decode ()
{
   return asn1PD_MsgAutomateOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgAutomateOrderAck                                       */
/*                                                            */
/**************************************************************/

ASN1C_MsgAutomateOrderAck::ASN1C_MsgAutomateOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgAutomateOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgAutomateOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgAutomateOrderAck: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Agent (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgAutomateOrderAck: end\n");
   return (stat);
}

int ASN1C_MsgAutomateOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgAutomateOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgAutomateOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgAutomateOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgAutomateOrderAck: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Agent (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgAutomateOrderAck: end\n");

   return (stat);
}

int ASN1C_MsgAutomateOrderAck::Decode ()
{
   return asn1PD_MsgAutomateOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationOrder                                        */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationOrder::ASN1C_MsgPopulationOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationOrder (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationOrder: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Population (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PE_OID (ctxt_p, pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationOrder: end\n");
   return (stat);
}

int ASN1C_MsgPopulationOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationOrder (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationOrder: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Population (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode mission */

   PU_PUSHNAME (ctxt_p, "mission");

   stat = asn1PD_OID (ctxt_p, &pvalue->mission);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationOrder: end\n");

   return (stat);
}

int ASN1C_MsgPopulationOrder::Decode ()
{
   return asn1PD_MsgPopulationOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgPopulationOrderAck                                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgPopulationOrderAck::ASN1C_MsgPopulationOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgPopulationOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgPopulationOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgPopulationOrderAck: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_Population (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgPopulationOrderAck: end\n");
   return (stat);
}

int ASN1C_MsgPopulationOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgPopulationOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgPopulationOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgPopulationOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgPopulationOrderAck: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_Population (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgPopulationOrderAck: end\n");

   return (stat);
}

int ASN1C_MsgPopulationOrderAck::Decode ()
{
   return asn1PD_MsgPopulationOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgFragOrder                                              */
/*                                                            */
/**************************************************************/

ASN1C_MsgFragOrder::ASN1C_MsgFragOrder (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgFragOrder& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgFragOrder (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgFragOrder: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode frag_order */

   PU_PUSHNAME (ctxt_p, "frag_order");

   stat = asn1PE_OID (ctxt_p, pvalue->frag_order);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgFragOrder: end\n");
   return (stat);
}

int ASN1C_MsgFragOrder::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgFragOrder (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgFragOrder (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrder* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgFragOrder: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode frag_order */

   PU_PUSHNAME (ctxt_p, "frag_order");

   stat = asn1PD_OID (ctxt_p, &pvalue->frag_order);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgFragOrder: end\n");

   return (stat);
}

int ASN1C_MsgFragOrder::Decode ()
{
   return asn1PD_MsgFragOrder (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgFragOrderAck                                           */
/*                                                            */
/**************************************************************/

ASN1C_MsgFragOrderAck::ASN1C_MsgFragOrderAck (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgFragOrderAck& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgFragOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgFragOrderAck: start\n");

   /* encode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PE_OID (ctxt_p, pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PE_EnumOrderErrorCode (ctxt_p, pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgFragOrderAck: end\n");
   return (stat);
}

int ASN1C_MsgFragOrderAck::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgFragOrderAck (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgFragOrderAck (ASN1CTXT* ctxt_p, ASN1T_MsgFragOrderAck* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgFragOrderAck: start\n");

   /* decode oid_unite_executante */

   PU_PUSHNAME (ctxt_p, "oid_unite_executante");

   stat = asn1PD_OID (ctxt_p, &pvalue->oid_unite_executante);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode error_code */

   PU_PUSHNAME (ctxt_p, "error_code");

   stat = asn1PD_EnumOrderErrorCode (ctxt_p, &pvalue->error_code);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgFragOrderAck: end\n");

   return (stat);
}

int ASN1C_MsgFragOrderAck::Decode ()
{
   return asn1PD_MsgFragOrderAck (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  EnumTypeCR                                                */
/*                                                            */
/**************************************************************/

ASN1C_EnumTypeCR::ASN1C_EnumTypeCR (
   ASN1MessageBuffer& msgBuf, ASN1T_EnumTypeCR& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_EnumTypeCR (ASN1CTXT* ctxt_p, ASN1T_EnumTypeCR value)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PE_EnumTypeCR: start\n");

   switch (value) {
      case EnumTypeCR::message: ui = 0; break;
      case EnumTypeCR::operationel: ui = 1; break;
      case EnumTypeCR::evenement_exceptionnel: ui = 2; break;
      case EnumTypeCR::warning: ui = 3; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   stat = pe_ConsUnsigned (ctxt_p, ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   rtdiag ("asn1PE_EnumTypeCR: end\n");
   return (stat);
}

int ASN1C_EnumTypeCR::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_EnumTypeCR (mpContext->GetPtr(), msgData);
   return stat;
}

EXTERN int asn1PD_EnumTypeCR (ASN1CTXT* ctxt_p, ASN1T_EnumTypeCR* pvalue)
{
   int stat = ASN_OK;
   ASN1UINT ui;

   rtdiag ("asn1PD_EnumTypeCR: start\n");

   stat = pd_ConsUnsigned (ctxt_p, &ui, 0, 3);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   switch (ui) {
      case 0: *pvalue = EnumTypeCR::message; break;
      case 1: *pvalue = EnumTypeCR::operationel; break;
      case 2: *pvalue = EnumTypeCR::evenement_exceptionnel; break;
      case 3: *pvalue = EnumTypeCR::warning; break;
      default: return LOG_ASN1ERR (ctxt_p, ASN_E_INVENUM);
   }

   rtdiag ("asn1PD_EnumTypeCR: end\n");

   return (stat);
}

int ASN1C_EnumTypeCR::Decode ()
{
   return asn1PD_EnumTypeCR (mpContext->GetPtr(), &msgData);
}

/**************************************************************/
/*                                                            */
/*  MsgCR                                                     */
/*                                                            */
/**************************************************************/

ASN1C_MsgCR::ASN1C_MsgCR (
   ASN1MessageBuffer& msgBuf, ASN1T_MsgCR& data) :
   ASN1CType(msgBuf), msgData(data)
{}

EXTERN int asn1PE_MsgCR (ASN1CTXT* ctxt_p, ASN1T_MsgCR* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PE_MsgCR: start\n");

   /* encode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PE_OID (ctxt_p, pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode cr */

   PU_PUSHNAME (ctxt_p, "cr");

   stat = asn1PE_OID (ctxt_p, pvalue->cr);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PE_EnumTypeCR (ctxt_p, pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);

   /* encode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PE_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);
   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PE_MsgCR: end\n");
   return (stat);
}

int ASN1C_MsgCR::Encode ()
{
   mMsgBuf.Init ();
   int stat = asn1PE_MsgCR (mpContext->GetPtr(), &msgData);
   return stat;
}

EXTERN int asn1PD_MsgCR (ASN1CTXT* ctxt_p, ASN1T_MsgCR* pvalue)
{
   int stat = ASN_OK;

   rtdiag ("asn1PD_MsgCR: start\n");

   /* decode unit_id */

   PU_PUSHNAME (ctxt_p, "unit_id");

   stat = asn1PD_OID (ctxt_p, &pvalue->unit_id);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode cr */

   PU_PUSHNAME (ctxt_p, "cr");

   stat = asn1PD_OID (ctxt_p, &pvalue->cr);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode type */

   PU_PUSHNAME (ctxt_p, "type");

   stat = asn1PD_EnumTypeCR (ctxt_p, &pvalue->type);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);

   /* decode parametres */

   PU_PUSHNAME (ctxt_p, "parametres");

   stat = asn1PD_MissionParameters (ctxt_p, &pvalue->parametres);
   if (stat != ASN_OK) return LOG_ASN1ERR (ctxt_p, stat);

   PU_POPNAME (ctxt_p);


   rtdiag ("asn1PD_MsgCR: end\n");

   return (stat);
}

int ASN1C_MsgCR::Decode ()
{
   return asn1PD_MsgCR (mpContext->GetPtr(), &msgData);
}

